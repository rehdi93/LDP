<part label="4" xml:id="part4" xmlns="http://docbook.org/ns/docbook">
    <title>Commands</title>


  <partintro>  

    <para><anchor xml:id="part4A" /></para>
    <para>Mastering the commands on your Linux machine is an indispensable
      prelude to writing effective shell scripts.</para>
      
    <para>This section covers the following commands:</para>


      <itemizedlist xml:id="Commandlist">

               <listitem><para><link linkend="dotref">.</link>
	         (See also <link linkend="sourceref">source</link>)</para></listitem>
               <listitem><para><link linkend="acref">ac</link></para></listitem>
               <listitem><para><link linkend="useraddref">adduser</link></para></listitem>
               <listitem><para><link linkend="agettyref">agetty</link></para></listitem>
               <listitem><para><link linkend="agrepref">agrep</link></para></listitem>
               <listitem><para><link linkend="arref">ar</link></para></listitem>
               <listitem><para><link linkend="archref">arch</link></para></listitem>
               <listitem><para><link linkend="atref">at</link></para></listitem>
               <listitem><para><link linkend="autoloadref">autoload</link></para></listitem>
               <listitem><para><link linkend="awkref">awk</link>
		 (See also <link linkend="awkmath">Using
		 <command>awk</command> for
		 math operations</link>)</para></listitem>
               <listitem><para><link linkend="badblocksref">badblocks</link></para></listitem>
               <listitem><para><link linkend="bannerref">banner</link></para></listitem>
               <listitem><para><link linkend="basenameref">basename</link></para></listitem>
               <listitem><para><link linkend="batchref">batch</link></para></listitem>
               <listitem><para><link linkend="bcref">bc</link></para></listitem>
               <listitem><para><link linkend="bgref">bg</link></para></listitem>
               <listitem><para><link linkend="bindref">bind</link></para></listitem>
               <listitem><para><link linkend="bisonref">bison</link></para></listitem>
               <listitem><para><link linkend="bltref">builtin</link></para></listitem>
               <listitem><para><link linkend="bzgrepref">bzgrep</link></para></listitem>
               <listitem><para><link linkend="bzipref">bzip2</link></para></listitem>
               <listitem><para><link linkend="calref">cal</link></para></listitem>
               <listitem><para><link linkend="callerref">caller</link></para></listitem>
               <listitem><para><link linkend="catref">cat</link></para></listitem>
               <listitem><para><link linkend="cdref">cd</link></para></listitem>
               <listitem><para><link linkend="chattrref">chattr</link></para></listitem>
               <listitem><para><link linkend="chfnref">chfn</link></para></listitem>
               <listitem><para><link linkend="chgrpref">chgrp</link></para></listitem>
               <listitem><para><link linkend="chkconfigref">chkconfig</link></para></listitem>
               <listitem><para><link linkend="chmodref">chmod</link></para></listitem>
               <listitem><para><link linkend="chownref">chown</link></para></listitem>
               <listitem><para><link linkend="chrootref">chroot</link></para></listitem>
               <listitem><para><link linkend="cksumref">cksum</link></para></listitem>
               <listitem><para><link linkend="clearref">clear</link></para></listitem>
               <listitem><para><link linkend="clockref">clock</link></para></listitem>
               <listitem><para><link linkend="cmpref">cmp</link></para></listitem>
               <listitem><para><link linkend="colref">col</link></para></listitem>
               <listitem><para><link linkend="colrmref">colrm</link></para></listitem>
               <listitem><para><link linkend="columnref">column</link></para></listitem>
               <listitem><para><link linkend="commref">comm</link></para></listitem>
               <listitem><para><link linkend="commandref">command</link></para></listitem>
               <listitem><para><link linkend="compgenref">compgen</link></para></listitem>
               <listitem><para><link linkend="completeref">complete</link></para></listitem>
               <listitem><para><link linkend="compressref">compress</link></para></listitem>
               <listitem><para><link linkend="coprocref">coproc</link></para></listitem>
               <listitem><para><link linkend="cpref">cp</link></para></listitem>
               <listitem><para><link linkend="cpioref">cpio</link></para></listitem>
               <listitem><para><link linkend="cronref">cron</link></para></listitem>
               <listitem><para><link linkend="cryptref">crypt</link></para></listitem>
               <listitem><para><link linkend="csplitref">csplit</link></para></listitem>
               <listitem><para><link linkend="curef">cu</link></para></listitem>
               <listitem><para><link linkend="cutref">cut</link></para></listitem>
               <listitem><para><link linkend="dateref">date</link></para></listitem>
               <listitem><para><link linkend="dcref">dc</link></para></listitem>
               <listitem><para><link linkend="ddref">dd</link></para></listitem>
               <listitem><para><link linkend="debugfsref">debugfs</link></para></listitem>
               <listitem><para><link linkend="declareref">declare</link></para></listitem>
               <listitem><para><link linkend="depmodref">depmod</link></para></listitem>
               <listitem><para><link linkend="dfref">df</link></para></listitem>
               <listitem><para><link linkend="dialogref">dialog</link></para></listitem>
               <listitem><para><link linkend="diffref">diff</link></para></listitem>
               <listitem><para><link linkend="diff3ref">diff3</link></para></listitem>
               <listitem><para><link linkend="diffstatref">diffstat</link></para></listitem>
               <listitem><para><link linkend="digref">dig</link></para></listitem>
               <listitem><para><link linkend="dirnameref">dirname</link></para></listitem>
               <listitem><para><link linkend="dirsd">dirs</link></para></listitem>
               <listitem><para><link linkend="disownref">disown</link></para></listitem>
               <listitem><para><link linkend="dmesgref">dmesg</link></para></listitem>
               <listitem><para><link linkend="doexecref">doexec</link></para></listitem>
               <listitem><para><link linkend="dos2unixref">dos2unix</link></para></listitem>
               <listitem><para><link linkend="duref">du</link></para></listitem>
               <listitem><para><link linkend="dumpref">dump</link></para></listitem>
               <listitem><para><link linkend="dumpe2fsref">dumpe2fs</link></para></listitem>
               <listitem><para><link linkend="e2fsckref">e2fsck</link></para></listitem>
               <listitem><para><link linkend="echoref">echo</link></para></listitem>
               <listitem><para><link linkend="egrepref">egrep</link></para></listitem>
               <listitem><para><link linkend="enableref">enable</link></para></listitem>
               <listitem><para><link linkend="enscriptref">enscript</link></para></listitem>
               <listitem><para><link linkend="envvref">env</link></para></listitem>
               <listitem><para><link linkend="eqnref">eqn</link></para></listitem>
               <listitem><para><link linkend="evalref">eval</link></para></listitem>
               <listitem><para><link linkend="execref">exec</link></para></listitem>
               <listitem><para><link linkend="exitref">exit</link>
		 (Related topic: <link linkend="exitstatusref">exit
		 status</link>)</para></listitem>
               <listitem><para><link linkend="expandref">expand</link></para></listitem>
               <listitem><para><link linkend="exportref">export</link></para></listitem>
               <listitem><para><link linkend="exprref">expr</link></para></listitem>
               <listitem><para><link linkend="factorref">factor</link></para></listitem>
               <listitem><para><link linkend="falseref">false</link></para></listitem>
               <listitem><para><link linkend="fdformatref">fdformat</link></para></listitem>
               <listitem><para><link linkend="fdiskref">fdisk</link></para></listitem>
               <listitem><para><link linkend="fgref">fg</link></para></listitem>
               <listitem><para><link linkend="fgrepref">fgrep</link></para></listitem>
               <listitem><para><link linkend="fileref">file</link></para></listitem>
               <listitem><para><link linkend="findref">find</link></para></listitem>
               <listitem><para><link linkend="fingerref">finger</link></para></listitem>
               <listitem><para><link linkend="flexref">flex</link></para></listitem>
               <listitem><para><link linkend="flockref">flock</link></para></listitem>
               <listitem><para><link linkend="fmtref">fmt</link></para></listitem>
               <listitem><para><link linkend="foldref">fold</link></para></listitem>
               <listitem><para><link linkend="freeref">free</link></para></listitem>
               <listitem><para><link linkend="fsckref">fsck</link></para></listitem>
               <listitem><para><link linkend="ftpref">ftp</link></para></listitem>
               <listitem><para><link linkend="fuserref">fuser</link></para></listitem>
               <listitem><para><link linkend="getfaclref">getfacl</link></para></listitem>
               <listitem><para><link linkend="getopty">getopt</link></para></listitem>
               <listitem><para><link linkend="getoptsx">getopts</link></para></listitem>
               <listitem><para><link linkend="gettextref">gettext</link></para></listitem>
               <listitem><para><link linkend="gettyref">getty</link></para></listitem>
               <listitem><para><link linkend="gnomemountref">gnome-mount</link></para></listitem>
               <listitem><para><link linkend="grepref">grep</link></para></listitem>
               <listitem><para><link linkend="groffref">groff</link></para></listitem>
               <listitem><para><link linkend="groupmodref">groupmod</link></para></listitem>
               <listitem><para><link linkend="groupscmdref">groups</link>
		 (Related topic: the <link linkend="groupsref">$GROUPS</link>
		 variable)</para></listitem>
               <listitem><para><link linkend="gsref">gs</link></para></listitem>
               <listitem><para><link linkend="gzipref">gzip</link></para></listitem>
               <listitem><para><link linkend="haltref">halt</link></para></listitem>
               <listitem><para><link linkend="hashcmdref">hash</link></para></listitem>
               <listitem><para><link linkend="hdparmref">hdparm</link></para></listitem>
               <listitem><para><link linkend="headref">head</link></para></listitem>
               <listitem><para><link linkend="helpref">help</link></para></listitem>
               <listitem><para><link linkend="hexdumpref">hexdump</link></para></listitem>
               <listitem><para><link linkend="hostref">host</link></para></listitem>
               <listitem><para><link linkend="hostidref">hostid</link></para></listitem>
               <listitem><para><link linkend="hnameref">hostname</link>
		 (Related topic: the <link linkend="hostnameref">$HOSTNAME</link>
		 variable)</para></listitem>
               <listitem><para><link linkend="hwclockref">hwclock</link></para></listitem>
               <listitem><para><link linkend="iconvref">iconv</link></para></listitem>
               <listitem><para><link linkend="idref">id</link>
		 (Related topic: the <link linkend="uidref">$UID</link>
	       variable)</para></listitem>
               <listitem><para><link linkend="ifconfigref">ifconfig</link></para></listitem>
               <listitem><para><link linkend="inforef">info</link></para></listitem>
               <listitem><para><link linkend="infocmpref">infocmp</link></para></listitem>
               <listitem><para><link linkend="initref">init</link></para></listitem>
               <listitem><para><link linkend="insmodref">insmod</link></para></listitem>
               <listitem><para><link linkend="installref">install</link></para></listitem>
               <listitem><para><link linkend="ipref">ip</link></para></listitem>
               <listitem><para><link linkend="ipcalcref">ipcalc</link></para></listitem>
               <listitem><para><link linkend="iptablesref">iptables</link></para></listitem>
               <listitem><para><link linkend="iwconfigref">iwconfig</link></para></listitem>
               <listitem><para><link linkend="jobsref">jobs</link></para></listitem>
               <listitem><para><link linkend="joinref">join</link></para></listitem>
               <listitem><para><link linkend="jotref">jot</link></para></listitem>
               <listitem><para><link linkend="killref">kill</link></para></listitem>
               <listitem><para><link linkend="killallref">killall</link></para></listitem>
               <listitem><para><link linkend="lastref">last</link></para></listitem>
               <listitem><para><link linkend="lastcommref">lastcomm</link></para></listitem>
               <listitem><para><link linkend="lastlogref">lastlog</link></para></listitem>
               <listitem><para><link linkend="lddref">ldd</link></para></listitem>
               <listitem><para><link linkend="lessref">less</link></para></listitem>
               <listitem><para><link linkend="letref">let</link></para></listitem>
               <listitem><para><link linkend="lexref">lex</link></para></listitem>
               <listitem><para><link linkend="lidref">lid</link></para></listitem>
               <listitem><para><link linkend="linkref">ln</link></para></listitem>
               <listitem><para><link linkend="locateref">locate</link></para></listitem>
               <listitem><para><link linkend="lockfileref">lockfile</link></para></listitem>
               <listitem><para><link linkend="loggerref">logger</link></para></listitem>
               <listitem><para><link linkend="lognameref">logname</link></para></listitem>
               <listitem><para><link linkend="logoutref">logout</link></para></listitem>
               <listitem><para><link linkend="logrotateref">logrotate</link></para></listitem>
               <listitem><para><link linkend="lookref">look</link></para></listitem>
               <listitem><para><link linkend="losetupref">losetup</link></para></listitem>
               <listitem><para><link linkend="lpref">lp</link></para></listitem>
               <listitem><para><link linkend="lsref">ls</link></para></listitem>
               <listitem><para><link linkend="lsdevref">lsdev</link></para></listitem>
               <listitem><para><link linkend="lsmodref">lsmod</link></para></listitem>
               <listitem><para><link linkend="lsofref">lsof</link></para></listitem>
               <listitem><para><link linkend="lspciref">lspci</link></para></listitem>
               <listitem><para><link linkend="lsusbref">lsusb</link></para></listitem>
               <listitem><para><link linkend="ltraceref">ltrace</link></para></listitem>
               <listitem><para><link linkend="lynxref">lynx</link></para></listitem>
               <listitem><para><link linkend="lzmaref">lzcat</link></para></listitem>
               <listitem><para><link linkend="lzmaref">lzma</link></para></listitem>
               <listitem><para><link linkend="m4ref">m4</link></para></listitem>
               <listitem><para><link linkend="commmail1">mail</link></para></listitem>
               <listitem><para><link linkend="mailstatsref">mailstats</link></para></listitem>
               <listitem><para><link linkend="mailtoref">mailto</link></para></listitem>
               <listitem><para><link linkend="makeref">make</link></para></listitem>
               <listitem><para><link linkend="MAKEDEVref">MAKEDEV</link></para></listitem>
               <listitem><para><link linkend="manref">man</link></para></listitem>
               <listitem><para><link linkend="mapfileref">mapfile</link></para></listitem>
               <listitem><para><link linkend="mcookieref">mcookie</link></para></listitem>
               <listitem><para><link linkend="md5sumref">md5sum</link></para></listitem>
               <listitem><para><link linkend="mergeref">merge</link></para></listitem>
               <listitem><para><link linkend="mesgref">mesg</link></para></listitem>
               <listitem><para><link linkend="mimencoderef">mimencode</link></para></listitem>
               <listitem><para><link linkend="mkbootdiskref">mkbootdisk</link></para></listitem>
               <listitem><para><link linkend="mkdirref">mkdir</link></para></listitem>
               <listitem><para><link linkend="mkdosfsref">mkdosfs</link></para></listitem>
               <listitem><para><link linkend="mke2fsref">mke2fs</link></para></listitem>
               <listitem><para><link linkend="mkfiforef">mkfifo</link></para></listitem>
               <listitem><para><link linkend="mkisofsref">mkisofs</link></para></listitem>
               <listitem><para><link linkend="mknodref">mknod</link></para></listitem>
               <listitem><para><link linkend="mkswapref">mkswap</link></para></listitem>
               <listitem><para><link linkend="mktempref">mktemp</link></para></listitem>
               <listitem><para><link linkend="mmencoderef">mmencode</link></para></listitem>
               <listitem><para><link linkend="modinforef">modinfo</link></para></listitem>
               <listitem><para><link linkend="modproberef">modprobe</link></para></listitem>
               <listitem><para><link linkend="moreref">more</link></para></listitem>
               <listitem><para><link linkend="mountref">mount</link></para></listitem>
               <listitem><para><link linkend="msgfmtref">msgfmt</link></para></listitem>
               <listitem><para><link linkend="mvref">mv</link></para></listitem>
               <listitem><para><link linkend="ncref">nc</link></para></listitem>
               <listitem><para><link linkend="netconfigref">netconfig</link></para></listitem>
               <listitem><para><link linkend="netstatref">netstat</link></para></listitem>
               <listitem><para><link linkend="newgrpref">newgrp</link></para></listitem>
               <listitem><para><link linkend="niceref">nice</link></para></listitem>
               <listitem><para><link linkend="nlref">nl</link></para></listitem>
               <listitem><para><link linkend="nmref">nm</link></para></listitem>
               <listitem><para><link linkend="nmapref">nmap</link></para></listitem>
               <listitem><para><link linkend="nohupref">nohup</link></para></listitem>
               <listitem><para><link linkend="nslookupref">nslookup</link></para></listitem>
               <listitem><para><link linkend="objdumpref">objdump</link></para></listitem>
               <listitem><para><link linkend="odref">od</link></para></listitem>
               <listitem><para><link linkend="opensslref">openssl</link></para></listitem>
               <listitem><para><link linkend="passwdref">passwd</link></para></listitem>
               <listitem><para><link linkend="pasteref">paste</link></para></listitem>
               <listitem><para><link linkend="patchref">patch</link>
		 (Related topic: <link linkend="diffref">diff</link>)</para></listitem>
               <listitem><para><link linkend="pathchkref">pathchk</link></para></listitem>
               <listitem><para><link linkend="paxref">pax</link></para></listitem>
               <listitem><para><link linkend="pgrepref">pgrep</link></para></listitem>
               <listitem><para><link linkend="pidofref">pidof</link></para></listitem>
               <listitem><para><link linkend="pingref">ping</link></para></listitem>
               <listitem><para><link linkend="pkillref">pkill</link></para></listitem>
               <listitem><para><link linkend="dirsd">popd</link></para></listitem>
               <listitem><para><link linkend="prref">pr</link></para></listitem>
               <listitem><para><link linkend="printenvref">printenv</link></para></listitem>
               <listitem><para><link linkend="printfref">printf</link></para></listitem>
               <listitem><para><link linkend="procinforef">procinfo</link></para></listitem>
               <listitem><para><link linkend="ppssref">ps</link></para></listitem>
               <listitem><para><link linkend="pstreeref">pstree</link></para></listitem>
               <listitem><para><link linkend="ptxref">ptx</link></para></listitem>
               <listitem><para><link linkend="dirsd">pushd</link></para></listitem>
               <listitem><para><link linkend="pwd2ref">pwd</link>
		 (Related topic: the <link linkend="pwdref">$PWD</link>
		 variable)</para></listitem>
               <listitem><para><link linkend="quotaref">quota</link></para></listitem>
               <listitem><para><link linkend="rcpref">rcp</link></para></listitem>
               <listitem><para><link linkend="rdevref">rdev</link></para></listitem>
               <listitem><para><link linkend="rdistref">rdist</link></para></listitem>
               <listitem><para><link linkend="readref">read</link></para></listitem>
               <listitem><para><link linkend="readelfref">readelf</link></para></listitem>
               <listitem><para><link linkend="readlinkref">readlink</link></para></listitem>
               <listitem><para><link linkend="readonlyref">readonly</link></para></listitem>
               <listitem><para><link linkend="rebootref">reboot</link></para></listitem>
               <listitem><para><link linkend="recoderef">recode</link></para></listitem>
               <listitem><para><link linkend="nice2ref">renice</link></para></listitem>
               <listitem><para><link linkend="resetref">reset</link></para></listitem>
               <listitem><para><link linkend="resizeref">resize</link></para></listitem>
               <listitem><para><link linkend="restoreref">restore</link></para></listitem>
               <listitem><para><link linkend="revref">rev</link></para></listitem>
               <listitem><para><link linkend="rloginref">rlogin</link></para></listitem>
               <listitem><para><link linkend="rmref">rm</link></para></listitem>
               <listitem><para><link linkend="rmdirref">rmdir</link></para></listitem>
               <listitem><para><link linkend="rmmodref">rmmod</link></para></listitem>
               <listitem><para><link linkend="routeref">route</link></para></listitem>
               <listitem><para><link linkend="rpmref">rpm</link></para></listitem>
               <listitem><para><link linkend="rpm2cpioref">rpm2cpio</link></para></listitem>
               <listitem><para><link linkend="rshref">rsh</link></para></listitem>
               <listitem><para><link linkend="rsyncref">rsync</link></para></listitem>
               <listitem><para><link linkend="runlevelref">runlevel</link></para></listitem>
               <listitem><para><link linkend="runpartsref">run-parts</link></para></listitem>
               <listitem><para><link linkend="rxref">rx</link></para></listitem>
               <listitem><para><link linkend="rzref">rz</link></para></listitem>
               <listitem><para><link linkend="sarref">sar</link></para></listitem>
               <listitem><para><link linkend="scpref">scp</link></para></listitem>
               <listitem><para><link linkend="scriptref">script</link></para></listitem>
               <listitem><para><link linkend="sdiffref">sdiff</link></para></listitem>
               <listitem><para><link linkend="sedref">sed</link></para></listitem>
               <listitem><para><link linkend="seqref">seq</link></para></listitem>
               <listitem><para><link linkend="serviceref">service</link></para></listitem>
               <listitem><para><link linkend="setref">set</link></para></listitem>
               <listitem><para><link linkend="setfaclref">setfacl</link></para></listitem>
               <listitem><para><link linkend="setquotaref">setquota</link></para></listitem>
               <listitem><para><link linkend="setserialref">setserial</link></para></listitem>
               <listitem><para><link linkend="settermref">setterm</link></para></listitem>
               <listitem><para><link linkend="sha1sumref">sha1sum</link></para></listitem>
               <listitem><para><link linkend="sharref">shar</link></para></listitem>
               <listitem><para><link linkend="shoptref">shopt</link></para></listitem>
               <listitem><para><link linkend="shredref">shred</link></para></listitem>
               <listitem><para><link linkend="shutdownref">shutdown</link></para></listitem>
               <listitem><para><link linkend="sizeref">size</link></para></listitem>
               <listitem><para><link linkend="nice2ref">skill</link></para></listitem>
               <listitem><para><link linkend="sleepref">sleep</link></para></listitem>
               <listitem><para><link linkend="slocateref">slocate</link></para></listitem>
               <listitem><para><link linkend="nice2ref">snice</link></para></listitem>
               <listitem><para><link linkend="sortref">sort</link></para></listitem>
               <listitem><para><link linkend="sourceref">source</link></para></listitem>
               <listitem><para><link linkend="soxref">sox</link></para></listitem>
               <listitem><para><link linkend="splitref">split</link></para></listitem>
               <listitem><para><link linkend="sqref">sq</link></para></listitem>
               <listitem><para><link linkend="sshref">ssh</link></para></listitem>
               <listitem><para><link linkend="statref">stat</link></para></listitem>
               <listitem><para><link linkend="straceref">strace</link></para></listitem>
               <listitem><para><link linkend="stringsref">strings</link></para></listitem>
               <listitem><para><link linkend="stripref">strip</link></para></listitem>
               <listitem><para><link linkend="sttyref">stty</link></para></listitem>
               <listitem><para><link linkend="suref">su</link></para></listitem>
               <listitem><para><link linkend="sudoref">sudo</link></para></listitem>
               <listitem><para><link linkend="sumref">sum</link></para></listitem>
               <listitem><para><link linkend="suspendref">suspend</link></para></listitem>
               <listitem><para><link linkend="swaponref">swapoff</link></para></listitem>
               <listitem><para><link linkend="swaponref">swapon</link></para></listitem>
               <listitem><para><link linkend="rxref">sx</link></para></listitem>
               <listitem><para><link linkend="syncref">sync</link></para></listitem>
               <listitem><para><link linkend="rzref">sz</link></para></listitem>
               <listitem><para><link linkend="catref">tac</link></para></listitem>
               <listitem><para><link linkend="tailref">tail</link></para></listitem>
               <listitem><para><link linkend="tarref">tar</link></para></listitem>
               <listitem><para><link linkend="tblref">tbl</link></para></listitem>
               <listitem><para><link linkend="tcpdumpref">tcpdump</link></para></listitem>
               <listitem><para><link linkend="teeref">tee</link></para></listitem>
               <listitem><para><link linkend="telinitref">telinit</link></para></listitem>
               <listitem><para><link linkend="telnetref">telnet</link></para></listitem>
               <listitem><para><link linkend="texref">Tex</link></para></listitem>
               <listitem><para><link linkend="texexecref">texexec</link></para></listitem>
               <listitem><para><link linkend="timref">time</link></para></listitem>
               <listitem><para><link linkend="timesref">times</link></para></listitem>
               <listitem><para><link linkend="tmpwatchref">tmpwatch</link></para></listitem>
               <listitem><para><link linkend="topref">top</link></para></listitem>
               <listitem><para><link linkend="touchref">touch</link></para></listitem>
               <listitem><para><link linkend="tputref">tput</link></para></listitem>
               <listitem><para><link linkend="trref">tr</link></para></listitem>
               <listitem><para><link linkend="tracerouteref">traceroute</link></para></listitem>
               <listitem><para><link linkend="trueref">true</link></para></listitem>
               <listitem><para><link linkend="tsetref">tset</link></para></listitem>
               <listitem><para><link linkend="tsortref">tsort</link></para></listitem>
               <listitem><para><link linkend="ttyref">tty</link></para></listitem>
               <listitem><para><link linkend="tune2fsref">tune2fs</link></para></listitem>
               <listitem><para><link linkend="typeref">type</link></para></listitem>
               <listitem><para><link linkend="declareref">typeset</link></para></listitem>
               <listitem><para><link linkend="ulimitref">ulimit</link></para></listitem>
               <listitem><para><link linkend="umaskref">umask</link></para></listitem>
               <listitem><para><link linkend="umountref">umount</link></para></listitem>
               <listitem><para><link linkend="unameref">uname</link></para></listitem>
               <listitem><para><link linkend="unarcref">unarc</link></para></listitem>
               <listitem><para><link linkend="unarcref">unarj</link></para></listitem>
               <listitem><para><link linkend="uncompressref">uncompress</link></para></listitem>
               <listitem><para><link linkend="expandref">unexpand</link></para></listitem>
               <listitem><para><link linkend="uniqref">uniq</link></para></listitem>
               <listitem><para><link linkend="unitsref">units</link></para></listitem>
               <listitem><para><link linkend="lzmaref">unlzma</link></para></listitem>
               <listitem><para><link linkend="unarcref">unrar</link></para></listitem>
               <listitem><para><link linkend="unsetref">unset</link></para></listitem>
               <listitem><para><link linkend="sqref">unsq</link></para></listitem>
               <listitem><para><link linkend="zipref">unzip</link></para></listitem>
               <listitem><para><link linkend="uptimeref">uptime</link></para></listitem>
               <listitem><para><link linkend="lsusbref">usbmodules</link></para></listitem>
               <listitem><para><link linkend="useraddref">useradd</link></para></listitem>
               <listitem><para><link linkend="useraddref">userdel</link></para></listitem>
               <listitem><para><link linkend="usermodref">usermod</link></para></listitem>
               <listitem><para><link linkend="usersref">users</link></para></listitem>
               <listitem><para><link linkend="usleepref">usleep</link></para></listitem>
               <listitem><para><link linkend="uucpref">uucp</link></para></listitem>
               <listitem><para><link linkend="uudecoderef">uudecode</link></para></listitem>
               <listitem><para><link linkend="uuencoderef">uuencode</link></para></listitem>
               <listitem><para><link linkend="uuxref">uux</link></para></listitem>
               <listitem><para><link linkend="vacationref">vacation</link></para></listitem>
               <listitem><para><link linkend="vdirref">vdir</link></para></listitem>
               <listitem><para><link linkend="vmstatref">vmstat</link></para></listitem>
               <listitem><para><link linkend="vrfyref">vrfy</link></para></listitem>
               <listitem><para><link linkend="wref">w</link></para></listitem>
               <listitem><para><link linkend="waitref">wait</link></para></listitem>
               <listitem><para><link linkend="wallref">wall</link></para></listitem>
               <listitem><para><link linkend="watchref">watch</link></para></listitem>
               <listitem><para><link linkend="wcref">wc</link></para></listitem>
               <listitem><para><link linkend="wgetref">wget</link></para></listitem>
               <listitem><para><link linkend="whatisref">whatis</link></para></listitem>
               <listitem><para><link linkend="whereisref">whereis</link></para></listitem>
               <listitem><para><link linkend="whichref">which</link></para></listitem>
               <listitem><para><link linkend="whoref">who</link></para></listitem>
               <listitem><para><link linkend="whoamiref">whoami</link></para></listitem>
               <listitem><para><link linkend="whoisref">whois</link></para></listitem>
               <listitem><para><link linkend="writeref">write</link></para></listitem>
               <listitem><para><link linkend="xargsref">xargs</link></para></listitem>
               <listitem><para><link linkend="xrandrref">xrandr</link></para></listitem>
               <listitem><para><link linkend="xzref">xz</link></para></listitem>
               <listitem><para><link linkend="yaccref">yacc</link></para></listitem>
               <listitem><para><link linkend="yesref">yes</link></para></listitem>
               <listitem><para><link linkend="zcatref">zcat</link></para></listitem>
               <listitem><para><link linkend="zdiffref">zdiff</link></para></listitem>
               <listitem><para><link linkend="zdumpref">zdump</link></para></listitem>
               <listitem><para><link linkend="zegrepref">zegrep</link></para></listitem>
               <listitem><para><link linkend="zegrepref">zfgrep</link></para></listitem>
               <listitem><para><link linkend="zegrepref">zgrep</link></para></listitem>
               <listitem><para><link linkend="zipref">zip</link></para></listitem>

	    </itemizedlist>


  </partintro>

  <chapter xml:id="internal">
    <title>Internal Commands and Builtins</title>


      <indexterm>
	<primary>builtin</primary>
      </indexterm>


      <para><anchor xml:id="builtinref" />A <firstterm>builtin</firstterm>
	is a <command>command</command> contained within the Bash tool
	set, literally <firstterm>built in</firstterm>. This is either
	for performance reasons -- builtins execute faster than external
	commands, which usually require <firstterm>forking off</firstterm>
	  <footnote><para>As Nathan Coulter points out, "while forking a
	  process is a low-cost operation, executing a new program in
	  the newly-forked child process adds more
	  overhead."</para></footnote>
	a separate process -- or because a particular builtin needs
	direct access to the shell internals.</para>

      <para><anchor xml:id="forkref" /></para>

		 <sidebar>

		 <para><anchor xml:id="parentref" />When a command or
		   the shell itself initiates (or
		   <firstterm>spawns</firstterm>) a new
		   subprocess to carry out a task, this is called
		   <firstterm>forking</firstterm>. This new process
		   is the <firstterm>child</firstterm>, and the process
		   that <firstterm>forked</firstterm> it off is the
		   <firstterm>parent</firstterm>. While the <firstterm>child
		   process</firstterm> is doing its work, the
		   <firstterm>parent process</firstterm> is still
		   executing.</para>

		 <para>Note that while a <firstterm>parent
		   process</firstterm> gets the <firstterm>process
		   ID</firstterm> of the <firstterm>child
		   process</firstterm>, and can thus pass arguments to it,
		   <emphasis>the reverse is not true</emphasis>. <link linkend="parchildprobref">This can create problems
		   that are subtle and hard to track down.</link></para>

	    <example xml:id="spawnscr">
	      <title>A script that spawns multiple instances of itself</title>
	      <programlisting>#!/bin/bash
# spawn.sh


PIDS=$(pidof sh $0)  # Process IDs of the various instances of this script.
P_array=( $PIDS )    # Put them in an array (why?).
echo $PIDS           # Show process IDs of parent and child processes.
let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
                                      # Why subtract 1?
echo "$instances instance(s) of this script running."
echo "[Hit Ctl-C to exit.]"; echo


sleep 1              # Wait.
sh $0                # Play it again, Sam.

exit 0               # Not necessary; script will never get to here.
                     # Why not?

#  After exiting with a Ctl-C,
#+ do all the spawned instances of the script die?
#  If so, why?

# Note:
# ----
# Be careful not to run this script too long.
# It will eventually eat up too many system resources.

#  Is having a script spawn multiple instances of itself
#+ an advisable scripting technique.
#  Why or why not?
</programlisting>
	    </example>


		 <para><anchor xml:id="bltinfrk" /></para>
		 <para>Generally, a Bash <firstterm>builtin</firstterm>
		   does not fork a subprocess when it executes within
		   a script. An external system command or filter in
		   a script usually <emphasis>will</emphasis> fork a
		   subprocess.</para>

		   </sidebar>


      <para>A builtin may be a synonym to a system command of the same
	name, but Bash reimplements it internally.  For example,
	the Bash <command>echo</command> command is not the same as
	<filename>/bin/echo</filename>, although their behavior is
	almost identical.
	   <programlisting>#!/bin/bash

echo "This line uses the \"echo\" builtin."
/bin/echo "This line uses the /bin/echo system command."</programlisting>
	</para>

      <para><anchor xml:id="keywordref" />A <firstterm>keyword</firstterm>
	is a <firstterm>reserved</firstterm> word, token or
	operator. Keywords have a special meaning to the shell,
	and indeed are the building blocks of the shell's
	syntax. As examples, <firstterm>for</firstterm>,
	<firstterm>while</firstterm>, <firstterm>do</firstterm>,
	and <firstterm>!</firstterm> are keywords. Similar to a <link linkend="builtinref">builtin</link>, a keyword is hard-coded into
	Bash, but unlike a <firstterm>builtin</firstterm>, a keyword is
	not in itself a command, but <emphasis>a subunit of a command
	construct</emphasis>.

	   <footnote><para>An exception to this is the <link linkend="timref">time</link> command, listed in the
	     official Bash documentation as a keyword (<quote>reserved
	     word</quote>).</para></footnote>

	</para>


      <variablelist xml:id="intio">
        <title><anchor xml:id="intio1" />I/O</title>

	<varlistentry>
	  <term><anchor xml:id="echoref" /><command moreinfo="none">echo</command></term>
	  <listitem>
	  <indexterm>
	    <primary>echo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>echo</secondary>
	  </indexterm>
	    <para>prints (to <filename>stdout</filename>) an expression
	      or variable (see <xref linkend="ex9" />). 
	      <programlisting>echo Hello
echo $a</programlisting></para>
	    
	    <para>An <command>echo</command> requires the
	      <option>-e</option> option to print escaped characters. See
	      <xref linkend="escaped" />.</para>

	    <para>Normally, each <command>echo</command> command prints
	      a terminal newline, but the <option>-n</option> option
	      suppresses this.</para>

	    <para><anchor xml:id="echogrepref" /></para>
	    <note>
	    <para>An <command>echo</command> can be used to feed a
	      sequence of commands down a pipe.</para>
	    <para><programlisting>if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
then
  echo "$VAR contains the substring sequence \"txt\""
fi</programlisting></para>  
	    </note>  

	    <para><anchor xml:id="echocs" /></para>
	    <note><para>An <command>echo</command>, in combination with
	      <link linkend="commandsubref">command substitution</link>
	      can set a variable.</para> <para><userinput>a=`echo
	      "HELLO" | tr A-Z a-z`</userinput></para>
	      <para>See also <xref linkend="lowercase" />, <xref linkend="ex57" />, <xref linkend="monthlypmt" />, and <xref linkend="base" />.</para></note>


	    <para>Be aware that <command>echo `command`</command>
	      deletes any linefeeds that the output
	      of <replaceable>command</replaceable>
	      generates.</para>
	      
	    <para>The <link linkend="ifsref">$IFS</link> (internal field
	      separator) variable normally contains
	      <token>\n</token> (linefeed) as one of its set of
	      <link linkend="whitespaceref">whitespace</link>
	      characters. Bash therefore splits the output of
	      <replaceable>command</replaceable> at linefeeds
	      into arguments to <command>echo</command>.  Then
	      <command>echo</command> outputs these arguments,
	      separated by spaces.</para>
	      
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>ls -l /usr/share/apps/kjezz/sounds</userinput>
<computeroutput>-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</computeroutput>




<prompt>bash$ </prompt><userinput>echo `ls -l /usr/share/apps/kjezz/sounds`</userinput>
<computeroutput>total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...</computeroutput>
	      </screen>
	    </para>

            <para>
              So, how can we embed a linefeed within an
	      <link linkend="echoref">echoed</link> character string?

	     <programlisting># Embedding a linefeed?
echo "Why doesn't this string \n split on two lines?"
# Doesn't split.

# Let's try something else.

echo
	     
echo $"A line of text containing
a linefeed."
# Prints as two distinct lines (embedded linefeed).
# But, is the "$" variable prefix really necessary?

echo

echo "This string splits
on two lines."
# No, the "$" is not needed.

echo
echo "---------------"
echo

echo -n $"Another line of text containing
a linefeed."
# Prints as two distinct lines (embedded linefeed).
# Even the -n option fails to suppress the linefeed here.

echo
echo
echo "---------------"
echo
echo

# However, the following doesn't work as expected.
# Why not? Hint: Assignment to a variable.
string1=$"Yet another line of text containing
a linefeed (maybe)."

echo $string1
# Yet another line of text containing a linefeed (maybe).
#                                    ^
# Linefeed becomes a space.

# Thanks, Steve Parker, for pointing this out.</programlisting>
            </para>

	    <para><anchor xml:id="binecho" /></para>
	    <note>
	    <para>This command is a shell builtin, and not the same as
	      <filename>/bin/echo</filename>, although its behavior is
	      similar.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>type -a echo</userinput>
<computeroutput>echo is a shell builtin
 echo is /bin/echo</computeroutput>
	      </screen>
	  </para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="printfref" /><command moreinfo="none">printf</command></term>
	  <listitem>
	  <indexterm>
	    <primary>printf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>printf</secondary>
	  </indexterm>
	    <para>The <command>printf</command>, formatted print, command is an
	      enhanced <command>echo</command>. It is a limited variant
	      of the <firstterm>C</firstterm> language
	      <function>printf()</function> library function, and its
	      syntax is somewhat different.</para>
	    <cmdsynopsis sepchar=" ">
	      <command>printf</command>
	      <arg choice="plain" rep="repeat"><replaceable>format-string</replaceable></arg>
	      <arg choice="plain" rep="repeat"><replaceable>parameter</replaceable></arg>
	    </cmdsynopsis>

	    <para>This is the Bash <firstterm>builtin</firstterm> version
	      of the <filename>/bin/printf</filename> or
	      <filename>/usr/bin/printf</filename> command. See the
	      <command>printf</command> <link linkend="manref">manpage</link> (of the system command)
	      for in-depth coverage.</para>

	    <caution><para>Older versions of Bash may not support
	      <command>printf</command>.</para></caution>

	    <example xml:id="ex47">
	      <title><firstterm>printf</firstterm> in action</title>
	      <programlisting>#!/bin/bash
# printf demo

declare -r PI=3.14159265358979     # Read-only variable, i.e., a constant.
declare -r DecimalConstant=31373

Message1="Greetings,"
Message2="Earthling."

echo

printf "Pi to 2 decimal places = %1.2f" $PI
echo
printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.

printf "\n"                                  # Prints a line feed,
                                             # Equivalent to 'echo' . . .

printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t).

printf "%s %s \n" $Message1 $Message2

echo

# ==========================================#
# Simulation of C function, sprintf().
# Loading a variable with a formatted string.

echo 

Pi12=$(printf "%1.12f" $PI)
echo "Pi to 12 decimal places = $Pi12"      # Roundoff error!

Msg=`printf "%s %s \n" $Message1 $Message2`
echo $Msg; echo $Msg

#  As it happens, the 'sprintf' function can now be accessed
#+ as a loadable module to Bash,
#+ but this is not portable.

exit 0
</programlisting>
	    </example>

	    <para>Formatting error messages is a useful application of
	      <command>printf</command></para>

            <para>
	        <programlisting>E_BADDIR=85

var=nonexistent_directory

error()
{
  printf "$@" &gt;&amp;2
  # Formats positional params passed, and sends them to stderr.
  echo
  exit $E_BADDIR
}

cd $var || error $"Can't cd to %s." "$var"

# Thanks, S.C.</programlisting>
            </para>

            <para>See also <xref linkend="progressbar" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="readref" /><command moreinfo="none">read</command></term> 
	  <listitem>
          <indexterm>
	    <primary>read</primary>
	  </indexterm> <indexterm>
	    <primary>command</primary> <secondary>read</secondary>
	  </indexterm> 
          <para><quote>Reads</quote> the value
	    of a variable from <filename>stdin</filename>, that
	    is, interactively fetches input from the keyboard. The
	    <option>-a</option> option lets <command>read</command>
	    get array variables (see <xref linkend="ex67" />).</para>

	    <example xml:id="ex36">
	      <title>Variable assignment, using <firstterm>read</firstterm></title>
	      <programlisting>#!/bin/bash
# "Reading" variables.

echo -n "Enter the value of variable 'var1': "
# The -n option to echo suppresses newline.

read var1
# Note no '$' in front of var1, since it is being set.

echo "var1 = $var1"


echo

# A single 'read' statement can set multiple variables.
echo -n "Enter the values of variables 'var2' and 'var3' "
echo =n "(separated by a space or tab): "
read var2 var3
echo "var2 = $var2      var3 = $var3"
#  If you input only one value,
#+ the other variable(s) will remain unset (null).

exit 0
</programlisting>
	    </example>


	    <para>A <command>read</command> without an associated variable
	      assigns its input to the dedicated variable <link linkend="replyref">$REPLY</link>.</para>

	    <example xml:id="readnovar">
	      <title>What happens when <firstterm>read</firstterm> has no
	        variable</title>
	      <programlisting>#!/bin/bash
# read-novar.sh

echo

# -------------------------- #
echo -n "Enter a value: "
read var
echo "\"var\" = "$var""
# Everything as expected here.
# -------------------------- #

echo

# ------------------------------------------------------------------- #
echo -n "Enter another value: "
read           #  No variable supplied for 'read', therefore...
               #+ Input to 'read' assigned to default variable, $REPLY.
var="$REPLY"
echo "\"var\" = "$var""
# This is equivalent to the first code block.
# ------------------------------------------------------------------- #

echo
echo "========================="
echo


#  This example is similar to the "reply.sh" script.
#  However, this one shows that $REPLY is available
#+ even after a 'read' to a variable in the conventional way.


# ================================================================= #

#  In some instances, you might wish to discard the first value read.
#  In such cases, simply ignore the $REPLY variable.

{ # Code block.
read            # Line 1, to be discarded.
read line2      # Line 2, saved in variable.
  } &lt;$0
echo "Line 2 of this script is:"
echo "$line2"   #   # read-novar.sh
echo            #   #!/bin/bash  line discarded.

# See also the soundcard-on.sh script.

exit 0
</programlisting>
	    </example>


	    <para>Normally, inputting a <userinput>\</userinput>
	      suppresses a newline during input to
	      a <command>read</command>. The <option>-r</option>
	      option causes an inputted <userinput>\</userinput> to be
	      interpreted literally.</para>

	    <example xml:id="readr">
	      <title>Multi-line input to <firstterm>read</firstterm></title>
	      <programlisting>#!/bin/bash

echo

echo "Enter a string terminated by a \\, then press &lt;ENTER&gt;."
echo "Then, enter a second string (no \\ this time), and again press &lt;ENTER&gt;."

read var1     # The "\" suppresses the newline, when reading $var1.
              #     first line \
              #     second line

echo "var1 = $var1"
#     var1 = first line second line

#  For each line terminated by a "\"
#+ you get a prompt on the next line to continue feeding characters into var1.

echo; echo

echo "Enter another string terminated by a \\ , then press &lt;ENTER&gt;."
read -r var2  # The -r option causes the "\" to be read literally.
              #     first line \

echo "var2 = $var2"
#     var2 = first line \

# Data entry terminates with the first &lt;ENTER&gt;.

echo 

exit 0
</programlisting>
	    </example>

	    
	    <para><anchor xml:id="readoptions" /></para>
	    <para>The <command>read</command> command has some interesting
	      options that permit echoing a prompt and even reading keystrokes
	      without hitting <keycap>ENTER</keycap>.</para>

	    <para><programlisting># Read a keypress without hitting ENTER.

read -s -n1 -p "Hit a key " keypress
echo; echo "Keypress was "\"$keypress\""."

# -s option means do not echo input.
# -n N option means accept only N characters of input.
# -p option means echo the following prompt before reading input.

# Using these options is tricky, since they need to be in the correct order.</programlisting></para>


	    <para><anchor xml:id="readarrow" /></para>
	    <para>The <option>-n</option> option to <command>read</command>
	      also allows detection of the <keycap>arrow keys</keycap>
	      and certain of the other unusual keys.</para>

	    <example xml:id="arrowdetect">
	      <title>Detecting the arrow keys</title>
	      <programlisting>#!/bin/bash
# arrow-detect.sh: Detects the arrow keys, and a few more.
# Thank you, Sandro Magi, for showing me how.

# --------------------------------------------
# Character codes generated by the keypresses.
arrowup='\[A'
arrowdown='\[B'
arrowrt='\[C'
arrowleft='\[D'
insert='\[2'
delete='\[3'
# --------------------------------------------

SUCCESS=0
OTHER=65

echo -n "Press a key...  "
# May need to also press ENTER if a key not listed above pressed.
read -n3 key                      # Read 3 characters.

echo -n "$key" | grep "$arrowup"  #Check if character code detected.
if [ "$?" -eq $SUCCESS ]
then
  echo "Up-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowdown"
if [ "$?" -eq $SUCCESS ]
then
  echo "Down-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowrt"
if [ "$?" -eq $SUCCESS ]
then
  echo "Right-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowleft"
if [ "$?" -eq $SUCCESS ]
then
  echo "Left-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$insert"
if [ "$?" -eq $SUCCESS ]
then
  echo "\"Insert\" key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$delete"
if [ "$?" -eq $SUCCESS ]
then
  echo "\"Delete\" key pressed."
  exit $SUCCESS
fi


echo " Some other key pressed."

exit $OTHER

# ========================================= #

#  Mark Alexander came up with a simplified
#+ version of the above script (Thank you!).
#  It eliminates the need for grep.

#!/bin/bash

  uparrow=$'\x1b[A'
  downarrow=$'\x1b[B'
  leftarrow=$'\x1b[D'
  rightarrow=$'\x1b[C'

  read -s -n3 -p "Hit an arrow key: " x

  case "$x" in
  $uparrow)
     echo "You pressed up-arrow"
     ;;
  $downarrow)
     echo "You pressed down-arrow"
     ;;
  $leftarrow)
     echo "You pressed left-arrow"
     ;;
  $rightarrow)
     echo "You pressed right-arrow"
     ;;
  esac

exit $?

# ========================================= #

# Antonio Macchi has a simpler alternative.

#!/bin/bash

while true
do
  read -sn1 a
  test "$a" == `echo -en "\e"` || continue
  read -sn1 a
  test "$a" == "[" || continue
  read -sn1 a
  case "$a" in
    A)  echo "up";;
    B)  echo "down";;
    C)  echo "right";;
    D)  echo "left";;
  esac
done

# ========================================= #

#  Exercise:
#  --------
#  1) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.
</programlisting>
	    </example>

	    <note><para>The <option>-n</option> option to <command>read</command>
	      will not detect the <keycap>ENTER</keycap> (newline)
	      key.</para></note>


	    <para><anchor xml:id="readtimed" /></para>
	    <para>The <option>-t</option> option to <command>read</command>
	      permits timed input (see <xref linkend="tout" /> and <xref linkend="qky" />).</para>

             <para><anchor xml:id="readfd" />The <option>-u</option> option
                takes the <link linkend="fdref">file descriptor</link>
                of the target file.</para>

	    <para><anchor xml:id="readredir0" /></para>
	    <para>The <command>read</command> command may also
	      <quote>read</quote> its variable value from a file
	      <link linkend="ioredirref">redirected</link> to
	      <filename>stdin</filename>.  If the file contains
	      more than one line, only the first line is assigned
	      to the variable. If <command>read</command>
	      has more than one parameter, then each of
	      these variables gets assigned a successive <link linkend="whitespaceref">whitespace-delineated</link>
	      string. Caution!</para>

	    <example xml:id="readredir">
	      <title>Using <firstterm>read</firstterm> with
	        <link linkend="ioredirref">file redirection</link></title>
	      <programlisting>#!/bin/bash

read var1 &lt;data-file
echo "var1 = $var1"
# var1 set to the entire first line of the input file "data-file"

read var2 var3 &lt;data-file
echo "var2 = $var2   var3 = $var3"
# Note non-intuitive behavior of "read" here.
# 1) Rewinds back to the beginning of input file.
# 2) Each variable is now set to a corresponding string,
#    separated by whitespace, rather than to an entire line of text.
# 3) The final variable gets the remainder of the line.
# 4) If there are more variables to be set than whitespace-terminated strings
#    on the first line of the file, then the excess variables remain empty.

echo "------------------------------------------------"

# How to resolve the above problem with a loop:
while read line
do
  echo "$line"
done &lt;data-file
# Thanks, Heiner Steven for pointing this out.

echo "------------------------------------------------"

# Use $IFS (Internal Field Separator variable) to split a line of input to
# "read", if you do not want the default to be whitespace.

echo "List of all users:"
OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
while read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done &lt;/etc/passwd   # I/O redirection.
IFS=$OIFS              # Restore original $IFS.
# This code snippet also by Heiner Steven.



#  Setting the $IFS variable within the loop itself
#+ eliminates the need for storing the original $IFS
#+ in a temporary variable.
#  Thanks, Dim Segebart, for pointing this out.
echo "------------------------------------------------"
echo "List of all users:"

while IFS=: read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done &lt;/etc/passwd   # I/O redirection.

echo
echo "\$IFS still $IFS"

exit 0
</programlisting>
	    </example>

	    <note>

		    <para><anchor xml:id="pipereadref0" /></para>
	    <para><link linkend="piperef">Piping</link> output
	      to a <firstterm>read</firstterm>, using <link linkend="echoref">echo</link> to set variables <link linkend="badread0">will fail</link>.</para>

	    <para><anchor xml:id="readpiperef" />Yet, piping the output of <link linkend="catref">cat</link> <emphasis>seems</emphasis> to
	      work.</para>

	    <para><anchor xml:id="whilereadref" /></para>

	    <para><programlisting>cat file1 file2 |
while read line
do
echo $line
done</programlisting></para>


            <para>However, as Bjn Eriksson shows:</para>

    <example xml:id="readpipe">
      <title>Problems reading from a pipe</title>
      <programlisting>#!/bin/sh
# readpipe.sh
# This example contributed by Bjon Eriksson.

### shopt -s lastpipe

last="(null)"
cat $0 |
while read line
do
    echo "{$line}"
    last=$line
done

echo
echo "++++++++++++++++++++++"
printf "\nAll done, last: $last\n" #  The output of this line
                                   #+ changes if you uncomment line 5.
                                   #  (Bash, version -ge 4.2 required.)

exit 0  # End of code.
        # (Partial) output of script follows.
        # The 'echo' supplies extra brackets.

#############################################

./readpipe.sh 

{#!/bin/sh}
{last="(null)"}
{cat $0 |}
{while read line}
{do}
{echo "{$line}"}
{last=$line}
{done}
{printf "nAll done, last: $lastn"}


All done, last: (null)

The variable (last) is set within the loop/subshell
but its value does not persist outside the loop.
</programlisting>
    </example>

            <para>The <firstterm>gendiff</firstterm> script, usually
              found in <filename>/usr/bin</filename> on
              many Linux distros, pipes the output of <link linkend="findref">find</link> to a <firstterm>while
              read</firstterm> construct.

	      <programlisting>find $1 \( -name "*$2" -o -name ".*$2" \) -print |
while read f; do
. . .</programlisting>
            </para>

	      </note>

	      <tip>
	      <para>It is possible to <firstterm>paste</firstterm> text into
	        the input field of a <firstterm>read</firstterm> (but
		<emphasis>not</emphasis> multiple lines!). See <xref linkend="padsw" />.</para>
	      </tip>
	      

	    </listitem>
	  </varlistentry>

      </variablelist>

      <variablelist xml:id="intfilesystem">
        <title><anchor xml:id="intfilesystem1" />Filesystem</title>

	<varlistentry>
	  <term><anchor xml:id="cdref" /><command moreinfo="none">cd</command></term>
          <listitem>
	  <indexterm>
	    <primary>cd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cd</secondary>
	  </indexterm>
	    <para>The familiar <command>cd</command> change directory
	      command finds use in scripts where execution of a command
	      requires being in a specified directory.</para>

	    <para>  
	      <programlisting>(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)</programlisting>
	      [from the <link linkend="coxex">previously cited</link>
	      example by Alan Cox]</para>

	    <para>The <option>-P</option> (physical) option to
	      <command>cd</command> causes it to ignore symbolic
	      links.</para>

	    <para><command>cd -</command> changes to <link linkend="oldpwd">$OLDPWD</link>, the previous working
	    directory.</para>

	    <para><anchor xml:id="doubleslashref" /></para>

	    <caution><para>The <command>cd</command> command does not function
	      as expected when presented with two forward slashes.

	      <screen>
<prompt>bash$ </prompt><userinput>cd //</userinput>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>//</computeroutput>
	      </screen>
	      The output should, of course, be <computeroutput>/</computeroutput>.
	      This is a problem both from the command-line and in a script.</para></caution>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor xml:id="pwd2ref" /><command moreinfo="none">pwd</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pwd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
            <para>Print Working Directory. This gives the user's
	      (or script's) current directory (see <xref linkend="ex37" />). The effect is identical to
	      reading the value of the builtin variable <link linkend="pwdref">$PWD</link>.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor xml:id="dirsd" /><command moreinfo="none">pushd</command></term>
	<term><command moreinfo="none">popd</command></term>
	<term><command moreinfo="none">dirs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pushd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pushd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>popd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>popd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>bookmark</primary>
	  </indexterm>
            <para>This command set is a mechanism for bookmarking
	      working directories, a means of moving back and forth
	      through directories in an orderly manner. A pushdown <link linkend="stackdefref">stack</link> is used to keep track
	      of directory names. Options allow various manipulations
	      of the directory stack.</para>

	    <para><anchor xml:id="pushdref" /><userinput>pushd
	      dir-name</userinput> pushes the path
	      <replaceable>dir-name</replaceable> onto the directory
	      stack (to the <firstterm>top</firstterm> of the stack)
	      and simultaneously changes the current working directory
	      to <replaceable>dir-name</replaceable></para>

	    <para><anchor xml:id="popdref" /><command>popd</command> removes
	      (pops) the top directory path name off the directory stack
	      and simultaneously changes the current working directory
	      to the directory now at the <firstterm>top</firstterm> of
	      the stack.</para>
	    
	    <para><anchor xml:id="dirsref" /><command>dirs</command> lists
	      the contents of the directory stack (compare this
	      with the <link linkend="dirstackref">$DIRSTACK</link>
	      variable).  A successful <command>pushd</command>
	      or <command>popd</command> will automatically invoke
	      <command>dirs</command>.</para>


	    <para>Scripts that require various changes to the current
	      working directory without hard-coding the directory name
	      changes can make good use of these commands. Note that
	      the implicit <varname>$DIRSTACK</varname> array variable,
	      accessible from within a script, holds the contents of
	      the directory stack.
	    </para>

	    <example xml:id="ex37">
	      <title>Changing the current working directory</title>
	      <programlisting>#!/bin/bash

dir1=/usr/local
dir2=/var/spool

pushd $dir1
# Will do an automatic 'dirs' (list directory stack to stdout).
echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.

# Now, do some stuff in directory 'dir1'.
pushd $dir2
echo "Now in directory `pwd`."

# Now, do some stuff in directory 'dir2'.
echo "The top entry in the DIRSTACK array is $DIRSTACK."
popd
echo "Now back in directory `pwd`."

# Now, do some more stuff in directory 'dir1'.
popd
echo "Now back in original working directory `pwd`."

exit 0

# What happens if you don't 'popd' -- then exit the script?
# Which directory do you end up in? Why?
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="intvar">
        <title><anchor xml:id="intvar1" />Variables</title>

	<varlistentry>
	  <term><anchor xml:id="letref" /><command moreinfo="none">let</command></term>
	  <listitem>
	  <indexterm>
	    <primary>let</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>let</secondary>
	  </indexterm>
		  <para>The <command>let</command> command carries out
                    <firstterm>arithmetic</firstterm> operations on variables.

          <footnote><para>Note that <firstterm>let</firstterm>
          <link linkend="letbad">cannot be used
          for setting <firstterm>string</firstterm>
          variables.</link></para></footnote>
			  
		    In many cases, it functions as a less complex version
                    of <link linkend="exprref">expr</link>.</para>

	    <example xml:id="ex46">
	      <title>Letting <firstterm>let</firstterm> do arithmetic.</title>
	      <programlisting>#!/bin/bash

echo

let a=11            # Same as 'a=11'
let a=a+5           # Equivalent to  let "a = a + 5"
                    # (Double quotes and spaces make it more readable.)
echo "11 + 5 = $a"  # 16

let "a &lt;&lt;= 3"       # Equivalent to  let "a = a &lt;&lt; 3"
echo "\"\$a\" (=16) left-shifted 3 places = $a"
                    # 128

let "a /= 4"        # Equivalent to  let "a = a / 4"
echo "128 / 4 = $a" # 32

let "a -= 5"        # Equivalent to  let "a = a - 5"
echo "32 - 5 = $a"  # 27

let "a *=  10"      # Equivalent to  let "a = a * 10"
echo "27 * 10 = $a" # 270

let "a %= 8"        # Equivalent to  let "a = a % 8"
echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
                    # 6


# Does "let" permit C-style operators?
# Yes, just as the (( ... )) double-parentheses construct does.

let a++             # C-style (post) increment.
echo "6++ = $a"     # 6++ = 7
let a--             # C-style decrement.
echo "7-- = $a"     # 7-- = 6
# Of course, ++a, etc., also allowed . . .
echo


# Trinary operator.

# Note that $a is 6, see above.
let "t = a&lt;7?7:11"   # True
echo $t  # 7

let a++
let "t = a&lt;7?7:11"   # False
echo $t  #     11

exit
</programlisting>
	    </example>	    

            <para><anchor xml:id="exitvalanomaly02" /></para>

		    <caution>
                      <para>The <firstterm>let</firstterm> command can,
                      in certain contexts, return a surprising <link linkend="exitstatusref">exit status</link>.</para>
                     <para><programlisting># Evgeniy Ivanov points out:

var=0
echo $?     # 0
            # As expected.

let var++
echo $?     # 1
            # The command was successful, so why isn't $?=0 ???
            # Anomaly!

let var++
echo $?     # 0
            # As expected.


# Likewise . . .

let var=0
echo $?     # 1
            # The command was successful, so why isn't $?=0 ???

#  However, as Jeff Gorak points out,
#+ this is part of the design spec for 'let' . . .
# "If the last ARG evaluates to 0, let returns 1;
#  let returns 0 otherwise." ['help let']</programlisting></para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="evalref" /><command moreinfo="none">eval</command></term>
	  <listitem>
	  <indexterm>
	    <primary>eval</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>eval</secondary>
	  </indexterm>
	    
	    <para><userinput>eval arg1 [arg2] ... [argN]</userinput></para>
	    
	    <para>Combines the arguments in an expression or list of
              expressions and <replaceable>evaluates</replaceable> them.
              Any variables within the expression are expanded. The
	      net result is to <command>convert a string into a
              command</command>.</para>
	      
            <tip><para>The <command>eval</command> command can be used for
	      code generation from the command-line or within a script.
	      </para></tip>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>command_string="ps ax"</userinput>
<prompt>bash$ </prompt><userinput>process="ps ax"</userinput>
<prompt>bash$ </prompt><userinput>eval "$command_string" | grep "$process"</userinput>
<computeroutput>26973 pts/3    R+     0:00 grep --color ps ax
 26974 pts/3    R+     0:00 ps ax</computeroutput>
	      </screen>
	      </para>

      <para><anchor xml:id="evalforced" /></para>
      <para>Each invocation of <firstterm>eval</firstterm> forces
        a re-<emphasis>evaluation</emphasis> of its arguments.
	<programlisting>a='$b'
b='$c'
c=d

echo $a             # $b
                    # First level.
eval echo $a        # $c
                    # Second level.
eval eval echo $a   # d
                    # Third level.

# Thank you, E. Choroba.</programlisting></para>


	    <para><anchor xml:id="evaleff" /></para>
	    <example xml:id="ex43">
	      <title>Showing the effect of <firstterm>eval</firstterm></title>
	      <programlisting>#!/bin/bash
# Exercising "eval" ...

y=`eval ls -l`  #  Similar to y=`ls -l`
echo $y         #+ but linefeeds removed because "echoed" variable is unquoted.
echo
echo "$y"       #  Linefeeds preserved when variable is quoted.

echo; echo

y=`eval df`     #  Similar to y=`df`
echo $y         #+ but linefeeds removed.

#  When LF's not preserved, it may make it easier to parse output,
#+ using utilities such as "awk".

echo
echo "==========================================================="
echo

eval "`seq 3 | sed -e 's/.*/echo var&amp;=ABCDEFGHIJ/'`"
# var1=ABCDEFGHIJ
# var2=ABCDEFGHIJ
# var3=ABCDEFGHIJ

echo
echo "==========================================================="
echo


# Now, showing how to do something useful with "eval" . . .
# (Thank you, E. Choroba!)

version=3.4     #  Can we split the version into major and minor
                #+ part in one command?
echo "version = $version"
eval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='
                                    #  The substitution yields '3; minor=4'
                                    #+ so eval does minor=4, major=3
echo Major: $major, minor: $minor   #  Major: 3, minor: 4
</programlisting>
	    </example>	    

	    <para><anchor xml:id="arrchoice0" /></para>
	    <example xml:id="arrchoice">
		    <title>Using <firstterm>eval</firstterm> to select
                      among variables</title>
	      <programlisting>#!/bin/bash
# arr-choice.sh

#  Passing arguments to a function to select
#+ one particular variable out of a group.

arr0=( 10 11 12 13 14 15 )
arr1=( 20 21 22 23 24 25 )
arr2=( 30 31 32 33 34 35 )
#       0  1  2  3  4  5      Element number (zero-indexed)


choose_array ()
{
  eval array_member=\${arr${array_number}[element_number]}
  #                 ^       ^^^^^^^^^^^^
  #  Using eval to construct the name of a variable,
  #+ in this particular case, an array name.

  echo "Element $element_number of array $array_number is $array_member"
} #  Function can be rewritten to take parameters.

array_number=0    # First array.
element_number=3
choose_array      # 13

array_number=2    # Third array.
element_number=4
choose_array      # 34

array_number=3    # Null array (arr3 not allocated).
element_number=4
choose_array      # (null)

# Thank you, Antonio Macchi, for pointing this out.
</programlisting>
	    </example>	    

	    <example xml:id="echoparams">
	      <title><firstterm>Echoing</firstterm> the
	        <firstterm>command-line parameters</firstterm></title>
	      <programlisting>#!/bin/bash
# echo-params.sh

# Call this script with a few command-line parameters.
# For example:
#     sh echo-params.sh first second third fourth fifth

params=$#              # Number of command-line parameters.
param=1                # Start at first command-line param.

while [ "$param" -le "$params" ]
do
  echo -n "Command-line parameter "
  echo -n \$$param     #  Gives only the *name* of variable.
#         ^^^          #  $1, $2, $3, etc.
                       #  Why?
                       #  \$ escapes the first "$"
                       #+ so it echoes literally,
                       #+ and $param dereferences "$param" . . .
                       #+ . . . as expected.
  echo -n " = "
  eval echo \$$param   #  Gives the *value* of variable.
# ^^^^      ^^^        #  The "eval" forces the *evaluation*
                       #+ of \$$
                       #+ as an indirect variable reference.

(( param ++ ))         # On to the next.
done

exit $?

# =================================================

$ sh echo-params.sh first second third fourth fifth
Command-line parameter $1 = first
Command-line parameter $2 = second
Command-line parameter $3 = third
Command-line parameter $4 = fourth
Command-line parameter $5 = fifth
</programlisting>
	    </example>	    

	    <example xml:id="ex44">
	      <title>Forcing a log-off</title>
	      <programlisting>#!/bin/bash
# Killing ppp to force a log-off.
# For dialup connection, of course.

# Script should be run as root user.

SERPORT=ttyS3
#  Depending on the hardware and even the kernel version,
#+ the modem port on your machine may be different --
#+ /dev/ttyS1 or /dev/ttyS2.


killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
#                     -------- process ID of ppp -------  

$killppp                     # This variable is now a command.


# The following operations must be done as root user.

chmod 666 /dev/$SERPORT      # Restore r+w permissions, or else what?
#  Since doing a SIGKILL on ppp changed the permissions on the serial port,
#+ we restore permissions to previous state.

rm /var/lock/LCK..$SERPORT   # Remove the serial port lock file. Why?

exit $?

# Exercises:
# ---------
# 1) Have script check whether root user is invoking it.
# 2) Do a check on whether the process to be killed
#+   is actually running before attempting to kill it.   
# 3) Write an alternate version of this script based on 'fuser':
#+      if [ fuser -s /dev/modem ]; then . . .
</programlisting>
	    </example>	    

	    <example xml:id="rot14">
	      <title>A version of <firstterm>rot13</firstterm></title>
	      <programlisting>#!/bin/bash
# A version of "rot13" using 'eval'.
# Compare to "rot13.sh" example.

setvar_rot_13()              # "rot13" scrambling
{
  local varname=$1 varvalue=$2
  eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
}


setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
echo $var                    # sbbone

setvar_rot_13 var "$var"     # Run "sbbone" through rot13.
                             # Back to original variable.
echo $var                    # foobar

# This example by Stephane Chazelas.
# Modified by document author.

exit 0
</programlisting>
	    </example>	    

	    <para>Here is another example of using
              <firstterm>eval</firstterm> to
              <emphasis>evaluate</emphasis> a complex expression,
              this one from an earlier version of YongYe's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/yongye/shell/blob/master/Tetris_Game.sh">Tetris
			  game script</link>.</para>

	   <para>
           <programlisting>eval ${1}+=\"${x} ${y} \"</programlisting>
           </para>

	    <para><xref linkend="samorse" /> uses
	      <firstterm>eval</firstterm> to convert <link linkend="arrayref">array</link> elements into a command
              list.</para>

	    <para>The <firstterm>eval</firstterm> command occurs
	      in the older version of <link linkend="ivrref">indirect
	      referencing</link>.
	      <programlisting>eval var=\$$var</programlisting> 
	      </para>

	      <tip><para>The <firstterm>eval</firstterm> command can
                be used to <link linkend="braceexpref3">parameterize
                <firstterm>brace expansion</firstterm></link>.</para></tip>


	    <para><anchor xml:id="evalrisk" /></para>
	    <caution><para>The <command>eval</command> command can be
	      risky, and normally should be avoided when there
	      exists a reasonable alternative. An <userinput>eval
	      $COMMANDS</userinput> executes the contents of
	      <replaceable>COMMANDS</replaceable>, which may
	      contain such unpleasant surprises as <command>rm -rf
	      *</command>. Running an <command>eval</command> on
	      unfamiliar code written by persons unknown is living
	      dangerously.</para></caution>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="setref" /><command moreinfo="none">set</command></term>
	  <listitem>
	  <indexterm>
	    <primary>set</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>set</secondary>
	  </indexterm>
            <para>The <command>set</command> command changes
	      the value of internal script variables/options. One use for
	      this is to toggle <link linkend="optionsref">option
	      flags</link> which help determine the behavior of the
	      script. Another application for it is to reset the <link linkend="posparamref">positional parameters</link> that
	      a script sees as the result of a command (<userinput>set
	      `command`</userinput>). The script can then parse the
	      <link linkend="fieldref">fields</link> of the command
	      output.</para>

	    <example xml:id="ex34">
	      <title>Using <firstterm>set</firstterm> with positional
	        parameters</title>
	      <programlisting>#!/bin/bash
# ex34.sh
# Script "set-test"

# Invoke this script with three command-line parameters,
# for example, "sh ex34.sh one two three".

echo
echo "Positional parameters before  set \`uname -a\` :"
echo "Command-line argument #1 = $1"
echo "Command-line argument #2 = $2"
echo "Command-line argument #3 = $3"


set `uname -a` # Sets the positional parameters to the output
               # of the command `uname -a`

echo
echo +++++
echo $_        # +++++
# Flags set in script.
echo $-        # hB
#                Anomalous behavior?
echo

echo "Positional parameters after  set \`uname -a\` :"
# $1, $2, $3, etc. reinitialized to result of `uname -a`
echo "Field #1 of 'uname -a' = $1"
echo "Field #2 of 'uname -a' = $2"
echo "Field #3 of 'uname -a' = $3"
echo \#\#\#
echo $_        # ###
echo

exit 0
</programlisting>
	    </example>

	    <para>More fun with positional parameters.</para>

	    <example xml:id="revposparams">
	      <title>Reversing the positional parameters</title>
	      <programlisting>#!/bin/bash
# revposparams.sh: Reverse positional parameters.
# Script by Dan Jacobson, with stylistic revisions by document author.


set a\ b c d\ e;
#     ^      ^     Spaces escaped 
#       ^ ^        Spaces not escaped
OIFS=$IFS; IFS=:;
#              ^   Saving old IFS and setting new one.

echo

until [ $# -eq 0 ]
do          #      Step through positional parameters.
  echo "### k0 = "$k""     # Before
  k=$1:$k;  #      Append each pos param to loop variable.
#     ^
  echo "### k = "$k""      # After
  echo
  shift;
done

set $k  #  Set new positional parameters.
echo -
echo $# #  Count of positional parameters.
echo -
echo

for i   #  Omitting the "in list" sets the variable -- i --
        #+ to the positional parameters.
do
  echo $i  # Display new positional parameters.
done

IFS=$OIFS  # Restore IFS.

#  Question:
#  Is it necessary to set an new IFS, internal field separator,
#+ in order for this script to work properly?
#  What happens if you don't? Try it.
#  And, why use the new IFS -- a colon -- in line 17,
#+ to append to the loop variable?
#  What is the purpose of this?

exit 0

$ ./revposparams.sh

### k0 = 
### k = a b

### k0 = a b
### k = c a b

### k0 = c a b
### k = d e c a b

-
3
-

d e
c
a b
</programlisting>
	    </example>

	    <para>Invoking <command>set</command> without any options or
	      arguments simply lists all the <link linkend="envref">environmental</link> and other variables
	      that have been initialized.</para>

            <para>
	      <screen>
<prompt>bash$ </prompt><userinput>set</userinput>
<computeroutput>AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$'2.05.8(1)-release'
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy</computeroutput>
	      </screen>
            </para>


	    <para>Using <command>set</command> with the <option>--</option>
	      option explicitly assigns the contents of a variable to
	      the positional parameters. If no variable follows the
	      <option>--</option> it <firstterm>unsets</firstterm>
	      the positional parameters.</para>

	    <example xml:id="setpos">
	      <title>Reassigning the positional parameters</title>
	      <programlisting>#!/bin/bash

variable="one two three four five"

set -- $variable
# Sets positional parameters to the contents of "$variable".

first_param=$1
second_param=$2
shift; shift        # Shift past first two positional params.
# shift 2             also works.
remaining_params="$*"

echo
echo "first parameter = $first_param"             # one
echo "second parameter = $second_param"           # two
echo "remaining parameters = $remaining_params"   # three four five

echo; echo

# Again.
set -- $variable
first_param=$1
second_param=$2
echo "first parameter = $first_param"             # one
echo "second parameter = $second_param"           # two

# ======================================================

set --
# Unsets positional parameters if no variable specified.

first_param=$1
second_param=$2
echo "first parameter = $first_param"             # (null value)
echo "second parameter = $second_param"           # (null value)

exit 0
</programlisting>
	    </example>

	    <para>See also <xref linkend="ex22a" /> and <xref linkend="ex33a" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="unsetref" /><command moreinfo="none">unset</command></term>
	  <listitem>
	  <indexterm>
	    <primary>unset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unset</secondary>
	  </indexterm>
            <para>The <command>unset</command> command deletes a
	      shell variable, effectively setting it to
	      <firstterm>null</firstterm>. Note that this command does
	      not affect positional parameters.</para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>unset PATH</userinput>

<prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>


</computeroutput>
<prompt>bash$ </prompt></screen>
	    </para>

	    <example xml:id="uns">
	      <title><quote>Unsetting</quote> a variable</title>
	      <programlisting>#!/bin/bash
# unset.sh: Unsetting a variable.

variable=hello                       #  Initialized.
echo "variable = $variable"

unset variable                       #  Unset.
                                     #  In this particular context,
                                     #+ same effect as:   variable=
echo "(unset) variable = $variable"  #  $variable is null.

if [ -z "$variable" ]                #  Try a string-length test.
then
  echo "\$variable has zero length."
fi

exit 0
</programlisting>
	    </example>

	    <note><para>In most contexts, an <firstterm>undeclared</firstterm>
              variable and one that has been <firstterm>unset</firstterm>
	      are equivalent. However, the <link linkend="unddr">
              ${parameter:-default}</link> parameter substitution
              construct can distinguish between the two.</para></note>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor xml:id="exportref" /><command moreinfo="none">export</command></term>
	  <listitem>
	  <indexterm>
	    <primary>export</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>export</secondary>
	  </indexterm>
	  
          <para><anchor xml:id="exportref2" /></para>
	  <para>The <command>export</command>

	      <footnote><para>To <firstterm>Export</firstterm>
	      information is to make it available in a more general context.
	      See also <link linkend="scoperef">scope</link>.</para></footnote>
	  
	      command makes available variables to all child processes
	      of the running script or shell. One important use
	      of the <command>export</command> command is in <link linkend="filesref1">startup files</link>, to initialize
	      and make accessible <link linkend="envref">environmental
	      variables</link> to subsequent user processes.</para>

	  <caution><para>Unfortunately, <link linkend="parchildprobref">
	     there is no way to export variables back to the parent
	     process</link>, to the process that called or invoked the
	     script or shell.</para></caution>


	  <para><anchor xml:id="exportawk" /></para>
	  <example xml:id="coltotaler3">
	    <title>Using <firstterm>export</firstterm> to pass a variable to an
	      embedded <firstterm>awk</firstterm> script</title>
	    <programlisting>#!/bin/bash

#  Yet another version of the "column totaler" script (col-totaler.sh)
#+ that adds up a specified column (of numbers) in the target file.
#  This uses the environment to pass a script variable to 'awk' . . .
#+ and places the awk script in a variable.


ARGS=2
E_WRONGARGS=85

if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== Same as original script, up to this point =====#

export column_number
# Export column number to environment, so it's available for retrieval.


# -----------------------------------------------
awkscript='{ total += $ENVIRON["column_number"] }
END { print total }'
# Yes, a variable can hold an awk script.
# -----------------------------------------------

# Now, run the awk script.
awk "$awkscript" "$filename"

# Thanks, Stephane Chazelas.

exit 0
</programlisting>
	  </example>



	      <tip>

	        <para>It is possible to initialize and export
		  variables in the same operation, as in <command>export
		  var1=xxx</command>.</para>

		<para>However, as Greg Keraunen points out, in certain
		  situations this may have a different effect than
		  setting a variable, then exporting it.</para>

	        <para>
	        <screen>
<prompt>bash$ </prompt><userinput>export var=(a b); echo ${var[0]}</userinput>
<computeroutput>(a b)</computeroutput>



<prompt>bash$ </prompt><userinput>var=(a b); export var; echo ${var[0]}</userinput>
<computeroutput>a</computeroutput>
	      </screen>
	    </para>

	       	
              </tip>

              <note>
              <para>A variable to be exported may require special
                treatment.  See <xref linkend="bashprof" />.</para>
              </note>

	    </listitem>
	  </varlistentry>
	
	<varlistentry>
	  <term><anchor xml:id="declare2ref" /><command moreinfo="none">declare</command></term>
	  <term><command moreinfo="none">typeset</command></term>
	  <listitem>
	  <indexterm>
	    <primary>declare</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>declare</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>typeset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>typeset</secondary>
	  </indexterm>
	    <para>The <link linkend="declareref">declare</link> and
	      <link linkend="declareref">typeset</link> commands specify
	      and/or restrict properties of variables.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="readonlyref" /><command moreinfo="none">readonly</command></term>
	  <listitem>
	  <indexterm>
	    <primary>readonly</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>readonly</secondary>
	  </indexterm>
            <para>Same as <link linkend="declareref">declare -r</link>,
	      sets a variable as read-only, or, in effect, as a
	      constant. Attempts to change the variable fail with
	      an error message. This is the shell analog of the
	      <firstterm>C</firstterm> language <command>const</command>
	      type qualifier.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="getoptsx" /><command moreinfo="none">getopts</command></term>
	  <listitem>
	  <indexterm>
	    <primary>getopts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getopts</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTIND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTIND</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTARG</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTARG</secondary>
	  </indexterm>
	    <para>This powerful tool parses command-line arguments passed
	      to the script. This is the Bash analog of the <link linkend="getopty">getopt</link> external command and the
	      <firstterm>getopt</firstterm> library function familiar to
	      <firstterm>C</firstterm> programmers. It permits passing
	      and concatenating multiple options

	      <footnote><para>An <firstterm>option</firstterm> is an
		argument that acts as a flag, switching script behaviors
		on or off. The argument associated with a particular
		option indicates the behavior that the option (flag)
		switches on or off.</para></footnote>

	      and associated arguments to a script (for
	      example <userinput>scriptname -abc -e
	      /usr/local</userinput>).</para>

	    <para><anchor xml:id="getoptsopt" /></para>
	    <para>The <command>getopts</command> construct uses two implicit
	      variables. <varname>$OPTIND</varname> is the argument
	      pointer (<wordasword>OPTion INDex</wordasword>)
	      and <varname>$OPTARG</varname> (<wordasword>OPTion
	      ARGument</wordasword>) the (optional) argument attached
	      to an option. A colon following the option name in the
	      declaration tags that option as having an associated
	      argument.</para>

	    <para>A <command>getopts</command> construct usually comes
	      packaged in a <link linkend="whileloopref">while
	      loop</link>, which processes the options and
	      arguments one at a time, then increments the implicit
	      <varname>$OPTIND</varname> variable to point to the
	      next.</para>

	    <note>
	      <para>
		<orderedlist>
		  <listitem>

		    <para>The arguments passed from the command-line to
		      the script must be preceded by a
		      dash (<option>-</option>). It is the
		      prefixed <option>-</option> that lets
		      <command>getopts</command> recognize command-line
		      arguments as <firstterm>options</firstterm>.
		      In fact, <command>getopts</command> will not process
		      arguments without the prefixed <option>-</option>,
		      and will terminate option processing at the first
		      argument encountered lacking them.</para>

		  </listitem>
		  <listitem><para>The <command>getopts</command> template
		      differs slightly from the standard <link linkend="whileloopref">while loop</link>, in that
		      it lacks condition brackets.</para>
		  </listitem>
		  <listitem>

		  <para>The <command>getopts</command> construct is a highly
		     functional replacement for the traditional
		     <link linkend="getopty">getopt</link> external
		     command.</para>

		   </listitem>
		</orderedlist>
	      </para>
	    </note>

	    <para><programlisting>
while getopts ":abcde:fg" Option
# Initial declaration.
# a, b, c, d, e, f, and g are the options (flags) expected.
# The : after option 'e' shows it will have an argument passed with it.
do
  case $Option in
    a ) # Do something with variable 'a'.
    b ) # Do something with variable 'b'.
    ...
    e)  # Do something with 'e', and also with $OPTARG,
        # which is the associated argument passed with option 'e'.
    ...
    g ) # Do something with variable 'g'.
  esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

# All this is not nearly as complicated as it looks &lt;grin&gt;.</programlisting></para>

	    <example xml:id="ex33">
	      <title>Using <firstterm>getopts</firstterm> to read the
	        options/arguments passed to a script</title>
	      <programlisting>#!/bin/bash
# ex33.sh: Exercising getopts and OPTIND
#          Script modified 10/09/03 at the suggestion of Bill Gradwohl.


# Here we observe how 'getopts' processes command-line arguments to script.
# The arguments are parsed as "options" (flags) and associated arguments.

# Try invoking this script with:
#   'scriptname -mn'
#   'scriptname -oq qOption' (qOption can be some arbitrary string.)
#   'scriptname -qXXX -r'
#
#   'scriptname -qr'
#+      - Unexpected result, takes "r" as the argument to option "q"
#   'scriptname -q -r' 
#+      - Unexpected result, same as above
#   'scriptname -mnop -mnop'  - Unexpected result
#   (OPTIND is unreliable at stating where an option came from.)
#
#  If an option expects an argument ("flag:"), then it will grab
#+ whatever is next on the command-line.

NO_ARGS=0 
E_OPTERROR=85

if [ $# -eq "$NO_ARGS" ]    # Script invoked with no command-line args?
then
  echo "Usage: `basename $0` options (-mnopqrs)"
  exit $E_OPTERROR          # Exit and explain usage.
                            # Usage: scriptname -options
                            # Note: dash (-) necessary
fi  


while getopts ":mnopq:rs" Option
do
  case $Option in
    m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
    n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
    p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
    q     ) echo "Scenario #4: option -q-\
                  with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
    #  Note that option 'q' must have an associated argument,
    #+ otherwise it falls through to the default.
    r | s ) echo "Scenario #5: option -$Option-";;
    *     ) echo "Unimplemented option chosen.";;   # Default.
  esac
done

shift $(($OPTIND - 1))
#  Decrements the argument pointer so it points to next argument.
#  $1 now references the first non-option item supplied on the command-line
#+ if one exists.

exit $?

#   As Bill Gradwohl states,
#  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
#+  but there is no reliable way to differentiate what came
#+ from where by using OPTIND."
#  There are, however, workarounds.
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="intscrbeh">
        <title><anchor xml:id="intscrbeh1" />Script Behavior</title>

      <varlistentry>
	<term><anchor xml:id="sourceref" /><command moreinfo="none">source</command></term>
	<term><token>.</token> (<link linkend="dotref">dot</link> command)</term>
	  <listitem>
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>source</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>.</secondary>
	  </indexterm>

	  
	  <para>This command, when invoked from the command-line,
	      executes a script. Within a script, a
	      <userinput>source file-name</userinput>
	      loads the file <filename>file-name</filename>.
	      <firstterm>Sourcing</firstterm> a file (dot-command)
	      <firstterm>imports</firstterm>
	     code into the script, appending to the script (same effect
	     as the <userinput>#include</userinput> directive in a
	     <firstterm>C</firstterm> program). The net result is the
	     same as if the <quote>sourced</quote> lines of code were
	     physically present in the body of the script. This is useful
	     in situations when multiple scripts use a common data file
	     or function library.</para>

	    <example xml:id="ex38">
	      <title><quote>Including</quote> a data file</title>
	      <programlisting>#!/bin/bash
#  Note that this example must be invoked with bash, i.e., bash ex38.sh
#+ not  sh ex38.sh !

. data-file    # Load a data file.
# Same effect as "source data-file", but more portable.

#  The file "data-file" must be present in current working directory,
#+ since it is referred to by its basename.

# Now, let's reference some data from that file.

echo "variable1 (from data-file) = $variable1"
echo "variable3 (from data-file) = $variable3"

let "sum = $variable2 + $variable4"
echo "Sum of variable2 + variable4 (from data-file) = $sum"
echo "message1 (from data-file) is \"$message1\""
#                                  Escaped quotes
echo "message2 (from data-file) is \"$message2\""

print_message This is the message-print function in the data-file.


exit $?
</programlisting>

	      <para>File <filename>data-file</filename> for <xref linkend="ex38" />, above.  Must be present in same
		directory.</para>

	      <programlisting># This is a data file loaded by a script.
# Files of this type may contain variables, functions, etc.
# It loads with a 'source' or '.' command from a shell script.

# Let's initialize some variables.

variable1=23
variable2=474
variable3=5
variable4=97

message1="Greetings from *** line $LINENO *** of the data file!"
message2="Enough for now. Goodbye."

print_message ()
{   # Echoes any message passed to it.

  if [ -z "$1" ]
  then
    return 1 # Error, if argument missing.
  fi

  echo

  until [ -z "$1" ]
  do             # Step through arguments passed to function.
    echo -n "$1" # Echo args one at a time, suppressing line feeds.
    echo -n " "  # Insert spaces between words.
    shift        # Next one.
  done  

  echo

  return 0
}
</programlisting>
	    </example>	    

	     <para>If the <firstterm>sourced</firstterm> file is itself
	       an executable script, then it will run, then return
	       control to the script that called it. A
	       <firstterm>sourced</firstterm> executable script may use a
	      <link linkend="returnref">return</link> for this
	      purpose.</para>

	    <para><anchor xml:id="sourceparams" /></para>
	    <para>
	      Arguments may be (optionally) passed to the
	      <firstterm>sourced</firstterm> file as <link linkend="posparamref1">positional parameters</link>.
	       <programlisting>source $filename $arg1 arg2</programlisting>
	    </para>



	  <para>It is even possible for a script to
	    <firstterm>source</firstterm> itself, though this does not
	    seem to have any practical applications.</para>

	    <example xml:id="selfsource">
	      <title>A (useless) script that sources itself</title>
	      <programlisting>#!/bin/bash
# self-source.sh: a script sourcing itself "recursively."
# From "Stupid Script Tricks," Volume II.

MAXPASSCNT=100    # Maximum number of execution passes.

echo -n  "$pass_count  "
#  At first execution pass, this just echoes two blank spaces,
#+ since $pass_count still uninitialized.

let "pass_count += 1"
#  Assumes the uninitialized variable $pass_count
#+ can be incremented the first time around.
#  This works with Bash and pdksh, but
#+ it relies on non-portable (and possibly dangerous) behavior.
#  Better would be to initialize $pass_count to 0 before incrementing.

while [ "$pass_count" -le $MAXPASSCNT ]
do
  . $0   # Script "sources" itself, rather than calling itself.
         # ./$0 (which would be true recursion) doesn't work here. Why?
done  

#  What occurs here is not actually recursion,
#+ since the script effectively "expands" itself, i.e.,
#+ generates a new section of code
#+ with each pass through the 'while' loop',
#  with each 'source' in line 20.
#
#  Of course, the script interprets each newly 'sourced' "#!" line
#+ as a comment, and not as the start of a new script.

echo

exit 0   # The net effect is counting from 1 to 100.
         # Very impressive.

# Exercise:
# --------
# Write a script that uses this trick to actually do something useful.
</programlisting>
	    </example>


	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><anchor xml:id="exitref" /><command moreinfo="none">exit</command></term>
	  <listitem>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	    <para>Unconditionally terminates a script.
		    <footnote><para>Technically, an
		    <command>exit</command> only terminates the
		    process (or shell) in which it is running,
		    <emphasis>not</emphasis> the <firstterm>parent
		    process</firstterm>.</para></footnote>
	        The <command>exit</command> command may optionally take an
		integer argument, which is returned to the shell as
		the <link linkend="exitstatusref">exit status</link>
		of the script. It is good practice to end all but the
		simplest scripts with an <userinput>exit 0</userinput>,
		indicating a successful run.</para>

	    <note><para>If a script terminates with an <command>exit</command>
	      lacking an argument, the exit status of the script is the exit
	      status of the last command executed in the script, not counting
	      the <command>exit</command>. This is equivalent to an
	      <command>exit $?</command>.</para></note>

	    <note><para>An <command>exit</command> command may also be used to
	      terminate a <link linkend="subshellsref">subshell</link>.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="execref" /><command moreinfo="none">exec</command></term>
	  <listitem>
	  <indexterm>
	    <primary>exec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exec</secondary>
	  </indexterm>

	    <para>
	      This shell builtin replaces the current process with
	      a specified command. Normally, when the shell encounters
	      a command, it <link linkend="forkref">forks off</link> a
	      child process to actually execute the command.  Using the
	      <command>exec</command> builtin, the shell does not fork,
	      and the command <firstterm>exec</firstterm>'ed replaces
	      the shell.  When used in a script, therefore, it forces an
	      exit from the script when the <command>exec</command>'ed
	      command terminates.
		<footnote><para>Unless the <command>exec</command> is used
		   to <link linkend="usingexecref">reassign file
		   descriptors</link>.</para></footnote>
	    </para>

	    <example xml:id="ex54">
	      <title>Effects of <firstterm>exec</firstterm></title>
	      <programlisting>#!/bin/bash

exec echo "Exiting \"$0\" at line $LINENO."   # Exit from script here.
# $LINENO is an internal Bash variable set to the line number it's on.

# ----------------------------------
# The following lines never execute.

echo "This echo fails to echo."

exit 99                       #  This script will not exit here.
                              #  Check exit value after script terminates
                              #+ with an 'echo $?'.
                              #  It will *not* be 99.
</programlisting>
	    </example>	    	   

	    <example xml:id="selfexec">
	      <title>A script that <firstterm>exec's</firstterm> itself</title>
	      <programlisting>#!/bin/bash
# self-exec.sh

# Note: Set permissions on this script to 555 or 755,
#       then call it with ./self-exec.sh or sh ./self-exec.sh.

echo

echo "This line appears ONCE in the script, yet it keeps echoing."
echo "The PID of this instance of the script is still $$."
#     Demonstrates that a subshell is not forked off.

echo "==================== Hit Ctl-C to exit ===================="

sleep 1

exec $0   #  Spawns another instance of this same script
          #+ that replaces the previous one.

echo "This line will never echo!"  # Why not?

exit 99                            # Will not exit here!
                                   # Exit code will not be 99!
</programlisting>
	    </example>	    	   

	    <para>An <command>exec</command> also serves to <link linkend="usingexecref">reassign
	      file descriptors</link>.	For example, <userinput>exec
	      &lt;zzz-file</userinput> replaces <filename>stdin</filename>
	      with the file <filename>zzz-file</filename>.</para>

	    <note><para>The <option>-exec</option> option to
	      <link linkend="findref">find</link> is
	      <replaceable>not</replaceable> the same as the
	      <command>exec</command> shell builtin.</para></note>

	  </listitem>
	</varlistentry>
	

	<varlistentry>
	  <term><anchor xml:id="shoptref" /><command moreinfo="none">shopt</command></term>
	  <listitem>
	  <indexterm>
	    <primary>shopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shopt</secondary>
	  </indexterm>
	    <para>This command permits changing <firstterm>shell
	      options</firstterm> on the fly (see <xref linkend="al" />
	      and <xref linkend="unal" />).  It often appears in the Bash
	      <link linkend="filesref1">startup files</link>, but also has
	      its uses in scripts. Needs <link linkend="bash2ref">version
	      2</link> or later of Bash.</para>

	    <para><programlisting>shopt -s cdspell
# Allows minor misspelling of directory names with 'cd'
# Option -s sets, -u unsets.

cd /hpme  # Oops! Mistyped '/home'.
pwd       # /home
          # The shell corrected the misspelling.</programlisting></para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command moreinfo="none">caller</command><anchor xml:id="callerref" /></term>
	  <listitem>
	  <indexterm>
	    <primary>caller</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>caller</secondary>
	  </indexterm>
	    <para>Putting a <command>caller</command> command
	       inside a <link linkend="functionref">function</link>
	       echoes to <filename>stdout</filename> information about
	       the <firstterm>caller</firstterm> of that function.</para>


	<para><programlisting>#!/bin/bash

function1 ()
{
  # Inside function1 ().
  caller 0   # Tell me about it.
}

function1    # Line 9 of script.

# 9 main test.sh
# ^                 Line number that the function was called from.
#   ^^^^            Invoked from "main" part of script.
#        ^^^^^^^    Name of calling script.

caller 0     # Has no effect because it's not inside a function.</programlisting></para>

	    <para>A <command>caller</command> command can also return
	      <firstterm>caller</firstterm> information from a script <link linkend="sourceref">sourced</link> within another
	      script. Analogous to a function, this is a <quote>subroutine
	      call.</quote></para>

	    <para>You may find this command useful in debugging.</para>

	  </listitem>
	</varlistentry>



      </variablelist>


      <variablelist xml:id="intcommand">
        <title><anchor xml:id="intcommand1" />Commands</title>

      <varlistentry>
	<term><anchor xml:id="trueref" /><command moreinfo="none">true</command></term>
	  <listitem>
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>true</secondary>
	  </indexterm>
	  
            <para>A command that returns a successful
	    (<returnvalue>zero</returnvalue>) <link linkend="exitstatusref">exit status</link>, but does
	    nothing else.
	  </para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>true</userinput>
<prompt>bash$ </prompt><userinput>echo $?</userinput>
<computeroutput>0</computeroutput>
	      </screen>
	    </para>

	  <para><programlisting># Endless loop
while true   # alias for ":"
do
   operation-1
   operation-2
   ...
   operation-n
   # Need a way to break out of loop or script will hang.
done</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><anchor xml:id="falseref" /><command moreinfo="none">false</command></term>
	  <listitem>
	  <indexterm>
	    <primary>false</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>false</secondary>
	  </indexterm>
	    <para>A command that returns an unsuccessful <link linkend="exitstatusref">exit status</link>,
	    but does nothing else.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>false</userinput>
<prompt>bash$ </prompt><userinput>echo $?</userinput>
<computeroutput>1</computeroutput>
	      </screen>
	    </para>

	  <para><programlisting># Testing "false" 
if false
then
  echo "false evaluates \"true\""
else
  echo "false evaluates \"false\""
fi
# false evaluates "false"


# Looping while "false" (null loop)
while false
do
   # The following code will not execute.
   operation-1
   operation-2
   ...
   operation-n
   # Nothing happens!
done   
</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><anchor xml:id="typeref" /><command moreinfo="none">type [cmd]</command></term>
	  <listitem>
	  <indexterm>
	    <primary>type</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>type</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>which</secondary>
	  </indexterm>
            <para>Similar to the <link linkend="whichref">which</link> external command,
	    <command>type cmd</command> identifies
	    <quote>cmd.</quote> Unlike <command>which</command>,
	    <command>type</command> is a Bash builtin. The useful
	    <option>-a</option> option to <command>type</command>
	    identifies <replaceable>keywords</replaceable>
	    and <replaceable>builtins</replaceable>, and also locates
	    system commands with identical names.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>type '['</userinput>
<computeroutput>[ is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type -a '['</userinput>
<computeroutput>[ is a shell builtin
 [ is /usr/bin/[</computeroutput>


<prompt>bash$ </prompt><userinput>type type</userinput>
<computeroutput>type is a shell builtin</computeroutput>
	      </screen>
	    </para>

	    <para>The <command>type</command> command can be useful
              for <link linkend="devnullredirect">testing whether a
              certain command exists</link>.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor xml:id="hashcmdref" /><command moreinfo="none">hash [cmds]</command></term>
	  <listitem>
	  <indexterm>
	    <primary>hash</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hash</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <para>Records the <firstterm>path</firstterm>
	    name of specified commands -- in the shell <firstterm>hash
	    table</firstterm>

	        <footnote>
		<para><anchor xml:id="hashref" /></para>
		<para><firstterm>Hashing</firstterm> is a method of
		creating lookup keys for data stored in a table. The
		<emphasis>data items themselves</emphasis> are
		<quote>scrambled</quote> to create keys, using one of
		a number of simple mathematical
		<firstterm>algorithms</firstterm> (methods, or
		recipes).</para>

		<para>An advantage of <firstterm>hashing</firstterm> is that
		it is fast. A disadvantage is that
		<firstterm>collisions</firstterm> -- where a single key
		maps to more than one data item -- are possible.</para>

		<para>For examples of hashing see <xref linkend="hashlib" /> and
		  <xref linkend="hashexample" />.</para>
	        </footnote>
	      
              -- so the shell or script will not need to search the
              <link linkend="pathref">$PATH</link> on subsequent calls to those
              commands. When <command>hash</command> is called with no
	      arguments, it simply lists the commands that have been hashed.
	      The <option>-r</option> option resets the hash table.</para>
	  </listitem>
	</varlistentry>


      <varlistentry>
	<term><anchor xml:id="bindref" /><command moreinfo="none">bind</command></term>
	  <listitem>
	  <indexterm>
	    <primary>bind</primary>
	  </indexterm>
	  <indexterm>
	    <primary>bind</primary>
	    <secondary>key bindings </secondary>
	  </indexterm>

	  <para>The <command>bind</command> builtin displays or modifies
	  <firstterm>readline</firstterm>
	    <footnote><para><anchor xml:id="readlineref" />The
            <firstterm>readline</firstterm> library is what
            Bash uses for reading input in an
            interactive shell.</para></footnote>
	  key bindings.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor xml:id="helpref" /><command moreinfo="none">help</command></term>
	  <listitem>
	  <indexterm>
	    <primary>help</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary />
	  </indexterm>
	  
	  <para>Gets a short usage summary of a shell builtin. This is
	    the counterpart to <link linkend="whatisref">whatis</link>,
	    but for builtins. The display of <firstterm>help</firstterm>
	    information got a much-needed update in the <link linkend="bash4ref">version 4 release</link> of Bash.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>help exit</userinput>
<computeroutput>exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <section>
	<title>Job Control Commands</title>


	<para>Certain of the following job control commands take a
	  <firstterm>job identifier</firstterm> as an argument. See
	  the <link linkend="jobidtable">table</link> at end of the
	  chapter.</para>

	<variablelist xml:id="jccommandlist">

	  <varlistentry>
	    <term><anchor xml:id="jobsref" /><command moreinfo="none">jobs</command></term>
	    <listitem>
	    <indexterm>
	      <primary>jobs</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>jobs</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>ps</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>ps</secondary>
	    </indexterm>

	      <para>Lists the jobs running in the background, giving
	        the <firstterm>job number</firstterm>.
		Not as useful as <link linkend="ppssref">ps</link>.</para>

              <note>
	      <para>It is all too easy to confuse
		<firstterm>jobs</firstterm> and
		<firstterm>processes</firstterm>.  Certain <link linkend="builtinref">builtins</link>, such as
		<command>kill</command>, <command>disown</command>, and
		<command>wait</command> accept either a job number or a
		process number as an argument. The <link linkend="fgref">fg</link>,
		<link linkend="bgref">bg</link> and <command>jobs</command>
		commands accept only a job number.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>sleep 100 &amp;</userinput>
<computeroutput>[1] 1384</computeroutput>

<prompt>bash $ </prompt><userinput>jobs</userinput>
<computeroutput>[1]+  Running                 sleep 100 &amp;</computeroutput></screen>
	      </para>

	      <para><quote>1</quote> is the job number (jobs are
		maintained by the current shell). <quote>1384</quote>
		is the <link linkend="ppidref">PID</link> or <firstterm>process ID
		number</firstterm> (processes are maintained by the system). To kill
		this job/process, either a <command>kill %1</command>
		or a <command>kill 1384</command> works.</para>

	      <para><emphasis>Thanks, S.C.</emphasis></para>	
               </note>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor xml:id="disownref" /><command moreinfo="none">disown</command></term>
	    <listitem>
	    <indexterm>
	      <primary>disown</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>disown</secondary>
	    </indexterm>
	      <para>Remove job(s) from the shell's table of active jobs.</para>
	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><anchor xml:id="fgref" /><command moreinfo="none">fg</command></term>
	  <term><anchor xml:id="bgref" /><command moreinfo="none">bg</command></term>
	    <listitem>
	    <indexterm>
	      <primary>fg</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>foreground</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>background</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>bg</secondary>
	    </indexterm>
	    <para>The <command>fg</command> command switches a job
	      running in the background into the foreground.  The
	      <command>bg</command> command restarts a suspended job, and
	      runs it in the background. If no job number is specified,
	      then the <command>fg</command> or <command>bg</command>
	      command acts upon the currently running job.</para>
	  </listitem>
	</varlistentry>

	  <varlistentry>
	    <term><anchor xml:id="waitref" /><command moreinfo="none">wait</command></term>
	    <listitem>
	    <indexterm>
	      <primary>wait</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>wait</secondary>
	    </indexterm>

	      <para>Suspend script execution until all jobs running in
	        background have terminated, or until the job number or
	        process ID specified as an option terminates. Returns the <link linkend="exitstatusref">exit status</link> of waited-for
	        command.</para>

	      <para>You may use the <command>wait</command> command
		to prevent a script from exiting before a background
		job finishes executing (this would create a dreaded
		<link linkend="zombieref">orphan process</link>).</para>

	    <example xml:id="ex39">
	      <title>Waiting for a process to finish before proceeding</title>
	      <programlisting>#!/bin/bash

ROOT_UID=0   # Only users with $UID 0 have root privileges.
E_NOTROOT=65
E_NOPARAMS=66

if [ "$UID" -ne "$ROOT_UID" ]
then
  echo "Must be root to run this script."
  # "Run along kid, it's past your bedtime."
  exit $E_NOTROOT
fi  

if [ -z "$1" ]
then
  echo "Usage: `basename $0` find-string"
  exit $E_NOPARAMS
fi


echo "Updating 'locate' database..."
echo "This may take a while."
updatedb /usr &amp;     # Must be run as root.

wait
# Don't run the rest of the script until 'updatedb' finished.
# You want the database updated before looking up the file name.

locate $1

#  Without the 'wait' command, in the worse case scenario,
#+ the script would exit while 'updatedb' was still running,
#+ leaving it as an orphan process.

exit 0
</programlisting>
	    </example>	    

	      <para>Optionally, <command>wait</command> can take a <firstterm>job
		identifier</firstterm> as an argument, for example,
		<replaceable>wait%1</replaceable> or <replaceable>wait
                $PPID</replaceable>.

	<footnote><para>This only applies to <firstterm>child
         processes</firstterm>, of course.</para></footnote>
		
		See the <link linkend="jobidtable">job id table</link>.</para>

	      <para><anchor xml:id="waithang" /></para>
              <tip>
	      <para>Within a script, running a command in the background
		with an ampersand (&amp;) may cause the script
		to hang until <keycap>ENTER</keycap> is hit. This
		seems to occur with commands that write to
		<filename>stdout</filename>. It can be a major annoyance.
		  <programlisting>#!/bin/bash
# test.sh		  

ls -l &amp;
echo "Done."</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>./test.sh</userinput>
<computeroutput>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
 _
</computeroutput>
               </screen>
	       </para>

      <blockquote>
	<literallayout>
    As Walter Brameld IV explains it:

    As far as I can tell, such scripts don't actually hang. It just
    seems that they do because the background command writes text to
    the console after the prompt. The user gets the impression that
    the prompt was never displayed. Here's the sequence of events:

    1. Script launches background command.
    2. Script exits.
    3. Shell displays the prompt.
    4. Background command continues running and writing text to the
       console.
    5. Background command finishes.
    6. User doesn't see a prompt at the bottom of the output, thinks script
       is hanging.
	</literallayout>
      </blockquote>

              <para>Placing a <command>wait</command> after the background
                command seems to remedy this.
		  <programlisting>#!/bin/bash
# test.sh		  

ls -l &amp;
echo "Done."
wait</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>./test.sh</userinput>
<computeroutput>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</computeroutput>
               </screen>
	        <link linkend="ioredirref">Redirecting</link> the
                output of the command to a file or even to
		<filename>/dev/null</filename> also takes care of this
		problem.
              </para>
	      </tip>


	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><anchor xml:id="suspendref" /><command moreinfo="none">suspend</command></term>
	    <listitem>
	    <indexterm>
	      <primary>suspend</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>suspend</secondary>
	    </indexterm>
	      <para>This has a similar effect to
		<keycombo><keycap>Control</keycap><keycap>Z</keycap></keycombo>, 
		but it suspends the shell (the shell's parent process should
		resume it at an appropriate time).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor xml:id="logoutref" /><command moreinfo="none">logout</command></term>
	    <listitem>
	    <indexterm>
	      <primary>logout</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>log out</secondary>
	    </indexterm>
	      <para>Exit a login shell, optionally specifying an <link linkend="exitstatusref">exit status</link>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor xml:id="timesref" /><command moreinfo="none">times</command></term>
	    <listitem>
	    <indexterm>
	      <primary>times</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>times</secondary>
	    </indexterm>
	      <para>Gives statistics on the system time elapsed when
	        executing commands, in the following form:
		<screen><computeroutput>0m0.020s 0m0.020s</computeroutput></screen></para>

              <para>This capability is of relatively limited value, since it is not common to
		profile and benchmark shell scripts.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor xml:id="killref" /><command moreinfo="none">kill</command></term>
	    <listitem>
	    <indexterm>
	      <primary>kill</primary>
	    </indexterm>
	    <indexterm>
	    <primary>command</primary>
	    <secondary>kill</secondary>
	    </indexterm>
	      <para>Forcibly terminate a process by sending it an
		appropriate <firstterm>terminate</firstterm> signal
		(see <xref linkend="killprocess" />).</para>

	    <example xml:id="selfdestruct">
	      <title>A script that kills itself</title>
	      <programlisting>#!/bin/bash
# self-destruct.sh

kill $$  # Script kills its own process here.
         # Recall that "$$" is the script's PID.

echo "This line will not echo."
# Instead, the shell sends a "Terminated" message to stdout.

exit 0   # Normal exit? No!

#  After this script terminates prematurely,
#+ what exit status does it return?
#
# sh self-destruct.sh
# echo $?
# 143
#
# 143 = 128 + 15
#             TERM signal
</programlisting>
	    </example>
	      
	      <para><anchor xml:id="zombieref" /></para>
	      <note><para><userinput>kill -l</userinput> lists all the
		<link linkend="signald">signals</link> (as does the
		file <filename>/usr/include/asm/signal.h</filename>).
		A <userinput>kill -9</userinput> is a <firstterm>sure
		kill</firstterm>, which will usually terminate a
		process that stubbornly refuses to die with a plain
		<command>kill</command>. Sometimes, a <userinput>kill
		-15</userinput> works. A <firstterm>zombie</firstterm> process,
		that is, a child process that has terminated, but that
		the <link linkend="forkref">parent process</link>
		has not (yet) killed, cannot be killed by a logged-on
		user -- you can't kill something that is already dead --
		but <command>init</command> will generally clean it up
		sooner or later.</para></note>

	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><anchor xml:id="killallref" /><command moreinfo="none">killall</command></term>
	    <listitem>
	    <indexterm>
	      <primary>killall</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>kill</secondary>
	    </indexterm>
	    <para>The <command>killall</command> command
	    kills a running process by <firstterm>name</firstterm>,
            rather than by <link linkend="processidref">process ID</link>.
	    If there are multiple instances of a particular command running,
	    then doing a <firstterm>killall</firstterm> on that command will
	    terminate them <emphasis>all</emphasis>.</para>

	    <note><para>This refers to the <command>killall</command>
	      command in <filename class="directory">/usr/bin</filename>,
	      <emphasis>not</emphasis> the <link linkend="killall2ref">killall script</link> in <filename class="directory">/etc/rc.d/init.d</filename>.</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor xml:id="commandref" /><command moreinfo="none">command</command></term>
	  <listitem>
	  <indexterm>
	    <primary>command</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>command</secondary>
	  </indexterm>
            <para>The <command>command</command> directive
	    disables aliases and functions for the command immediately
	    following it.</para>
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>command ls</userinput>
              </screen>
	    </para>

	    <note><para>This is one of three shell directives that
	      effect script command processing. The others are
	      <link linkend="bltref">builtin</link> and <link linkend="enableref">enable</link>.</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor xml:id="bltref" /><command moreinfo="none">builtin</command></term>
	  <listitem>
	  <indexterm>
	    <primary>builtin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>builtin</secondary>
	  </indexterm>
	    <para>Invoking <command>builtin
	      BUILTIN_COMMAND</command> runs the command
	      <replaceable>BUILTIN_COMMAND</replaceable> as a shell <link linkend="builtinref">builtin</link>, temporarily disabling
	      both functions and external system commands with the
	      same name.</para>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor xml:id="enableref" /><command moreinfo="none">enable</command></term>
	  <listitem>
	  <indexterm>
	    <primary>enable</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>enable</secondary>
	  </indexterm>

	    <para>This either enables or disables a shell
	      builtin command. As an example, <replaceable>enable -n
	      kill</replaceable> disables the shell builtin <link linkend="killref">kill</link>, so that when Bash
	      subsequently encounters <firstterm>kill</firstterm>, it invokes
	      the external command <filename>/bin/kill</filename>.</para>
	      
	    <para><anchor xml:id="enableref1" />The <option>-a</option>
	      option to <firstterm>enable</firstterm> lists all the
	      shell builtins, indicating whether or not they
	      are enabled. The <option>-f filename</option>
	      option lets <firstterm>enable</firstterm> load a <link linkend="builtinref">builtin</link> as a shared library
	      (DLL) module from a properly compiled object file.
	        <footnote>
		  <para>The C source for a number of loadable builtins is
		    typically found in the <filename class="directory">/usr/share/doc/bash-?.??/functions</filename>
		    directory.</para>
		  <para>Note that the <option>-f</option> option to
                    <command>enable</command> is not <link linkend="portabilityissues">portable</link> to all
                    systems.</para>
		</footnote>.
	     </para>	

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor xml:id="autoloadref" /><command moreinfo="none">autoload</command></term>
	  <listitem>
	  <indexterm>
	    <primary>autoload</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>autoloader</secondary>
	  </indexterm>

	  <para>This is a port to Bash of the
	    <firstterm>ksh</firstterm> autoloader. With
	    <command>autoload</command> in place, a function with
	    an <firstterm>autoload</firstterm> declaration will load from an
	    external file at its first invocation.
	      <footnote><para>The same effect as
	      <command>autoload</command> can be achieved with <link linkend="declareref">typeset -fu</link>.</para></footnote>
	    This saves system resources.</para>

	  <para>Note that <firstterm>autoload</firstterm> is not a part of the
	    core Bash installation. It needs to be loaded in with
	    <replaceable>enable -f</replaceable> (see above).</para>

	    </listitem>
	  </varlistentry>

	</variablelist>

      <para><anchor xml:id="jobidtable0" /></para>
      <table xml:id="jobidtable">
	<title>Job identifiers</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Notation</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>%N</option></entry>
	      <entry>Job number [N]</entry>
	    </row>
	    <row>
	      <entry><option>%S</option></entry>
	      <entry>Invocation (command-line) of job begins with string <emphasis>S</emphasis></entry>
	    </row>
	    <row>
	      <entry><option>%?S</option></entry>
	      <entry>Invocation (command-line) of job contains within it string <emphasis>S</emphasis></entry>
	    </row>
	    <row>
	      <entry><option>%%</option></entry>
	      <entry><quote>current</quote> job (last job stopped in
	      foreground or started in background)</entry>
	    </row>
	    <row>
	      <entry><option>%+</option></entry>
	      <entry><quote>current</quote> job (last job stopped in
	      foreground or started in background)</entry>
	    </row>
	    <row>
	      <entry><option>%-</option></entry>
	      <entry>Last job</entry>
	    </row>
	    <row>
	      <entry><option>$!</option></entry>
	      <entry>Last background process</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      </section> <!-- Job Control Commands -->

  </chapter> <!-- Internal Commands and Builtins -->



  <chapter xml:id="external">
      <title>External Filters, Programs and Commands</title>

      <para><anchor xml:id="externalref" /></para>

      <para>Standard UNIX commands make shell scripts more versatile. The
	power of scripts comes from coupling system commands and shell
	directives with simple programming constructs.</para>

      <section xml:id="basic">
        <title>Basic Commands</title>

      <variablelist xml:id="basiccommands">
        <title><anchor xml:id="basiccommands1" />The first commands a novice learns</title>

	<varlistentry>
	  <term><anchor xml:id="lsref" /><command moreinfo="none">ls</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ls</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	    <para>The basic file <quote>list</quote> command. It is all too easy
	      to underestimate the power of this humble command. For
	      example, using the <option>-R</option>, recursive option,
	      <command>ls</command> provides a tree-like listing of
	      a directory structure. Other useful options are
	      <option>-S</option>, sort listing by file size,
	      <option>-t</option>, sort by file modification time,
	      <option>-v</option>, sort by (numerical) version numbers
	      embedded in the filenames,
                <footnote><para>The <option>-v</option> option also orders the
                sort by <emphasis>upper- and lowercase prefixed</emphasis>
                filenames.</para></footnote>
	      <option>-b</option>, show escape characters, and
	      <option>-i</option>, show file inodes (see <xref linkend="idelete" />).</para>

              <para>
	      <screen><prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>-rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter10.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter11.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter12.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter1.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter2.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter3.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Chapter_headings.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Preface.txt</computeroutput>


<prompt>bash$ </prompt><userinput>ls -lv</userinput>
<computeroutput> total 0
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Chapter_headings.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:49 Preface.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter1.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter2.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter3.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter10.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter11.txt
 -rw-rw-r-- 1 bozo bozo 0 Sep 14 18:44 chapter12.txt</computeroutput></screen>
</para>


	    <tip><para>
	      The <firstterm>ls</firstterm> command returns a
	      non-zero <link linkend="exitstatusref">exit status</link> when
	      attempting to list a non-existent file.
	      <screen><prompt>bash$ </prompt><userinput>ls abc</userinput>
<computeroutput>ls: abc: No such file or directory</computeroutput>


<prompt>bash$ </prompt><userinput>echo $?</userinput>
<computeroutput>2</computeroutput></screen>
	    </para></tip>

	    <example xml:id="ex40">
	      <title>Using <firstterm>ls</firstterm> to create a table of contents
		for burning a <abbrev>CDR</abbrev> disk</title>
	      <programlisting>#!/bin/bash
# ex40.sh (burn-cd.sh)
# Script to automate burning a CDR.


SPEED=10         # May use higher speed if your hardware supports it.
IMAGEFILE=cdimage.iso
CONTENTSFILE=contents
# DEVICE=/dev/cdrom     For older versions of cdrecord
DEVICE="1,0,0"
DEFAULTDIR=/opt  # This is the directory containing the data to be burned.
                 # Make sure it exists.
                 # Exercise: Add a test for this.

# Uses Joerg Schilling's "cdrecord" package:
# http://www.fokus.fhg.de/usr/schilling/cdrecord.html

#  If this script invoked as an ordinary user, may need to suid cdrecord
#+ chmod u+s /usr/bin/cdrecord, as root.
#  Of course, this creates a security hole, though a relatively minor one.

if [ -z "$1" ]
then
  IMAGE_DIRECTORY=$DEFAULTDIR
  # Default directory, if not specified on command-line.
else
    IMAGE_DIRECTORY=$1
fi

# Create a "table of contents" file.
ls -lRF $IMAGE_DIRECTORY &gt; $IMAGE_DIRECTORY/$CONTENTSFILE
# The "l" option gives a "long" file listing.
# The "R" option makes the listing recursive.
# The "F" option marks the file types (directories get a trailing /).
echo "Creating table of contents."

# Create an image file preparatory to burning it onto the CDR.
mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY
echo "Creating ISO9660 file system image ($IMAGEFILE)."

# Burn the CDR.
echo "Burning the disk."
echo "Please be patient, this will take a while."
wodim -v -isosize dev=$DEVICE $IMAGEFILE
#  In newer Linux distros, the "wodim" utility assumes the
#+ functionality of "cdrecord."
exitcode=$?
echo "Exit code = $exitcode"

exit $exitcode
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="catref" /><command moreinfo="none">cat</command></term>
	  <term><command moreinfo="none">tac</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cat</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tac</secondary>
	  </indexterm>
	    <para><command>cat</command>, an acronym for
	    <wordasword>concatenate</wordasword>,
	      lists a file to <filename>stdout</filename>. When
	      combined with redirection (<token>&gt;</token> or
	      <token>&gt;&gt;</token>), it is commonly used to concatenate
	      files.

		<anchor xml:id="catuses" />
	        <programlisting># Uses of 'cat'
cat filename                          # Lists the file.

cat file.1 file.2 file.3 &gt; file.123   # Combines three files into one.</programlisting>

	      The <option>-n</option> option to <command>cat</command>
	      inserts consecutive numbers before all lines of the
	      target file(s). The <option>-b</option> option numbers
	      only the non-blank lines. The <option>-v</option> option
	      echoes nonprintable characters, using <token>^</token>
	      notation. The <option>-s</option> option squeezes multiple
	      consecutive blank lines into a single blank line.</para>

            <para>See also <xref linkend="lnum" /> and <xref linkend="rot13" />.</para>

	    <note>
	    <para><anchor xml:id="catlesseff" />
	    In a <link linkend="piperef">pipe</link>, it may be
	    more efficient to <link linkend="ioredirref">redirect</link>
	    the <filename>stdin</filename> to a file, rather than to
            <command>cat</command> the file.
            </para>

            <para>
	    <programlisting>cat filename | tr a-z A-Z

tr a-z A-Z &lt; filename   #  Same effect, but starts one less process,
                        #+ and also dispenses with the pipe.</programlisting>
            </para>
	    </note>


	    <para><command>tac</command>, is the inverse of
	      <wordasword>cat</wordasword>, listing a file backwards from its end.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="revref" /><command moreinfo="none">rev</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rev</secondary>
	  </indexterm>
	    <para>reverses each line of a file, and outputs to
	      <filename>stdout</filename>.  This does not have the same effect
	      as <command>tac</command>, as it preserves the order of
	      the lines, but flips each one around (mirror image).</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cat file1.txt</userinput>
<computeroutput>This is line 1.
 This is line 2.</computeroutput>


<prompt>bash$ </prompt><userinput>tac file1.txt</userinput>
<computeroutput>This is line 2.
 This is line 1.</computeroutput>


<prompt>bash$ </prompt><userinput>rev file1.txt</userinput>
<computeroutput>.1 enil si sihT
 .2 enil si sihT</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="cpref" /><command moreinfo="none">cp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cp</secondary>
	  </indexterm>

	    <para>This is the file copy command. <userinput>cp file1
	      file2</userinput> copies <filename>file1</filename>
	      to <filename>file2</filename>, overwriting
	      <filename>file2</filename> if it already exists (see <xref linkend="ex42" />).</para>

	     <tip>
	     <para>Particularly useful are the <option>-a</option>
	       archive flag (for copying an entire directory tree),
	       the <option>-u</option> update flag (which prevents
	       overwriting identically-named newer files), and the
	       <option>-r</option> and <option>-R</option> recursive
	       flags.</para>
	       <para><programlisting>cp -u source_dir/* dest_dir
#  "Synchronize" dest_dir to source_dir
#+  by copying over all newer and not previously existing files.</programlisting></para>
	       </tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mvref" /><command moreinfo="none">mv</command></term>
	  <listitem>
	    <para>This is the file <firstterm>move</firstterm> command.
	      It is equivalent to a combination of <command>cp</command>
	      and <command>rm</command>. It may be used to move multiple
	      files to a directory, or even to rename a directory. For
	      some examples of using <command>mv</command> in a script,
	      see <xref linkend="rfe" /> and <xref linkend="rn" />.</para>

	    <note>
	    <para>When used in a non-interactive script,
	      <command>mv</command> takes the <option>-f</option>
	      (<firstterm>force</firstterm>) option to bypass user
	      input.</para>

	    <para>When a directory is moved to a preexisting directory,
	      it becomes a subdirectory of the destination directory.</para>
	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>mv source_directory target_directory</userinput>

<prompt>bash$ </prompt><userinput>ls -lF target_directory</userinput>
<computeroutput>total 1
 drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/</computeroutput>
	      </screen>
	    </para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rmref" /><command moreinfo="none">rm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rm</secondary>
	  </indexterm>
	    <para>Delete (remove) a file or files. The <option>-f</option>
	      option forces removal of even readonly files, and is useful
	      for bypassing user input in a script.</para>

	    <note>
		<para><anchor xml:id="dashrem" /></para>
	      <para>The <firstterm>rm</firstterm> command will, by
		itself,  fail to remove filenames beginning with
		a dash. Why? Because <firstterm>rm</firstterm>
		sees a dash-prefixed filename as an
		<firstterm>option</firstterm>.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>rm -badname</userinput>
<computeroutput>rm: invalid option -- b
 Try `rm --help' for more information.</computeroutput></screen>
	      </para>

	        
		<para>
		One clever workaround is to precede
		the filename with a <quote> -- </quote> (the
		<firstterm>end-of-options</firstterm> flag).

	      <screen><prompt>bash$ </prompt><userinput>rm -- -badname</userinput></screen>
		</para>

	      <para>
	      Another method to is to preface the filename to be removed
	      with a <filename>dot-slash</filename> .

	      <screen><prompt>bash$ </prompt><userinput>rm ./-badname</userinput></screen>
	      </para>
	    </note>


	    <warning><para><anchor xml:id="rmrecurs" />When used with the
	      recursive flag <option>-r</option>, this command removes
	      files all the way down the directory tree from the current
	      directory.  A careless <command>rm -rf *</command> can wipe
	      out a big chunk of a directory structure.</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rmdirref" /><command moreinfo="none">rmdir</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rmdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rmdir</secondary>
	  </indexterm>
	    <para>Remove directory. The directory must be empty of
	      all files -- including <quote>invisible</quote>
	      <firstterm>dotfiles</firstterm>

		<footnote>
		  <para><anchor xml:id="dotfilesref" /></para>
		  <para><firstterm>Dotfiles</firstterm> are files whose
		    names begin with a <firstterm>dot</firstterm>, such as
		    <filename>~/.Xdefaults</filename>. Such filenames do
		    not appear in a normal <command>ls</command> listing
		    (although an <command>ls -a</command> will show
		    them), and they cannot be deleted by an accidental
		    <command>rm -rf *</command>. Dotfiles are generally
		    used as setup and configuration files in a user's
		    home directory.</para>
		  </footnote>

	      -- for this command to succeed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mkdirref" /><command moreinfo="none">mkdir</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mkdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkdir</secondary>
	  </indexterm>
	    <para>Make directory, creates a new directory. For example,
	      <userinput>mkdir -p project/programs/December</userinput>
	      creates the named directory. The
	      <replaceable>-p</replaceable> option automatically creates
	      any necessary parent directories.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="chmodref" /><command moreinfo="none">chmod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>chmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chmod</secondary>
	  </indexterm>

	    <para>Changes the attributes of an existing file or directory
	      (see <xref linkend="ex44" />).</para>

	    <para><programlisting>chmod +x filename
# Makes "filename" executable for all users.

chmod u+s filename
# Sets "suid" bit on "filename" permissions.
# An ordinary user may execute "filename" with same privileges as the file's owner.
# (This does not apply to shell scripts.)</programlisting></para>

	    <para><programlisting>chmod 644 filename
#  Makes "filename" readable/writable to owner, readable to others
#+ (octal mode).

chmod 444 filename
#  Makes "filename" read-only for all.
#  Modifying the file (for example, with a text editor)
#+ not allowed for a user who does not own the file (except for root),
#+ and even the file owner must force a file-save
#+ if she modifies the file.
#  Same restrictions apply for deleting the file.</programlisting></para>

	    <para><programlisting>chmod 1777 directory-name
#  Gives everyone read, write, and execute permission in directory,
#+ however also sets the "sticky bit".
#  This means that only the owner of the directory,
#+ owner of the file, and, of course, root
#+ can delete any particular file in that directory.

chmod 111 directory-name
#  Gives everyone execute-only permission in a directory.
#  This means that you can execute and READ the files in that directory
#+ (execute permission necessarily includes read permission
#+ because you can't execute a file without being able to read it).
#  But you can't list the files or search for them with the "find" command.
#  These restrictions do not apply to root.

chmod 000 directory-name
#  No permissions at all for that directory.
#  Can't read, write, or execute files in it.
#  Can't even list files in it or "cd" to it.
#  But, you can rename (mv) the directory
#+ or delete it (rmdir) if it is empty.
#  You can even symlink to files in the directory,
#+ but you can't read, write, or execute the symlinks.
#  These restrictions do not apply to root.</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="chattrref" /><command moreinfo="none">chattr</command></term>
	  <listitem>
	  <indexterm>
	    <primary>chattr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chattr</secondary>
	  </indexterm>

	    <para><command>Ch</command>ange file
	      <command>attr</command>ibutes. This is analogous to
	      <command>chmod</command> above, but with different options
	      and a different invocation syntax, and it works only on
	       <firstterm>ext2/ext3</firstterm> filesystems.</para>

	    <para>One particularly interesting <command>chattr</command>
	      option is <option>i</option>. A <command>chattr +i
	      <filename>filename</filename></command> marks the file
	      as immutable. The file cannot be modified, linked to, or
	      deleted, <emphasis>not even by root</emphasis>. This
	      file attribute can be set or removed only by
	      <firstterm>root</firstterm>. In a similar fashion,
	      the <option>a</option> option marks the file as append
	      only.</para>

	    <para>
	      <screen>
<prompt>root# </prompt><userinput>chattr +i file1.txt</userinput>


<prompt>root# </prompt><userinput>rm file1.txt</userinput>

<computeroutput>rm: remove write-protected regular file `file1.txt'? y
 rm: cannot remove `file1.txt': Operation not permitted</computeroutput>
	      </screen>
	    </para>

            <para>If a file has the <option>s</option> (secure)
              attribute set, then when it is deleted its block is 
	      overwritten with binary zeroes.
		<footnote><para>This particular feature may not yet be
		implemented in the version of the ext2/ext3 filesystem
		installed on your system. Check the documentation for
		your Linux distro.</para></footnote>
	      </para>

            <para>If a file has the <option>u</option> (undelete)
              attribute set, then when it is deleted, its contents can still
	      be retrieved (undeleted).</para>

            <para>If a file has the <option>c</option> (compress)
              attribute set, then it will automatically be compressed
	      on writes to disk, and uncompressed on reads.</para>

            <note><para>The file attributes set with
	      <command>chattr</command> do not show in a file listing
	      (<command>ls -l</command>).</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="linkref" /><command moreinfo="none">ln</command></term>
	  <listitem>

	    <para>Creates links to pre-existings files. A <quote>link</quote>
	      is a reference to a file, an alternate name for it.
	      The <command>ln</command> command permits referencing
	      the linked file by more than one name and is a superior
	      alternative to aliasing (see <xref linkend="ex18" />).</para>

            <para>The <command>ln</command> creates only a reference, a
	       pointer to the file only a few bytes in size.</para>
	    
	    <para><anchor xml:id="symlinkref" /></para>

	    <para>The <command>ln</command> command is most often used
	      with the <option>-s</option>, symbolic or
	      <quote>soft</quote> link flag. Advantages of using the
	      <option>-s</option> flag are that it permits linking across
	      file systems or to directories.</para>

	    <para>The syntax of the command is a bit tricky. For example:
	      <userinput>ln -s oldfile newfile</userinput> links the
	      previously existing <filename>oldfile</filename> to the
	      newly created link, <filename>newfile</filename>.</para>

	    <caution><para>If a file named <filename>newfile</filename> has
	      previously existed, an error message will
	      result.</para></caution>


	    <sidebar><title>Which type of link to use?</title>

	      <para>As John Macdonald explains it:</para>

	      <para>Both of these [types of links] provide a certain measure of dual reference
		-- if you edit the contents of the file using any name,
		your changes will affect both the original name and either
		a hard or soft new name.  The differences between them
		occurs when you work at a higher level.  The advantage of
		a hard link is that the new name is totally independent
		of the old name -- if you remove or rename the old name,
		that does not affect the hard link, which continues
		to point to the data while it would leave a soft link
		hanging pointing to the old name which is no longer
		there. The advantage of a soft link is that it can refer
		to a different file system (since it is just a reference
		to a file name, not to actual data). And, unlike a hard
		link, a symbolic link can refer to a directory.</para>

		</sidebar>

	    <para><anchor xml:id="linkminvok" /></para>
            <para>Links give the ability to invoke a script (or any other type
	      of executable) with multiple names, and having that script
	      behave according to how it was invoked.</para>

	    <example xml:id="hellol">
	      <title>Hello or Good-bye</title>
	      <programlisting>#!/bin/bash
# hello.sh: Saying "hello" or "goodbye"
#+          depending on how script is invoked.

# Make a link in current working directory ($PWD) to this script:
#    ln -s hello.sh goodbye
# Now, try invoking this script both ways:
# ./hello.sh
# ./goodbye


HELLO_CALL=65
GOODBYE_CALL=66

if [ $0 = "./goodbye" ]
then
  echo "Good-bye!"
  # Some other goodbye-type commands, as appropriate.
  exit $GOODBYE_CALL
fi

echo "Hello!"
# Some other hello-type commands, as appropriate.
exit $HELLO_CALL
</programlisting>
	    </example>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="manref" /><command moreinfo="none">man</command></term>
	  <term><anchor xml:id="inforef" /><command moreinfo="none">info</command></term>
	  <listitem>
	  <indexterm>
	    <primary>man</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>man</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>info</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>info</secondary>
	  </indexterm>

	    <para>These commands access the manual and information pages on
	      system commands and installed utilities. When available, the
	      <firstterm>info</firstterm> pages usually contain more detailed
	      descriptions than do the <firstterm>man</firstterm> pages.</para>

            <para>There have been various attempts at
	      <quote>automating</quote> the writing of <firstterm>man
	      pages</firstterm>. For a script that makes a tentative first
	      step in that direction, see <xref linkend="maned" />.</para>

	  </listitem>
	</varlistentry>


      </variablelist>


        </section> <!-- End Basic Commands -->


      <section xml:id="moreadv">
        <title>Complex Commands</title>

      <variablelist xml:id="cclisting">
        <title><anchor xml:id="cclisting1" />Commands for more advanced users</title>

	<varlistentry>
	  <term><anchor xml:id="findref" /><command moreinfo="none">find</command></term>
	  <listitem>
	  <indexterm>
	    <primary>find</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>find</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>\;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\;</secondary>
	  </indexterm>

	    <para><anchor xml:id="findref0" /></para>
	    <para>-exec <replaceable>COMMAND</replaceable> \;</para>
	    <para>Carries out <replaceable>COMMAND</replaceable> on
	      each file that <command>find</command> matches.  The
	      command sequence terminates with <token>;</token> (the
	      <quote>;</quote> is <link linkend="escp">escaped</link> to
	      make certain the shell passes it to <command>find</command>
	      literally, without interpreting it as a special character).</para>


	  <para>
	      <screen><prompt>bash$ </prompt><userinput>find ~/ -name '*.txt'</userinput>
<computeroutput>/home/bozo/.kde/share/apps/karm/karmdata.txt
 /home/bozo/misc/irmeyc.txt
 /home/bozo/test-scripts/1.txt</computeroutput>
	      </screen>
	  </para>

	    <para><anchor xml:id="curlybracketsref" /></para>

	    <para>If <replaceable>COMMAND</replaceable> contains
	      <token>{}</token>, then <command>find</command>
	      substitutes the full path name of the selected file for
	      <quote>{}</quote>.</para>

	  <para>
          <programlisting>find ~/ -name 'core*' -exec rm {} \;
# Removes all core dump files from user's home directory.</programlisting>
	  </para>


	  <para>
<programlisting>find /home/bozo/projects -mtime -1
#                               ^   Note minus sign!
#  Lists all files in /home/bozo/projects directory tree
#+ that were modified within the last day (current_day - 1).
#
find /home/bozo/projects -mtime 1
#  Same as above, but modified *exactly* one day ago.
#
#  mtime = last modification time of the target file
#  ctime = last status change time (via 'chmod' or otherwise)
#  atime = last access time

DIR=/home/bozo/junk_files
find "$DIR" -type f -atime +5 -exec rm {} \;
#                          ^           ^^
#  Curly brackets are placeholder for the path name output by "find."
#
#  Deletes all files in "/home/bozo/junk_files"
#+ that have not been accessed in *at least* 5 days (plus sign ... +5).
#
#  "-type filetype", where
#  f = regular file
#  d = directory
#  l = symbolic link, etc.
#
#  (The 'find' manpage and info page have complete option listings.)</programlisting>
          </para>



	    <para><programlisting>find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

# Finds all IP addresses (xxx.xxx.xxx.xxx) in /etc directory files.
# There a few extraneous hits. Can they be filtered out?

# Possibly by:

find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
| grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
#
#  [:digit:] is one of the character classes
#+ introduced with the POSIX 1003.2 standard. 

# Thanks, Stphane Chazelas. 
</programlisting></para>


            <note><para>The <option>-exec</option> option to
	      <command>find</command> should not be confused with the <link linkend="execref">exec</link> shell builtin.</para></note>

	    <example xml:id="ex57">
	      <title><firstterm>Badname</firstterm>, eliminate file names
		in current directory containing bad characters and <link linkend="whitespaceref">whitespace</link>.</title>
	      <programlisting>#!/bin/bash
# badname.sh
# Delete filenames in current directory containing bad characters.

for filename in *
do
  badname=`echo "$filename" | sed -n /[\+\{\;\"\\\=\?~\(\)\&lt;\&gt;\&amp;\*\|\$]/p`
# badname=`echo "$filename" | sed -n '/[+{;"\=?~()&lt;&gt;&amp;*|$]/p'`  also works.
# Deletes files containing these nasties:     + { ; " \ = ? ~ ( ) &lt; &gt; &amp; * | $
#
  rm $badname 2&gt;/dev/null
#             ^^^^^^^^^^^ Error messages deep-sixed.
done

# Now, take care of files containing all manner of whitespace.
find . -name "* *" -exec rm -f {} \;
# The path name of the file that _find_ finds replaces the "{}".
# The '\' ensures that the ';' is interpreted literally, as end of command.

exit 0

#---------------------------------------------------------------------
# Commands below this line will not execute because of _exit_ command.

# An alternative to the above script:
find . -name '*[+{;"\\=?~()&lt;&gt;&amp;*|$ ]*' -maxdepth 0 \
-exec rm -f '{}' \;
#  The "-maxdepth 0" option ensures that _find_ will not search
#+ subdirectories below $PWD.

# (Thanks, S.C.)
</programlisting>
	    </example>

	    <example xml:id="idelete">
	      <title>Deleting a file by its <firstterm>inode</firstterm>
	        number</title>
	      <programlisting>#!/bin/bash
# idelete.sh: Deleting a file by its inode number.

#  This is useful when a filename starts with an illegal character,
#+ such as ? or -.

ARGCOUNT=1                      # Filename arg must be passed to script.
E_WRONGARGS=70
E_FILE_NOT_EXIST=71
E_CHANGED_MIND=72

if [ $# -ne "$ARGCOUNT" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_WRONGARGS
fi  

if [ ! -e "$1" ]
then
  echo "File \""$1"\" does not exist."
  exit $E_FILE_NOT_EXIST
fi  

inum=`ls -i | grep "$1" | awk '{print $1}'`
# inum = inode (index node) number of file
# -----------------------------------------------------------------------
# Every file has an inode, a record that holds its physical address info.
# -----------------------------------------------------------------------

echo; echo -n "Are you absolutely sure you want to delete \"$1\" (y/n)? "
# The '-v' option to 'rm' also asks this.
read answer
case "$answer" in
[nN]) echo "Changed your mind, huh?"
      exit $E_CHANGED_MIND
      ;;
*)    echo "Deleting file \"$1\".";;
esac

find . -inum $inum -exec rm {} \;
#                           ^^
#        Curly brackets are placeholder
#+       for text output by "find."
echo "File "\"$1"\" deleted!"

exit 0
</programlisting>
	    </example>

	    <para>The <command>find</command> command also works
	      without the <option>-exec</option> option.</para>

	    <para>
	    <programlisting>#!/bin/bash
#  Find suid root files.
#  A strange suid file might indicate a security hole,
#+ or even a system intrusion.

directory="/usr/sbin"
# Might also try /sbin, /bin, /usr/bin, /usr/local/bin, etc.
permissions="+4000"  # suid root (dangerous!)


for file in $( find "$directory" -perm "$permissions" )
do
  ls -ltF --author "$file"
done</programlisting>
	    </para>

	    <para>See <xref linkend="ex48" />, <xref linkend="ex58" />,
	      and <xref linkend="findstring" /> for scripts using
	      <command>find</command>. Its <link linkend="manref">manpage</link> provides more detail
	      on this complex and powerful command.</para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="xargsref" /><command moreinfo="none">xargs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>xargs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xargs</secondary>
	  </indexterm>
	    <para>A filter for feeding arguments to a command, and also
	      a tool for assembling the commands themselves. It breaks
	      a data stream into small enough chunks for filters and
	      commands to process.  Consider it as a powerful replacement
	      for <link linkend="backquotesref">backquotes</link>.
	      In situations where <link linkend="commandsubref">command
	      substitution</link> fails with a <errorname>too
	      many arguments</errorname> error,
	      substituting <command>xargs</command> often
	      works.
	        <footnote><para>And even when <firstterm>xargs</firstterm> is
		not strictly necessary, it can speed up execution of a command
		involving <link linkend="batchprocref">batch-processing</link> of multiple
		files.</para></footnote>
	      Normally, <command>xargs</command> reads from
	      <filename>stdin</filename> or from a pipe, but it can also
	      be given the output of a file.</para>

	    <para>The default command for <command>xargs</command> is
	      <link linkend="echoref">echo</link>. This means that input
	      piped to <command>xargs</command> may have linefeeds and
	      other whitespace characters stripped out.</para>
	      
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>total 0
 -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
 -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2</computeroutput>



<prompt>bash$ </prompt><userinput>ls -l | xargs</userinput>
<computeroutput>total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan...</computeroutput>



<prompt>bash$ </prompt><userinput>find ~/mail -type f | xargs grep "Linux"</userinput>
<computeroutput>./misc:User-Agent: slrn/0.9.8.1 (Linux)
 ./sent-mail-jul-2005: hosted by the Linux Documentation Project.
 ./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)
 ./sent-mail-jul-2005: Subject: Criticism of Bozo's Windows/Linux article
 ./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem
 . . .</computeroutput>
	      </screen>
	      </para>

	    <para><userinput>ls | xargs -p -l gzip</userinput> <link linkend="gzipref">gzips</link> every file in current
	      directory, one at a time, prompting before each
	      operation.</para>

	    <para><anchor xml:id="xargsoneatatime" /></para>
	    <note>
	    <para>Note that <firstterm>xargs</firstterm> processes the
	      arguments passed to it sequentially, <emphasis>one at
	      a time</emphasis>.</para>

            <para><screen>
<prompt>bash$ </prompt><userinput>find /usr/bin | xargs file</userinput>
<computeroutput>/usr/bin:          directory
 /usr/bin/foomatic-ppd-options:          perl script text executable
 . . .</computeroutput>
	      </screen>
	      </para>
	    </note>

	    <para><anchor xml:id="xargslimargs" /></para>
	    <tip>
	    <para>An interesting <firstterm>xargs</firstterm>
	      option is <option>-n <replaceable>NN</replaceable></option>,
	      which limits to <replaceable>NN</replaceable> the number
	      of arguments passed.</para>
	    <para><userinput>ls | xargs -n 8 echo</userinput> lists the files in the
	      current directory in <literal>8</literal> columns.</para>
	    </tip>  
	      
	      
	    <para><anchor xml:id="xargsws" /></para>
	    <tip>
	    <para>Another useful option is
	      <option>-0</option>, in combination with <userinput>find
	      -print0</userinput> or <userinput>grep -lZ</userinput>. This
	      allows handling arguments containing whitespace or
	      quotes.</para>
	      
	    <para>
	    <userinput>find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f</userinput>
	    </para>
	    
	    <para>
	    <userinput>grep -rliwZ GUI / | xargs -0 rm -f</userinput>
	    </para>

	    <para>Either of the above will remove any file containing <quote>GUI</quote>.
	      <emphasis>(Thanks, S.C.)</emphasis></para>

            <para>Or:
	      <programlisting>cat /proc/"$pid"/"$OPTION" | xargs -0 echo
#  Formats output:         ^^^^^^^^^^^^^^^
#  From Han Holl's fixup of "get-commandline.sh"
#+ script in "/dev and /proc" chapter.</programlisting></para>
	    </tip>

	    <tip>
	    <para><anchor xml:id="xargsmultiprocess" /></para>
		    <para>The <option>-P</option> option to
		      <firstterm>xargs</firstterm> permits running
		      processes in parallel. This speeds up execution
		      in a machine with a multicore CPU.</para>
	      <para><programlisting>#!/bin/bash

ls *gif | xargs -t -n1 -P2 gif2png
# Converts all the gif images in current directory to png.

# Options:
# =======
# -t    Print command to stderr.
# -n1   At most 1 argument per command line.
# -P2   Run up to 2 processes simultaneously.

# Thank you, Roberto Polli, for the inspiration.</programlisting></para>
            </tip>


	    <example xml:id="ex41">
	      <title>Logfile: Using <firstterm>xargs</firstterm> to monitor system log</title>
	      <programlisting>#!/bin/bash

# Generates a log file in current directory
# from the tail end of /var/log/messages.

# Note: /var/log/messages must be world readable
# if this script invoked by an ordinary user.
#         #root chmod 644 /var/log/messages

LINES=5

( date; uname -a ) &gt;&gt;logfile
# Time and machine name
echo ---------------------------------------------------------- &gt;&gt;logfile
tail -n $LINES /var/log/messages | xargs | fmt -s &gt;&gt;logfile
echo &gt;&gt;logfile
echo &gt;&gt;logfile

exit 0

#  Note:
#  ----
#  As Frank Wang points out,
#+ unmatched quotes (either single or double quotes) in the source file
#+ may give xargs indigestion.
#
#  He suggests the following substitution for line 15:
#  tail -n $LINES /var/log/messages | tr -d "\"'" | xargs | fmt -s &gt;&gt;logfile



#  Exercise:
#  --------
#  Modify this script to track changes in /var/log/messages at intervals
#+ of 20 minutes.
#  Hint: Use the "watch" command. 
</programlisting>
	    </example>	    

	    <para><anchor xml:id="xargscurlyref" /></para>
	    <para><link linkend="curlybracketsref">As in
	      <command>find</command></link>, a curly bracket
	      pair serves as a placeholder for replacement text.</para>

	    <example xml:id="ex42">
	      <title>Copying files in current directory to another</title>
	      <programlisting>#!/bin/bash
# copydir.sh

#  Copy (verbose) all files in current directory ($PWD)
#+ to directory specified on command-line.

E_NOARGS=85

if [ -z "$1" ]   # Exit if no argument given.
then
  echo "Usage: `basename $0` directory-to-copy-to"
  exit $E_NOARGS
fi  

ls . | xargs -i -t cp ./{} $1
#            ^^ ^^      ^^
#  -t is "verbose" (output command-line to stderr) option.
#  -i is "replace strings" option.
#  {} is a placeholder for output text.
#  This is similar to the use of a curly-bracket pair in "find."
#
#  List the files in current directory (ls .),
#+ pass the output of "ls" as arguments to "xargs" (-i -t options),
#+ then copy (cp) these arguments ({}) to new directory ($1).  
#
#  The net result is the exact equivalent of
#+   cp * $1
#+ unless any of the filenames has embedded "whitespace" characters.

exit 0
</programlisting>
	    </example>	    

	    <example xml:id="killbyname">
	      <title>Killing processes by name</title>
	      <programlisting>#!/bin/bash
# kill-byname.sh: Killing processes by name.
# Compare this script with kill-process.sh.

#  For instance,
#+ try "./kill-byname.sh xterm" --
#+ and watch all the xterms on your desktop disappear.

#  Warning:
#  -------
#  This is a fairly dangerous script.
#  Running it carelessly (especially as root)
#+ can cause data loss and other undesirable effects.

E_BADARGS=66

if test -z "$1"  # No command-line arg supplied?
then
  echo "Usage: `basename $0` Process(es)_to_kill"
  exit $E_BADARGS
fi


PROCESS_NAME="$1"
ps ax | grep "$PROCESS_NAME" | awk '{print $1}' | xargs -i kill {} 2&amp;&gt;/dev/null
#                                                       ^^      ^^

# ---------------------------------------------------------------
# Notes:
# -i is the "replace strings" option to xargs.
# The curly brackets are the placeholder for the replacement.
# 2&amp;&gt;/dev/null suppresses unwanted error messages.
#
# Can  grep "$PROCESS_NAME" be replaced by pidof "$PROCESS_NAME"?
# ---------------------------------------------------------------

exit $?

#  The "killall" command has the same effect as this script,
#+ but using it is not quite as educational.
</programlisting>
	    </example>

	    <example xml:id="wf2">
	      <title>Word frequency analysis using
	      <firstterm>xargs</firstterm></title>
	      <programlisting>#!/bin/bash
# wf2.sh: Crude word frequency analysis on a text file.

# Uses 'xargs' to decompose lines of text into single words.
# Compare this example to the "wf.sh" script later on.


# Check for input file on command-line.
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne "$ARGS" ]
# Correct number of arguments passed to script?
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ ! -f "$1" ]       # Does file exist?
then
  echo "File \"$1\" does not exist."
  exit $E_NOFILE
fi



#####################################################
cat "$1" | xargs -n1 | \
#  List the file, one word per line. 
tr A-Z a-z | \
#  Shift characters to lowercase.
sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
/g' | \
#  Filter out periods and commas, and
#+ change space between words to linefeed,
sort | uniq -c | sort -nr
#  Finally remove duplicates, prefix occurrence count
#+ and sort numerically.
#####################################################

#  This does the same job as the "wf.sh" example,
#+ but a bit more ponderously, and it runs more slowly (why?).

exit $?
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="exprref" /><userinput moreinfo="none">expr</userinput></term>
	  <listitem>
	  <indexterm>
	    <primary>expr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expr</secondary>
	  </indexterm>
	    <para>All-purpose expression evaluator:
	      Concatenates and evaluates the arguments according
	      to the operation given (arguments must be separated
	      by spaces). Operations may be arithmetic, comparison,
	      string, or logical.</para>

	    <variablelist>
	      <varlistentry>
		<term><userinput moreinfo="none">expr 3 + 5</userinput></term>
		<listitem>
		  <para>returns <literal>8</literal></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput moreinfo="none">expr 5 % 3</userinput></term>
		<listitem>
		  <para>returns 2</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput moreinfo="none">expr 1 / 0</userinput></term>
		<listitem>
		  <para>returns the error message, <errorcode>expr: division by
		    zero</errorcode></para>
                  <para>Illegal arithmetic operations not allowed.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput moreinfo="none">expr 5 \* 3</userinput></term>
		<listitem>
		<para>returns 15</para>
		<para>The multiplication operator
		  must be escaped when used in an arithmetic expression
		  with <command>expr</command>.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput moreinfo="none">y=`expr $y + 1`</userinput></term>
		<listitem>
		  <para>Increment a variable, with the same effect
		    as <userinput>let y=y+1</userinput> and
		    <userinput>y=$(($y+1))</userinput>. This is an
		    example of <link linkend="arithexpref">arithmetic
		    expansion</link>.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><anchor xml:id="expextrsub" /><userinput moreinfo="none">z=`expr substr
		$string $position $length`</userinput></term>
		<listitem>
		  <para>Extract substring of $length characters, starting
		    at $position.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example xml:id="ex45">
	      <title>Using <firstterm>expr</firstterm></title>
	      <programlisting>#!/bin/bash

# Demonstrating some of the uses of 'expr'
# =======================================

echo

# Arithmetic Operators
# ---------- ---------

echo "Arithmetic Operators"
echo
a=`expr 5 + 3`
echo "5 + 3 = $a"

a=`expr $a + 1`
echo
echo "a + 1 = $a"
echo "(incrementing a variable)"

a=`expr 5 % 3`
# modulo
echo
echo "5 mod 3 = $a"

echo
echo

# Logical Operators
# ------- ---------

#  Returns 1 if true, 0 if false,
#+ opposite of normal Bash convention.

echo "Logical Operators"
echo

x=24
y=25
b=`expr $x = $y`         # Test equality.
echo "b = $b"            # 0  ( $x -ne $y )
echo

a=3
b=`expr $a \&gt; 10`
echo 'b=`expr $a \&gt; 10`, therefore...'
echo "If a &gt; 10, b = 0 (false)"
echo "b = $b"            # 0  ( 3 ! -gt 10 )
echo

b=`expr $a \&lt; 10`
echo "If a &lt; 10, b = 1 (true)"
echo "b = $b"            # 1  ( 3 -lt 10 )
echo
# Note escaping of operators.

b=`expr $a \&lt;= 3`
echo "If a &lt;= 3, b = 1 (true)"
echo "b = $b"            # 1  ( 3 -le 3 )
# There is also a "\&gt;=" operator (greater than or equal to).


echo
echo



# String Operators
# ------ ---------

echo "String Operators"
echo

a=1234zipper43231
echo "The string being operated upon is \"$a\"."

# length: length of string
b=`expr length $a`
echo "Length of \"$a\" is $b."

# index: position of first character in substring
#        that matches a character in string
b=`expr index $a 23`
echo "Numerical position of first \"2\" in \"$a\" is \"$b\"."

# substr: extract substring, starting position &amp; length specified
b=`expr substr $a 2 6`
echo "Substring of \"$a\", starting at position 2,\
and 6 chars long is \"$b\"."


#  The default behavior of the 'match' operations is to
#+ search for the specified match at the BEGINNING of the string.
#
#       Using Regular Expressions ...
b=`expr match "$a" '[0-9]*'`               #  Numerical count.
echo Number of digits at the beginning of \"$a\" is $b.
b=`expr match "$a" '\([0-9]*\)'`           #  Note that escaped parentheses
#                   ==      ==             #+ trigger substring match.
echo "The digits at the beginning of \"$a\" are \"$b\"."

echo

exit 0
</programlisting>
	    </example>	    
	    
	    <important>
	    <para>The <link linkend="nullref">:
	      (<firstterm>null</firstterm>)</link> operator
	      can substitute for <command>match</command>. For example,
	      <userinput>b=`expr $a : [0-9]*`</userinput> is the
	      exact equivalent of <userinput>b=`expr match $a
	      [0-9]*`</userinput> in the above listing.</para>

	    <para><programlisting>#!/bin/bash

echo
echo "String operations using \"expr \$string : \" construct"
echo "==================================================="
echo

a=1234zipper5FLIPPER43231

echo "The string being operated upon is \"`expr "$a" : '\(.*\)'`\"."
#     Escaped parentheses grouping operator.            ==  ==

#       ***************************
#+          Escaped parentheses
#+           match a substring
#       ***************************


#  If no escaped parentheses ...
#+ then 'expr' converts the string operand to an integer.

echo "Length of \"$a\" is `expr "$a" : '.*'`."   # Length of string

echo "Number of digits at the beginning of \"$a\" is `expr "$a" : '[0-9]*'`."

# ------------------------------------------------------------------------- #

echo

echo "The digits at the beginning of \"$a\" are `expr "$a" : '\([0-9]*\)'`."
#                                                             ==      ==
echo "The first 7 characters of \"$a\" are `expr "$a" : '\(.......\)'`."
#         =====                                          ==       ==
# Again, escaped parentheses force a substring match.
#
echo "The last 7 characters of \"$a\" are `expr "$a" : '.*\(.......\)'`."
#         ====                  end of string operator  ^^
#  (In fact, means skip over one or more of any characters until specified
#+  substring found.)

echo

exit 0
</programlisting></para>
	      </important>

	  </listitem>
	</varlistentry>

       </variablelist>

	    <para>The above script illustrates how
	      <command>expr</command> uses the <firstterm>escaped
	      parentheses -- \( ... \) --</firstterm> grouping operator
	      in tandem with <link linkend="regexref">regular
	      expression</link> parsing to match a substring.
	      Here is a another example, this time from <quote>real
	      life.</quote>

	        <programlisting># Strip the whitespace from the beginning and end.
LRFDATE=`expr "$LRFDATE" : '[[:space:]]*\(.*\)[[:space:]]*$'`

#  From Peter Knowles' "booklistgen.sh" script
#+ for converting files to Sony Librie/PRS-50X format.
#  (http://booklistgensh.peterknowles.com)</programlisting>

	      </para>


            <para><link linkend="perlref">Perl</link>,
	      <link linkend="sedref">sed</link>, and <link linkend="awkref">awk</link> have far superior string
	      parsing facilities. A short <command>sed</command> or
	      <command>awk</command> <quote>subroutine</quote> within
	      a script (see <xref linkend="wrapper" />) is an attractive
	      alternative to <command>expr</command>.</para>


            <para>See <xref linkend="String-Manipulation" /> for more on
              using <command>expr</command> in string operations.</para>


	</section> <!-- End Complex Commands -->



      <section xml:id="timedate">
        <title>Time / Date Commands</title>

       <variablelist xml:id="tdlisting">
         <title><anchor xml:id="tdlisting1" />Time/date and timing</title>

	<varlistentry>
	  <term><anchor xml:id="dateref" /><command moreinfo="none">date</command></term>
	  <listitem>
	  <indexterm>
	    <primary>date</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>date</secondary>
	  </indexterm>
	    <para>Simply invoked, <command>date</command> prints the date and
	      time to <filename>stdout</filename>. Where this command gets
	      interesting is in its formatting and parsing options.</para>

	    <example xml:id="ex51">
	      <title>Using <firstterm>date</firstterm></title>
	      <programlisting>#!/bin/bash
# Exercising the 'date' command

echo "The number of days since the year's beginning is `date +%j`."
# Needs a leading '+' to invoke formatting.
# %j gives day of year.

echo "The number of seconds elapsed since 01/01/1970 is `date +%s`."
#  %s yields number of seconds since "UNIX epoch" began,
#+ but how is this useful?

prefix=temp
suffix=$(date +%s)  # The "+%s" option to 'date' is GNU-specific.
filename=$prefix.$suffix
echo "Temporary filename = $filename"
#  It's great for creating "unique and random" temp filenames,
#+ even better than using $$.

# Read the 'date' man page for more formatting options.

exit 0
</programlisting>
	    </example>	    	   


	    <para>The <option>-u</option> option gives the UTC (Universal
	      Coordinated Time).</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>date</userinput>
<computeroutput>Fri Mar 29 21:07:39 MST 2002</computeroutput>



<prompt>bash$ </prompt><userinput>date -u</userinput>
<computeroutput>Sat Mar 30 04:07:42 UTC 2002</computeroutput>
	      </screen>
	      </para>

	    <para>This option facilitates calculating the time between
	      different dates.</para>

	    <example xml:id="datecalc">
	      <title><firstterm>Date</firstterm> calculations</title>
	      <programlisting>#!/bin/bash
# date-calc.sh
# Author: Nathan Coulter
# Used in ABS Guide with permission (thanks!).

MPHR=60    # Minutes per hour.
HPD=24     # Hours per day.

diff () {
        printf '%s' $(( $(date -u -d"$TARGET" +%s) -
                        $(date -u -d"$CURRENT" +%s)))
#                       %d = day of month.
}


CURRENT=$(date -u -d '2007-09-01 17:30:24' '+%F %T.%N %Z')
TARGET=$(date -u -d'2007-12-25 12:30:00' '+%F %T.%N %Z')
# %F = full date, %T = %H:%M:%S, %N = nanoseconds, %Z = time zone.

printf '\nIn 2007, %s ' \
       "$(date -d"$CURRENT +
        $(( $(diff) /$MPHR /$MPHR /$HPD / 2 )) days" '+%d %B')" 
#       %B = name of month                ^ halfway
printf 'was halfway between %s ' "$(date -d"$CURRENT" '+%d %B')"
printf 'and %s\n' "$(date -d"$TARGET" '+%d %B')"

printf '\nOn %s at %s, there were\n' \
        $(date -u -d"$CURRENT" +%F) $(date -u -d"$CURRENT" +%T)
DAYS=$(( $(diff) / $MPHR / $MPHR / $HPD ))
CURRENT=$(date -d"$CURRENT +$DAYS days" '+%F %T.%N %Z')
HOURS=$(( $(diff) / $MPHR / $MPHR ))
CURRENT=$(date -d"$CURRENT +$HOURS hours" '+%F %T.%N %Z')
MINUTES=$(( $(diff) / $MPHR ))
CURRENT=$(date -d"$CURRENT +$MINUTES minutes" '+%F %T.%N %Z')
printf '%s days, %s hours, ' "$DAYS" "$HOURS"
printf '%s minutes, and %s seconds ' "$MINUTES" "$(diff)"
printf 'until Christmas Dinner!\n\n'

#  Exercise:
#  --------
#  Rewrite the diff () function to accept passed parameters,
#+ rather than using global variables.
</programlisting>
	    </example>	    	   


	      <para><anchor xml:id="daterandref" /></para>
	      <para>The <firstterm>date</firstterm> command has quite a
		number of <firstterm>output</firstterm> options. For
		example <option>%N</option> gives the nanosecond portion
		of the current time. One interesting use for this is to
		generate random integers.

	       <programlisting>date +%N | sed -e 's/000$//' -e 's/^0//'
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#  Strip off leading and trailing zeroes, if present.
#  Length of generated integer depends on
#+ how many zeroes stripped off.

# 115281032
# 63408725
# 394504284</programlisting>
	      </para>

	      <para>There are many more options (try <command>man
	        date</command>).</para>

	      <para><programlisting>date +%j
# Echoes day of the year (days elapsed since January 1).

date +%k%M
# Echoes hour and minute in 24-hour format, as a single digit string.



# The 'TZ' parameter permits overriding the default time zone.
date                 # Mon Mar 28 21:42:16 MST 2005
TZ=EST date          # Mon Mar 28 23:42:16 EST 2005
# Thanks, Frank Kannemann and Pete Sjoberg, for the tip.


SixDaysAgo=$(date --date='6 days ago')
OneMonthAgo=$(date --date='1 month ago')  # Four weeks back (not a month!)
OneYearAgo=$(date --date='1 year ago')</programlisting></para>

              <para>See also <xref linkend="ex58" /> and <xref linkend="stopwatch" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="zdumpref" /><command moreinfo="none">zdump</command></term>
	  <listitem>
	  <indexterm>
	    <primary>zdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time zone dump</secondary>
	  </indexterm>
	    <para>Time zone dump: echoes the time in a specified time zone.</para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>zdump EST</userinput>
<computeroutput>EST  Tue Sep 18 22:09:22 2001 EST</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="timref" /><command moreinfo="none">time</command></term>
	  <listitem>
	  <indexterm>
	    <primary>time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time</secondary>
	  </indexterm>

	    <para>Outputs verbose timing statistics for executing a command.</para>

	    <para><userinput>time ls -l /</userinput> gives something
	    like this:</para>

	    <para>
<screen><computeroutput>real    0m0.067s
 user    0m0.004s
 sys     0m0.005s</computeroutput></screen>
	  </para>

	  <para>See also the very similar <link linkend="timesref">times</link> command in the previous
	    section.</para>

	  <note><para>As of <link linkend="bash2ref">version 2.0</link>
	    of Bash, <command>time</command> became a shell reserved word,
	    with slightly altered behavior in a pipeline.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="touchref" /><command moreinfo="none">touch</command></term>
	  <listitem>
	  <indexterm>
	    <primary>touch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>touch</secondary>
	  </indexterm>

	    <para>Utility for updating access/modification times of a
	      file to current system time or other specified time,
	      but also useful for creating a new file. The command
	      <userinput>touch zzz</userinput> will create a new file
	      of zero length, named <filename>zzz</filename>, assuming
	      that <filename>zzz</filename> did not previously exist.
	      Time-stamping empty files in this way is useful for
	      storing date information, for example in keeping track of
	      modification times on a project.
	      </para>

	    <note><para>The <command>touch</command> command is
	      equivalent to <userinput>: &gt;&gt; newfile</userinput>
	      or <userinput>&gt;&gt; newfile</userinput> (for ordinary
	      files).</para></note>

	    <tip>
	    <para>Before doing a <link linkend="cpref">cp -u</link>
	      (<firstterm>copy/update</firstterm>), use
	      <command>touch</command> to update the time stamp of files
	      you don't wish overwritten.</para>
	    <para>As an example, if the directory <filename class="directory">/home/bozo/tax_audit</filename> contains the
	      files <filename>spreadsheet-051606.data</filename>,
	      <filename>spreadsheet-051706.data</filename>, and
	      <filename>spreadsheet-051806.data</filename>, then
	      doing a <command>touch spreadsheet*.data</command>
	      will protect these files from being overwritten
	      by files with the same names during a
	      <command>cp -u /home/bozo/financial_info/spreadsheet*data
	      /home/bozo/tax_audit</command>.</para>
	      </tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="atref" /><command moreinfo="none">at</command></term>
	  <listitem>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cron</secondary>
	  </indexterm>
	    <para>The <command>at</command> job control command executes
	      a given set of commands at a specified time. Superficially,
	      it resembles <link linkend="cronref">cron</link>, however,
	      <command>at</command> is chiefly useful for one-time execution
	      of a command set.</para>
	  
	    <para><userinput>at 2pm January 15</userinput> prompts for a set of
	      commands to execute at that time. These commands should be
	      shell-script compatible, since, for all practical
	      purposes, the user is typing in an executable shell
	      script a line at a time.	Input terminates with a <link linkend="ctldref">Ctl-D</link>.</para>

	    <para>Using either the <option>-f</option> option or input
	      redirection (<token>&lt;</token>), <command>at</command>
	      reads a command list from a file. This file is an
	      executable shell script, though it should, of course,
	      be non-interactive. Particularly clever is including the
	      <link linkend="runpartsref">run-parts</link> command in
	      the file to execute a different set of scripts.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>at 2:30 am Friday &lt; at-jobs.list</userinput>
<computeroutput>job 2 at 2000-10-27 02:30</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="batchref" /><command moreinfo="none">batch</command></term>
	  <listitem>
	  <indexterm>
	    <primary>batch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>batch</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>

	    <para>The <command>batch</command> job control command is similar to
	      <command>at</command>, but it runs a command list when the system
	      load drops below <literal>.8</literal>. Like
	      <command>at</command>, it can read commands from a file with the
	      <option>-f</option> option.</para>

	    <para><anchor xml:id="batchprocref" /></para>

	    <sidebar>
            <para>The concept of <firstterm>batch processing</firstterm>
              dates back to the era of mainframe computers. It means
              running a set of commands without user intervention.</para>
	    </sidebar>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="calref" /><command moreinfo="none">cal</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cal</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cal</secondary>
	  </indexterm>
	    <para>Prints a neatly formatted monthly calendar to
	      <filename>stdout</filename>. Will do current year or a large
	      range of past and future years.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sleepref" /><command moreinfo="none">sleep</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sleep</secondary>
	  </indexterm>
	    <para>This is the shell equivalent of a <firstterm>wait
	      loop</firstterm>. It pauses for a specified number of
	      seconds, doing nothing. It can be useful for timing or
	      in processes running in the background, checking for
	      a specific event every so often (polling), as in <xref linkend="online" />.  <programlisting>sleep 3     # Pauses 3 seconds.</programlisting>
	    </para>

	    <note><para>The <command>sleep</command> command defaults to
	      seconds, but minute, hours, or days may also be specified.
	      <programlisting>sleep 3 h   # Pauses 3 hours!</programlisting>
            </para></note>

	    <note><para>The <link linkend="watchref">watch</link> command may
	      be a better choice than <command>sleep</command> for running
	      commands at timed intervals.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="usleepref" /><command moreinfo="none">usleep</command></term>
	  <listitem>
	  <indexterm>
	    <primary>usleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usleep</secondary>
	  </indexterm>
	    <para><firstterm>Microsleep</firstterm> (the
	      <firstterm>u</firstterm> may be read as the Greek
	      <firstterm>mu</firstterm>, or <firstterm>micro-</firstterm>
	      prefix). This is the same as <command>sleep</command>,
	      above, but <quote>sleeps</quote> in microsecond
	      intervals. It can be used for fine-grained timing,
	      or for polling an ongoing process at very frequent
	      intervals.</para>

	    <para>  
	      <programlisting>usleep 30     # Pauses 30 microseconds.</programlisting>
	    </para>

	    <para>This command is part of the Red Hat
	    <firstterm>initscripts / rc-scripts</firstterm> package.</para>

	    <caution><para>The <command>usleep</command> command does not
	      provide particularly accurate timing, and is therefore
	      unsuitable for critical timing loops.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="hwclockref" /><command moreinfo="none">hwclock</command></term>
	  <term><anchor xml:id="clockref" /><command moreinfo="none">clock</command></term>
	  <listitem>
	  <indexterm>
	    <primary>hwclock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hwclock</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>clock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clock</secondary>
	  </indexterm>
	    <para>The <command>hwclock</command> command accesses or
	      adjusts the machine's hardware clock. Some options
	      require <firstterm>root</firstterm> privileges. The
	      <filename>/etc/rc.d/rc.sysinit</filename> startup file
	      uses <command>hwclock</command> to set the system time
	      from the hardware clock at bootup.</para>

	    <para>The <command>clock</command> command is a synonym for
	      <command>hwclock</command>.</para>
	  </listitem>
	</varlistentry>


       </variablelist>
       
        </section> <!-- End Time / Date Commands -->




      <section xml:id="textproc">
        <title>Text Processing Commands</title>

       <variablelist xml:id="tpcommandlisting">
         <title><anchor xml:id="tpcommandlisting1" />Commands affecting text and
	   text files</title>

	<varlistentry>
	  <term><anchor xml:id="sortref" /><command moreinfo="none">sort</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sort</secondary>
	  </indexterm>
	    <para>File sort utility, often used as a filter in a pipe. This
	      command sorts a <firstterm>text stream</firstterm>
	      or file forwards or backwards, or according to various
	      keys or character positions. Using the <option>-m</option>
	      option, it merges presorted input files.	The <firstterm>info
	      page</firstterm> lists its many capabilities and options. See
	      <xref linkend="findstring" />, <xref linkend="symlinks" />,
	      and <xref linkend="makedict" />.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="tsortref" /><command moreinfo="none">tsort</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tsort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>topological sort</secondary>
	  </indexterm>

	    <para><firstterm>Topological sort</firstterm>, reading in
	      pairs of whitespace-separated strings and sorting
	      according to input patterns. The original purpose of
	      <command>tsort</command> was to sort a list of dependencies
	      for an obsolete version of the <firstterm>ld</firstterm>
	      linker in an <quote>ancient</quote> version of UNIX.</para>

            <para>The results of a <firstterm>tsort</firstterm> will usually
	      differ markedly from those of the standard
	      <command>sort</command> command, above.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="uniqref" /><command moreinfo="none">uniq</command></term>
	  <listitem>
	  <indexterm>
	    <primary>uniq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uniq</secondary>
	  </indexterm>
	    <para>This filter removes duplicate lines from a sorted
	      file. It is often seen in a pipe coupled with
	      <link linkend="sortref">sort</link>.</para>

	    <para><programlisting>cat list-1 list-2 list-3 | sort | uniq &gt; final.list
# Concatenates the list files,
# sorts them,
# removes duplicate lines,
# and finally writes the result to an output file.</programlisting></para>
 
             <para>The useful <option>-c</option> option prefixes each line of
	       the input file with its number of occurrences.</para>
	     <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cat testfile</userinput>
<computeroutput>This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times.</computeroutput>


<prompt>bash$ </prompt><userinput>uniq -c testfile</userinput>
<computeroutput>      1 This line occurs only once.
       2 This line occurs twice.
       3 This line occurs three times.</computeroutput>


<prompt>bash$ </prompt><userinput>sort testfile | uniq -c | sort -nr</userinput>
<computeroutput>      3 This line occurs three times.
       2 This line occurs twice.
       1 This line occurs only once.</computeroutput>
	      </screen>
	     </para>

	     <para>The <userinput>sort INPUTFILE | uniq -c | sort -nr</userinput>
	       command string produces a <firstterm>frequency
	       of occurrence</firstterm> listing on the
	       <filename>INPUTFILE</filename> file (the
	       <option>-nr</option> options to <command>sort</command>
	       cause a reverse numerical sort). This template finds
	       use in analysis of log files and dictionary lists, and
	       wherever the lexical structure of a document needs to
	       be examined.</para>

	    <example xml:id="wf">
	      <title>Word Frequency Analysis</title>
	      <programlisting>#!/bin/bash
# wf.sh: Crude word frequency analysis on a text file.
# This is a more efficient version of the "wf2.sh" script.


# Check for input file on command-line.
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne "$ARGS" ]  # Correct number of arguments passed to script?
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ ! -f "$1" ]       # Check if file exists.
then
  echo "File \"$1\" does not exist."
  exit $E_NOFILE
fi



########################################################
# main ()
sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
/g' "$1" | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr
#                           =========================
#                            Frequency of occurrence

#  Filter out periods and commas, and
#+ change space between words to linefeed,
#+ then shift characters to lowercase, and
#+ finally prefix occurrence count and sort numerically.

#  Arun Giridhar suggests modifying the above to:
#  . . . | sort | uniq -c | sort +1 [-f] | sort +0 -nr
#  This adds a secondary sort key, so instances of
#+ equal occurrence are sorted alphabetically.
#  As he explains it:
#  "This is effectively a radix sort, first on the
#+ least significant column
#+ (word or string, optionally case-insensitive)
#+ and last on the most significant column (frequency)."
#
#  As Frank Wang explains, the above is equivalent to
#+       . . . | sort | uniq -c | sort +0 -nr
#+ and the following also works:
#+       . . . | sort | uniq -c | sort -k1nr -k
########################################################

exit 0

# Exercises:
# ---------
# 1) Add 'sed' commands to filter out other punctuation,
#+   such as semicolons.
# 2) Modify the script to also filter out multiple spaces and
#+   other whitespace.
</programlisting>
	    </example>	    

	     <para>
	       <screen>
<prompt>bash$ </prompt><userinput>cat testfile</userinput>
<computeroutput>This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times.</computeroutput>


<prompt>bash$ </prompt><userinput>./wf.sh testfile</userinput>
<computeroutput>      6 this
       6 occurs
       6 line
       3 times
       3 three
       2 twice
       1 only
       1 once</computeroutput>
	       </screen>
	     </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="expandref" /><command moreinfo="none">expand</command></term>
	  <term><command moreinfo="none">unexpand</command></term>
	  <listitem>
	  <indexterm>
	    <primary>expand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expand</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unexpand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unexpand</secondary>
	  </indexterm>
	    <para>The <command>expand</command> filter converts tabs to
	      spaces. It is often used in a <link linkend="piperef">pipe</link>.</para>
	    <para>The <command>unexpand</command> filter
	      converts spaces to tabs. This reverses the effect of
	      <command>expand</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="cutref" /><command moreinfo="none">cut</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	    <para>A tool for extracting <link linkend="fieldref">fields</link> from files. It is similar
	      to the <userinput>print $N</userinput> command set in <link linkend="awkref">awk</link>, but more limited. It may be
	      simpler to use <firstterm>cut</firstterm> in a script than
	      <firstterm>awk</firstterm>. Particularly important are the
	      <option>-d</option> (delimiter) and <option>-f</option>
	      (field specifier) options.</para>

	    <para>Using <command>cut</command> to obtain a listing of the
	      mounted filesystems: 
	      <programlisting>cut -d ' ' -f1,2 /etc/mtab</programlisting></para>

	    <para>Using <command>cut</command> to list the OS and kernel version:
	      <programlisting>uname -a | cut -d" " -f1,3,11,12</programlisting></para>

	    <para>Using <command>cut</command> to extract message headers from
	      an e-mail folder:

	      <screen><prompt>bash$ </prompt><userinput>grep '^Subject:' read-messages | cut -c10-80</userinput>
<computeroutput>Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME!!!
 Spam complaint
 Re: Spam complaint</computeroutput></screen>
	    </para>

	    <para>Using <command>cut</command> to parse a file:
	      <programlisting># List all the users in /etc/passwd.

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# Thanks, Oleg Philon for suggesting this.</programlisting></para>

	    <para><userinput>cut -d ' ' -f2,3 filename</userinput> is equivalent to
	      <userinput>awk -F'[ ]' '{ print $2, $3 }' filename</userinput></para>

            <note>
	    <para>It is even possible to specify a linefeed as a
	      delimiter. The trick is to actually embed a linefeed
	      (<keycap>RETURN</keycap>) in the command sequence.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cut -d'
 ' -f3,7,19 testfile</userinput>
<computeroutput>This is line 3 of testfile.
 This is line 7 of testfile.
 This is line 19 of testfile.</computeroutput>
	      </screen>
	  </para>

	  <para>Thank you, Jaka Kranjc, for pointing this out.</para>
            </note>

	    <para>See also <xref linkend="base" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="pasteref" /><command moreinfo="none">paste</command></term>
	  <listitem>
	  <indexterm>
	    <primary>paste</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>paste</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	    <para>Tool for merging together different files into a single,
	      multi-column file.  In combination with
	      <link linkend="cutref">cut</link>, useful for creating system log
	      files.
	    </para>


	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cat items</userinput>
<computeroutput>alphabet blocks
 building blocks
 cables</computeroutput>

<prompt>bash$ </prompt><userinput>cat prices</userinput>
<computeroutput>$1.00/dozen
 $2.50 ea.
 $3.75</computeroutput>

<prompt>bash$ </prompt><userinput>paste items prices</userinput>
<computeroutput>alphabet blocks $1.00/dozen
 building blocks $2.50 ea.
 cables  $3.75</computeroutput></screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="joinref" /><command moreinfo="none">join</command></term>
	  <listitem>
	  <indexterm>
	    <primary>join</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>join</secondary>
	  </indexterm>
	    <para>Consider this a special-purpose cousin of
	      <command>paste</command>. This powerful utility allows
	      merging two files in a meaningful fashion, which essentially
	      creates a simple version of a relational database.</para>

	    <para>The <command>join</command> command operates on
	      exactly two files, but pastes together only those lines
	      with a common tagged <link linkend="fieldref">field</link>
	      (usually a numerical label), and writes the result to
	      <filename>stdout</filename>.  The files to be joined should
	      be sorted according to the tagged field for the matchups
	      to work properly.</para>

	      <para><programlisting>File: 1.data

100 Shoes
200 Laces
300 Socks</programlisting></para>
      
              <para><programlisting>File: 2.data

100 $40.00
200 $1.00
300 $2.00</programlisting></para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>join 1.data 2.data</userinput>
<computeroutput>File: 1.data 2.data

 100 Shoes $40.00
 200 Laces $1.00
 300 Socks $2.00</computeroutput>
	      </screen>
	    </para>

	    <note><para>The tagged field appears only once in the
	      output.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="headref" /><command moreinfo="none">head</command></term>
	  <listitem>
	  <indexterm>
	    <primary>head</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>head</secondary>
	  </indexterm>
	    <para>lists the beginning of a file to <filename>stdout</filename>.
	      The default is <literal>10</literal> lines, but a different
	      number can be specified. The command has a number of
	      interesting options.

	    <example xml:id="scriptdetector">
	      <title>Which files are scripts?</title>
	      <programlisting>#!/bin/bash
# script-detector.sh: Detects scripts within a directory.

TESTCHARS=2    # Test first 2 characters.
SHABANG='#!'   # Scripts begin with a "sha-bang."

for file in *  # Traverse all the files in current directory.
do
  if [[ `head -c$TESTCHARS "$file"` = "$SHABANG" ]]
  #      head -c2                      #!
  #  The '-c' option to "head" outputs a specified
  #+ number of characters, rather than lines (the default).
  then
    echo "File \"$file\" is a script."
  else
    echo "File \"$file\" is *not* a script."
  fi
done
  
exit 0

#  Exercises:
#  ---------
#  1) Modify this script to take as an optional argument
#+    the directory to scan for scripts
#+    (rather than just the current working directory).
#
#  2) As it stands, this script gives "false positives" for
#+    Perl, awk, and other scripting language scripts.
#     Correct this.
</programlisting>
	    </example>	    

	    <example xml:id="rnd">
	      <title>Generating 10-digit random numbers</title>
	      <programlisting>#!/bin/bash
# rnd.sh: Outputs a 10-digit random number

# Script by Stephane Chazelas.

head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'


# =================================================================== #

# Analysis
# --------

# head:
# -c4 option takes first 4 bytes.

# od:
# -N4 option limits output to 4 bytes.
# -tu4 option selects unsigned decimal format for output.

# sed: 
# -n option, in combination with "p" flag to the "s" command,
# outputs only matched lines.



# The author of this script explains the action of 'sed', as follows.

# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
# ----------------------------------&gt; |

# Assume output up to "sed" --------&gt; |
# is 0000000 1198195154\n

#  sed begins reading characters: 0000000 1198195154\n.
#  Here it finds a newline character,
#+ so it is ready to process the first line (0000000 1198195154).
#  It looks at its &lt;range&gt;&lt;action&gt;s. The first and only one is

#   range     action
#   1         s/.* //p

#  The line number is in the range, so it executes the action:
#+ tries to substitute the longest string ending with a space in the line
#  ("0000000 ") with nothing (//), and if it succeeds, prints the result
#  ("p" is a flag to the "s" command here, this is different
#+ from the "p" command).

#  sed is now ready to continue reading its input. (Note that before
#+ continuing, if -n option had not been passed, sed would have printed
#+ the line once again).

#  Now, sed reads the remainder of the characters, and finds the
#+ end of the file.
#  It is now ready to process its 2nd line (which is also numbered '$' as
#+ it's the last one).
#  It sees it is not matched by any &lt;range&gt;, so its job is done.

#  In few word this sed commmand means:
#  "On the first line only, remove any character up to the right-most space,
#+ then print it."

# A better way to do this would have been:
#           sed -e 's/.* //;q'

# Here, two &lt;range&gt;&lt;action&gt;s (could have been written
#           sed -e 's/.* //' -e q):

#   range                    action
#   nothing (matches line)   s/.* //
#   nothing (matches line)   q (quit)

#  Here, sed only reads its first line of input.
#  It performs both actions, and prints the line (substituted) before
#+ quitting (because of the "q" action) since the "-n" option is not passed.

# =================================================================== #

# An even simpler altenative to the above one-line script would be:
#           head -c4 /dev/urandom| od -An -tu4

exit
</programlisting>
	    </example>	    

	      See also <xref linkend="ex52" />.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="tailref" /><command moreinfo="none">tail</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tail</secondary>
	  </indexterm>
	    <para>lists the (tail) end of a file to <filename>stdout</filename>.
	      The default is <literal>10</literal> lines, but this can
	      be changed with the <option>-n</option> option.
	      Commonly used to keep track of
	      changes to a system logfile, using the <option>-f</option>
	      option, which outputs lines appended to the file.</para>

	   <example xml:id="ex12">
	     <title>Using <firstterm>tail</firstterm> to monitor the system log</title>
	     <programlisting>#!/bin/bash

filename=sys.log

cat /dev/null &gt; $filename; echo "Creating / cleaning out file."
#  Creates the file if it does not already exist,
#+ and truncates it to zero length if it does.
#  : &gt; filename   and   &gt; filename also work.

tail /var/log/messages &gt; $filename  
# /var/log/messages must have world read permission for this to work.

echo "$filename contains tail end of system log."

exit 0
</programlisting>
	   </example>

	      <tip>
	      <para>To list a specific line of a text file,
	        <link linkend="piperef">pipe</link> the output of
	        <command>head</command> to <command>tail -n 1</command>.
		For example <userinput>head -n 8 database.txt | tail
		-n 1</userinput> lists the 8th line of the file
		<filename>database.txt</filename>.</para>
	      <para>To set a variable to a given block of a text file:
	        <programlisting>var=$(head -n $m $filename | tail -n $n)

# filename = name of file
# m = from beginning of file, number of lines to end of block
# n = number of lines to set variable to (trim from end of block)</programlisting></para>
	      </tip>

	      <note>
	      <para>Newer implementations of <command>tail</command>
	        deprecate the older <command>tail -$LINES
	        filename</command> usage. The standard <command>tail -n $LINES
	        filename</command> is correct.</para>
	      </note>

	      <para>See also <xref linkend="ex41" />, <xref linkend="ex52" /> and
		<xref linkend="online" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="grepref" /><command moreinfo="none">grep</command></term>
	  <listitem>
	  <indexterm>
	    <primary>grep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>grep</secondary>
	  </indexterm>
	    <para>A multi-purpose file search tool that uses
	      <link linkend="regexref">Regular Expressions</link>.
	      It was originally a command/filter in the
	      venerable <command>ed</command> line editor:
	      <userinput>g/re/p</userinput> -- <firstterm>global -
	      regular expression - print</firstterm>.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>grep</command> <arg choice="plain" rep="norepeat"><replaceable>pattern</replaceable></arg>
		<arg choice="opt" rep="repeat"><replaceable>file</replaceable></arg>
	      </cmdsynopsis>Search the target file(s) for
	      occurrences of <replaceable>pattern</replaceable>, where
	      <replaceable>pattern</replaceable> may be literal text
	      or a Regular Expression.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>grep '[rst]ystem.$' osinfo.txt</userinput>
<computeroutput>The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	      </para>

	    <para>If no target file(s) specified, <command>grep</command>
	      works as a filter on <filename>stdout</filename>, as in
	      a <link linkend="piperef">pipe</link>.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>ps ax | grep clock</userinput>
<computeroutput>765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</computeroutput>
	      </screen>
	      </para>

	    <para>The <option>-i</option> option causes a case-insensitive
	      search.</para>

	    <para>The <option>-w</option> option matches only whole
	      words.</para>

	    <para>The <option>-l</option> option lists only the files in which
	      matches were found, but not the matching lines.</para>

	    <para>The <option>-r</option> (recursive) option searches files in
	      the current working directory and all subdirectories below
	      it.</para>

	    <para>The <option>-n</option> option lists the matching lines,
	      together with line numbers.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>grep -n Linux osinfo.txt</userinput>
<computeroutput>2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	      </para>

	    <para>The <option>-v</option> (or <option>--invert-match</option>)
	      option <firstterm>filters out</firstterm> matches.
	      <programlisting>grep pattern1 *.txt | grep -v pattern2

# Matches all lines in "*.txt" files containing "pattern1",
# but ***not*** "pattern2".	      
</programlisting></para>

	    <para>The <option>-c</option> (<option>--count</option>)
	      option gives a numerical count of matches, rather than
	      actually listing the matches.

	        <programlisting>grep -c txt *.xml   # (number of occurrences of "txt" in "*.xml" files)


#   grep -cz .
#            ^ dot
# means count (-c) zero-separated (-z) items matching "."
# that is, non-empty ones (containing at least 1 character).
# 
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 3
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
#
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
# By default, newline chars (\n) separate items to match. 

# Note that the -z option is GNU "grep" specific.


# Thanks, S.C.</programlisting>
            </para>

	    <para>The <option>--color</option> (or <option>--colour</option>)
	      option marks the matching string in color (on the console
	      or in an <firstterm>xterm</firstterm> window). Since
	      <firstterm>grep</firstterm> prints out each entire line
	      containing the matching pattern, this lets you see exactly
	      <emphasis>what</emphasis> is being matched. See also
	      the <option>-o</option> option, which shows only the
	      matching portion of the line(s).</para>


	    <example xml:id="fromsh">
	      <title>Printing out the <firstterm>From</firstterm> lines in
	        stored e-mail messages</title>
	      <programlisting>#!/bin/bash
# from.sh

#  Emulates the useful 'from' utility in Solaris, BSD, etc.
#  Echoes the "From" header line in all messages
#+ in your e-mail directory.


MAILDIR=~/mail/*               #  No quoting of variable. Why?
# Maybe check if-exists $MAILDIR:   if [ -d $MAILDIR ] . . .
GREP_OPTS="-H -A 5 --color"    #  Show file, plus extra context lines
                               #+ and display "From" in color.
TARGETSTR="^From"              # "From" at beginning of line.

for file in $MAILDIR           #  No quoting of variable.
do
  grep $GREP_OPTS "$TARGETSTR" "$file"
  #    ^^^^^^^^^^              #  Again, do not quote this variable.
  echo
done

exit $?

#  You might wish to pipe the output of this script to 'more'
#+ or redirect it to a file . . .
</programlisting>
	    </example>	    

	    <para>When invoked with more than one target file given,
	      <command>grep</command> specifies which file contains
	      matches.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep Linux osinfo.txt misc.txt</userinput>
<computeroutput>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</computeroutput>
	      </screen>
	    </para>


	    <tip>
	    <para>To force <command>grep</command> to show the filename
	      when searching only one target file, simply give
	      <filename>/dev/null</filename> as the second file.</para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep Linux osinfo.txt /dev/null</userinput>
<computeroutput>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	    </para>
	    </tip>


	    <para>If there is a successful match, <command>grep</command>
	      returns an <link linkend="exitstatusref">exit status</link>
	      of 0, which makes it useful in a condition test in a
	      script, especially in combination with the <option>-q</option>
	      option to suppress output.
	        <programlisting>SUCCESS=0                      # if grep lookup succeeds
word=Linux
filename=data.file

grep -q "$word" "$filename"    #  The "-q" option
                               #+ causes nothing to echo to stdout.
if [ $? -eq $SUCCESS ]
# if grep -q "$word" "$filename"   can replace lines 5 - 7.
then
  echo "$word found in $filename"
else
  echo "$word not found in $filename"
fi</programlisting>
            </para>


	    <para><xref linkend="online" /> demonstrates how to use
	      <command>grep</command> to search for a word pattern in
	      a system logfile.</para>


	    <example xml:id="grp">
	      <title>Emulating <firstterm>grep</firstterm> in a script</title>
	      <programlisting>#!/bin/bash
# grp.sh: Rudimentary reimplementation of grep.

E_BADARGS=85

if [ -z "$1" ]    # Check for argument to script.
then
  echo "Usage: `basename $0` pattern"
  exit $E_BADARGS
fi  

echo

for file in *     # Traverse all files in $PWD.
do
  output=$(sed -n /"$1"/p $file)  # Command substitution.

  if [ ! -z "$output" ]           # What happens if "$output" is not quoted?
  then
    echo -n "$file: "
    echo "$output"
  fi              #  sed -ne "/$1/s|^|${file}: |p"  is equivalent to above.

  echo
done  

echo

exit 0

# Exercises:
# ---------
# 1) Add newlines to output, if more than one match in any given file.
# 2) Add features.
</programlisting>
	    </example>	    	   

	    <para>How can <command>grep</command> search for two (or
	      more) separate patterns? What if you want
	      <command>grep</command> to display all lines in a file
	      or files that contain both <quote>pattern1</quote>
	      <emphasis>and</emphasis> <quote>pattern2</quote>?</para>

	    <para>One method is to <link linkend="piperef">pipe</link> the result of <command>grep
	      pattern1</command> to <command>grep pattern2</command>.</para>

            <para>For example, given the following file:</para>

            <para>
	    <programlisting># Filename: tstfile

This is a sample file.
This is an ordinary text file.
This file does not contain any unusual text.
This file is not unusual.
Here is some text.</programlisting>
            </para>

            <para>Now, let's search this file for lines containing
	      <emphasis>both</emphasis> <quote>file</quote> and
	      <quote>text</quote> . . . </para>

	      <screen><prompt>bash$ </prompt><userinput>grep file tstfile</userinput>
<computeroutput># Filename: tstfile
 This is a sample file.
 This is an ordinary text file.
 This file does not contain any unusual text.
 This file is not unusual.</computeroutput>

<prompt>bash$ </prompt><userinput>grep file tstfile | grep text</userinput>
<computeroutput>This is an ordinary text file.
 This file does not contain any unusual text.</computeroutput></screen>

            <para>Now, for an interesting recreational use
	      of <firstterm>grep</firstterm> . . .</para>


	    <example xml:id="cwsolver">
	      <title>Crossword puzzle solver</title>
	      <programlisting>#!/bin/bash
# cw-solver.sh
# This is actually a wrapper around a one-liner (line 46).

#  Crossword puzzle and anagramming word game solver.
#  You know *some* of the letters in the word you're looking for,
#+ so you need a list of all valid words
#+ with the known letters in given positions.
#  For example: w...i....n
#               1???5????10
# w in position 1, 3 unknowns, i in the 5th, 4 unknowns, n at the end.
# (See comments at end of script.)


E_NOPATT=71
DICT=/usr/share/dict/word.lst
#                    ^^^^^^^^   Looks for word list here.
#  ASCII word list, one word per line.
#  If you happen to need an appropriate list,
#+ download the author's "yawl" word list package.
#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
#  or
#  http://bash.deta.in/yawl-0.3.2.tar.gz


if [ -z "$1" ]   #  If no word pattern specified
then             #+ as a command-line argument . . .
  echo           #+ . . . then . . .
  echo "Usage:"  #+ Usage message.
  echo
  echo ""$0" \"pattern,\""
  echo "where \"pattern\" is in the form"
  echo "xxx..x.x..."
  echo
  echo "The x's represent known letters,"
  echo "and the periods are unknown letters (blanks)."
  echo "Letters and periods can be in any position."
  echo "For example, try:   sh cw-solver.sh w...i....n"
  echo
  exit $E_NOPATT
fi

echo
# ===============================================
# This is where all the work gets done.
grep ^"$1"$ "$DICT"   # Yes, only one line!
#    |    |
# ^ is start-of-word regex anchor.
# $ is end-of-word regex anchor.

#  From _Stupid Grep Tricks_, vol. 1,
#+ a book the ABS Guide author may yet get around
#+ to writing . . . one of these days . . .
# ===============================================
echo


exit $?  # Script terminates here.
#  If there are too many words generated,
#+ redirect the output to a file.

$ sh cw-solver.sh w...i....n

wellington
workingman
workingmen
</programlisting>
	    </example>	    



	    <para><anchor xml:id="egrepref" /><command>egrep</command>
	      -- <firstterm>extended grep</firstterm> -- is the same
	      as <command>grep -E</command>. This uses a somewhat
	      different, extended set of <link linkend="regexref">Regular
	      Expressions</link>, which can make the search a bit more
	      flexible. It also allows the boolean |
	      (<firstterm>or</firstterm>) operator.
	      <screen><prompt>bash $ </prompt><userinput>egrep 'matches|Matches' file.txt</userinput>
<computeroutput>Line 1 matches.
 Line 3 Matches.
 Line 4 contains matches, but also Matches</computeroutput>
              </screen>
	      </para>

	    <para><anchor xml:id="fgrepref" /><command>fgrep</command> --
	      <firstterm>fast grep</firstterm> -- is the same as
	      <command>grep -F</command>. It does a literal string search
	      (no <link linkend="regexref">Regular Expressions</link>),
	      which generally speeds things up a bit.</para>

            <note><para>On some Linux distros, <command>egrep</command> and
	      <command>fgrep</command> are symbolic links to, or aliases for
	      <command>grep</command>, but invoked with the
	      <option>-E</option> and <option>-F</option> options,
	      respectively.</para></note>

	    <example xml:id="dictlookup">
	      <title>Looking up definitions in <citetitle pubwork="book">Webster's 1913 Dictionary</citetitle></title>
	      <programlisting>#!/bin/bash
# dict-lookup.sh

#  This script looks up definitions in the 1913 Webster's Dictionary.
#  This Public Domain dictionary is available for download
#+ from various sites, including
#+ Project Gutenberg (http://www.gutenberg.org/etext/247).
#
#  Convert it from DOS to UNIX format (with only LF at end of line)
#+ before using it with this script.
#  Store the file in plain, uncompressed ASCII text.
#  Set DEFAULT_DICTFILE variable below to path/filename.


E_BADARGS=85
MAXCONTEXTLINES=50                        # Maximum number of lines to show.
DEFAULT_DICTFILE="/usr/share/dict/webster1913-dict.txt"
                                          # Default dictionary file pathname.
                                          # Change this as necessary.
#  Note:
#  ----
#  This particular edition of the 1913 Webster's
#+ begins each entry with an uppercase letter
#+ (lowercase for the remaining characters).
#  Only the *very first line* of an entry begins this way,
#+ and that's why the search algorithm below works.



if [[ -z $(echo "$1" | sed -n '/^[A-Z]/p') ]]
#  Must at least specify word to look up, and
#+ it must start with an uppercase letter.
then
  echo "Usage: `basename $0` Word-to-define [dictionary-file]"
  echo
  echo "Note: Word to look up must start with capital letter,"
  echo "with the rest of the word in lowercase."
  echo "--------------------------------------------"
  echo "Examples: Abandon, Dictionary, Marking, etc."
  exit $E_BADARGS
fi


if [ -z "$2" ]                            #  May specify different dictionary
                                          #+ as an argument to this script.
then
  dictfile=$DEFAULT_DICTFILE
else
  dictfile="$2"
fi

# ---------------------------------------------------------
Definition=$(fgrep -A $MAXCONTEXTLINES "$1 \\" "$dictfile")
#                  Definitions in form "Word \..."
#
#  And, yes, "fgrep" is fast enough
#+ to search even a very large text file.


# Now, snip out just the definition block.

echo "$Definition" |
sed -n '1,/^[A-Z]/p' |
#  Print from first line of output
#+ to the first line of the next entry.
sed '$d' | sed '$d'
#  Delete last two lines of output
#+ (blank line and first line of next entry).
# ---------------------------------------------------------

exit $?

# Exercises:
# ---------
# 1)  Modify the script to accept any type of alphabetic input
#   + (uppercase, lowercase, mixed case), and convert it
#   + to an acceptable format for processing.
#
# 2)  Convert the script to a GUI application,
#   + using something like 'gdialog' or 'zenity' . . .
#     The script will then no longer take its argument(s)
#   + from the command-line.
#
# 3)  Modify the script to parse one of the other available
#   + Public Domain Dictionaries, such as the U.S. Census Bureau Gazetteer.
</programlisting>
	    </example>

	    <note><para>See also <xref linkend="qky" /> for an example
	      of speedy <firstterm>fgrep</firstterm> lookup on a large
	      text file.</para></note>

	    <para><anchor xml:id="agrepref" /></para>
	    <para><command>agrep</command> (<firstterm>approximate
	      grep</firstterm>) extends the capabilities of
	      <command>grep</command> to approximate matching. The search
	      string may differ by a specified number of characters
	      from the resulting matches. This utility is not part of
	      the core Linux distribution.</para>


	    <para><anchor xml:id="zegrepref" /></para>
	    <tip> <para>To search compressed files, use
	      <command>zgrep</command>, <command>zegrep</command>, or
	      <command>zfgrep</command>. These also work on non-compressed
	      files, though slower than plain <command>grep</command>,
	      <command>egrep</command>, <command>fgrep</command>.
	      They are handy for searching through a mixed set of files,
	      some compressed, some not.</para>
	    <para><anchor xml:id="bzgrepref" /></para>
	    <para>To search <link linkend="bzipref">bzipped</link>
	      files, use <command>bzgrep</command>.</para> </tip>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="lookref" /><command moreinfo="none">look</command></term>
	  <listitem>
	  <indexterm>
	    <primary>look</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>look</secondary>
	  </indexterm>
	    <para>The command <command>look</command> works like
	      <command>grep</command>, but does a lookup on
	      a <quote>dictionary,</quote> a sorted word list.
	      By default, <command>look</command> searches for a match
	      in <filename>/usr/dict/words</filename>, but a different
	      dictionary file may be specified.</para>

	    <example xml:id="lookup">
	      <title>Checking words in a list for validity</title>
	      <programlisting>#!/bin/bash
# lookup: Does a dictionary lookup on each word in a data file.

file=words.data  # Data file from which to read words to test.

echo
echo "Testing file $file"
echo

while [ "$word" != end ]  # Last word in data file.
do               # ^^^
  read word      # From data file, because of redirection at end of loop.
  look $word &gt; /dev/null  # Don't want to display lines in dictionary file.
  #  Searches for words in the file /usr/share/dict/words
  #+ (usually a link to linux.words).
  lookup=$?      # Exit status of 'look' command.

  if [ "$lookup" -eq 0 ]
  then
    echo "\"$word\" is valid."
  else
    echo "\"$word\" is invalid."
  fi  

done &lt;"$file"    # Redirects stdin to $file, so "reads" come from there.

echo

exit 0

# ----------------------------------------------------------------
# Code below line will not execute because of "exit" command above.


# Stephane Chazelas proposes the following, more concise alternative:

while read word &amp;&amp; [[ $word != end ]]
do if look "$word" &gt; /dev/null
   then echo "\"$word\" is valid."
   else echo "\"$word\" is invalid."
   fi
done &lt;"$file"

exit 0
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command moreinfo="none">sed</command></term>
	  <term><command moreinfo="none">awk</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	    <para>Scripting languages especially suited for parsing text
	      files and command output. May be embedded singly or in
	      combination in pipes and shell scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command moreinfo="none"><link linkend="sedref">sed</link></command></term>
	  <listitem>
	    <para>Non-interactive <quote>stream editor</quote>, permits using
	      many <command>ex</command> commands in <link linkend="batchprocref">batch</link> mode. It finds many
	      uses in shell scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command moreinfo="none"><link linkend="awkref">awk</link></command></term>
	  <listitem>
	    <para>Programmable file extractor and formatter, good for
	      manipulating and/or extracting <link linkend="fieldref">fields</link> (columns) in structured
	      text files. Its syntax is similar to C.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="wcref" /><command moreinfo="none">wc</command></term>
	  <listitem>
	  <indexterm>
	    <primary>wc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wc</secondary>
	  </indexterm>

	    <para><firstterm>wc</firstterm> gives a <quote>word
	      count</quote> on a file or I/O stream:

	      <screen><prompt>bash $ </prompt><userinput>wc /usr/share/doc/sed-4.1.2/README</userinput>
<computeroutput>13  70  447 README</computeroutput>
[13 lines  70 words  447 characters]</screen></para>

	    <para><userinput>wc -w</userinput> gives only the word count.</para>
	    <para><userinput>wc -l</userinput> gives only the line count.</para>
	    <para><userinput>wc -c</userinput> gives only the byte count.</para>
	    <para><userinput>wc -m</userinput> gives only the character count.</para>
	    <para><userinput>wc -L</userinput> gives only the length of the longest line.</para>

            <para>Using <command>wc</command> to count how many
	    <filename>.txt</filename> files are in current working directory:
	      <programlisting>$ ls *.txt | wc -l
#  Will work as long as none of the "*.txt" files
#+ have a linefeed embedded in their name.

#  Alternative ways of doing this are:
#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
#      (shopt -s nullglob; set -- *.txt; echo $#)

#  Thanks, S.C.</programlisting>
	    </para>

	    <para>Using <command>wc</command> to total up the size of all the
	      files whose names begin with letters in the range d - h
	      <screen><prompt>bash$ </prompt><userinput>wc [d-h]* | grep total | awk '{print $3}'</userinput>
<computeroutput>71832</computeroutput>
	      </screen>
	    </para>

	    <para>Using <command>wc</command> to count the instances of the
	      word <quote>Linux</quote> in the main source file for
	      this book.
	      <screen><prompt>bash$ </prompt><userinput>grep Linux abs-book.xml | wc -l</userinput>
<computeroutput>138</computeroutput>
	      </screen>
	    </para>

	    <para>See also <xref linkend="ex52" /> and <xref linkend="redir4" />.</para>

	    <para>Certain commands include some of the
	      functionality of <command>wc</command> as options.
	      
	    <programlisting>... | grep foo | wc -l
# This frequently used construct can be more concisely rendered.

... | grep -c foo
# Just use the "-c" (or "--count") option of grep.

# Thanks, S.C.</programlisting></para>

	  </listitem>
	</varlistentry>

	
	<varlistentry>
	  <term><anchor xml:id="trref" /><command moreinfo="none">tr</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tr</secondary>
	  </indexterm>
	    <para>character translation filter.</para>
	    
	    <caution><para><link linkend="ucref">Must use quoting and/or
	      brackets</link>, as appropriate. Quotes prevent the
	      shell from reinterpreting the special characters in
	      <command>tr</command> command sequences. Brackets should be
	      quoted to prevent expansion by the shell.  </para></caution>

	    <para>Either <userinput>tr "A-Z" "*" &lt;filename</userinput>
	      or <userinput>tr A-Z \* &lt;filename</userinput> changes
	      all the uppercase letters in <filename>filename</filename>
	      to asterisks (writes to <filename>stdout</filename>).
	      On some systems this may not work, but <userinput>tr A-Z
	      '[**]'</userinput> will.</para>

	    <para><anchor xml:id="troptions" /></para>
	    <para>The <option>-d</option> option deletes a range of
	      characters.
	    <programlisting>echo "abcdef"                 # abcdef
echo "abcdef" | tr -d b-d     # aef


tr -d 0-9 &lt;filename
# Deletes all digits from the file "filename".</programlisting></para>

            <para>The <option>--squeeze-repeats</option> (or
              <option>-s</option>) option deletes all but the
              first instance of a string of consecutive characters.
              This option is useful for removing excess <link linkend="whitespaceref">whitespace</link>.



	      <screen><prompt>bash$ </prompt><userinput>echo "XXXXX" | tr --squeeze-repeats 'X'</userinput>
<computeroutput>X</computeroutput></screen></para>

	    <para>The <option>-c</option> <quote>complement</quote>
	      option <firstterm>inverts</firstterm> the character set to
	      match. With this option, <command>tr</command> acts only
	      upon those characters <emphasis>not</emphasis> matching
	      the specified set.</para>

            <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "acfdeb123" | tr -c b-d +</userinput>
<computeroutput>+c+d+b++++</computeroutput></screen>
            </para>



            <para>Note that <command>tr</command> recognizes <link linkend="posixref">POSIX character classes</link>.
	         <footnote><para>This is only true of the GNU version of
		 <command>tr</command>, not the generic version often found on
		 commercial UNIX systems.</para></footnote>
	      </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "abcd2ef1" | tr '[:alpha:]' -</userinput>
<computeroutput>----2--1</computeroutput>
	      </screen>
	    </para>

	    <example xml:id="ex49">
	      <title><firstterm>toupper</firstterm>: Transforms a file
	      to all uppercase.</title>
	      <programlisting>#!/bin/bash
# Changes a file to all uppercase.

E_BADARGS=85

if [ -z "$1" ]  # Standard check for command-line arg.
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi  

tr a-z A-Z &lt;"$1"

# Same effect as above, but using POSIX character set notation:
#        tr '[:lower:]' '[:upper:]' &lt;"$1"
# Thanks, S.C.

#     Or even . . .
#     cat "$1" | tr a-z A-Z
#     Or dozens of other ways . . .

exit 0

#  Exercise:
#  Rewrite this script to give the option of changing a file
#+ to *either* upper or lowercase.
#  Hint: Use either the "case" or "select" command.
</programlisting>
	    </example>	    


	    <example xml:id="lowercase">
	      <title><firstterm>lowercase</firstterm>: Changes all
	      filenames in working directory to lowercase.</title>
	      <programlisting>#!/bin/bash
#
#  Changes every filename in working directory to all lowercase.
#
#  Inspired by a script of John Dubois,
#+ which was translated into Bash by Chet Ramey,
#+ and considerably simplified by the author of the ABS Guide.


for filename in *                # Traverse all files in directory.
do
   fname=`basename $filename`
   n=`echo $fname | tr A-Z a-z`  # Change name to lowercase.
   if [ "$fname" != "$n" ]       # Rename only files not already lowercase.
   then
     mv $fname $n
   fi  
done   

exit $?


# Code below this line will not execute because of "exit".
#--------------------------------------------------------#
# To run it, delete script above line.

# The above script will not work on filenames containing blanks or newlines.
# Stephane Chazelas therefore suggests the following alternative:


for filename in *    # Not necessary to use basename,
                     # since "*" won't return any file containing "/".
do n=`echo "$filename/" | tr '[:upper:]' '[:lower:]'`
#                             POSIX char set notation.
#                    Slash added so that trailing newlines are not
#                    removed by command substitution.
   # Variable substitution:
   n=${n%/}          # Removes trailing slash, added above, from filename.
   [[ $filename == $n ]] || mv "$filename" "$n"
                     # Checks if filename already lowercase.
done

exit $?
</programlisting>
	    </example>	    

	    <para><anchor xml:id="trd2u" /></para>
	    <example xml:id="du">
	      <title><firstterm>du</firstterm>: DOS to UNIX text file conversion.</title>
	      <programlisting>#!/bin/bash
# Du.sh: DOS to UNIX text file converter.

E_WRONGARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename-to-convert"
  exit $E_WRONGARGS
fi

NEWFILENAME=$1.unx

CR='\015'  # Carriage return.
           # 015 is octal ASCII code for CR.
           # Lines in a DOS text file end in CR-LF.
           # Lines in a UNIX text file end in LF only.

tr -d $CR &lt; $1 &gt; $NEWFILENAME
# Delete CR's and write to new file.

echo "Original DOS text file is \"$1\"."
echo "Converted UNIX text file is \"$NEWFILENAME\"."

exit 0

# Exercise:
# --------
# Change the above script to convert from UNIX to DOS.
</programlisting>
	    </example>	    

	    <example xml:id="rot13">
	      <title><firstterm>rot13</firstterm>: ultra-weak encryption.</title>
	      <programlisting>#!/bin/bash
# rot13.sh: Classic rot13 algorithm,
#           encryption that might fool a 3-year old
#           for about 10 minutes.

# Usage: ./rot13.sh filename
# or     ./rot13.sh &lt;filename
# or     ./rot13.sh and supply keyboard input (stdin)

cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M'   # "a" goes to "n", "b" to "o" ...
#  The   cat "$@"   construct
#+ permits input either from stdin or from files.

exit 0
</programlisting>
	    </example>	    

	    <example xml:id="cryptoquote">
	      <title>Generating <quote>Crypto-Quote</quote> Puzzles</title>
	      <programlisting>#!/bin/bash
# crypto-quote.sh: Encrypt quotes

#  Will encrypt famous quotes in a simple monoalphabetic substitution.
#  The result is similar to the "Crypto Quote" puzzles
#+ seen in the Op Ed pages of the Sunday paper.


key=ETAOINSHRDLUBCFGJMQPVWZYXK
# The "key" is nothing more than a scrambled alphabet.
# Changing the "key" changes the encryption.

# The 'cat "$@"' construction gets input either from stdin or from files.
# If using stdin, terminate input with a Control-D.
# Otherwise, specify filename as command-line parameter.

cat "$@" | tr "a-z" "A-Z" | tr "A-Z" "$key"
#        |  to uppercase  |     encrypt       
# Will work on lowercase, uppercase, or mixed-case quotes.
# Passes non-alphabetic characters through unchanged.


# Try this script with something like:
# "Nothing so needs reforming as other people's habits."
# --Mark Twain
#
# Output is:
# "CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ."
# --BEML PZERC

# To reverse the encryption:
# cat "$@" | tr "$key" "A-Z"


#  This simple-minded cipher can be broken by an average 12-year old
#+ using only pencil and paper.

exit 0

#  Exercise:
#  --------
#  Modify the script so that it will either encrypt or decrypt,
#+ depending on command-line argument(s).
</programlisting>
	    </example>

	    <para><anchor xml:id="jabh" />Of course, <firstterm>tr</firstterm>
              lends itself to <firstterm>code
              obfuscation</firstterm>.</para>

            <para><programlisting>#!/bin/bash
# jabh.sh

x="wftedskaebjgdBstbdbsmnjgz"
echo $x | tr "a-z" 'oh, turtleneck Phrase Jar!'

# Based on the Wikipedia "Just another Perl hacker" article.</programlisting></para>


	    <para><anchor xml:id="trvariants" /></para>
	    <sidebar><title><firstterm>tr</firstterm> variants</title>
	    <para>
	    The <command>tr</command> utility has two historic
	    variants. The BSD version does not use brackets
	    (<userinput>tr a-z A-Z</userinput>), but the SysV one does
	    (<userinput>tr '[a-z]' '[A-Z]'</userinput>). The GNU version
	    of <command>tr</command> resembles the BSD one.
	    </para>
	    </sidebar>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="foldref" /><command moreinfo="none">fold</command></term>
	  <listitem>
	  <indexterm>
	    <primary>fold</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fold</secondary>
	  </indexterm>
	    <para>A filter that wraps lines of input to a specified width.
	      This is especially useful with the <option>-s</option>
	      option, which breaks lines at word spaces (see <xref linkend="ex50" /> and <xref linkend="mailformat" />).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="fmtref" /><command moreinfo="none">fmt</command></term>
	  <listitem>
	  <indexterm>
	    <primary>fmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	    <para>Simple-minded file formatter, used as a filter in a
	      pipe to <quote>wrap</quote> long lines of text
	      output.</para>

	    <example xml:id="ex50">
	      <title>Formatted file listing.</title>
	      <programlisting>#!/bin/bash

WIDTH=40                    # 40 columns wide.

b=`ls /usr/local/bin`       # Get a file listing...

echo $b | fmt -w $WIDTH

# Could also have been done by
#    echo $b | fold - -s -w $WIDTH
 
exit 0
</programlisting>
	    </example>	    

	    <para>See also <xref linkend="ex41" />.</para>

	    <tip><para>A powerful alternative to <command>fmt</command> is
	      Kamil Toman's <command>par</command>
	      utility, available from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.cs.berkeley.edu/~amc/Par/">http://www.cs.berkeley.edu/~amc/Par/</link>.
	      </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="colref" /><command moreinfo="none">col</command></term>
	  <listitem>
	  <indexterm>
	    <primary>col</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reverse line feed</secondary>
	  </indexterm>
	    <para>This deceptively named filter removes reverse line feeds
	      from an input stream. It also attempts to replace
	      whitespace with equivalent tabs. The chief use of
	      <command>col</command> is in filtering the output
	      from certain text processing utilities, such as
	      <command>groff</command> and <command>tbl</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="columnref" /><command moreinfo="none">column</command></term>
	  <listitem>
	  <indexterm>
	    <primary>column</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>column</secondary>
	  </indexterm>
	    <para>Column formatter. This filter transforms list-type
	      text output into a <quote>pretty-printed</quote> table
	      by inserting tabs at appropriate places.</para>

	    <example xml:id="col">
	      <title>Using <firstterm>column</firstterm> to format a directory
	        listing</title>
	      <programlisting>#!/bin/bash
# colms.sh
# A minor modification of the example file in the "column" man page.


(printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
; ls -l | sed 1d) | column -t
#         ^^^^^^           ^^

#  The "sed 1d" in the pipe deletes the first line of output,
#+ which would be "total        N",
#+ where "N" is the total number of files found by "ls -l".

# The -t option to "column" pretty-prints a table.

exit 0
</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="colrmref" /><command moreinfo="none">colrm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>colrm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>colrm</secondary>
	  </indexterm>
	    <para>Column removal filter. This removes columns (characters)
	      from a file and writes the file, lacking the range of
	      specified columns, back to <filename>stdout</filename>.
	      <userinput>colrm 2 4 &lt;filename</userinput> removes the
	      second through fourth characters from each line of the
	      text file <filename>filename</filename>.</para>
	    <caution><para>If the file contains tabs or nonprintable
	      characters, this may cause unpredictable
	      behavior. In such cases, consider using
	      <link linkend="expandref">expand</link> and
	      <command>unexpand</command> in a pipe preceding
	      <command>colrm</command>.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="nlref" /><command moreinfo="none">nl</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	    <para>Line numbering filter: <userinput>nl filename</userinput>
	    lists <filename>filename</filename> to
	    <filename>stdout</filename>, but inserts consecutive
	    numbers at the beginning of each non-blank line. If
	    <filename>filename</filename> omitted, operates on
	    <filename>stdin.</filename></para>

	    <para>The output of <command>nl</command> is very similar to
	      <userinput>cat -b</userinput>, since, by default
	      <command>nl</command> does not list blank lines.</para>

	    <example xml:id="lnum">
	      <title><firstterm>nl</firstterm>: A self-numbering script.</title>
	      <programlisting>#!/bin/bash
# line-number.sh

# This script echoes itself twice to stdout with its lines numbered.

echo "     line number = $LINENO" # 'nl' sees this as line 4
#                                   (nl does not number blank lines).
#                                   'cat -n' sees it correctly as line #6.

nl `basename $0`

echo; echo  # Now, let's try it with 'cat -n'

cat -n `basename $0`
# The difference is that 'cat -n' numbers the blank lines.
# Note that 'nl -ba' will also do so.

exit 0
# -----------------------------------------------------------------
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="prref" /><command moreinfo="none">pr</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pr</secondary>
	  </indexterm>
	    <para>Print formatting filter. This will paginate files
	      (or <filename>stdout</filename>) into sections suitable for
	      hard copy printing or viewing on screen.	Various options
	      permit row and column manipulation, joining lines, setting
	      margins, numbering lines, adding page headers, and merging
	      files, among other things. The <command>pr</command>
	      command combines much of the functionality of
	      <command>nl</command>, <command>paste</command>,
	      <command>fold</command>, <command>column</command>, and
	      <command>expand</command>.</para>

	   <para><userinput>pr -o 5 --width=65 fileZZZ | more</userinput>
	     gives a nice paginated listing to screen of
	     <filename>fileZZZ</filename> with margins set at 5 and
	     65.</para>

	    <para>A particularly useful option is <option>-d</option>,
	      forcing double-spacing (same effect as <command>sed
	      -G</command>).</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="gettextref" /><command moreinfo="none">gettext</command></term>
	  <listitem>
	  <indexterm>
	    <primary>gettext</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>localization</secondary>
	  </indexterm>

	    <para>The GNU <command>gettext</command> package is a set of
	      utilities for <link linkend="localization">localizing</link>
	      and translating the text output of programs into foreign
	      languages. While originally intended for C programs, it
	      now supports quite a number of programming and scripting
	      languages.</para>

	    <para>The  <command>gettext</command>
	      <emphasis>program</emphasis> works on shell scripts. See
	      the <replaceable>info page</replaceable>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="msgfmtref" /><command moreinfo="none">msgfmt</command></term>
	  <listitem>
	  <indexterm>
	    <primary>msgfmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>localization</secondary>
	  </indexterm>
	    <para>A program for generating binary
	      message catalogs. It is used for <link linkend="localization">localization</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="iconvref" /><command moreinfo="none">iconv</command></term>
	  <listitem>
	  <indexterm>
	    <primary>iconv</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encoding</secondary>
	  </indexterm>

	    <para>A utility for converting file(s) to a different encoding
	      (character set). Its chief use is for <link linkend="localization">localization</link>.</para>

	    <para>
	    <programlisting># Convert a string from UTF-8 to UTF-16 and print to the BookList
function write_utf8_string {
    STRING=$1
    BOOKLIST=$2
    echo -n "$STRING" | iconv -f UTF8 -t UTF16 | \
    cut -b 3- | tr -d \\n &gt;&gt; "$BOOKLIST"
}

#  From Peter Knowles' "booklistgen.sh" script
#+ for converting files to Sony Librie/PRS-50X format.
#  (http://booklistgensh.peterknowles.com)</programlisting>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="recoderef" /><command moreinfo="none">recode</command></term>
	  <listitem>
	  <indexterm>
	    <primary>recode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encoding</secondary>
	  </indexterm>
	    <para>Consider this a fancier version of
	      <command>iconv</command>, above. This very versatile utility
	      for converting a file to a different encoding scheme.
	      Note that <firstterm>recode</firstterm> is not part of the
	      standard Linux installation.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="texref" /><command moreinfo="none">TeX</command></term>
	  <term><anchor xml:id="gsref" /><command moreinfo="none">gs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>TeX</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>TeX</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>gs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>Postscript</secondary>
	  </indexterm>

	    <para><command>TeX</command> and <command>Postscript</command>
	      are text markup languages used for preparing copy for
	      printing or formatted video display.</para>
		
	      <para><command>TeX</command> is Donald Knuth's elaborate
		typsetting system. It is often convenient to write a
		shell script encapsulating all the options and arguments
		passed to one of these markup languages.</para>

	      <para><firstterm>Ghostscript</firstterm>
		(<command>gs</command>) is a GPL-ed Postscript
		interpreter.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="texexecref" /><command moreinfo="none">texexec</command></term>
	  <listitem>
	  <indexterm>
	    <primary>texexec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pdf</secondary>
	  </indexterm>

	    <para>Utility for processing <firstterm>TeX</firstterm> and
	      <firstterm>pdf</firstterm> files. Found in
	      <filename class="directory">/usr/bin</filename>
	      on many Linux distros, it is actually a <link linkend="shwrapper">shell wrapper</link> that
	      calls <link linkend="perlref">Perl</link> to invoke
	      <firstterm>Tex</firstterm>.</para>

            <para>
	    <programlisting>texexec --pdfarrange --result=Concatenated.pdf *pdf

#  Concatenates all the pdf files in the current working directory
#+ into the merged file, Concatenated.pdf . . .
#  (The --pdfarrange option repaginates a pdf file. See also --pdfcombine.)
#  The above command-line could be parameterized and put into a shell script.</programlisting> 
            </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="enscriptref" /><command moreinfo="none">enscript</command></term>
	  <listitem>
	  <indexterm>
	    <primary>enscript</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>PostScript</secondary>
	  </indexterm>
	    <para>Utility for converting plain text file to PostScript</para>
	    <para>For example, <command>enscript filename.txt -p filename.ps</command>
	      produces the PostScript output file
	      <filename>filename.ps</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="groffref" /><command moreinfo="none">groff</command></term>
	  <term><anchor xml:id="tblref" /><command moreinfo="none">tbl</command></term>
	  <term><anchor xml:id="eqnref" /><command moreinfo="none">eqn</command></term>
	  <listitem>
	  <indexterm>
	    <primary>groff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tbl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>table</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>eqn</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>equation</secondary>
	  </indexterm>

            <para>Yet another text markup and display formatting language
	      is <command>groff</command>. This is the enhanced GNU version
	      of the venerable UNIX <command>roff/troff</command> display
	      and typesetting package. <link linkend="manref">Manpages</link>
	      use <command>groff</command>.</para>

	    <para>The <command>tbl</command> table processing utility
	      is considered part of <command>groff</command>, as its
	      function is to convert table markup into
	      <command>groff</command> commands.</para>

	    <para>The <command>eqn</command> equation processing utility
	      is likewise part of <command>groff</command>, and
	      its function is to convert equation markup into
	      <command>groff</command> commands.</para>

    <example xml:id="manview">
      <title><firstterm>manview</firstterm>: Viewing formatted manpages</title>
      <programlisting>#!/bin/bash
# manview.sh: Formats the source of a man page for viewing.

#  This script is useful when writing man page source.
#  It lets you look at the intermediate results on the fly
#+ while working on it.

E_WRONGARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_WRONGARGS
fi

# ---------------------------
groff -Tascii -man $1 | less
# From the man page for groff.
# ---------------------------

#  If the man page includes tables and/or equations,
#+ then the above code will barf.
#  The following line can handle such cases.
#
#   gtbl &lt; "$1" | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man
#
#   Thanks, S.C.

exit $?   # See also the "maned.sh" script.
</programlisting>
    </example>

	    <para>See also <xref linkend="maned" />.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="lexref" /><command moreinfo="none">lex</command></term>
	  <term><anchor xml:id="yaccref" /><command moreinfo="none">yacc</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lex</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>flex</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>yacc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bison</secondary>
	  </indexterm>
	    <para><anchor xml:id="flexref" /></para>
	    <para>The <command>lex</command> lexical analyzer produces
	      programs for pattern matching. This has been replaced
	      by the nonproprietary <command>flex</command> on Linux
	      systems.</para>
	    <para><anchor xml:id="bisonref" /></para>
	    <para>The <command>yacc</command> utility creates a
	      parser based on a set of specifications. This has been
	      replaced by the nonproprietary <command>bison</command>
	      on Linux systems.</para>
	  </listitem>
	</varlistentry>

       </variablelist>

        </section> <!-- End Text Processing Commands -->


      <section xml:id="filearchiv">
        <title>File and Archiving Commands</title>

       <variablelist xml:id="faarchiving">
         <title><anchor xml:id="faarchiving1" />Archiving</title>

	<varlistentry>
	  <term><anchor xml:id="tarref" /><command moreinfo="none">tar</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tar</secondary>
	  </indexterm>

	    <para>The standard UNIX archiving utility.

	        <footnote><para>An <firstterm>archive</firstterm>,
	        in the sense discussed here, is simply a set of related
	        files stored in a single location.</para></footnote>

	      Originally a
	      <wordasword>Tape ARchiving</wordasword> program, it has
	      developed into a general purpose package that can handle
	      all manner of archiving with all types of destination
	      devices, ranging from tape drives to regular files to even
	      <filename>stdout</filename> (see <xref linkend="ex58" />). GNU
	      <firstterm>tar</firstterm> has been patched to accept
	      various compression filters, for example: <command>tar
	      czvf archive_name.tar.gz *</command>, which recursively
	      archives and <link linkend="gzipref">gzips</link>
	      all files in a directory tree except <link linkend="dotfilesref">dotfiles</link> in the current
	      working directory (<link linkend="pwdref">$PWD</link>).

		<footnote>
		  <para>
		    A <replaceable>tar czvf ArchiveName.tar.gz *</replaceable>
		    <emphasis>will</emphasis> include dotfiles in
		    subdirectories <emphasis>below</emphasis> the current
		    working directory. This is an undocumented GNU
		    <command>tar</command> <quote>feature.</quote>
		  </para>
		</footnote>
            </para>		
		

	    <para>Some useful <command>tar</command> options:  
	      <orderedlist>

		<listitem><para><option>-c</option> create (a new
		  archive)</para></listitem>

		<listitem><para><option>-x</option> extract (files from
		  existing archive)</para></listitem>

		<listitem>
		<para><option>--delete</option> delete (files
		  from existing archive)</para>
		<caution><para>This option will not work on magnetic tape
		  devices.</para></caution>  
		  </listitem>

		<listitem><para><option>-r</option> append (files to
		  existing archive)</para></listitem>

		<listitem><para><option>-A</option> append
		  (<firstterm>tar</firstterm> files to
		  existing archive)</para></listitem>

		<listitem><para><option>-t</option> list (contents of
                  existing archive)</para></listitem>

	        <listitem><para><option>-u</option> update archive</para></listitem>

	        <listitem><para><option>-d</option> compare archive with
		  specified filesystem</para></listitem>

	        <listitem><para><option>--after-date</option> only process
		  files with a date stamp <emphasis>after</emphasis>
		  specified date</para></listitem>

		<listitem>
		<para><option>-z</option> <link linkend="gzipref">gzip</link> the archive</para>
		<para>(compress or uncompress, depending on whether
		combined with the <option>-c</option> or
		<option>-x</option>) option</para>
		</listitem>

		<listitem><para><option>-j</option>
		  <link linkend="bzipref">bzip2</link> the
		  archive</para></listitem>

	      </orderedlist>
	      </para>

	    <caution><para>It may be difficult to recover data from a
	      corrupted <firstterm>gzipped</firstterm> tar
	      archive. When archiving important files, make multiple
	      backups.</para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sharref" /><command moreinfo="none">shar</command></term>
	  <listitem>
	  <indexterm>
	    <primary>shar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>

	    <para><firstterm>Shell archiving</firstterm> utility.
              The text and/or binary files in a shell archive are
              concatenated without compression, and the resultant
              archive is essentially a shell script, complete with
              <token>#!/bin/sh</token> header, containing all the
              necessary unarchiving commands, as well as the files
              themselves. Unprintable binary characters in the target
              file(s) are converted to printable ASCII characters in the
              output <firstterm>shar</firstterm> file. <firstterm>Shar
              archives</firstterm> still show up in Usenet newsgroups,
              but otherwise <command>shar</command> has been replaced
              by <command>tar</command>/<command>gzip</command>.
              The <command>unshar</command> command unpacks
              <firstterm>shar</firstterm> archives.</para> <para>The
              <command>mailshar</command> command is a Bash script that
              uses <command>shar</command> to concatenate multiple files
              into a single one for e-mailing.
              This script supports compression and <link linkend="uuencoderef">uuencoding</link>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="arref" /><command moreinfo="none">ar</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>
	    <para>Creation and manipulation utility for archives, mainly
	      used for binary object file libraries.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rpmref" /><command moreinfo="none">rpm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rpm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>package manager</secondary>
	  </indexterm>

	    <para>The <firstterm>Red Hat Package Manager</firstterm>, or
	      <command>rpm</command> utility provides a wrapper for
	      source or binary archives. It includes commands for
	      installing and checking the integrity of packages, among
	      other things.</para>

	    <para>A simple <command>rpm -i package_name.rpm</command>
	      usually suffices to install a package, though there are many
	      more options available.</para>


	    <tip>
	    <para><userinput>rpm -qf</userinput> identifies which package a
	      file originates from.</para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>rpm -qf /bin/ls</userinput>
<computeroutput>coreutils-5.2.1-31</computeroutput>
	      </screen>
	    </para>
	    </tip>

	    <tip>
	    <para><userinput>rpm -qa</userinput> gives a
	      complete list of all installed <firstterm>rpm</firstterm> packages
	      on a given system. An <userinput>rpm -qa package_name</userinput>
	      lists only the package(s) corresponding to
	      <filename>package_name</filename>.</para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>rpm -qa</userinput>
<computeroutput>redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</computeroutput>


<prompt>bash$ </prompt><userinput>rpm -qa docbook-utils</userinput>
<computeroutput>docbook-utils-0.6.9-2</computeroutput>


<prompt>bash$ </prompt><userinput>rpm -qa docbook | grep docbook</userinput>
<computeroutput>docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</computeroutput>
	      </screen>
	    </para>
	    </tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="cpioref" /><command moreinfo="none">cpio</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cpio</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	    <para>This specialized archiving copy command
	      (<command>c</command>o<command>p</command>y
	      <command>i</command>nput and <command>o</command>utput)
	      is rarely seen any more, having been supplanted by
	      <command>tar</command>/<command>gzip</command>. It still
	      has its uses, such as moving a directory tree. With an
	      appropriate block size (for copying) specified, it
	      can be appreciably faster than <command>tar</command>.</para>

	    <example xml:id="ex48">
	      <title>Using <firstterm>cpio</firstterm> to move a directory tree</title>
	      <programlisting>#!/bin/bash

# Copying a directory tree using cpio.

# Advantages of using 'cpio':
#   Speed of copying. It's faster than 'tar' with pipes.
#   Well suited for copying special files (named pipes, etc.)
#+  that 'cp' may choke on.

ARGS=2
E_BADARGS=65

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` source destination"
  exit $E_BADARGS
fi  

source="$1"
destination="$2"

###################################################################
find "$source" -depth | cpio -admvp "$destination"
#               ^^^^^         ^^^^^
#  Read the 'find' and 'cpio' info pages to decipher these options.
#  The above works only relative to $PWD (current directory) . . .
#+ full pathnames are specified.
###################################################################


# Exercise:
# --------

#  Add code to check the exit status ($?) of the 'find | cpio' pipe
#+ and output appropriate error messages if anything went wrong.

exit $?
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rpm2cpioref" /><command moreinfo="none">rpm2cpio</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rpm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	    <para>This command extracts a
	      <command>cpio</command> archive from an <link linkend="rpmref">rpm</link> one.</para>

	    <example xml:id="derpm">
	      <title>Unpacking an <firstterm>rpm</firstterm> archive</title>
	      <programlisting>#!/bin/bash
# de-rpm.sh: Unpack an 'rpm' archive

: ${1?"Usage: `basename $0` target-file"}
# Must specify 'rpm' archive name as an argument.


TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
                                         #  $$ is process ID of script.

rpm2cpio &lt; $1 &gt; $TEMPFILE                #  Converts rpm archive into
                                         #+ cpio archive.
cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
rm -f $TEMPFILE                          #  Deletes cpio archive.

exit 0

#  Exercise:
#  Add check for whether 1) "target-file" exists and
#+                       2) it is an rpm archive.
#  Hint:                    Parse output of 'file' command.
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="paxref" /><command moreinfo="none">pax</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pax</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>

          <para>The <firstterm>pax</firstterm>
            <command>p</command>ortable <command>a</command>rchive
            e<command>x</command>change toolkit facilitates periodic
            file backups and is designed to be cross-compatible
            between various flavors of UNIX. It was designed
	    to replace <link linkend="tarref">tar</link> and <link linkend="cpioref">cpio</link>.</para>

          <para>
	  <programlisting>pax -wf daily_backup.pax ~/linux-server/files 
#  Creates a tar archive of all files in the target directory.
#  Note that the options to pax must be in the correct order --
#+ pax -fw     has an entirely different effect.

pax -f daily_backup.pax
#  Lists the files in the archive.

pax -rf daily_backup.pax ~/bsd-server/files
#  Restores the backed-up files from the Linux machine
#+ onto a BSD one.</programlisting>
	  </para>

	  <para>Note that <firstterm>pax</firstterm> handles many of
            the standard archiving and compression commands.</para>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="facompression">
        <title><anchor xml:id="facompression1" />Compression</title>

	<varlistentry>
	  <term><anchor xml:id="gzipref" /><command moreinfo="none">gzip</command></term>
	  <listitem>
	  <indexterm>
	    <primary>gzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gzip</secondary>
	  </indexterm>

	    <para>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <command>compress</command>. The corresponding decompression
	      command is <command>gunzip</command>, which is the equivalent of
	      <command>gzip -d</command>.</para>

            <note><para>The <option>-c</option> option sends the output of
	      <command>gzip</command> to <filename>stdout</filename>. This
	      is useful when <link linkend="piperef">piping</link> to other
	      commands.</para></note>

	    <para><anchor xml:id="zcatref" /></para>
	    <para>The <command>zcat</command> filter decompresses a
	      <firstterm>gzipped</firstterm> file to
	      <filename>stdout</filename>, as possible input to a pipe or
	      redirection. This is, in effect, a <command>cat</command>
	      command that works on compressed files (including files
	      processed with the older <link linkend="compressref">compress</link>
	      utility). The <command>zcat</command> command is equivalent to
	      <command>gzip -dc</command>.</para>


	    <caution><para>On some commercial UNIX systems, <command>zcat</command>
	      is a synonym for <command>uncompress -c</command>,
	      and will not work on <firstterm>gzipped</firstterm>
	      files.</para></caution>

	      <para>See also <xref linkend="ex14" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="bzipref" /><command moreinfo="none">bzip2</command></term>
	  <listitem>
	  <indexterm>
	    <primary>bzip2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bzip2</secondary>
	  </indexterm>

	    <para>An alternate compression utility, usually more efficient
	      (but slower) than <command>gzip</command>, especially on
	      large files. The corresponding decompression command is
	      <command>bunzip2</command>.</para>

	    <para>Similar to the <command>zcat</command> command,
	      <command>bzcat</command> decompresses a
	      <firstterm>bzipped2-ed</firstterm> file to
	      <filename>stdout</filename>.</para>

	    <note><para>Newer versions of <link linkend="tarref">tar</link> have been patched with
	      <command>bzip2</command> support.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="compressref" /><command moreinfo="none">compress</command></term>
	  <term><anchor xml:id="uncompressref" /><command moreinfo="none">uncompress</command></term>
	  <listitem>
	  <indexterm>
	    <primary>compress</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>compress</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>uncompress</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uncompress</secondary>
	  </indexterm>
	    <para>This is an older, proprietary compression
	      utility found in commercial UNIX distributions. The
	      more efficient <command>gzip</command> has largely
	      replaced it. Linux distributions generally include a
	      <command>compress</command> workalike for compatibility,
	      although <command>gunzip</command> can unarchive files
	      treated with <command>compress</command>.</para>

	    <tip><para>The <command>znew</command> command transforms
	      <firstterm>compressed</firstterm> files into
	      <firstterm>gzipped</firstterm> ones.</para></tip>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sqref" /><command moreinfo="none">sq</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sq</secondary>
	  </indexterm>

	    <para>Yet another compression (<command>sq</command>ueeze)
	      utility, a filter that works only on sorted
	      <link linkend="asciidef">ASCII</link> word lists. It
	      uses the standard invocation syntax for a filter,
	      <command>sq &lt; input-file &gt; output-file</command>.
	      Fast, but not nearly as efficient as <link linkend="gzipref">gzip</link>.  The corresponding
	      uncompression filter is <command>unsq</command>, invoked
	      like <command>sq</command>.</para>

	      <tip><para>The output of <command>sq</command> may be
	        piped to <command>gzip</command> for further
		compression.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="zipref" /><command moreinfo="none">zip</command></term>
	  <term><command moreinfo="none">unzip</command></term>
	  <listitem>
	  <indexterm>
	    <primary>zip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pkzip.exe</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unzip</secondary>
	  </indexterm>
	    <para>Cross-platform file archiving and compression utility
	      compatible with DOS <firstterm>pkzip.exe</firstterm>.
	      <quote>Zipped</quote> archives seem to be a more
	      common medium of file exchange on the Internet than
	      <quote>tarballs.</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="unarcref" /><command moreinfo="none">unarc</command></term>
	  <term><command moreinfo="none">unarj</command></term>
	  <term><command moreinfo="none">unrar</command></term>
	  <listitem>
	  <indexterm>
	    <primary>unarc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arc.exe</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unarj</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arj.exe</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unrar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rar.exe</secondary>
	  </indexterm>
	    <para>These Linux utilities permit unpacking archives
	      compressed with the DOS <firstterm>arc.exe</firstterm>,
	      <firstterm>arj.exe</firstterm>, and
	      <firstterm>rar.exe</firstterm> programs.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lzmaref" /><command moreinfo="none">lzma</command></term>
	  <term><command moreinfo="none">unlzma</command></term>
	  <term><command moreinfo="none">lzcat</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lzma</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lzma</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unlzma</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unlzma</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lzcat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lzcat</secondary>
	  </indexterm>
	    <para>Highly efficient Lempel-Ziv-Markov compression.
	      The syntax of <firstterm>lzma</firstterm> is similar to
              that of <firstterm>gzip</firstterm>. The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.7-zip.org/sdk.html">7-zip Website</link>
              has more information.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="xzref" /><command moreinfo="none">xz</command></term>
	  <term><command moreinfo="none">unxz</command></term>
	  <term><command moreinfo="none">xzcat</command></term>
	  <listitem>
	  <indexterm>
	    <primary>xz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xz</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unxz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unxz</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>xzcat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xzcat</secondary>
	  </indexterm>
	    <para>A new high-efficiency compression tool, backward compatible
	      with <firstterm>lzma</firstterm>, and with an invocation
	      syntax similar to <firstterm>gzip</firstterm>. For
	      more information, see the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://en.wikipedia.org/wiki/Xz">Wikipedia
	      entry</link>.</para>

	  </listitem>
	</varlistentry>


      </variablelist>


      <variablelist xml:id="fainformation">
        <title><anchor xml:id="fainformation1" />File Information</title>

	<varlistentry>
	  <term><anchor xml:id="fileref" /><command moreinfo="none">file</command></term>
	  <listitem>
	  <indexterm>
	    <primary>file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file</secondary>
	  </indexterm>

	    <para>A utility for identifying file types. The command
	      <userinput>file file-name</userinput> will return a
	      file specification for <filename>file-name</filename>,
	      such as <computeroutput>ascii text</computeroutput> or
	      <computeroutput>data</computeroutput>. It references
	      the <link linkend="magnumref">magic numbers</link>
	      found in <filename>/usr/share/magic</filename>,
	      <filename>/etc/magic</filename>, or
	      <filename>/usr/lib/magic</filename>, depending on the
	      Linux/UNIX distribution.</para>

	    <para>The <option>-f</option> option causes
	      <command>file</command> to run in <link linkend="batchprocref">batch</link> mode, to read from
	      a designated file a list of filenames to analyze. The
	      <option>-z</option> option, when used on a compressed
	      target file, forces an attempt to analyze the uncompressed
	      file type.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>file test.tar.gz</userinput>
<computeroutput>test.tar.gz: gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix</computeroutput>

<prompt>bash </prompt><userinput>file -z test.tar.gz</userinput>
<computeroutput>test.tar.gz: GNU tar archive (gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix)</computeroutput>
	      </screen>
	    </para>

	    <para>
	      <programlisting># Find sh and Bash scripts in a given directory:

DIRECTORY=/usr/local/bin
KEYWORD=Bourne
# Bourne and Bourne-Again shell scripts

file $DIRECTORY/* | fgrep $KEYWORD

# Output:

# /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
# /usr/local/bin/burnit:           Bourne-Again shell script text executable
# /usr/local/bin/cassette.sh:      Bourne shell script text executable
# /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
# . . .</programlisting>
	    </para>

	    <example xml:id="stripc">
	      <title>Stripping comments from C program files</title>
	      <programlisting>#!/bin/bash
# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.

E_NOARGS=0
E_ARGERROR=66
E_WRONG_FILE_TYPE=67

if [ $# -eq "$E_NOARGS" ]
then
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2 # Error message to stderr.
  exit $E_ARGERROR
fi  

# Test for correct file type.
type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
# "file $1" echoes file type . . .
# Then awk removes the first field, the filename . . .
# Then the result is fed into the variable "type."
correct_type="ASCII C program text"

if [ "$type" != "$correct_type" ]
then
  echo
  echo "This script works on C program files only."
  echo
  exit $E_WRONG_FILE_TYPE
fi  


# Rather cryptic sed script:
#--------
sed '
/^\/\*/d
/.*\*\//d
' $1
#--------
# Easy to understand if you take several hours to learn sed fundamentals.


#  Need to add one more line to the sed script to deal with
#+ case where line of code has a comment following it on same line.
#  This is left as a non-trivial exercise.

#  Also, the above code deletes non-comment lines with a "*/" . . .
#+ not a desirable result.

exit 0


# ----------------------------------------------------------------
# Code below this line will not execute because of 'exit 0' above.

# Stephane Chazelas suggests the following alternative:

usage() {
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2
  exit 1
}

WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
[[ $# -eq 1 ]] || usage
case `file "$1"` in
  *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
     | tr '\377\n' '\n\377' \
     | sed -ne 'p;n' \
     | tr -d '\n' | tr '\377' '\n';;
  *) usage;;
esac

#  This is still fooled by things like:
#  printf("/*");
#  or
#  /*  /* buggy embedded comment */
#
#  To handle all special cases (comments in strings, comments in string
#+ where there is a \", \\" ...),
#+ the only way is to write a C parser (using lex or yacc perhaps?).

exit 0
</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="whichref" /><command moreinfo="none">which</command></term>
	  <listitem>
	  <indexterm>
	    <primary>which</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>which</secondary>
	  </indexterm>
	    <para><command>which command</command> gives the full path
	      to <quote>command.</quote> This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</para>
	    <para><userinput>$bash which rm</userinput>
<screen><computeroutput>/usr/bin/rm</computeroutput></screen>
	  </para>
            <para>For an interesting use of this command, see <xref linkend="horserace" />.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="whereisref" /><command moreinfo="none">whereis</command></term>
	  <listitem>
	  <indexterm>
	    <primary>whereis</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whereis</secondary>
	  </indexterm>
	    <para>Similar to <command>which</command>, above,
	      <command>whereis command</command> gives the
	      full path to <quote>command,</quote> but also to its
	      <link linkend="manref">manpage</link>.</para>
	    <para><userinput>$bash whereis rm</userinput>
<screen><computeroutput>rm: /bin/rm /usr/share/man/man1/rm.1.bz2</computeroutput></screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="whatisref" /><command moreinfo="none">whatis</command></term>
	  <listitem>
	  <indexterm>
	    <primary>whatis</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whatis</secondary>
	  </indexterm>
	    <para><command>whatis command</command> looks up
	      <quote>command</quote> in the
	      <replaceable>whatis</replaceable> database. This is useful
	      for identifying system commands and important configuration
	      files. Consider it a simplified <command>man</command>
	      command.</para>
	    <para><userinput>$bash whatis whatis</userinput>
<screen><computeroutput>whatis               (1)  - search the whatis database for complete words</computeroutput></screen>
	  </para>
	  
      <example xml:id="what">
	<title>Exploring <filename class="directory">/usr/X11R6/bin</filename></title>
	<programlisting>#!/bin/bash

# What are all those mysterious binaries in /usr/X11R6/bin?

DIRECTORY="/usr/X11R6/bin"
# Try also "/bin", "/usr/bin", "/usr/local/bin", etc.

for file in $DIRECTORY/*
do
  whatis `basename $file`   # Echoes info about the binary.
done

exit 0

#  Note: For this to work, you must create a "whatis" database
#+ with /usr/sbin/makewhatis.
#  You may wish to redirect output of this script, like so:
#    ./what.sh &gt;&gt;whatis.db
#  or view it a page at a time on stdout,
#    ./what.sh | less
</programlisting>
      </example>

            <para>See also <xref linkend="fileinfo" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="vdirref" /><command moreinfo="none">vdir</command></term>
	  <listitem>
	  <indexterm>
	    <primary>vdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	    <para>Show a detailed directory listing. The effect is similar to
	      <link linkend="lsref">ls -lb</link>.</para>
	    <para>This is one of the GNU
	    <firstterm>fileutils</firstterm>.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>vdir</userinput>
<computeroutput>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</computeroutput>

<prompt>bash </prompt><userinput>ls -l</userinput>
<computeroutput>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="locateref" /><command moreinfo="none">locate</command></term>
	  <term><anchor xml:id="slocateref" /><command moreinfo="none">slocate</command></term>
	  <listitem>
	  <indexterm>
	    <primary>locate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>locate</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slocate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>slocate</secondary>
	  </indexterm>
	    <para>The <command>locate</command> command searches for
	      files using a database stored for just that purpose. The
	      <command>slocate</command> command is the secure version of
	      <command>locate</command> (which may be aliased to
	      <command>slocate</command>).</para>
	    <para><userinput>$bash locate hickson</userinput>
<screen><computeroutput>/usr/lib/xephem/catalogs/hickson.edb</computeroutput></screen></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="getfaclref" /><command moreinfo="none">getfacl</command></term>
	  <term><anchor xml:id="setfaclref" /><command moreinfo="none">setfacl</command></term>
	  <listitem>
	  <indexterm>
	    <primary>getfacl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getfacl</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>setfacl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>setfacl</secondary>
	  </indexterm>
	    <para>These commands <firstterm>retrieve</firstterm> or
              <firstterm>set</firstterm> the <command>f</command>ile
              <command>a</command>ccess <command>c</command>ontrol
              <command>l</command>ist -- the <firstterm>owner</firstterm>,
	      <firstterm>group</firstterm>, and file permissions.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>getfacl *</userinput>
<computeroutput># file: test1.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--

 # file: test2.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--</computeroutput>
 

 
<prompt>bash$ </prompt><userinput>setfacl -m u:bozo:rw yearly_budget.csv</userinput>
<prompt>bash$ </prompt><userinput>getfacl yearly_budget.csv</userinput>
<computeroutput># file: yearly_budget.csv
 # owner: accountant
 # group: budgetgrp
 user::rw-
 user:bozo:rw-
 user:accountant:rw-
 group::rw-
 mask::rw-
 other::r--</computeroutput>
	      </screen>
	    </para>


	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="readlinkref" /><command moreinfo="none">readlink</command></term>
	  <listitem>
	  <indexterm>
	    <primary>readlink</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>link</secondary>
	  </indexterm>
	    <para>Disclose the file that a symbolic link points to.</para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>readlink /usr/bin/awk</userinput>
<computeroutput>../../bin/gawk</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="stringsref" /><command moreinfo="none">strings</command></term>
	  <listitem>
	  <indexterm>
	    <primary>strings</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>strings</secondary>
	  </indexterm>
	    <para>Use the <command>strings</command> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<userinput>strings image-file | more</userinput> might
	      show something like <firstterm>JFIF</firstterm>,
	      which would identify the file as a <firstterm>jpeg</firstterm>
	      graphic). In a script, you would probably
	      parse the output of <command>strings</command>
	      with <link linkend="grepref">grep</link> or <link linkend="sedref">sed</link>. See <xref linkend="bingrep" />
	      and <xref linkend="findstring" />.</para>

	    <example xml:id="wstrings">
	      <title>An <quote>improved</quote>
	      <firstterm>strings</firstterm> command</title>
	      <programlisting>#!/bin/bash
# wstrings.sh: "word-strings" (enhanced "strings" command)
#
#  This script filters the output of "strings" by checking it
#+ against a standard word list file.
#  This effectively eliminates gibberish and noise,
#+ and outputs only recognized words.

# ===========================================================
#                 Standard Check for Script Argument(s)
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne $ARGS ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ ! -f "$1" ]                      # Check if file exists.
then
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
fi
# ===========================================================


MINSTRLEN=3                           #  Minimum string length.
WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
#  May specify a different word list file
#+ of one-word-per-line format.
#  For example, the "yawl" word-list package,
#  http://bash.deta.in/yawl-0.3.2.tar.gz


wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
       tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`

# Translate output of 'strings' command with multiple passes of 'tr'.
#  "tr A-Z a-z"  converts to lowercase.
#  "tr '[:space:]'"  converts whitespace characters to Z's.
#  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
#+ and squeezes multiple consecutive Z's.
#  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
#+ and squeezes multiple consecutive Z's,
#+ which gets rid of all the weird characters that the previous
#+ translation failed to deal with.
#  Finally, "tr Z ' '" converts all those Z's to whitespace,
#+ which will be seen as word separators in the loop below.

#  ***********************************************************************
#  Note the technique of feeding/piping the output of 'tr' back to itself,
#+ but with different arguments and/or options on each successive pass.
#  ***********************************************************************


for word in $wlist                    #  Important:
                                      #  $wlist must not be quoted here.
                                      # "$wlist" does not work.
                                      #  Why not?
do
  strlen=${#word}                     #  String length.
  if [ "$strlen" -lt "$MINSTRLEN" ]   #  Skip over short strings.
  then
    continue
  fi

  grep -Fw $word "$WORDFILE"          #   Match whole words only.
#      ^^^                            #  "Fixed strings" and
                                      #+ "whole words" options. 
done  

exit $?
</programlisting>
	    </example>
	  </listitem>

	</varlistentry>

      </variablelist>

      <variablelist xml:id="comparisonn">
        <title><anchor xml:id="comparisonn1" />Comparison</title>

	<varlistentry>
	  <term><anchor xml:id="diffref" /><command moreinfo="none">diff</command></term>
	  <term><command moreinfo="none">patch</command></term>
	  <listitem>
	  <indexterm>
	    <primary>diff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>patch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>patch</secondary>
	  </indexterm>
	    <para><command>diff</command>: flexible file comparison
	      utility. It compares the target files line-by-line
	      sequentially.  In some applications, such as comparing
	      word dictionaries, it may be helpful to filter the
	      files through <link linkend="sortref">sort</link>
	      and <command>uniq</command> before piping them
	      to <command>diff</command>. <userinput>diff file-1
	      file-2</userinput> outputs the lines in the files that
	      differ, with carets showing which file each particular
	      line belongs to.</para>

	  <para>The <option>--side-by-side</option> option to
	    <command>diff</command> outputs each compared file, line by
	    line, in separate columns, with non-matching lines marked. The
	    <option>-c</option> and <option>-u</option> options likewise
	    make the output of the command easier to interpret.</para>

          <para>There are available various fancy frontends for
	    <command>diff</command>, such as <command>sdiff</command>,
	    <command>wdiff</command>, <command>xdiff</command>, and
	    <command>mgdiff</command>. </para>

            <tip><para><anchor xml:id="differr2" />The <command>diff</command>
              command returns an exit status of <errorcode>0</errorcode>
              if the compared files are identical, and
              <errorcode>1</errorcode> if they differ (or
              <errorcode>2</errorcode> when <firstterm>binary</firstterm>
              files are being compared).  This permits use of
              <command>diff</command> in a test construct within a shell
              script (see below).</para></tip>


	    <para>A common use for <command>diff</command> is generating
	      difference files to be used with <command>patch</command>
	      The <option>-e</option> option outputs files suitable
	      for <command>ed</command> or <command>ex</command>
	      scripts.</para>


	    <para><anchor xml:id="patchref" /></para>
	    <para><command>patch</command>: flexible versioning
	      utility. Given a difference file generated by
	      <command>diff</command>, <command>patch</command> can
	      upgrade a previous version of a package to a newer version.
	      It is much more convenient to distribute a relatively
	      small <quote>diff</quote> file than the entire body of a
	      newly revised package. Kernel <quote>patches</quote> have
	      become the preferred method of distributing the frequent
	      releases of the Linux kernel.</para>

	    <para><programlisting>patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file'
# and applies them to the files referenced therein.
# This upgrades to a newer version of the package.</programlisting></para>

	    <para>Patching the kernel:</para>
            <para><programlisting>cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</programlisting></para>



            <note>
	    <para>The <command>diff</command> command can also
	      recursively compare directories (for the filenames
	      present).</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>diff -r ~/notes1 ~/notes2</userinput>
<computeroutput>Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</computeroutput>
	      </screen>
	    </para>
            </note>

	    <tip>
	    <para><anchor xml:id="zdiffref" /></para>
	    <para>Use <command>zdiff</command> to compare
	       <firstterm>gzipped</firstterm> files.</para>
	     </tip>

	    <tip>
	    <para><anchor xml:id="diffstatref" /></para>
	    <para>Use <command>diffstat</command> to create
	       a histogram (point-distribution graph) of output from
	       <command>diff</command>.</para>
	     </tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="diff3ref" /><command moreinfo="none">diff3</command></term>
	  <term><command moreinfo="none">merge</command></term>
	  <listitem>
	  <indexterm>
	    <primary>diff3</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff3</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>merge</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>merge</secondary>
	  </indexterm>

	    <para>An extended version of <command>diff</command> that compares
	      three files at a time. This command returns an exit value
	      of 0 upon successful execution, but unfortunately this gives
	      no information about the results of the comparison.</para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>diff3 file-1 file-2 file-3</userinput>
<computeroutput>====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</computeroutput>
	      </screen>
	      </para>

	    <para><anchor xml:id="mergeref" />The <command>merge</command>
	      (3-way file merge) command is an interesting adjunct to
	      <firstterm>diff3</firstterm>. Its syntax is
	      <userinput>merge Mergefile file1 file2</userinput>.
	      The result is to output to <filename>Mergefile</filename>
	      the changes that lead from <filename>file1</filename>
	      to <filename>file2</filename>. Consider this command
	      a stripped-down version of <firstterm>patch</firstterm>.</para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sdiffref" /><command moreinfo="none">sdiff</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sdiff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sdiff</secondary>
	  </indexterm>
	    <para>Compare and/or edit two files in order to merge
	      them into an output file. Because of its interactive nature,
	      this command would find little use in a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="cmpref" /><command moreinfo="none">cmp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cmp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cmp</secondary>
	  </indexterm>
	    <para>The <command>cmp</command> command is a simpler version of
	      <command>diff</command>, above. Whereas <command>diff</command>
	      reports the differences between two files,
	      <command>cmp</command> merely shows at what point they
	      differ.</para>

	  <note><para>Like <command>diff</command>, <command>cmp</command>
	    returns an exit status of 0 if the compared files are
	    identical, and 1 if they differ. This permits use in a test
	    construct within a shell script.</para></note>

	    <example xml:id="filecomp">
	      <title>Using <firstterm>cmp</firstterm> to compare two files
	        within a script.</title>
	      <programlisting>#!/bin/bash
# file-comparison.sh

ARGS=2  # Two args to script expected.
E_BADARGS=85
E_UNREADABLE=86

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` file1 file2"
  exit $E_BADARGS
fi

if [[ ! -r "$1" || ! -r "$2" ]]
then
  echo "Both files to be compared must exist and be readable."
  exit $E_UNREADABLE
fi

cmp $1 $2 &amp;&gt; /dev/null
#   Redirection to /dev/null buries the output of the "cmp" command.
#   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
#   Thank you  Anders Gustavsson for pointing this out.
#
#  Also works with 'diff', i.e.,
#+ diff $1 $2 &amp;&gt; /dev/null

if [ $? -eq 0 ]         # Test exit status of "cmp" command.
then
  echo "File \"$1\" is identical to file \"$2\"."
else  
  echo "File \"$1\" differs from file \"$2\"."
fi

exit 0
</programlisting>
	    </example>	    	   

	    <tip><para>Use <command>zcmp</command> on
	      <firstterm>gzipped</firstterm> files.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="commref" /><command moreinfo="none">comm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>comm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>comm</secondary>
	  </indexterm>
	    <para>Versatile file comparison utility. The files must be
	      sorted for this to be useful.</para>

	    <para><command>comm
		<replaceable>-options</replaceable>
		<replaceable>first-file</replaceable>
		<replaceable>second-file</replaceable></command></para>

	    <para><userinput>comm file-1 file-2</userinput> outputs three columns:
	      <itemizedlist>
		<listitem><para>column 1 = lines unique to <filename>file-1</filename></para>
		</listitem>
		
		<listitem><para>column 2 = lines unique to <filename>file-2</filename></para>
		</listitem>
		
		<listitem><para>column 3 = lines common to both.</para>
		</listitem>
	      </itemizedlist></para>
	      
	    <para>The options allow suppressing output of one or more columns.
	      <itemizedlist>
		<listitem><para><option>-1</option> suppresses column
		    <literal>1</literal></para>
		</listitem>
		<listitem><para><option>-2</option> suppresses column
		    <literal>2</literal></para>
		</listitem>
		<listitem><para><option>-3</option> suppresses column
		    <literal>3</literal></para>
		</listitem>
		<listitem><para><option>-12</option> suppresses both columns
		    <literal>1</literal> and <literal>2</literal>, etc.</para>
		</listitem>
		</itemizedlist>
	    </para>

	    <para>This command is useful for comparing
	      <quote>dictionaries</quote> or <firstterm>word
	      lists</firstterm> -- sorted text files with one word per
	      line.</para>

	  </listitem>
	</varlistentry>


      </variablelist>

      <variablelist xml:id="fautils">
        <title><anchor xml:id="fautils1" />Utilities</title>

	<varlistentry>
	  <term><anchor xml:id="basenameref" /><command moreinfo="none">basename</command></term>
	  <listitem>
	  <indexterm>
	    <primary>basename</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>basename</secondary>
	  </indexterm>
            <para>Strips the path information from a file name, printing
	      only the file name. The construction  <userinput>basename
		$0</userinput> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <quote>usage</quote> messages if, 
	      for example a script is called with missing arguments:
              <programlisting>echo "Usage: `basename $0` arg1 arg2 ... argn"</programlisting>
	    </para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><anchor xml:id="dirnameref" /><command moreinfo="none">dirname</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dirname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirname</secondary>
	  </indexterm>
           <para>Strips the <command>basename</command> from
	    a filename, printing only the path information.</para>
	    <note>
	      <para><command>basename</command> and <command>dirname</command>
		can operate on any arbitrary string. The argument
		does not need to refer to an existing file, or
		even be a filename for that matter (see <xref linkend="daysbetween" />).</para>
	    </note>
	    
	    <example xml:id="ex35">
	      <title><firstterm>basename</firstterm> and
	      <firstterm>dirname</firstterm></title>
	      <programlisting>#!/bin/bash

address=/home/bozo/daily-journal.txt

echo "Basename of /home/bozo/daily-journal.txt = `basename $address`"
echo "Dirname of /home/bozo/daily-journal.txt = `dirname $address`"
echo
echo "My own home is `basename ~/`."         # `basename ~` also works.
echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.

exit 0
</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="splitref" /><command moreinfo="none">split</command></term>
	  <term><anchor xml:id="csplitref" /><command moreinfo="none">csplit</command></term>
	  <listitem>
	  <indexterm>
	    <primary>split</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>split</secondary>
	  </indexterm>
	  <indexterm>
	  <primary>csplit</primary>
	  </indexterm>
	  <indexterm>
	  <primary>command</primary>
	  <secondary>csplit</secondary>
	  </indexterm>

	    <para>These are utilities for splitting a file into smaller
	      chunks. Their usual use is for splitting up large files
	      in order to back them up on floppies or preparatory to
	      e-mailing or uploading them.</para>

            <para>The <command>csplit</command> command splits a file
	      according to <firstterm>context</firstterm>, the split occuring
	      where patterns are matched.</para>

	    <example xml:id="splitcopy">
	      <title>A script that copies itself in sections</title>
	      <programlisting>#!/bin/bash
# splitcopy.sh

#  A script that splits itself into chunks,
#+ then reassembles the chunks into an exact copy
#+ of the original script.

CHUNKSIZE=4    #  Size of first chunk of split files.
OUTPREFIX=xx   #  csplit prefixes, by default,
               #+ files with "xx" ...

csplit "$0" "$CHUNKSIZE"

# Some comment lines for padding . . .
# Line 15
# Line 16
# Line 17
# Line 18
# Line 19
# Line 20

cat "$OUTPREFIX"* &gt; "$0.copy"  # Concatenate the chunks.
rm "$OUTPREFIX"*               # Get rid of the chunks.

exit $?
</programlisting>
	    </example>
	      
	  </listitem>
	</varlistentry>

      </variablelist>



      <variablelist xml:id="faencencr">
        <title><anchor xml:id="faencencr1" />Encoding and Encryption</title>

	<varlistentry>
	  <term><anchor xml:id="sumref" /><command moreinfo="none">sum</command></term>
	  <term><anchor xml:id="cksumref" /><command moreinfo="none">cksum</command></term>
	  <term><anchor xml:id="md5sumref" /><command moreinfo="none">md5sum</command></term>
	  <term><anchor xml:id="sha1sumref" /><command moreinfo="none">sha1sum</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cksum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cksum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>md5sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>md5sum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sha1sum</secondary>
	  </indexterm>
            <para><anchor xml:id="checksumref" />These are utilities for
              generating <firstterm>checksums</firstterm>. A
	      <firstterm>checksum</firstterm> is a number

		<footnote><para>The checksum may be expressed as a
		<firstterm>hexadecimal</firstterm> number, or to some
		other base.</para></footnote>

              mathematically calculated from the contents of a file,
              for the purpose of checking its integrity. A script might
              refer to a list of checksums for security purposes, such
              as ensuring that the contents of key system files have not
              been altered or corrupted. For security applications, use
              the <command>md5sum</command> (<command>m</command>essage
              <command>d</command>igest <command>5</command>
              check<command>sum</command>) command, or better yet, the
              newer <command>sha1sum</command> (Secure Hash Algorithm).

	        <footnote><para>For even <emphasis>better</emphasis>
		  security, use the <firstterm>sha256sum</firstterm>,
		  <firstterm>sha512</firstterm>, and
                  <firstterm>sha1pass</firstterm>
                  commands.</para></footnote>
            </para>


	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cksum /boot/vmlinuz</userinput>
<computeroutput>1670054224 804083 /boot/vmlinuz</computeroutput>

<prompt>bash$ </prompt><userinput>echo -n "Top Secret" | cksum</userinput>
<computeroutput>3391003827 10</computeroutput>



<prompt>bash$ </prompt><userinput>md5sum /boot/vmlinuz</userinput>
<computeroutput>0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</computeroutput>

<prompt>bash$ </prompt><userinput>echo -n "Top Secret" | md5sum</userinput>
<computeroutput>8babc97a6f62a4649716f4df8d61728f  -</computeroutput>
	      </screen>
	  </para>


	  <note>
	  <para>The <command>cksum</command> command shows the size,
	    in bytes, of its target, whether file or
	    <filename>stdout</filename>.</para>
	  <para>The <command>md5sum</command> and
	    <command>sha1sum</command> commands display a
	    <link linkend="dashref2">dash</link> when they receive their input from
	    <filename>stdout</filename>.</para>
	    </note>

	    <example xml:id="fileintegrity">
	      <title>Checking file integrity</title>
	      <programlisting>#!/bin/bash
# file-integrity.sh: Checking whether files in a given directory
#                    have been tampered with.

E_DIR_NOMATCH=80
E_BAD_DBFILE=81

dbfile=File_record.md5
# Filename for storing records (database file).


set_up_database ()
{
  echo ""$directory"" &gt; "$dbfile"
  # Write directory name to first line of file.
  md5sum "$directory"/* &gt;&gt; "$dbfile"
  # Append md5 checksums and filenames.
}

check_database ()
{
  local n=0
  local filename
  local checksum

  # ------------------------------------------- #
  #  This file check should be unnecessary,
  #+ but better safe than sorry.

  if [ ! -r "$dbfile" ]
  then
    echo "Unable to read checksum database file!"
    exit $E_BAD_DBFILE
  fi
  # ------------------------------------------- #

  while read record[n]
  do

    directory_checked="${record[0]}"
    if [ "$directory_checked" != "$directory" ]
    then
      echo "Directories do not match up!"
      # Tried to use file for a different directory.
      exit $E_DIR_NOMATCH
    fi

    if [ "$n" -gt 0 ]   # Not directory name.
    then
      filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
      #  md5sum writes records backwards,
      #+ checksum first, then filename.
      checksum[n]=$( md5sum "${filename[n]}" )


      if [ "${record[n]}" = "${checksum[n]}" ]
      then
        echo "${filename[n]} unchanged."

        elif [ "`basename ${filename[n]}`" != "$dbfile" ]
               #  Skip over checksum database file,
               #+ as it will change with each invocation of script.
               #  ---
               #  This unfortunately means that when running
               #+ this script on $PWD, tampering with the
               #+ checksum database file will not be detected.
               #  Exercise: Fix this.
        then
          echo "${filename[n]} : CHECKSUM ERROR!"
        # File has been changed since last checked.
        fi

      fi



    let "n+=1"
  done &lt;"$dbfile"       # Read from checksum database file. 

}  

# =================================================== #
# main ()

if [ -z  "$1" ]
then
  directory="$PWD"      #  If not specified,
else                    #+ use current working directory.
  directory="$1"
fi  

clear                   # Clear screen.
echo " Running file integrity check on $directory"
echo

# ------------------------------------------------------------------ #
  if [ ! -r "$dbfile" ] # Need to create database file?
  then
    echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
    set_up_database
  fi  
# ------------------------------------------------------------------ #

check_database          # Do the actual work.

echo 

#  You may wish to redirect the stdout of this script to a file,
#+ especially if the directory checked has many files in it.

exit 0

#  For a much more thorough file integrity check,
#+ consider the "Tripwire" package,
#+ http://sourceforge.net/projects/tripwire/.
</programlisting>
	    </example>

	  <para>Also see <xref linkend="directoryinfo" />, <xref linkend="horserace" />, and <xref linkend="randstring" /> for
	    creative uses of the <command>md5sum</command> command.</para>

          <note>

	  <para>
	    There have been reports that the 128-bit
	    <command>md5sum</command> can be cracked, so the more secure
	    160-bit <command>sha1sum</command> is a welcome new addition
	    to the checksum toolkit.
          </para>

	      <screen><prompt>bash$ </prompt><userinput>md5sum testfile</userinput>
<computeroutput>e181e2c8720c60522c4c4c981108e367  testfile</computeroutput>


<prompt>bash$ </prompt><userinput>sha1sum testfile</userinput>
<computeroutput>5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</computeroutput>
	      </screen></note>

	  <para>Security consultants have demonstrated that even
	      <command>sha1sum</command> can be compromised. Fortunately,
	      newer Linux distros include longer bit-length
	      <command>sha224sum</command>,
	      <command>sha256sum</command>,
	      <command>sha384sum</command>, and
	      <command>sha512sum</command> commands.</para>


	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor xml:id="uuencoderef" /><command moreinfo="none">uuencode</command></term>
	  <listitem>
	  <indexterm>
	    <primary>uuencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uuencode</secondary>
	  </indexterm>
	    <para>This utility encodes binary files (images, sound files,
		    compressed files, etc.) into <link linkend="asciidef">ASCII</link> characters, making
		    them suitable for transmission in the body of an
		    e-mail message or in a newsgroup posting. This is
		    especially useful where MIME (multimedia) encoding
		    is not available.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="uudecoderef" /><command moreinfo="none">uudecode</command></term>
	  <listitem>
	  <indexterm>
	    <primary>uudecode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uudecode</secondary>
	  </indexterm>
	    <para>This reverses the encoding, decoding
	      <firstterm>uuencoded</firstterm> files back into the
	      original binaries.</para>

	    <example xml:id="ex52">
	      <title>Uudecoding encoded files</title>
	      <programlisting>#!/bin/bash
# Uudecodes all uuencoded files in current working directory.

lines=35        # Allow 35 lines for the header (very generous).

for File in *   # Test all the files in $PWD.
do
  search1=`head -n $lines $File | grep begin | wc -w`
  search2=`tail -n $lines $File | grep end | wc -w`
  #  Uuencoded files have a "begin" near the beginning,
  #+ and an "end" near the end.
  if [ "$search1" -gt 0 ]
  then
    if [ "$search2" -gt 0 ]
    then
      echo "uudecoding - $File -"
      uudecode $File
    fi  
  fi
done  

#  Note that running this script upon itself fools it
#+ into thinking it is a uuencoded file,
#+ because it contains both "begin" and "end".

#  Exercise:
#  --------
#  Modify this script to check each file for a newsgroup header,
#+ and skip to next if not found.

exit 0
</programlisting>
	    </example>	    	   

	  <tip><para>The <link linkend="foldref">fold -s</link> command
	    may be useful (possibly in a pipe) to process long uudecoded
	    text messages downloaded from Usenet newsgroups.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mimencoderef" /><command moreinfo="none">mimencode</command></term>
	  <term><anchor xml:id="mmencoderef" /><command moreinfo="none">mmencode</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mimencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mime</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>mmencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encode</secondary>
	  </indexterm>
	    <para>The <command>mimencode</command> and
	      <command>mmencode</command> commands process
	      multimedia-encoded e-mail attachments. Although
	      <firstterm>mail user agents</firstterm> (such as
	      <firstterm>pine</firstterm> or <firstterm>kmail</firstterm>)
	      normally handle this automatically, these particular
	      utilities permit manipulating such attachments manually from
	      the command-line or in <link linkend="batchprocref">batch
	      processing mode</link> by means of a shell script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="cryptref" /><command moreinfo="none">crypt</command></term>
	  <listitem>
	  <indexterm>
	    <primary>crypt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>crypt</secondary>
	  </indexterm>
	    <para>At one time, this was the standard UNIX file encryption
	      utility.

              <footnote><para>This is a symmetric block cipher, used to
		encrypt files on a single system or local network,
		as opposed to the <firstterm>public key</firstterm>
		cipher class, of which <firstterm>pgp</firstterm> is a
		well-known example.</para></footnote>

	      Politically-motivated government regulations
	      prohibiting the export of encryption software resulted
	      in the disappearance of <command>crypt</command>
	      from much of the UNIX world, and it is still
	      missing from most Linux distributions. Fortunately,
	      programmers have come up with a number of decent
	      alternatives to it, among them the author's very own <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz">cruft</link>
	      (see <xref linkend="encryptedpw" />).  </para>

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor xml:id="opensslref" /><command moreinfo="none">openssl</command></term>
	  <listitem>
	  <indexterm>
	    <primary>openssl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>SSL</secondary>
	  </indexterm>
           <para>This is an Open Source implementation of
             <firstterm>Secure Sockets Layer</firstterm> encryption.

	     <programlisting># To encrypt a file:
openssl aes-128-ecb -salt -in file.txt -out file.encrypted \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.
#       aes-128-ecb      is the encryption method chosen.

# To decrypt an openssl-encrypted file:
openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.</programlisting></para>

	   <para><link linkend="piperef">Piping</link>
             <firstterm>openssl</firstterm> to/from <link linkend="tarref">tar</link> makes it possible to encrypt
             an entire directory tree.
     
            <programlisting># To encrypt a directory:

sourcedir="/home/bozo/testfiles"
encrfile="encr-dir.tar.gz"
password=my_secret_password

tar czvf - "$sourcedir" |
openssl des3 -salt -out "$encrfile" -pass pass:"$password"
#       ^^^^   Uses des3 encryption.
# Writes encrypted file "encr-dir.tar.gz" in current working directory.

# To decrypt the resulting tarball:
openssl des3 -d -salt -in "$encrfile" -pass pass:"$password" |
tar -xzv
# Decrypts and unpacks into current working directory.</programlisting>

           </para>

           <para>Of course, <firstterm>openssl</firstterm> has many other uses,
             such as obtaining signed <firstterm>certificates</firstterm>
	     for Web sites. See the <link linkend="inforef">info</link>
	     page.</para>

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor xml:id="shredref" /><command moreinfo="none">shred</command></term>
	  <listitem>
	  <indexterm>
	    <primary>shred</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure delete</secondary>
	  </indexterm>

	    <para>Securely erase a file by overwriting it multiple times with
	      random bit patterns before deleting it. This command has
	      the same effect as <xref linkend="blotout" />, but does it
	      in a more thorough and elegant manner.</para>

	    <para>This is one of the GNU
	    <firstterm>fileutils</firstterm>.</para>

	    <caution><para>Advanced forensic technology may still be able to
	      recover the contents of a file, even after application of
	      <command>shred</command>.</para></caution>
	    
	  </listitem>
	</varlistentry>


      </variablelist>


      <variablelist xml:id="famisc">
        <title><anchor xml:id="famisc1" />Miscellaneous</title>

	<varlistentry>
	  <term><anchor xml:id="mktempref" /><command moreinfo="none">mktemp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>temporary</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>filename</secondary>
	  </indexterm>
	    <para>Create a <firstterm>temporary file</firstterm>

	       <footnote><para>Creates a temporary
	       <firstterm>directory</firstterm> when invoked with the
	       <option>-d</option> option.</para></footnote>

	      with a <quote>unique</quote> filename. When invoked
	      from the command-line without additional arguments,
	      it creates a zero-length file in the <filename class="directory">/tmp</filename> directory.</para>


	  <para>
	      <screen><prompt>bash$ </prompt><userinput>mktemp</userinput>
<computeroutput>/tmp/tmp.zzsvql3154</computeroutput>
	      </screen>
	    </para>

	    <para><programlisting>PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ Need at least 6 placeholders
#+                              in the filename template.
#   If no filename template supplied,
#+ "tmp.XXXXXXXXXX" is the default.

echo "tempfile name = $tempfile"
# tempfile name = filename.QA2ZpY
#                 or something similar...

#  Creates a file of that name in the current working directory
#+ with 600 file permissions.
#  A "umask 177" is therefore unnecessary,
#+ but it's good programming practice nevertheless.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="makeref" /><command moreinfo="none">make</command></term>
	  <listitem>
	  <indexterm>
	    <primary>make</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>Makefile</secondary>
	  </indexterm>
	    <para><anchor xml:id="makefileref" /></para>
	    <para>Utility for building and compiling binary packages. 
	      This can also be used for any set of operations triggered
	      by incremental changes in source files.</para>
	    <para>The <firstterm>make</firstterm> command checks a
	    <filename>Makefile</filename>, a list of file dependencies and
	      operations to be carried out.</para>
            <para>The <firstterm>make</firstterm> utility is, in effect,
	      a powerful scripting language similar in many ways to
	      <firstterm>Bash</firstterm>, but with the capability of
	      recognizing <firstterm>dependencies</firstterm>. For in-depth
	      coverage of this useful tool set, see the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gnu.org/manual/manual.html">GNU software
	      documentation site</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="installref" /><command moreinfo="none">install</command></term>
	  <listitem>
	  <indexterm>
	    <primary>install</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>install</secondary>
	  </indexterm>
	    <para>Special purpose file copying command, similar to
	      <link linkend="cpref">cp</link>, but capable of
	      setting permissions and attributes of the copied
	      files. This command seems tailormade for installing
	      software packages, and as such it shows up frequently in
	      <filename>Makefiles</filename> (in the <replaceable>make
	      install :</replaceable> section). It could likewise prove
	      useful in installation scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="dos2unixref" /><command moreinfo="none">dos2unix</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dos2unix</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file converter</secondary>
	  </indexterm>
	    <para>This utility, written by Benjamin Lin and collaborators,
	      converts DOS-formatted text files (lines terminated by
	      CR-LF) to UNIX format (lines terminated by LF only),
	      and <link linkend="dosnewlines">vice-versa</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="ptxref" /><command moreinfo="none">ptx</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ptx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>index</secondary>
	  </indexterm>
	    <para>The <command>ptx [targetfile]</command> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="moreref" /><command moreinfo="none">more</command></term>
	  <term><anchor xml:id="lessref" /><command moreinfo="none">less</command></term>
	  <listitem>
	  <indexterm>
	    <primary>more</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>more</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>less</secondary>
	  </indexterm>

	    <para>Pagers that display a text file or stream to
	      <filename>stdout</filename>, one screenful at a time.
	      These may be used to filter the output of
	      <filename>stdout</filename> . . . or of a script.</para>

            <para>
	       An interesting application of <firstterm>more</firstterm>
	       is to <quote>test drive</quote> a command sequence,
	       to forestall potentially unpleasant consequences.
                 <programlisting>ls /home/bozo | awk '{print "rm -rf " $1}' | more
#                                            ^^^^
		 
# Testing the effect of the following (disastrous) command-line:
#      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
#      Hand off to the shell to execute . . .       ^^</programlisting>
            </para>

            <para>The <firstterm>less</firstterm> pager has the
	      interesting property of doing a formatted display of
	      <firstterm>man page</firstterm> source. See <xref linkend="maned" />.</para>

	  </listitem>
	</varlistentry>
       
       </variablelist>	

	</section> <!-- End File and Archiving Commands -->



      <section xml:id="communications">
        <title>Communications Commands</title>

	<para>Certain of the following commands find use in
	  network data transfer and analysis, as well as in
	  <link linkend="cspammers">chasing spammers</link>.</para>

       <variablelist xml:id="communinfo">
         <title><anchor xml:id="communinfo1" />Information and Statistics</title>

	<varlistentry>
	  <term><anchor xml:id="hostref" /><command moreinfo="none">host</command></term>
	  <listitem>
	  <indexterm>
	    <primary>host</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>host</secondary>
	  </indexterm>
	    <para>Searches for information about an Internet host by name or
	      IP address, using DNS.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>host surfacemail.com</userinput>
<computeroutput>surfacemail.com. has address 202.92.42.236</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="ipcalcref" /><command moreinfo="none">ipcalc</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ipcalc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ipcalc</secondary>
	  </indexterm>
	    <para>Displays IP information for a host.
	      With the <option>-h</option> option,
	      <command>ipcalc</command> does a reverse DNS lookup, finding
	      the name of the host (server) from the IP address.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>ipcalc -h 202.92.42.236</userinput>
<computeroutput>HOSTNAME=surfacemail.com</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="nslookupref" /><command moreinfo="none">nslookup</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nslookup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>name server lookup</secondary>
	  </indexterm>

	    <para>Do an Internet <quote>name server lookup</quote>
	      on a host by IP address. This is essentially equivalent
	      to <command>ipcalc -h</command> or <command>dig -x
	      </command>. The command may be run either interactively
	      or noninteractively, i.e., from within a script.</para>

	    <para>The <command>nslookup</command> command has allegedly
	      been <quote>deprecated,</quote> but it is still useful.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>nslookup -sil 66.97.104.180</userinput>
<computeroutput>nslookup kuhleersparnis.ch
 Server:         135.116.137.2
 Address:        135.116.137.2#53

 Non-authoritative answer:
 Name:   kuhleersparnis.ch</computeroutput>
	      </screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="digref" /><command moreinfo="none">dig</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain information groper</secondary>
	  </indexterm>

	    <para><command>D</command>omain <command>I</command>nformation
	      <command>G</command>roper. Similar to
	      <command>nslookup</command>, <firstterm>dig</firstterm> does
	      an Internet <firstterm>name server lookup</firstterm> on a host.
	      May be run from the command-line or from within a script.</para>

            <para>Some interesting options to <firstterm>dig</firstterm> are
	      <option>+time=N</option> for setting a query timeout to
	      <parameter>N</parameter> seconds, <option>+nofail</option> for
	      continuing to query servers until a reply is received, and
	      <option>-x</option> for doing a reverse address lookup.</para>

	    <para>Compare the output of <command>dig -x</command> with
	      <command>ipcalc -h</command> and
	      <command>nslookup</command>.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>dig -x 81.9.6.2</userinput>
<computeroutput>;; Got answer:
 ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 11649
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;2.6.9.81.in-addr.arpa.         IN      PTR

 ;; AUTHORITY SECTION:
 6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
 2002031705 900 600 86400 3600

 ;; Query time: 537 msec
 ;; SERVER: 135.116.137.2#53(135.116.137.2)
 ;; WHEN: Wed Jun 26 08:35:24 2002
 ;; MSG SIZE  rcvd: 91</computeroutput>
	      </screen>
	  </para>

	    <para><anchor xml:id="spamlookup_0" /></para>
	    <example xml:id="spamlookup">
	      <title>Finding out where to report a spammer</title>
	      <programlisting>#!/bin/bash
# spam-lookup.sh: Look up abuse contact to report a spammer.
# Thanks, Michael Zick.

# Check for command-line arg.
ARGCOUNT=1
E_WRONGARGS=85
if [ $# -ne "$ARGCOUNT" ]
then
  echo "Usage: `basename $0` domain-name"
  exit $E_WRONGARGS
fi


dig +short $1.contacts.abuse.net -c in -t txt
# Also try:
#     dig +nssearch $1
#     Tries to find "authoritative name servers" and display SOA records.

# The following also works:
#     whois -h whois.abuse.net $1
#           ^^ ^^^^^^^^^^^^^^^  Specify host.  
#     Can even lookup multiple spammers with this, i.e."
#     whois -h whois.abuse.net $spamdomain1 $spamdomain2 . . .


#  Exercise:
#  --------
#  Expand the functionality of this script
#+ so that it automatically e-mails a notification
#+ to the responsible ISP's contact address(es).
#  Hint: use the "mail" command.

exit $?

# spam-lookup.sh chinatietong.com
#                A known spam domain.

# "crnet_mgr@chinatietong.com"
# "crnet_tec@chinatietong.com"
# "postmaster@chinatietong.com"


#  For a more elaborate version of this script,
#+ see the SpamViz home page, http://www.spamviz.net/index.html.
</programlisting>
	    </example>

	    <para><anchor xml:id="isspammer_0" /></para>
	    <example xml:id="isspammer">
	      <title>Analyzing a spam domain</title>
	      <programlisting>#! /bin/bash
# is-spammer.sh: Identifying spam domains

# $Id$
# Above line is RCS ID info.
#
#  This is a simplified version of the "is_spammer.bash
#+ script in the Contributed Scripts appendix.

# is-spammer &lt;domain.name&gt;

# Uses an external program: 'dig'
# Tested with version: 9.2.4rc5

# Uses functions.
# Uses IFS to parse strings by assignment into arrays.
# And even does something useful: checks e-mail blacklists.

# Use the domain.name(s) from the text body:
# http://www.good_stuff.spammer.biz/just_ignore_everything_else
#                       ^^^^^^^^^^^
# Or the domain.name(s) from any e-mail address:
# Really_Good_Offer@spammer.biz
#
# as the only argument to this script.
#(PS: have your Inet connection running)
#
# So, to invoke this script in the above two instances:
#       is-spammer.sh spammer.biz


# Whitespace == :Space:Tab:Line Feed:Carriage Return:
WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'

# No Whitespace == Line Feed:Carriage Return
No_WSP=$'\x0A'$'\x0D'

# Field separator for dotted decimal ip addresses
ADR_IFS=${No_WSP}'.'

# Get the dns text resource record.
# get_txt &lt;error_code&gt; &lt;list_query&gt;
get_txt() {

    # Parse $1 by assignment at the dots.
    local -a dns
    IFS=$ADR_IFS
    dns=( $1 )
    IFS=$WSP_IFS
    if [ "${dns[0]}" == '127' ]
    then
        # See if there is a reason.
        echo $(dig +short $2 -t txt)
    fi
}

# Get the dns address resource record.
# chk_adr &lt;rev_dns&gt; &lt;list_server&gt;
chk_adr() {
    local reply
    local server
    local reason

    server=${1}${2}
    reply=$( dig +short ${server} )

    # If reply might be an error code . . .
    if [ ${#reply} -gt 6 ]
    then
        reason=$(get_txt ${reply} ${server} )
        reason=${reason:-${reply}}
    fi
    echo ${reason:-' not blacklisted.'}
}

# Need to get the IP address from the name.
echo 'Get address of: '$1
ip_adr=$(dig +short $1)
dns_reply=${ip_adr:-' no answer '}
echo ' Found address: '${dns_reply}

# A valid reply is at least 4 digits plus 3 dots.
if [ ${#ip_adr} -gt 6 ]
then
    echo
    declare query

    # Parse by assignment at the dots.
    declare -a dns
    IFS=$ADR_IFS
    dns=( ${ip_adr} )
    IFS=$WSP_IFS

    # Reorder octets into dns query order.
    rev_dns="${dns[3]}"'.'"${dns[2]}"'.'"${dns[1]}"'.'"${dns[0]}"'.'

# See: http://www.spamhaus.org (Conservative, well maintained)
    echo -n 'spamhaus.org says: '
    echo $(chk_adr ${rev_dns} 'sbl-xbl.spamhaus.org')

# See: http://ordb.org (Open mail relays)
    echo -n '   ordb.org  says: '
    echo $(chk_adr ${rev_dns} 'relays.ordb.org')

# See: http://www.spamcop.net/ (You can report spammers here)
    echo -n ' spamcop.net says: '
    echo $(chk_adr ${rev_dns} 'bl.spamcop.net')

# # # other blacklist operations # # #

# See: http://cbl.abuseat.org.
    echo -n ' abuseat.org says: '
    echo $(chk_adr ${rev_dns} 'cbl.abuseat.org')

# See: http://dsbl.org/usage (Various mail relays)
    echo
    echo 'Distributed Server Listings'
    echo -n '       list.dsbl.org says: '
    echo $(chk_adr ${rev_dns} 'list.dsbl.org')

    echo -n '   multihop.dsbl.org says: '
    echo $(chk_adr ${rev_dns} 'multihop.dsbl.org')

    echo -n 'unconfirmed.dsbl.org says: '
    echo $(chk_adr ${rev_dns} 'unconfirmed.dsbl.org')

else
    echo
    echo 'Could not use that address.'
fi

exit 0

# Exercises:
# --------

# 1) Check arguments to script,
#    and exit with appropriate error message if necessary.

# 2) Check if on-line at invocation of script,
#    and exit with appropriate error message if necessary.

# 3) Substitute generic variables for "hard-coded" BHL domains.

# 4) Set a time-out for the script using the "+time=" option
     to the 'dig' command.
</programlisting>
	    </example>

	  <para>For a much more elaborate version of the above script, see 
	    <xref linkend="isspammer2" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="tracerouteref" /><command moreinfo="none">traceroute</command></term>
	  <listitem>
	  <indexterm>
	    <primary>traceroute</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>traceroute</secondary>
	  </indexterm>

	    <para>Trace the route taken by packets sent to a remote host. This
	      command works within a LAN, WAN, or over the
	      Internet. The remote host may be specified by an IP
	      address. The output of this command may be filtered
	      by <link linkend="grepref">grep</link> or <link linkend="sedref">sed</link> in a pipe.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>traceroute 81.9.6.2</userinput>
<computeroutput>traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
 1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
 2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
 3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
 ...</computeroutput>
	      </screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="pingref" /><command moreinfo="none">ping</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ping</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ping</secondary>
	  </indexterm>

	    <para>Broadcast an <replaceable>ICMP
	      ECHO_REQUEST</replaceable> packet to another machine,
              either on a local or remote network. This is a
              diagnostic tool for testing network connections,
              and it should be used with caution.</para>


	  <para>
	      <screen><prompt>bash$ </prompt><userinput>ping localhost</userinput>
<computeroutput>PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

 --- localhost.localdomain ping statistics ---
 2 packets transmitted, 2 packets received, 0% packet loss
 round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</computeroutput>
	      </screen>
	    </para>

	    <para>A successful <firstterm>ping</firstterm> returns
	      an <link linkend="exitstatusref">exit status</link> of
	      <errorcode>0</errorcode>. This can be tested for in a
	      script.</para>
              <para><anchor xml:id="ping0" /></para>

            <para><programlisting>  HNAME=news-15.net  # Notorious spammer.
# HNAME=$HOST     # Debug: test for localhost.
  count=2  # Send only two pings.

if [[ `ping -c $count "$HNAME"` ]]
then
  echo ""$HNAME" still up and broadcasting spam your way."
else
  echo ""$HNAME" seems to be down. Pity."
fi</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="whoisref" /><command moreinfo="none">whois</command></term>
	  <listitem>
	  <indexterm>
	    <primary>whois</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain name server</secondary>
	  </indexterm>
	    <para>Perform a DNS (Domain Name System) lookup.
	      The <option>-h</option> option permits specifying which
	      particular <firstterm>whois</firstterm> server to query. See
	      <xref linkend="ex18" /> and <xref linkend="spamlookup" />.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="fingerref" /><command moreinfo="none">finger</command></term>
	  <listitem>
	  <indexterm>
	    <primary>finger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>finger</secondary>
	  </indexterm>

	    <para>Retrieve information about users on a
	      network. Optionally, this command can display
	      a user's <filename>~/.plan</filename>,
	      <filename>~/.project</filename>, and
	      <filename>~/.forward</filename> files, if present.</para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>finger</userinput>
<computeroutput>Login  Name           Tty      Idle  Login Time   Office     Office Phone
 bozo   Bozo Bozeman   tty1        8  Jun 25 16:59                (:0)
 bozo   Bozo Bozeman   ttyp0          Jun 25 16:59                (:0.0)
 bozo   Bozo Bozeman   ttyp1          Jun 25 17:07                (:0.0)</computeroutput>



<prompt>bash$ </prompt><userinput>finger bozo</userinput>
<computeroutput>Login: bozo                             Name: Bozo Bozeman
 Directory: /home/bozo                   Shell: /bin/bash
 Office: 2355 Clown St., 543-1234
 On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
 On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
 On since Fri Aug 31 20:13 (MST) on pts/1
 On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
 Mail last read Tue Jul  3 10:08 2007 (MST) 
 No Plan.</computeroutput>
	      </screen>
	    </para>
	      
	    <para>Out of security considerations, many networks disable
	      <command>finger</command> and its associated daemon.
	          <footnote>
		  <para><anchor xml:id="daemonref" /></para>
		  <para>A <firstterm>daemon</firstterm> is a background
		    process not attached to a terminal session. Daemons
		    perform designated services either at specified times
		    or explicitly triggered by certain events.</para>
		  <para>The word <quote>daemon</quote> means ghost in
		    Greek, and there is certainly something mysterious,
		    almost supernatural, about the way UNIX daemons
		    wander about behind the scenes, silently carrying
		    out their appointed tasks.</para>
	          </footnote>
	      </para>
	  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="chfnref" /><command moreinfo="none">chfn</command></term>
	  <listitem>
	  <indexterm>
	    <primary>chfn</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>finger</secondary>
	  </indexterm>
	    <para>Change information disclosed by the
	      <command>finger</command> command.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="vrfyref" /><command moreinfo="none">vrfy</command></term>
	  <listitem>
	  <indexterm>
	    <primary>vrfy</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>vrfy</secondary>
	  </indexterm>
	    <para>Verify an Internet e-mail address.</para>
	    
	    <para>This command seems to be missing from newer Linux
	      distros.</para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="commremote">
        <title><anchor xml:id="commremote1" />Remote Host Access</title>

	<varlistentry>
	  <term><anchor xml:id="rxref" /><command moreinfo="none">sx</command></term>
	  <term><command moreinfo="none">rx</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rx</secondary>
	  </indexterm>
	    <para>The <command>sx</command> and <command>rx</command>
	      command set serves to transfer files to and from a remote
	      host using the <firstterm>xmodem</firstterm> protocol. These
	      are generally part of a communications package, such as
	      <command>minicom</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rzref" /><command moreinfo="none">sz</command></term>
	  <term><command moreinfo="none">rz</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sz</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rz</secondary>
	  </indexterm>
	    <para>The <command>sz</command> and <command>rz</command>
	      command set serves to transfer files to and from a remote
	      host using the <firstterm>zmodem</firstterm> protocol.
	      <firstterm>Zmodem</firstterm> has certain advantages over
	      <firstterm>xmodem</firstterm>, such as faster transmission
	      rate and resumption of interrupted file transfers.
	      Like <command>sx</command> and <command>rx</command>,
	      these are generally part of a communications package.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="ftpref" /><command moreinfo="none">ftp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ftp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file transfer</secondary>
	  </indexterm>
	    <para>Utility and protocol for uploading / downloading
	      files to or from a remote host. An ftp session can be automated
	      in a script (see <xref linkend="ex72" /> and <xref linkend="encryptedpw" />).</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="uucpref" /><command moreinfo="none">uucp</command></term>
	  <term><anchor xml:id="uuxref" /><command moreinfo="none">uux</command></term>
	  <term><anchor xml:id="curef" /><command moreinfo="none">cu</command></term>
	  <listitem>
	  <indexterm>
	    <primary>uucp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uucp</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>uux</primary>
	    <secondary>unix to unix execute</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cu</primary>
	    <secondary>call up</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uucp</secondary>
	  </indexterm>

	    <para><command>uucp</command>: <firstterm>UNIX to UNIX
	      copy</firstterm>. This is a communications package for
	      transferring files between UNIX servers. A shell script
	      is an effective way to handle a <command>uucp</command>
	      command sequence.</para>

	    <para>Since the advent of the Internet and e-mail,
	      <command>uucp</command> seems to have faded into obscurity,
	      but it still exists and remains perfectly workable in
	      situations where an Internet connection is not available
	      or appropriate. The advantage of <command>uucp</command>
	      is that it is fault-tolerant, so even if there is a service
	      interruption the copy operation will resume where it left
	      off when the connection is restored.</para>

            <para>---</para>

	    <para><command>uux</command>: <firstterm>UNIX to UNIX
	      execute</firstterm>. Execute a command on a remote system.
	      This command is part of the <command>uucp</command>
	      package.</para>

            <para>---</para>

	    <para><command>cu</command>: <command>C</command>all
	      <command>U</command>p a remote system and connect as a
	      simple terminal. It is a sort of dumbed-down version of
	      <link linkend="telnetref">telnet</link>. This command is
	      part of the <command>uucp</command> package.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="telnetref" /><command moreinfo="none">telnet</command></term>
	  <listitem>
	  <indexterm>
	    <primary>telnet</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telnet</secondary>
	  </indexterm>
	    <para>Utility and protocol for connecting to a remote host.</para>
	    <caution><para>The <firstterm>telnet</firstterm> protocol
	    contains security holes and should therefore probably be
	    avoided. Its use within a shell script is
	    <emphasis>not</emphasis> recommended.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="wgetref" /><command moreinfo="none">wget</command></term>
	  <listitem>
	  <indexterm>
	    <primary>wget</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>download</secondary>
	  </indexterm>

	    <para>The <command>wget</command> utility
	      <firstterm>noninteractively</firstterm> retrieves or
	      downloads files from a Web or ftp site. It works well in a
	      script.</para>

	    <para><programlisting>wget -p http://www.xyz23.com/file01.html
#  The -p or --page-requisite option causes wget to fetch all files
#+ required to display the specified page.

wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE
#  The -r option recursively follows and retrieves all links
#+ on the specified site.

wget -c ftp://ftp.xyz25.net/bozofiles/filename.tar.bz2
#  The -c option lets wget resume an interrupted download.
#  This works with ftp servers and many HTTP sites.</programlisting></para>

	    <example xml:id="quotefetch">
	      <title>Getting a stock quote</title>
	      <programlisting>#!/bin/bash
# quote-fetch.sh: Download a stock quote.


E_NOPARAMS=86

if [ -z "$1" ]  # Must specify a stock (symbol) to fetch.
  then echo "Usage: `basename $0` stock-symbol"
  exit $E_NOPARAMS
fi

stock_symbol=$1

file_suffix=.html
# Fetches an HTML file, so name it appropriately.
URL='http://finance.yahoo.com/q?s='
# Yahoo finance board, with stock query suffix.

# -----------------------------------------------------------
wget -O ${stock_symbol}${file_suffix} "${URL}${stock_symbol}"
# -----------------------------------------------------------


# To look up stuff on http://search.yahoo.com:
# -----------------------------------------------------------
# URL="http://search.yahoo.com/search?fr=ush-news&amp;p=${query}"
# wget -O "$savefilename" "${URL}"
# -----------------------------------------------------------
# Saves a list of relevant URLs.

exit $?

# Exercises:
# ---------
#
# 1) Add a test to ensure the user running the script is on-line.
#    (Hint: parse the output of 'ps -ax' for "ppp" or "connect."
#
# 2) Modify this script to fetch the local weather report,
#+   taking the user's zip code as an argument.
</programlisting>
	    </example>


            <para>See also <xref linkend="wgetter2" /> and <xref linkend="bashpodder" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lynxref" /><command moreinfo="none">lynx</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lynx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>browser</secondary>
	  </indexterm>

	    <para>The <command>lynx</command> Web and file browser
	      can be used inside a script (with the
	      <option>-dump</option> option) to retrieve a file from a Web or 
	      ftp site noninteractively.</para>

	   <para>
	   <programlisting>lynx -dump http://www.xyz23.com/file01.html &gt;$SAVEFILE</programlisting>
            </para>		

            <para>With the <option>-traversal</option> option,
	      <command>lynx</command> starts at the HTTP URL specified
	      as an argument, then <quote>crawls</quote> through all
	      links located on that particular server. Used together
	      with the <option>-crawl</option> option, outputs page text
	      to a log file.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rloginref" /><command moreinfo="none">rlogin</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rlogin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote login</secondary>
	  </indexterm>
	    <para><replaceable>Remote login</replaceable>, initates a
	      session on a remote host. This command has security issues,
	      so use <link linkend="sshref">ssh</link> instead.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rshref" /><command moreinfo="none">rsh</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rsh</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote shell</secondary>
	  </indexterm>
	    <para><replaceable>Remote shell</replaceable>, executes
	      command(s) on a remote host. This has security issues,
	      so use <command>ssh</command> instead.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rcpref" /><command moreinfo="none">rcp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rcp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote copy</secondary>
	  </indexterm>
	    <para><replaceable>Remote copy</replaceable>, copies files
	      between two different networked machines.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rsyncref" /><command moreinfo="none">rsync</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rsync</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote update</secondary>
	  </indexterm>

	    <para><replaceable>Remote synchronize</replaceable>, updates
	    (synchronizes) files
	      between two different networked machines.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>rsync -a ~/sourcedir/*txt /node1/subdirectory/</userinput>
	      </screen>
	    </para>

	    <example xml:id="fc4upd">
	      <title>Updating FC4</title>
	      <programlisting>#!/bin/bash
# fc4upd.sh

# Script author: Frank Wang.
# Slight stylistic modifications by ABS Guide author.
# Used in ABS Guide with permission.


#  Download Fedora Core 4 update from mirror site using rsync. 
#  Should also work for newer Fedora Cores -- 5, 6, . . .
#  Only download latest package if multiple versions exist,
#+ to save space.

URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/
# URL=rsync://ftp.kddilabs.jp/fedora/core/updates/
# URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/

DEST=${1:-/var/www/html/fedora/updates/}
LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt
PID_FILE=/var/run/${0##*/}.pid

E_RETURN=85        # Something unexpected happened.


# General rsync options
# -r: recursive download
# -t: reserve time
# -v: verbose

OPTS="-rtv --delete-excluded --delete-after --partial"

# rsync include pattern
# Leading slash causes absolute path name match.
INCLUDE=(
    "/4/i386/kde-i18n-Chinese*" 
#   ^                         ^
# Quoting is necessary to prevent globbing.
) 


# rsync exclude pattern
# Temporarily comment out unwanted pkgs using "#" . . .
EXCLUDE=(
    /1
    /2
    /3
    /testing
    /4/SRPMS
    /4/ppc
    /4/x86_64
    /4/i386/debug
   "/4/i386/kde-i18n-*"
   "/4/i386/openoffice.org-langpack-*"
   "/4/i386/*i586.rpm"
   "/4/i386/GFS-*"
   "/4/i386/cman-*"
   "/4/i386/dlm-*"
   "/4/i386/gnbd-*"
   "/4/i386/kernel-smp*"
#  "/4/i386/kernel-xen*" 
#  "/4/i386/xen-*" 
)


init () {
    # Let pipe command return possible rsync error, e.g., stalled network.
    set -o pipefail                  # Newly introduced in Bash, version 3.

    TMP=${TMPDIR:-/tmp}/${0##*/}.$$  # Store refined download list.
    trap "{
        rm -f $TMP 2&gt;/dev/null
    }" EXIT                          # Clear temporary file on exit.
}


check_pid () {
# Check if process exists.
    if [ -s "$PID_FILE" ]; then
        echo "PID file exists. Checking ..."
        PID=$(/bin/egrep -o "^[[:digit:]]+" $PID_FILE)
        if /bin/ps --pid $PID &amp;&gt;/dev/null; then
            echo "Process $PID found. ${0##*/} seems to be running!"
           /usr/bin/logger -t ${0##*/} \
                 "Process $PID found. ${0##*/} seems to be running!"
            exit $E_RETURN
        fi
        echo "Process $PID not found. Start new process . . ."
    fi
}


#  Set overall file update range starting from root or $URL,
#+ according to above patterns.
set_range () {
    include=
    exclude=
    for p in "${INCLUDE[@]}"; do
        include="$include --include \"$p\""
    done

    for p in "${EXCLUDE[@]}"; do
        exclude="$exclude --exclude \"$p\""
    done
}


# Retrieve and refine rsync update list.
get_list () {
    echo $$ &gt; $PID_FILE || {
        echo "Can't write to pid file $PID_FILE"
        exit $E_RETURN
    }

    echo -n "Retrieving and refining update list . . ."

    # Retrieve list -- 'eval' is needed to run rsync as a single command.
    # $3 and $4 is the date and time of file creation.
    # $5 is the full package name.
    previous=
    pre_file=
    pre_date=0
    eval /bin/nice /usr/bin/rsync \
        -r $include $exclude $URL | \
        egrep '^dr.x|^-r' | \
        awk '{print $3, $4, $5}' | \
        sort -k3 | \
        { while read line; do
            # Get seconds since epoch, to filter out obsolete pkgs.
            cur_date=$(date -d "$(echo $line | awk '{print $1, $2}')" +%s)
            #  echo $cur_date

            # Get file name.
            cur_file=$(echo $line | awk '{print $3}')
            #  echo $cur_file

            # Get rpm pkg name from file name, if possible.
            if [[ $cur_file == *rpm ]]; then
                pkg_name=$(echo $cur_file | sed -r -e \
                    's/(^([^_-]+[_-])+)[[:digit:]]+\..*[_-].*$/\1/')
            else
                pkg_name=
            fi
            # echo $pkg_name

            if [ -z "$pkg_name" ]; then   #  If not a rpm file,
                echo $cur_file &gt;&gt; $TMP    #+ then append to download list.
            elif [ "$pkg_name" != "$previous" ]; then   # A new pkg found.
                echo $pre_file &gt;&gt; $TMP                  # Output latest file.
                previous=$pkg_name                      # Save current.
                pre_date=$cur_date
                pre_file=$cur_file
            elif [ "$cur_date" -gt "$pre_date" ]; then
                                                #  If same pkg, but newer,
                pre_date=$cur_date              #+ then update latest pointer.
                pre_file=$cur_file
            fi
            done
            echo $pre_file &gt;&gt; $TMP              #  TMP contains ALL
                                                #+ of refined list now.
            # echo "subshell=$BASH_SUBSHELL"

    }       # Bracket required here to let final "echo $pre_file &gt;&gt; $TMP" 
            # Remained in the same subshell ( 1 ) with the entire loop.

    RET=$?  # Get return code of the pipe command.

    [ "$RET" -ne 0 ] &amp;&amp; {
        echo "List retrieving failed with code $RET"
        exit $E_RETURN
    }

    echo "done"; echo
}

# Real rsync download part.
get_file () {

    echo "Downloading..."
    /bin/nice /usr/bin/rsync \
        $OPTS \
        --filter "merge,+/ $TMP" \
        --exclude '*'  \
        $URL $DEST     \
        | /usr/bin/tee $LOG

    RET=$?

   #  --filter merge,+/ is crucial for the intention. 
   #  + modifier means include and / means absolute path.
   #  Then sorted list in $TMP will contain ascending dir name and 
   #+ prevent the following --exclude '*' from "shortcutting the circuit." 

    echo "Done"

    rm -f $PID_FILE 2&gt;/dev/null

    return $RET
}

# -------
# Main
init
check_pid
set_range
get_list
get_file
RET=$?
# -------

if [ "$RET" -eq 0 ]; then
    /usr/bin/logger -t ${0##*/} "Fedora update mirrored successfully."
else
    /usr/bin/logger -t ${0##*/} \
    "Fedora update mirrored with failure code: $RET"
fi

exit $RET
</programlisting>
	    </example>

	    <para>See also <xref linkend="nightlybackup" />.</para>
	      
	    <note><para>Using <link linkend="rcpref">rcp</link>, <link linkend="rsyncref">rsync</link>, and similar
	      utilities with security implications in a shell
	      script may not be advisable. Consider, instead, using
	      <command>ssh</command>, <link linkend="scpref">scp</link>,
	      or an <command>expect</command> script.</para></note>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="sshref" /><command moreinfo="none">ssh</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ssh</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure shell</secondary>
	  </indexterm>
	    <para><replaceable>Secure shell</replaceable>, logs onto
	      a remote host and executes commands there. This
	      secure replacement for <command>telnet</command>,
	      <command>rlogin</command>, <command>rcp</command>, and
	      <command>rsh</command> uses identity authentication
	      and encryption. See its <link linkend="manref">manpage</link>
	      for details.</para>

	    <example xml:id="remote">
	      <title>Using <firstterm>ssh</firstterm></title>
	      <programlisting>#!/bin/bash
# remote.bash: Using ssh.

# This example by Michael Zick.
# Used with permission.


#   Presumptions:
#   ------------
#   fd-2 isn't being captured ( '2&gt;/dev/null' ).
#   ssh/sshd presumes stderr ('2') will display to user.
#
#   sshd is running on your machine.
#   For any 'standard' distribution, it probably is,
#+  and without any funky ssh-keygen having been done.

# Try ssh to your machine from the command-line:
#
# $ ssh $HOSTNAME
# Without extra set-up you'll be asked for your password.
#   enter password
#   when done,  $ exit
#
# Did that work? If so, you're ready for more fun.

# Try ssh to your machine as 'root':
#
#   $  ssh -l root $HOSTNAME
#   When asked for password, enter root's, not yours.
#          Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain
#   Enter 'exit' when done.

#  The above gives you an interactive shell.
#  It is possible for sshd to be set up in a 'single command' mode,
#+ but that is beyond the scope of this example.
#  The only thing to note is that the following will work in
#+ 'single command' mode.


# A basic, write stdout (local) command.

ls -l

# Now the same basic command on a remote machine.
# Pass a different 'USERNAME' 'HOSTNAME' if desired:
USER=${USERNAME:-$(whoami)}
HOST=${HOSTNAME:-$(hostname)}

#  Now excute the above command-line on the remote host,
#+ with all transmissions encrypted.

ssh -l ${USER} ${HOST} " ls -l "

#  The expected result is a listing of your username's home
#+ directory on the remote machine.
#  To see any difference, run this script from somewhere
#+ other than your home directory.

#  In other words, the Bash command is passed as a quoted line
#+ to the remote shell, which executes it on the remote machine.
#  In this case, sshd does  ' bash -c "ls -l" '   on your behalf.

#  For information on topics such as not having to enter a
#+ password/passphrase for every command-line, see
#+    man ssh
#+    man ssh-keygen
#+    man sshd_config.

exit 0
</programlisting>
	    </example>

	      <caution>
	      <para>Within a loop, <command>ssh</command> may cause
		unexpected behavior. According to a <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://groups-beta.google.com/group/comp.unix.shell/msg/dcb446b5fff7d230">
		Usenet post</link> in the comp.unix shell archives,
		<command>ssh</command> inherits the loop's
		<filename>stdin</filename>. To remedy this, pass
		<command>ssh</command> either the <option>-n</option>
		or <option>-f</option> option.</para>
		<para>Thanks, Jason Bechtel, for pointing this out.</para>
	      </caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="scpref" /><command moreinfo="none">scp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>scp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure copy</secondary>
	  </indexterm>
	    <para><replaceable>Secure copy</replaceable>, similar in
	      function to <command>rcp</command>, copies files between
	      two different networked machines, but does so using
	      authentication, and with a security level similar to
	      <command>ssh</command>.</para>
	  </listitem>
	</varlistentry>
       
       </variablelist>	


      <variablelist xml:id="commlocal">
        <title><anchor xml:id="commlocal1" />Local Network</title>

	<varlistentry>
	  <term><anchor xml:id="writeref" /><command moreinfo="none">write</command></term>
	  <listitem>
	  <indexterm>
	    <primary>write</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>write</secondary>
	  </indexterm>
	    <para>This is a utility for terminal-to-terminal communication.
	      It allows sending lines from your terminal (console or
	      <firstterm>xterm</firstterm>) to that of another user. The
	      <link linkend="mesgref">mesg</link> command may, of course,
	      be used to disable write access to a terminal</para>

	    <para>Since <command>write</command> is interactive, it
	      would not normally find use in a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="netconfigref" /><command moreinfo="none">netconfig</command></term>
	  <listitem>
	  <indexterm>
	    <primary>netconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>network</secondary>
	  </indexterm>
	    <para>A command-line utility for configuring a network adapter
	      (using <firstterm>DHCP</firstterm>). This command is native
	      to Red Hat centric Linux distros.</para>
	  </listitem>
	</varlistentry>

       </variablelist>	


      <variablelist xml:id="commmail">
        <title><anchor xml:id="commmail1" />Mail</title>

	<varlistentry>
	  <term><command moreinfo="none">mail</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mail</secondary>
	  </indexterm>

	    <para>Send or read e-mail messages.</para>

            <para>This stripped-down command-line mail client
	      works fine as a command embedded in a script.</para>

	    <example xml:id="selfmailer">
	      <title>A script that mails itself</title>
	      <programlisting>#!/bin/sh
# self-mailer.sh: Self-mailing script

adr=${1:-`whoami`}     # Default to current user, if not specified.
#  Typing 'self-mailer.sh wiseguy@superdupergenius.com'
#+ sends this script to that addressee.
#  Just 'self-mailer.sh' (no argument) sends the script
#+ to the person invoking it, for example, bozo@localhost.localdomain.
#
#  For more on the ${parameter:-default} construct,
#+ see the "Parameter Substitution" section
#+ of the "Variables Revisited" chapter.

# ============================================================================
  cat $0 | mail -s "Script \"`basename $0`\" has mailed itself to you." "$adr"
# ============================================================================

# --------------------------------------------
#  Greetings from the self-mailing script.
#  A mischievous person has run this script,
#+ which has caused it to mail itself to you.
#  Apparently, some people have nothing better
#+ to do with their time.
# --------------------------------------------

echo "At `date`, script \"`basename $0`\" mailed to "$adr"."

exit 0

#  Note that the "mailx" command (in "send" mode) may be substituted
#+ for "mail" ... but with somewhat different options.
</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mailtoref" /><command moreinfo="none">mailto</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mailto</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>MIME mail</secondary>
	  </indexterm>
	    <para>Similar to the <command>mail</command> command,
	      <command>mailto</command> sends e-mail messages
	      from the command-line or in a script. However,
	      <command>mailto</command> also permits sending MIME
	      (multimedia) messages.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mailstatsref" /><command moreinfo="none">mailstats</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mailstats</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>statistics</secondary>
	  </indexterm>
	    <para>Show <firstterm>mail statistics</firstterm>. This command
	      may be invoked only by <firstterm>root</firstterm>.</para>

	  <para>
	      <screen><prompt>root# </prompt><userinput>mailstats</userinput>
<computeroutput>Statistics from Tue Jan  1 20:32:08 2008
  M   msgsfr  bytes_from   msgsto    bytes_to  msgsrej msgsdis msgsqur  Mailer
  4     1682      24118K        0          0K        0       0       0  esmtp
  9      212        640K     1894      25131K        0       0       0  local
 =====================================================================
  T     1894      24758K     1894      25131K        0       0       0
  C      414                    0</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="vacationref" /><command moreinfo="none">vacation</command></term>
	  <listitem>
	  <indexterm>
	    <primary>vacation</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mail</secondary>
	  </indexterm>
	    <para>This utility automatically replies to e-mails that
	      the intended recipient is on vacation and temporarily
	      unavailable. It runs on a network, in conjunction with
	      <command>sendmail</command>, and is not applicable to a
	      dial-up POPmail account.</para>
	  </listitem>
	</varlistentry>


       </variablelist>	

	</section> <!-- End Communications Commands -->



      <section xml:id="terminalccmds">
        <title>Terminal Control Commands</title>

       <variablelist xml:id="termcommandlisting">	
         <title><anchor xml:id="termcommandlisting1" />Command affecting the console
	   or terminal</title>


	<varlistentry>
	  <term><anchor xml:id="tputref" /><command moreinfo="none">tput</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tput</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>

	    <para>Initialize terminal and/or fetch information about it from
	      <database>terminfo</database> data. Various options permit
	      certain terminal operations:  <command>tput clear</command>
	      is the equivalent of <link linkend="clearref">clear</link>;
	      <command>tput reset</command> is the equivalent
	      of <link linkend="resetref">reset</link>.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>tput longname</userinput>
<computeroutput>xterm terminal emulator (X Window System)</computeroutput>
	      </screen>
	    </para>

	    <para>Issuing a <command>tput cup X Y</command> moves
	      the cursor to the (X,Y) coordinates in the current
	      terminal. A <command>clear</command> to erase the terminal
	      screen would normally precede this.</para>


	    <para>

	      Some interesting options to <firstterm>tput</firstterm> are:

	  <itemizedlist>
	    <listitem><para><option>bold</option>, for high-intensity
	      text</para></listitem>
	    <listitem><para><option>smul</option>, to underline text
	      in the terminal</para></listitem>
	    <listitem><para><option>smso</option>, to render text in
	      reverse</para></listitem>
	    <listitem><para><option>sgr0</option>, to reset the terminal
	      parameters (to normal), without clearing the
	      screen</para></listitem>
	  </itemizedlist>

	    </para>


	    <para>Example scripts using <firstterm>tput</firstterm>:
            <orderedlist xml:id="tputexamples">
               <listitem><para><xref linkend="colorecho" /></para></listitem>
               <listitem><para><xref linkend="ex30a" /></para></listitem>
               <listitem><para><xref linkend="homework" /></para></listitem>
               <listitem><para><xref linkend="nim" /></para></listitem>
               <listitem><para><xref linkend="poem" /></para></listitem>
            </orderedlist>
	    </para>

	    <para>Note that <link linkend="sttyref">stty</link> offers
	      a more powerful command set for controlling a terminal.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="infocmpref" /><command moreinfo="none">infocmp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>infocmp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>

	    <para>This command prints out extensive information about the
	      current terminal. It references the
	      <firstterm>terminfo</firstterm> database.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>infocmp</userinput>
<computeroutput>#       Reconstructed via infocmp from file:
 /usr/share/terminfo/r/rxvt
 rxvt|rxvt terminal emulator (X Window System), 
         am, bce, eo, km, mir, msgr, xenl, xon, 
         colors#8, cols#80, it#8, lines#24, pairs#64, 
         acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, 
         bel=^G, blink=\E[5m, bold=\E[1m,
         civis=\E[?25l, 
         clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M, 
         ...</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="resetref" /><command moreinfo="none">reset</command></term>
	  <listitem>
	  <indexterm>
	    <primary>reset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reset</secondary>
	  </indexterm>
	    <para>Reset terminal parameters and clear text screen. As with
	    <command>clear</command>, the cursor and prompt reappear in the
	    upper lefthand corner of the terminal.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="clearref" /><command moreinfo="none">clear</command></term>
	  <listitem>
	  <indexterm>
	    <primary>clear</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clear</secondary>
	  </indexterm>
	    <para>The <command>clear</command> command simply clears
	      the text screen at the console or in an
	      <firstterm>xterm</firstterm>. The prompt and cursor
	      reappear at the upper lefthand corner of the screen or
	      xterm window. This command may be used either at the command
	      line or in a script. See <xref linkend="ex30" />.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="resizeref" /><command moreinfo="none">resize</command></term>
	  <listitem>
	  <indexterm>
	    <primary>resize</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>resize</secondary>
	  </indexterm>
	    <para>Echoes commands necessary to set <varname>$TERM</varname>
	      and <varname>$TERMCAP</varname> to duplicate the
	      <firstterm>size</firstterm> (dimensions) of the current
	      terminal.</para>
	    <para>
	        <screen><prompt>bash$ </prompt><userinput>resize</userinput>
<computeroutput>set noglob;
 setenv COLUMNS '80';
 setenv LINES '24';
 unset noglob;</computeroutput>
	        </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="scriptref" /><command moreinfo="none">script</command></term>
	  <listitem>
	  <indexterm>
	    <primary>script</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>script</secondary>
	  </indexterm>
	    <para>This utility records (saves to a file) all the user keystrokes at
	      the command-line in a console or an xterm window. This, in effect,
	      creates a record of a session.</para>
	  </listitem>
	</varlistentry>

       </variablelist>	

	</section> <!-- End Terminal Control Commands -->

	
      <section xml:id="mathc">
        <title>Math Commands</title>

       <variablelist xml:id="mathcommandlisting">	
         <title><anchor xml:id="mathcommandlisting1" /><quote>Doing the
	   numbers</quote></title>

      <varlistentry>
	<term><anchor xml:id="factorref" /><command moreinfo="none">factor</command></term>
	  <listitem>
	  <indexterm>
	    <primary>factor</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>factor</secondary>
	  </indexterm>
            <para>Decompose an integer into prime factors.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>factor 27417</userinput>
<computeroutput>27417: 3 13 19 37</computeroutput>
	      </screen>
	    </para>

            <example xml:id="primes2">
              <title>Generating prime numbers</title>
              <programlisting>#!/bin/bash
# primes2.sh

#  Generating prime numbers the quick-and-easy way,
#+ without resorting to fancy algorithms.

CEILING=10000   # 1 to 10000
PRIME=0
E_NOTPRIME=

is_prime ()
{
  local factors
  factors=( $(factor $1) )  # Load output of `factor` into array.

if [ -z "${factors[2]}" ]
#  Third element of "factors" array:
#+ ${factors[2]} is 2nd factor of argument.
#  If it is blank, then there is no 2nd factor,
#+ and the argument is therefore prime.
then
  return $PRIME             # 0
else
  return $E_NOTPRIME        # null
fi
}

echo
for n in $(seq $CEILING)
do
  if is_prime $n
  then
    printf %5d $n
  fi   #    ^  Five positions per number suffices.
done   #       For a higher $CEILING, adjust upward, as necessary.

echo

exit
</programlisting>
            </example>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor xml:id="bcref" /><command moreinfo="none">bc</command></term>
	  <listitem>
	  <indexterm>
	    <primary>bc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bc</secondary>
	  </indexterm>

	    <para>Bash can't handle floating point calculations, and
	      it lacks operators for certain important mathematical
	      functions. Fortunately, <command>bc</command> gallops to
	      the rescue.</para>

	    <para>Not just a versatile, arbitrary precision calculation
	      utility, <command>bc</command> offers many of the facilities of
	      a programming language. It has a syntax vaguely resembling
	      <command>C</command>.</para>

	    <para>Since it is a fairly well-behaved UNIX utility, and may
	       therefore be used in a <link linkend="piperef">pipe</link>,
	       <command>bc</command> comes in handy in scripts.</para>

	    <para><anchor xml:id="bctemplate" /></para>
	    <para>Here is a simple template for using
	      <command>bc</command> to calculate a script
	      variable. This uses <link linkend="commandsubref">command
	      substitution</link>.</para>

	      <para>
              <screen>
	      <userinput>variable=$(echo "OPTIONS; OPERATIONS" | bc)</userinput>
	      </screen>
	      </para>

	    <para><anchor xml:id="monthlypmt0" /></para>
            <example xml:id="monthlypmt">
              <title>Monthly Payment on a Mortgage</title>
              <programlisting>#!/bin/bash
# monthlypmt.sh: Calculates monthly payment on a mortgage.


#  This is a modification of code in the
#+ "mcalc" (mortgage calculator) package,
#+ by Jeff Schmidt
#+ and
#+ Mendel Cooper (yours truly, the ABS Guide author).
#   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz

echo
echo "Given the principal, interest rate, and term of a mortgage,"
echo "calculate the monthly payment."

bottom=1.0

echo
echo -n "Enter principal (no commas) "
read principal
echo -n "Enter interest rate (percent) "  # If 12%, enter "12", not ".12".
read interest_r
echo -n "Enter term (months) "
read term


 interest_r=$(echo "scale=9; $interest_r/100.0" | bc) # Convert to decimal.
                 #           ^^^^^^^^^^^^^^^^^  Divide by 100. 
                 # "scale" determines how many decimal places.

 interest_rate=$(echo "scale=9; $interest_r/12 + 1.0" | bc)
 

 top=$(echo "scale=9; $principal*$interest_rate^$term" | bc)
          #           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          #           Standard formula for figuring interest.

 echo; echo "Please be patient. This may take a while."

 let "months = $term - 1"
# ==================================================================== 
 for ((x=$months; x &gt; 0; x--))
 do
   bot=$(echo "scale=9; $interest_rate^$x" | bc)
   bottom=$(echo "scale=9; $bottom+$bot" | bc)
#  bottom = $(($bottom + $bot"))
 done
# ==================================================================== 

# -------------------------------------------------------------------- 
#  Rick Boivie pointed out a more efficient implementation
#+ of the above loop, which decreases computation time by 2/3.

# for ((x=1; x &lt;= $months; x++))
# do
#   bottom=$(echo "scale=9; $bottom * $interest_rate + 1" | bc)
# done


#  And then he came up with an even more efficient alternative,
#+ one that cuts down the run time by about 95%!

# bottom=`{
#     echo "scale=9; bottom=$bottom; interest_rate=$interest_rate"
#     for ((x=1; x &lt;= $months; x++))
#     do
#          echo 'bottom = bottom * interest_rate + 1'
#     done
#     echo 'bottom'
#     } | bc`       # Embeds a 'for loop' within command substitution.
# --------------------------------------------------------------------------
#  On the other hand, Frank Wang suggests:
#  bottom=$(echo "scale=9; ($interest_rate^$term-1)/($interest_rate-1)" | bc)

#  Because . . .
#  The algorithm behind the loop
#+ is actually a sum of geometric proportion series.
#  The sum formula is e0(1-q^n)/(1-q),
#+ where e0 is the first element and q=e(n+1)/e(n)
#+ and n is the number of elements.
# --------------------------------------------------------------------------


 # let "payment = $top/$bottom"
 payment=$(echo "scale=2; $top/$bottom" | bc)
 # Use two decimal places for dollars and cents.
 
 echo
 echo "monthly payment = \$$payment"  # Echo a dollar sign in front of amount.
 echo


 exit 0


 # Exercises:
 #   1) Filter input to permit commas in principal amount.
 #   2) Filter input to permit interest to be entered as percent or decimal.
 #   3) If you are really ambitious,
 #+     expand this script to print complete amortization tables.
</programlisting>
            </example>

	    <para><anchor xml:id="base0" /></para>
            <example xml:id="base">
              <title>Base Conversion</title>
              <programlisting>#!/bin/bash
###########################################################################
# Shellscript:	base.sh - print number to different bases (Bourne Shell)
# Author     :	Heiner Steven (heiner.steven@odn.de)
# Date       :	07-03-95
# Category   :	Desktop
# $Id$
# ==&gt; Above line is RCS ID info.
###########################################################################
# Description
#
# Changes
# 21-03-95 stv	fixed error occuring with 0xb as input (0.2)
###########################################################################

# ==&gt; Used in ABS Guide with the script author's permission.
# ==&gt; Comments added by ABS Guide author.

NOARGS=85
PN=`basename "$0"`			       # Program name
VER=`echo '$Revision$' | cut -d' ' -f2`  # ==&gt; VER=1.2

Usage () {
    echo "$PN - print number to different bases, $VER (stv '95)
usage: $PN [number ...]

If no number is given, the numbers are read from standard input.
A number may be
    binary (base 2)		starting with 0b (i.e. 0b1100)
    octal (base 8)		starting with 0  (i.e. 014)
    hexadecimal (base 16)	starting with 0x (i.e. 0xc)
    decimal			otherwise (i.e. 12)" &gt;&amp;2
    exit $NOARGS 
}   # ==&gt; Prints usage message.

Msg () {
    for i   # ==&gt; in [list] missing. Why?
    do echo "$PN: $i" &gt;&amp;2
    done
}

Fatal () { Msg "$@"; exit 66; }

PrintBases () {
    # Determine base of the number
    for i      # ==&gt; in [list] missing...
    do         # ==&gt; so operates on command-line arg(s).
	case "$i" in
	    0b*)		ibase=2;;	# binary
	    0x*|[a-f]*|[A-F]*)	ibase=16;;	# hexadecimal
	    0*)			ibase=8;;	# octal
	    [1-9]*)		ibase=10;;	# decimal
	    *)
		Msg "illegal number $i - ignored"
		continue;;
	esac

	# Remove prefix, convert hex digits to uppercase (bc needs this).
	number=`echo "$i" | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'`
	# ==&gt; Uses ":" as sed separator, rather than "/".

	# Convert number to decimal
	dec=`echo "ibase=$ibase; $number" | bc`  # ==&gt; 'bc' is calculator utility.
	case "$dec" in
	    [0-9]*)	;;			 # number ok
	    *)		continue;;		 # error: ignore
	esac

	# Print all conversions in one line.
	# ==&gt; 'here document' feeds command list to 'bc'.
	echo `bc &lt;&lt;!
	    obase=16; "hex="; $dec
	    obase=10; "dec="; $dec
	    obase=8;  "oct="; $dec
	    obase=2;  "bin="; $dec
!
    ` | sed -e 's: :	:g'

    done
}

while [ $# -gt 0 ]
# ==&gt;  Is a "while loop" really necessary here,
# ==&gt;+ since all the cases either break out of the loop
# ==&gt;+ or terminate the script.
# ==&gt; (Above comment by Paulo Marcel Coelho Aragao.)
do
    case "$1" in
	--)     shift; break;;
	-h)     Usage;;                 # ==&gt; Help message.
	-*)     Usage;;
         *)     break;;                 # First number
    esac   # ==&gt; Error checking for illegal input might be appropriate.
    shift
done

if [ $# -gt 0 ]
then
    PrintBases "$@"
else					# Read from stdin.
    while read line
    do
	PrintBases $line
    done
fi


exit
</programlisting>
            </example>

	      <para><anchor xml:id="bcheredoc" /></para>
	      <para>An alternate method of invoking <command>bc</command>
		involves using a <link linkend="heredocref">here
		document</link> embedded within a <link linkend="commandsubref">command substitution</link>
		block. This is especially appropriate when a script
		needs to pass a list of options and commands to
		<command>bc</command>.</para>

              <para>
	      <programlisting>variable=`bc &lt;&lt; LIMIT_STRING
options
statements
operations
LIMIT_STRING
`

...or...


variable=$(bc &lt;&lt; LIMIT_STRING
options
statements
operations
LIMIT_STRING
)</programlisting>
              </para>


            <example xml:id="altbc">
              <title>Invoking <firstterm>bc</firstterm> using a <firstterm>here
	        document</firstterm></title>
              <programlisting>#!/bin/bash
# Invoking 'bc' using command substitution
# in combination with a 'here document'.


var1=`bc &lt;&lt; EOF
18.33 * 19.78
EOF
`
echo $var1       # 362.56


#  $( ... ) notation also works.
v1=23.53
v2=17.881
v3=83.501
v4=171.63

var2=$(bc &lt;&lt; EOF
scale = 4
a = ( $v1 + $v2 )
b = ( $v3 * $v4 )
a * b + 15.35
EOF
)
echo $var2       # 593487.8452


var3=$(bc -l &lt;&lt; EOF
scale = 9
s ( 1.7 )
EOF
)
# Returns the sine of 1.7 radians.
# The "-l" option calls the 'bc' math library.
echo $var3       # .991664810


# Now, try it in a function...
hypotenuse ()    # Calculate hypotenuse of a right triangle.
{                # c = sqrt( a^2 + b^2 )
hyp=$(bc -l &lt;&lt; EOF
scale = 9
sqrt ( $1 * $1 + $2 * $2 )
EOF
)
# Can't directly return floating point values from a Bash function.
# But, can echo-and-capture:
echo "$hyp"
}

hyp=$(hypotenuse 3.68 7.31)
echo "hypotenuse = $hyp"    # 8.184039344


exit 0
</programlisting>
            </example>

	<para><anchor xml:id="cannonref" /></para>
            <example xml:id="cannon">
              <title>Calculating PI</title>
              <programlisting>#!/bin/bash
# cannon.sh: Approximating PI by firing cannonballs.

# Author: Mendel Cooper
# License: Public Domain
# Version 2.2, reldate 13oct08.

# This is a very simple instance of a "Monte Carlo" simulation:
#+ a mathematical model of a real-life event,
#+ using pseudorandom numbers to emulate random chance.

#  Consider a perfectly square plot of land, 10000 units on a side.
#  This land has a perfectly circular lake in its center,
#+ with a diameter of 10000 units.
#  The plot is actually mostly water, except for land in the four corners.
#  (Think of it as a square with an inscribed circle.)
#
#  We will fire iron cannonballs from an old-style cannon
#+ at the square.
#  All the shots impact somewhere on the square,
#+ either in the lake or on the dry corners.
#  Since the lake takes up most of the area,
#+ most of the shots will SPLASH! into the water.
#  Just a few shots will THUD! into solid ground
#+ in the four corners of the square.
#
#  If we take enough random, unaimed shots at the square,
#+ Then the ratio of SPLASHES to total shots will approximate
#+ the value of PI/4.
#
#  The simplified explanation is that the cannon is actually
#+ shooting only at the upper right-hand quadrant of the square,
#+ i.e., Quadrant I of the Cartesian coordinate plane.
#
#
#  Theoretically, the more shots taken, the better the fit.
#  However, a shell script, as opposed to a compiled language
#+ with floating-point math built in, requires some compromises.
#  This decreases the accuracy of the simulation.


DIMENSION=10000  # Length of each side of the plot.
                 # Also sets ceiling for random integers generated.

MAXSHOTS=1000    # Fire this many shots.
                 # 10000 or more would be better, but would take too long.
PMULTIPLIER=4.0  # Scaling factor.

declare -r M_PI=3.141592654
                 # Actual 9-place value of PI, for comparison purposes.

get_random ()
{
SEED=$(head -n 1 /dev/urandom | od -N 1 | awk '{ print $2 }')
RANDOM=$SEED                                  #  From "seeding-random.sh"
                                              #+ example script.
let "rnum = $RANDOM % $DIMENSION"             #  Range less than 10000.
echo $rnum
}

distance=        # Declare global variable.
hypotenuse ()    # Calculate hypotenuse of a right triangle.
{                # From "alt-bc.sh" example.
distance=$(bc -l &lt;&lt; EOF
scale = 0
sqrt ( $1 * $1 + $2 * $2 )
EOF
)
#  Setting "scale" to zero rounds down result to integer value,
#+ a necessary compromise in this script.
#  It decreases the accuracy of this simulation.
}


# ==========================================================
# main() {
# "Main" code block, mimicking a C-language main() function.

# Initialize variables.
shots=0
splashes=0
thuds=0
Pi=0
error=0

while [ "$shots" -lt  "$MAXSHOTS" ]           # Main loop.
do

  xCoord=$(get_random)                        # Get random X and Y coords.
  yCoord=$(get_random)
  hypotenuse $xCoord $yCoord                  #  Hypotenuse of
                                              #+ right-triangle = distance.
  ((shots++))

  printf "#%4d   " $shots
  printf "Xc = %4d  " $xCoord
  printf "Yc = %4d  " $yCoord
  printf "Distance = %5d  " $distance         #   Distance from
                                              #+  center of lake
                                              #+  -- the "origin" --
                                              #+  coordinate (0,0).

  if [ "$distance" -le "$DIMENSION" ]
  then
    echo -n "SPLASH!  "
    ((splashes++))
  else
    echo -n "THUD!    "
    ((thuds++))
  fi

  Pi=$(echo "scale=9; $PMULTIPLIER*$splashes/$shots" | bc)
  # Multiply ratio by 4.0.
  echo -n "PI ~ $Pi"
  echo

done

echo
echo "After $shots shots, PI looks like approximately   $Pi"
#  Tends to run a bit high,
#+ possibly due to round-off error and imperfect randomness of $RANDOM.
#  But still usually within plus-or-minus 5% . . .
#+ a pretty fair rough approximation.
error=$(echo "scale=9; $Pi - $M_PI" | bc)
pct_error=$(echo "scale=2; 100.0 * $error / $M_PI" | bc)
echo -n "Deviation from mathematical value of PI =        $error"
echo " ($pct_error% error)"
echo

# End of "main" code block.
# }
# ==========================================================

exit 0

#  One might well wonder whether a shell script is appropriate for
#+ an application as complex and computation-intensive as a simulation.
#
#  There are at least two justifications.
#  1) As a proof of concept: to show it can be done.
#  2) To prototype and test the algorithms before rewriting
#+    it in a compiled high-level language.
</programlisting>
            </example>

	<para>See also <xref linkend="stddev" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="dcref" /><command moreinfo="none">dc</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dc</secondary>
	  </indexterm>

	    <para>The <command>dc</command> (<command>d</command>esk
              <command>c</command>alculator) utility is <link linkend="stackdefref">stack-oriented</link>
              and uses RPN (<firstterm>Reverse Polish Notation</firstterm>).
              Like <command>bc</command>, it has much of the power of
              a programming language.</para>

            <para>Similar to the procedure with <command>bc</command>,
	      <link linkend="echoref">echo</link> a command-string
	      to <command>dc</command>.</para>

             <para>
		     <programlisting>echo "[Printing a string ... ]P" | dc
# The P command prints the string between the preceding brackets.

# And now for some simple arithmetic.
echo "7 8 * p" | dc     # 56
#  Pushes 7, then 8 onto the stack,
#+ multiplies ("*" operator), then prints the result ("p" operator).</programlisting>
             </para>

              <para>Most persons avoid <command>dc</command>, because
                of its non-intuitive input and rather cryptic
		operators. Yet, it has its uses.</para>

            <example xml:id="hexconvert">
              <title>Converting a decimal number to hexadecimal</title>
              <programlisting>#!/bin/bash
# hexconvert.sh: Convert a decimal number to hexadecimal.

E_NOARGS=85 # Command-line arg missing.
BASE=16     # Hexadecimal.

if [ -z "$1" ]
then        # Need a command-line argument.
  echo "Usage: $0 number"
  exit $E_NOARGS
fi          # Exercise: add argument validity checking.


hexcvt ()
{
if [ -z "$1" ]
then
  echo 0
  return    # "Return" 0 if no arg passed to function.
fi

echo ""$1" "$BASE" o p" | dc
#                  o    sets radix (numerical base) of output.
#                    p  prints the top of stack.
# For other options: 'man dc' ...
return
}

hexcvt "$1"

exit
</programlisting>
            </example>

	      <para>Studying the <link linkend="inforef">info</link> page for
		<command>dc</command> is a painful path to understanding its
		intricacies. There seems to be a small, select group of
		<emphasis>dc wizards</emphasis> who delight in showing off
		their mastery of this powerful, but arcane utility.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq" | dc</userinput>
<computeroutput>Bash</computeroutput>
	      </screen>
	  </para>

	  <para><anchor xml:id="goldenratio" />
          <programlisting>dc &lt;&lt;&lt; 10k5v1+2/p # 1.6180339887
#  ^^^            Feed operations to dc using a Here String.
#      ^^^        Pushes 10 and sets that as the precision (10k).
#         ^^      Pushes 5 and takes its square root
#                 (5v, v = square root).
#           ^^    Pushes 1 and adds it to the running total (1+).
#             ^^  Pushes 2 and divides the running total by that (2/).
#               ^ Pops and prints the result (p)
#  The result is  1.6180339887 ...
#  ... which happens to be the Pythagorean Golden Ratio, to 10 places.</programlisting>
	  </para>

            <example xml:id="factr">
              <title>Factoring</title>
              <programlisting>#!/bin/bash
# factr.sh: Factor a number

MIN=2       # Will not work for number smaller than this.
E_NOARGS=85
E_TOOSMALL=86

if [ -z $1 ]
then
  echo "Usage: $0 number"
  exit $E_NOARGS
fi

if [ "$1" -lt "$MIN" ]
then
  echo "Number to factor must be $MIN or greater."
  exit $E_TOOSMALL
fi  

# Exercise: Add type checking (to reject non-integer arg).

echo "Factors of $1:"
# -------------------------------------------------------
echo  "$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=\
1lrli2+dsi!&gt;.]ds.xd1&lt;2" | dc
# -------------------------------------------------------
#  Above code written by Michel Charpentier &lt;charpov@cs.unh.edu&gt;
#  (as a one-liner, here broken into two lines for display purposes).
#  Used in ABS Guide with permission (thanks!).

 exit

 # $ sh factr.sh 270138
 # 2
 # 3
 # 11
 # 4093
</programlisting>
            </example>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="awkmath" /><command moreinfo="none">awk</command></term>
	  <listitem>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>math</secondary>
	  </indexterm>
	    <para>Yet another way of doing floating point math in
	      a script is using <link linkend="awkref">awk's</link>
	      built-in math functions in a <link linkend="shwrapper">shell
	      wrapper</link>.</para>

            <example xml:id="hypot">
              <title>Calculating the hypotenuse of a triangle</title>
              <programlisting>#!/bin/bash
# hypotenuse.sh: Returns the "hypotenuse" of a right triangle.
#                (square root of sum of squares of the "legs")

ARGS=2                # Script needs sides of triangle passed.
E_BADARGS=85          # Wrong number of arguments.

if [ $# -ne "$ARGS" ] # Test number of arguments to script.
then
  echo "Usage: `basename $0` side_1 side_2"
  exit $E_BADARGS
fi


AWKSCRIPT=' { printf( "%3.7f\n", sqrt($1*$1 + $2*$2) ) } '
#             command(s) / parameters passed to awk


# Now, pipe the parameters to awk.
    echo -n "Hypotenuse of $1 and $2 = "
    echo $1 $2 | awk "$AWKSCRIPT"
#   ^^^^^^^^^^^^
# An echo-and-pipe is an easy way of passing shell parameters to awk.

exit

# Exercise: Rewrite this script using 'bc' rather than awk.
#           Which method is more intuitive?
</programlisting>
            </example>

	  </listitem>
	</varlistentry>

       </variablelist>	

	</section> <!-- End Math Commands -->


      <section xml:id="extmisc">
        <title>Miscellaneous Commands</title>

       <variablelist xml:id="misccommandlisting">	
         <title><anchor xml:id="misccommandlisting1" />Command that fit in no
	   special category</title>

	<varlistentry>
	  <term><anchor xml:id="jotref" /><command moreinfo="none">jot</command></term>
	  <term><anchor xml:id="seqref" /><command moreinfo="none">seq</command></term>
	  <listitem>
	  <indexterm>
	    <primary>jot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>seq</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>arguments</secondary>
	  </indexterm>
	    <para>These utilities emit a sequence of integers, with a
	      user-selectable increment.</para>

	    <para>The default separator character between each integer is a
	      newline, but this can be changed with the <option>-s</option>
	      option.</para>
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>seq 5</userinput>
<computeroutput>1
 2
 3
 4
 5</computeroutput>



<prompt>bash$ </prompt><userinput>seq -s : 5</userinput>
<computeroutput>1:2:3:4:5</computeroutput>
	      </screen>
	    </para>
	      
	      
	    <para>Both <command>jot</command> and <command>seq</command>
	      come in handy in a <link linkend="forloopref1">for
	      loop</link>.</para>

	    <example xml:id="ex53">
	      <title>Using <firstterm>seq</firstterm> to generate loop
	      arguments</title>
	      <programlisting>#!/bin/bash
# Using "seq"

echo

for a in `seq 80`  # or   for a in $( seq 80 )
# Same as   for a in 1 2 3 4 5 ... 80   (saves much typing!).
# May also use 'jot' (if present on system).
do
  echo -n "$a "
done      # 1 2 3 4 5 ... 80
# Example of using the output of a command to generate 
# the [list] in a "for" loop.

echo; echo


COUNT=80  # Yes, 'seq' also accepts a replaceable parameter.

for a in `seq $COUNT`  # or   for a in $( seq $COUNT )
do
  echo -n "$a "
done      # 1 2 3 4 5 ... 80

echo; echo

BEGIN=75
END=80

for a in `seq $BEGIN $END`
#  Giving "seq" two arguments starts the count at the first one,
#+ and continues until it reaches the second.
do
  echo -n "$a "
done      # 75 76 77 78 79 80

echo; echo

BEGIN=45
INTERVAL=5
END=80

for a in `seq $BEGIN $INTERVAL $END`
#  Giving "seq" three arguments starts the count at the first one,
#+ uses the second for a step interval,
#+ and continues until it reaches the third.
do
  echo -n "$a "
done      # 45 50 55 60 65 70 75 80

echo; echo

exit 0
</programlisting>
	    </example>	    	   

	    <para>A simpler example:</para>

	<para><programlisting>#  Create a set of 10 files,
#+ named file.1, file.2 . . . file.10.
COUNT=10
PREFIX=file

for filename in `seq $COUNT`
do
  touch $PREFIX.$filename
  #  Or, can do other operations,
  #+ such as rm, grep, etc.
done</programlisting></para>

	    <example xml:id="lettercount">
	      <title>Letter Count"</title>
	      <programlisting>#!/bin/bash
# letter-count.sh: Counting letter occurrences in a text file.
# Written by Stefano Palmeri.
# Used in ABS Guide with permission.
# Slightly modified by document author.

MINARGS=2          # Script requires at least two arguments.
E_BADARGS=65
FILE=$1

let LETTERS=$#-1   # How many letters specified (as command-line args).
                   # (Subtract 1 from number of command-line args.)


show_help(){
	   echo
           echo Usage: `basename $0` file letters  
           echo Note: `basename $0` arguments are case sensitive.
           echo Example: `basename $0` foobar.txt G n U L i N U x.
	   echo
}

# Checks number of arguments.
if [ $# -lt $MINARGS ]; then
   echo
   echo "Not enough arguments."
   echo
   show_help
   exit $E_BADARGS
fi  


# Checks if file exists.
if [ ! -f $FILE ]; then
    echo "File \"$FILE\" does not exist."
    exit $E_BADARGS
fi



# Counts letter occurrences .
for n in `seq $LETTERS`; do
      shift
      if [[ `echo -n "$1" | wc -c` -eq 1 ]]; then             #  Checks arg.
             echo "$1" -\&gt; `cat $FILE | tr -cd  "$1" | wc -c` #  Counting.
      else
             echo "$1 is not a  single char."
      fi  
done

exit $?

#  This script has exactly the same functionality as letter-count2.sh,
#+ but executes faster.
#  Why?
</programlisting>
	    </example>	    	   

      <note>
      <para>Somewhat more capable than <firstterm>seq</firstterm>,
	<command>jot</command> is a classic UNIX
	utility that is not normally included in a standard Linux
	distro. However, the source <firstterm>rpm</firstterm>
	is available for download from the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.mit.edu/afs/athena/system/rhlinux/athena-9.0/free/SRPMS/athena-jot-9.0-3.src.rpm">
	MIT repository</link>.</para>

      <para><anchor xml:id="jotrandom" /></para>
      <para>Unlike <firstterm>seq</firstterm>, <command>jot</command> can
        generate a sequence of random numbers, using the <option>-r</option>
	option.</para>
	  <para><screen><prompt>bash$ </prompt><userinput>jot -r 3 999</userinput>
<computeroutput>1069
 1272
 1428</computeroutput></screen></para>
      </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="getopty" /><command moreinfo="none">getopt</command></term>
	  <listitem>
	  <indexterm>
	    <primary>getopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>option</secondary>
	  </indexterm>
	    <para>The <command>getopt</command> command
	      parses command-line options preceded by a <link linkend="dashref">dash</link>. This external command
	      corresponds to the <link linkend="getoptsx">getopts</link>
	      Bash builtin. Using <command>getopt</command> permits
	      handling long options by means of the <option>-l</option>
	      flag, and this also allows parameter reshuffling.</para>

	    <example xml:id="ex33a">
	      <title>Using <firstterm>getopt</firstterm> to parse command-line
	        options</title>
	      <programlisting>#!/bin/bash
# Using getopt

# Try the following when invoking this script:
#   sh ex33a.sh -a
#   sh ex33a.sh -abc
#   sh ex33a.sh -a -b -c
#   sh ex33a.sh -d
#   sh ex33a.sh -dXYZ
#   sh ex33a.sh -d XYZ
#   sh ex33a.sh -abcd
#   sh ex33a.sh -abcdZ
#   sh ex33a.sh -z
#   sh ex33a.sh a
# Explain the results of each of the above.

E_OPTERR=65

if [ "$#" -eq 0 ]
then   # Script needs at least one command-line argument.
  echo "Usage $0 -[options a,b,c]"
  exit $E_OPTERR
fi  

set -- `getopt "abcd:" "$@"`
# Sets positional parameters to command-line arguments.
# What happens if you use "$*" instead of "$@"?

while [ ! -z "$1" ]
do
  case "$1" in
    -a) echo "Option \"a\"";;
    -b) echo "Option \"b\"";;
    -c) echo "Option \"c\"";;
    -d) echo "Option \"d\" $2";;
     *) break;;
  esac

  shift
done

#  It is usually better to use the 'getopts' builtin in a script.
#  See "ex33.sh."

exit 0
</programlisting>
	    </example>

	    <note>
	    <para>As <emphasis>Peggy Russell</emphasis> points out:</para>
	    <para>It is often necessary to include an <link linkend="evalref">eval</link> to correctly process
              <link linkend="whitespaceref">whitespace</link> and
	      <firstterm>quotes</firstterm>.
	        <programlisting>args=$(getopt -o a:bc:d -- "$@")
eval set -- "$args"</programlisting></para>
	    </note>

	    <para>See <xref linkend="getoptsimple" /> for a simplified emulation
	      of <command>getopt</command>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="runpartsref" /><command moreinfo="none">run-parts</command></term>
	  <listitem>
	  <indexterm>
	    <primary>run-parts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>run-parts</secondary>
	  </indexterm>
	    <para>The <command>run-parts</command> command

		<footnote><para>This is actually a script adapted from
		the Debian Linux distribution.</para></footnote>
	      
	      executes all the scripts in a target directory, sequentially
	      in ASCII-sorted filename order. Of course, the scripts
	      need to have execute permission.</para>
	      
	    <para>The <link linkend="cronref">cron</link> <link linkend="daemonref">daemon</link> invokes
	      <command>run-parts</command> to run the scripts in
	      the <filename class="directory">/etc/cron.*</filename>
	      directories.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="yesref" /><command moreinfo="none">yes</command></term>
	  <listitem>
	  <indexterm>
	    <primary>yes</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>yes</secondary>
	  </indexterm>

	    <para>In its default behavior the <command>yes</command>
	      command feeds a continuous string of the character
	      <computeroutput>y</computeroutput> followed
	      by a line feed to <filename>stdout</filename>. A
	      <keycombo><keycap>control</keycap><keycap>C</keycap></keycombo>
	      terminates the run. A different output string
	      may be specified, as in <userinput>yes different
	      string</userinput>, which would continually output
	      <computeroutput>different string</computeroutput> to
	      <filename>stdout</filename>.</para>
	      
	    <para>One might well ask the purpose of this. From the
	      command-line or in a script, the output of
	      <command>yes</command> can be redirected or piped into a
	      program expecting user input. In effect, this becomes a sort
	      of poor man's version of <firstterm>expect</firstterm>.</para>

	    <para><userinput>yes | fsck /dev/hda1</userinput> runs
	      <command>fsck</command> non-interactively (careful!).</para>

	   <para><userinput>yes | rm -r dirname</userinput> has same effect as
	     <userinput>rm -rf dirname</userinput> (careful!).</para>

	   <warning><para>Caution advised when piping
	     <firstterm>yes</firstterm> to a potentially dangerous
	     system command, such as <link linkend="fsckref">fsck</link>
	     or <link linkend="fdiskref">fdisk</link>. It might have
	     unintended consequences.</para></warning>

           <note>
	     <para>The <firstterm>yes</firstterm> command parses variables,
	       or more accurately, it echoes parsed variables.
	       For example:</para>
	        <para>
	        <screen><prompt>bash$ </prompt><userinput>yes $BASH_VERSION</userinput>
<computeroutput>3.1.17(1)-release
 3.1.17(1)-release
 3.1.17(1)-release
 3.1.17(1)-release
 3.1.17(1)-release
 . . .</computeroutput>
	      </screen>
	        </para>

	     <para>
	       This particular <quote>feature</quote> may be used
	       to create a <emphasis>very large</emphasis> ASCII file on the fly:
	      <screen><prompt>bash$ </prompt><userinput>yes $PATH &gt; huge_file.txt</userinput>
<userinput>Ctl-C</userinput>	      
	      </screen>
	      Hit <userinput>Ctl-C</userinput> <emphasis>very
	      quickly</emphasis>, or you just might get more than you
	      bargained for. . . .
	      </para>
           </note>

	   <para><anchor xml:id="yesemu" />The <firstterm>yes</firstterm>
	     command may be emulated in a very simple script <link linkend="functionref">function</link>.</para>

	   <para><programlisting>yes ()
{ # Trivial emulation of "yes" ...
  local DEFAULT_TEXT="y"
  while [ true ]   # Endless loop.
  do
    if [ -z "$1" ]
    then
      echo "$DEFAULT_TEXT"
    else           # If argument ...
      echo "$1"    # ... expand and echo it.
    fi
  done             #  The only things missing are the
}                  #+ --help and --version options.</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="bannerref" /><command moreinfo="none">banner</command></term>
	  <listitem>
	  <indexterm>
	    <primary>banner</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>banner</secondary>
	  </indexterm>
	    <para>Prints arguments as a large vertical banner to
	      <filename>stdout</filename>, using an <link linkend="asciidef">ASCII</link> character (default
	      '#'). This may be redirected to a printer for
	      hardcopy.</para>

	    <para>Note that <firstterm>banner</firstterm> has been
               dropped from many Linux distros, presumably because it
               is no longer considered useful.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="printenvref" /><command moreinfo="none">printenv</command></term>
	  <listitem>
	  <indexterm>
	    <primary>printenv</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>environment</secondary>
	  </indexterm>
	    <para>Show all the <link linkend="envref">environmental
	      variables</link> set for a particular user.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>printenv | grep HOME</userinput>
<computeroutput>HOME=/home/bozo</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lpref" /><command moreinfo="none">lp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lpr</secondary>
	  </indexterm>
	    <para>The <command>lp</command> and <command>lpr</command>
	      commands send file(s) to the print queue, to be printed as
	      hard copy.

	      <footnote><para>The <firstterm>print queue</firstterm> is
	      the group of jobs <quote>waiting in line</quote> to be
	      printed.</para></footnote>

	      These commands trace the origin of their names to the
	      line printers of another era.
		<footnote><para>Large mechanical <firstterm>line
		printers</firstterm> printed a single
		line of type at a time onto joined
		sheets of <firstterm>greenbar</firstterm>
		paper, to the accompaniment of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.columbia.edu/cu/computinghistory/1403.html">a
		great deal of noise</link>. The hardcopy
		thusly printed was referred to as a
		<firstterm>printout</firstterm>.</para></footnote>
      
      </para>

	      <para><prompt>bash$ </prompt><userinput>lp file1.txt</userinput>
	        or <prompt>bash </prompt><userinput>lp
		&lt;file1.txt</userinput></para>

	      <para>It is often useful to pipe the formatted output from
	        <command>pr</command> to <command>lp</command>.</para>

	      <para><prompt>bash$ </prompt><userinput>pr -options file1.txt | lp</userinput>
	        </para>

	      <para>Formatting packages, such as <link linkend="groffref">groff</link> and
		<firstterm>Ghostscript</firstterm> may send their output
		directly to <command>lp</command>.</para>

	      <para><prompt>bash$ </prompt><userinput>groff -Tascii file.tr | lp</userinput>
	        </para>

	      <para><prompt>bash$ </prompt><userinput>gs -options | lp file.ps</userinput>
	        </para>

	      <para>Related commands are <command>lpq</command>, for viewing
	        the print queue, and <command>lprm</command>, for removing
		jobs from the print queue.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="teeref" /><command moreinfo="none">tee</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tee</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tee</secondary>
	  </indexterm>
	    <para>[UNIX borrows an idea from the plumbing trade.]</para>
	    <para>This is a redirection operator, but with a difference. Like the
	      plumber's <firstterm>tee,</firstterm> it permits <quote>siphoning
              off</quote> <emphasis>to a file </emphasis>the output of a command 
	      or commands within a pipe, but without affecting the result. This is
	      useful for printing an ongoing process to a file or paper, perhaps to
	      keep track of it for debugging purposes.</para>
	    
	    <screen>
                             (redirection)
                            |----&gt; to file
                            |
  ==========================|====================
  command ---&gt; command ---&gt; |tee ---&gt; command ---&gt; ---&gt; output of pipe
  ===============================================
	      </screen>


	    <para><programlisting>cat listfile* | sort | tee check.file | uniq &gt; result.file
#                      ^^^^^^^^^^^^^^   ^^^^    

#  The file "check.file" contains the concatenated sorted "listfiles,"
#+ before the duplicate lines are removed by 'uniq.'</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mkfiforef" /><command moreinfo="none">mkfifo</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mkfifo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkfifo</secondary>
	  </indexterm>
	    <para><anchor xml:id="namedpiperef" />This obscure command
	      creates a <firstterm>named pipe</firstterm>, a temporary
	      <firstterm>first-in-first-out buffer</firstterm> for
	      transferring data between processes.

		<footnote><para>For an excellent overview of this
		  topic, see Andy Vaught's article, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www2.linuxjournal.com/lj-issues/issue41/2156.html">Introduction
		  to Named Pipes</link>, in the September, 1997 issue of
		  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxjournal.com"><citetitle pubwork="journal">Linux
		  Journal</citetitle></link>.</para></footnote>

	      Typically, one process writes to the FIFO, and the other
	      reads from it. See <xref linkend="fifo" />.</para>

            <para>
	      <programlisting>#!/bin/bash
# This short script by Omair Eshkenazi.
# Used in ABS Guide with permission (thanks!).

mkfifo pipe1   # Yes, pipes can be given names.
mkfifo pipe2   # Hence the designation "named pipe."

(cut -d' ' -f1 | tr "a-z" "A-Z") &gt;pipe2 &lt;pipe1 &amp;
ls -l | tr -s ' ' | cut -d' ' -f3,9- | tee pipe1 |
cut -d' ' -f2 | paste - pipe2

rm -f pipe1
rm -f pipe2

# No need to kill background processes when script terminates (why not?).

exit $?

Now, invoke the script and explain the output:
sh mkfifo-example.sh

4830.tar.gz          BOZO
pipe1   BOZO
pipe2   BOZO
mkfifo-example.sh    BOZO
Mixed.msg BOZO</programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="pathchkref" /><command moreinfo="none">pathchk</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pathchk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pathchk</secondary>
	  </indexterm>
	    <para>This command checks the validity of a filename. If the
	      filename exceeds the maximum allowable length (255
	      characters) or one or more of the directories in
	      its path is not searchable, then an error message
	      results.</para>
	      
	    <para>Unfortunately, <command>pathchk</command> does
	      not return a recognizable error code, and it is therefore
	      pretty much useless in a script. Consider instead the
	      <link linkend="rtif">file test operators</link>.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="ddref" /><command moreinfo="none">dd</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dd</secondary>
	  </indexterm>
	    <para>Though this somewhat obscure and much feared
              <command>d</command>ata <command>d</command>uplicator
              command originated as a utility for exchanging
              data on magnetic tapes between UNIX minicomputers
              and IBM mainframes, it still has its uses.
              The <command>dd</command> command simply copies a
              file (or <filename>stdin/stdout</filename>), but with
              conversions. <anchor xml:id="ddconversions" />Possible conversions
              include ASCII/EBCDIC,
	        
		<footnote><para><acronym>EBCDIC</acronym> (pronounced
		  <quote>ebb-sid-ick</quote>) is an acronym for Extended
		  Binary Coded Decimal Interchange Code, an obsolete
                  IBM data format. A bizarre application of
                  the <option>conv=ebcdic</option> option of
                  <command>dd</command> is as a quick 'n easy, but not
                  very secure text file encoder.
		    <programlisting>cat $file | dd conv=swab,ebcdic &gt; $file_encrypted
# Encode (looks like gibberish).		    
# Might as well switch bytes (swab), too, for a little extra obscurity.

cat $file_encrypted | dd conv=swab,ascii &gt; $file_plaintext
# Decode.</programlisting>
                </para></footnote>

	      upper/lower case, swapping of byte pairs between input
	      and output, and skipping and/or truncating the head or
	      tail of the input file.</para>
	      
            <para>
	      <programlisting># Converting a file to all uppercase:

dd if=$filename conv=ucase &gt; $filename.uppercase
#                    lcase   # For lower case conversion</programlisting>
            </para>

	    <para><anchor xml:id="ddoptions" /></para>
            <para>Some basic options to <command>dd</command> are:
                <itemizedlist>
                   <listitem>
                      <para>if=INFILE</para>
		      <para>INFILE is the <firstterm>source</firstterm>
		        file.</para>
                   </listitem>
                   <listitem>
                      <para>of=OUTFILE</para>
		      <para>OUTFILE is the <firstterm>target</firstterm>
		        file, the file that will have the data written to it.</para>
                   </listitem>
                   <listitem>
                      <para>bs=BLOCKSIZE</para>
		      <para>This is the size of each block of data being read
		        and written, usually a power of 2.</para>
                   </listitem>
                   <listitem>
                      <para>skip=BLOCKS</para>
		      <para>How many blocks of data to skip in INFILE before
		        starting to copy. This is useful when the INFILE has
			<quote>garbage</quote> or garbled data in its
			header or when it is desirable to copy only a portion
			of the INFILE.</para>
                   </listitem>
                   <listitem>
                      <para>seek=BLOCKS</para>
		      <para>How many blocks of data to skip in OUTFILE before
		        starting to copy, leaving blank data at beginning
			of OUTFILE.</para>
                   </listitem>
                   <listitem>
                      <para>count=BLOCKS</para>
		      <para>Copy only this many blocks of data, rather than the
		        entire INFILE.</para>
                   </listitem>
                   <listitem>
                      <para>conv=CONVERSION</para>
		      <para>Type of conversion to be applied to INFILE data
                        before copying operation.</para>
                   </listitem>
                </itemizedlist>
            </para>

	    <para>A <userinput>dd --help</userinput> lists all the
	      options this powerful utility takes.</para>


	    <example xml:id="selfcopy">
	      <title>A script that copies itself</title>
	      <programlisting>#!/bin/bash
# self-copy.sh

# This script copies itself.

file_subscript=copy

dd if=$0 of=$0.$file_subscript 2&gt;/dev/null
# Suppress messages from dd:   ^^^^^^^^^^^

exit $?

#  A program whose only output is its own source code
#+ is called a "quine" per Willard Quine.
#  Does this script qualify as a quine?
</programlisting>
	    </example>

	    <example xml:id="exercisingdd">
	      <title>Exercising <firstterm>dd</firstterm></title>
	      <programlisting>#!/bin/bash
# exercising-dd.sh

# Script by Stephane Chazelas.
# Somewhat modified by ABS Guide author.

infile=$0           # This script.
outfile=log.txt     # Output file left behind.
n=8
p=11

dd if=$infile of=$outfile bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt; /dev/null
# Extracts characters n to p (8 to 11) from this script ("bash").

# ----------------------------------------------------------------

echo -n "hello vertical world" | dd cbs=1 conv=unblock 2&gt; /dev/null
# Echoes "hello vertical world" vertically downward.
# Why? A newline follows each character dd emits.

exit $?
</programlisting>
	    </example>


	    <para><anchor xml:id="ddkeystrokes" /></para>
	    <para>To demonstrate just how versatile <command>dd</command> is,
	     let's use it to capture keystrokes.</para>

	    <example xml:id="ddkeypress">
	      <title>Capturing Keystrokes</title>
	      <programlisting>#!/bin/bash
# dd-keypress.sh: Capture keystrokes without needing to press ENTER.


keypresses=4                      # Number of keypresses to capture.


old_tty_setting=$(stty -g)        # Save old terminal settings.

echo "Press $keypresses keys."
stty -icanon -echo                # Disable canonical mode.
                                  # Disable local echo.
keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)
# 'dd' uses stdin, if "if" (input file) not specified.

stty "$old_tty_setting"           # Restore old terminal settings.

echo "You pressed the \"$keys\" keys."

# Thanks, Stephane Chazelas, for showing the way.
exit 0
</programlisting>
	    </example>	    

	    <para><anchor xml:id="ddrandom" /></para>
	    <para>The <command>dd</command> command can do random access on a
	      data stream.

	        <programlisting>echo -n . | dd bs=1 seek=4 of=file conv=notrunc
#  The "conv=notrunc" option means that the output file
#+ will not be truncated.

# Thanks, S.C.</programlisting>
            </para>


	    <para><anchor xml:id="ddcopy" /></para>
	    <para>The <command>dd</command> command can copy raw data
	      and disk images to and from devices, such as floppies and
	      tape drives (<xref linkend="copycd" />). A common use is
	      creating boot floppies.</para>
             <para>
		<userinput>dd if=kernel-image of=/dev/fd0H1440</userinput>
             </para>

             <para>Similarly, <command>dd</command> can copy the entire
	       contents of a floppy, even one formatted with a
	       <quote>foreign</quote> OS, to the hard drive as an
	       image file.</para>
             <para>
		<userinput>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</userinput>
             </para>

	     <para><anchor xml:id="bfs" />Likewise, <command>dd</command>
             can create bootable flash drives and SD cards.</para>

     <para><userinput>dd if=image.iso of=/dev/sdb</userinput></para>

	    <para><anchor xml:id="rpsdcard01" /></para>
	    <example xml:id="rpsdcard">
		    <title>Preparing a bootable SD card for the
		    <emphasis>Raspberry Pi</emphasis></title>
	      <programlisting>#!/bin/bash
# rp.sdcard.sh
# Preparing an SD card with a bootable image for the Raspberry Pi.

# $1 = imagefile name
# $2 = sdcard (device file)
# Otherwise defaults to the defaults, see below.

DEFAULTbs=4M                                 # Block size, 4 mb default.
DEFAULTif="2013-07-26-wheezy-raspbian.img"   # Commonly used distro.
DEFAULTsdcard="/dev/mmcblk0"                 # May be different. Check!
ROOTUSER_NAME=root                           # Must run as root!
E_NOTROOT=81
E_NOIMAGE=82

username=$(id -nu)                           # Who is running this script?
if [ "$username" != "$ROOTUSER_NAME" ]
then
  echo "This script must run as root or with root privileges."
  exit $E_NOTROOT
fi

if [ -n "$1" ]
then
  imagefile="$1"
else
  imagefile="$DEFAULTif"
fi

if [ -n "$2" ]
then
  sdcard="$2"
else
  sdcard="$DEFAULTsdcard"
fi

if [ ! -e $imagefile ]
then
  echo "Image file \"$imagefile\" not found!"
  exit $E_NOIMAGE
fi

echo "Last chance to change your mind!"; echo
read -s -n1 -p "Hit a key to write $imagefile to $sdcard [Ctl-c to exit]."
echo; echo

echo "Writing $imagefile to $sdcard ..."
dd bs=$DEFAULTbs if=$imagefile of=$sdcard

exit $?

# Exercises:
# ---------
# 1) Provide additional error checking.
# 2) Have script autodetect device file for SD card (difficult!).
# 3) Have script sutodetect image file (*img) in $PWD.
</programlisting>
	    </example>	    

	     <para><anchor xml:id="ddswap" /></para>
             <para>
	      Other applications of <command>dd</command> include
	      initializing temporary swap files (<xref linkend="ex73" />)
	      and ramdisks (<xref linkend="ramdisk" />). It can even do a
	      low-level copy of an entire hard drive partition, although
	      this is not necessarily recommended.</para>

	    <para>People (with presumably nothing better to do with
	      their time) are constantly thinking of interesting
	      applications of <command>dd</command>.</para>

	    <para><anchor xml:id="ddfdel" /></para>
	    <example xml:id="blotout">
	      <title>Securely deleting a file</title>
	      <programlisting>#!/bin/bash
# blot-out.sh: Erase "all" traces of a file.

#  This script overwrites a target file alternately
#+ with random bytes, then zeros before finally deleting it.
#  After that, even examining the raw disk sectors by conventional methods
#+ will not reveal the original file data.

PASSES=7         #  Number of file-shredding passes.
                 #  Increasing this slows script execution,
                 #+ especially on large target files.
BLOCKSIZE=1      #  I/O with /dev/urandom requires unit block size,
                 #+ otherwise you get weird results.
E_BADARGS=70     #  Various error exit codes.
E_NOT_FOUND=71
E_CHANGED_MIND=72

if [ -z "$1" ]   # No filename specified.
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

file=$1

if [ ! -e "$file" ]
then
  echo "File \"$file\" not found."
  exit $E_NOT_FOUND
fi  

echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
read answer
case "$answer" in
[nN]) echo "Changed your mind, huh?"
      exit $E_CHANGED_MIND
      ;;
*)    echo "Blotting out file \"$file\".";;
esac


flength=$(ls -l "$file" | awk '{print $5}')  # Field 5 is file length.
pass_count=1

chmod u+w "$file"   # Allow overwriting/deleting the file.

echo

while [ "$pass_count" -le "$PASSES" ]
do
  echo "Pass #$pass_count"
  sync         # Flush buffers.
  dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
               # Fill with random bytes.
  sync         # Flush buffers again.
  dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
               # Fill with zeros.
  sync         # Flush buffers yet again.
  let "pass_count += 1"
  echo
done  


rm -f $file    # Finally, delete scrambled and shredded file.
sync           # Flush buffers a final time.

echo "File \"$file\" blotted out and deleted."; echo


exit 0

#  This is a fairly secure, if inefficient and slow method
#+ of thoroughly "shredding" a file.
#  The "shred" command, part of the GNU "fileutils" package,
#+ does the same thing, although more efficiently.

#  The file cannot not be "undeleted" or retrieved by normal methods.
#  However . . .
#+ this simple method would *not* likely withstand
#+ sophisticated forensic analysis.

#  This script may not play well with a journaled file system.
#  Exercise (difficult): Fix it so it does.



#  Tom Vier's "wipe" file-deletion package does a much more thorough job
#+ of file shredding than this simple script.
#     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2

#  For an in-depth analysis on the topic of file deletion and security,
#+ see Peter Gutmann's paper,
#+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
#       http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html
</programlisting>
	    </example>	    

	    <para>See also the <link linkend="ddlink">dd
	      thread</link> entry in the <link linkend="biblioref">bibliography</link>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="odref" /><command moreinfo="none">od</command></term>
	  <listitem>
	  <indexterm>
	    <primary>od</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>od</secondary>
	  </indexterm>
	    <para>The <command>od</command>, or <firstterm>octal
	      dump</firstterm> filter converts input (or files) to octal
	      (base-8) or other bases. This is useful for viewing or
	      processing binary data files or otherwise unreadable system
	      <link linkend="devfileref">device files</link>, such as
	      <filename>/dev/urandom</filename>, and as a filter for
	      binary data.</para>

	  <para>
	      <programlisting>head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
# Sample output: 1324725719, 3918166450, 2989231420, etc.

# From rnd.sh example script, by Stphane Chazelas</programlisting>
	  </para>
	      
	  <para>See also <xref linkend="seedingrandom" /> and <xref linkend="insertionsort" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="hexdumpref" /><command moreinfo="none">hexdump</command></term>
	  <listitem>
	  <indexterm>
	    <primary>hexdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hexadecimal</secondary>
	  </indexterm>
	    <para>Performs a hexadecimal, octal, decimal, or ASCII
	      dump of a binary file. This command is the rough equivalent
	      of <command>od</command>, above, but not nearly as
	      useful. May be used to view the contents of a binary file,
	      in combination with <link linkend="ddref">dd</link> and <link linkend="lessref">less</link>.</para>

	  <para>
	  <programlisting>dd if=/bin/ls | hexdump -C | less
# The -C option nicely formats the output in tabular form.</programlisting>
	    </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="objdumpref" /><command moreinfo="none">objdump</command></term>
	  <listitem>
	  <indexterm>
	    <primary>objdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>object binary dump</secondary>
	  </indexterm>
	    <para>Displays information about an object file or binary
	      executable in either hexadecimal form or as a disassembled
	      listing (with the <option>-d</option> option).</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>objdump -d /bin/ls</userinput>
<computeroutput>/bin/ls:     file format elf32-i386

 Disassembly of section .init:

 080490bc &lt;.init&gt;:
  80490bc:       55                      push   %ebp
  80490bd:       89 e5                   mov    %esp,%ebp
  . . .</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mcookieref" /><command moreinfo="none">mcookie</command></term>
	  <listitem>
	  <indexterm>
	    <primary>magic</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cookie</secondary>
	  </indexterm>

	    <para>This command generates a <quote>magic cookie,</quote> a
	      128-bit (32-character) pseudorandom hexadecimal number,
	      normally used as an authorization <quote>signature</quote>
	      by the X server. This also available for use in a script
	      as a <quote>quick 'n dirty</quote> random number.</para>

	    <para><programlisting>random000=$(mcookie)</programlisting></para>

	    <para>Of course, a script could use <link linkend="md5sumref">md5sum</link> for the same purpose.</para>

            <para><programlisting># Generate md5 checksum on the script itself.
random001=`md5sum $0 | awk '{print $1}'`
# Uses 'awk' to strip off the filename.</programlisting></para>

	    <para>The <command>mcookie</command> command gives yet another way
	      to generate a <quote>unique</quote> filename.</para>

	    <example xml:id="tempfilename">
	      <title>Filename generator</title>
	      <programlisting>#!/bin/bash
# tempfile-name.sh:  temp filename generator

BASE_STR=`mcookie`   # 32-character magic cookie.
POS=11               # Arbitrary position in magic cookie string.
LEN=5                # Get $LEN consecutive characters.

prefix=temp          #  This is, after all, a "temp" file.
                     #  For more "uniqueness," generate the
                     #+ filename prefix using the same method
                     #+ as the suffix, below.

suffix=${BASE_STR:POS:LEN}
                     #  Extract a 5-character string,
                     #+ starting at position 11.

temp_filename=$prefix.$suffix
                     # Construct the filename.

echo "Temp filename = "$temp_filename""

# sh tempfile-name.sh
# Temp filename = temp.e19ea

#  Compare this method of generating "unique" filenames
#+ with the 'date' method in ex51.sh.

exit 0
</programlisting>
	    </example>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="unitsref" /><command moreinfo="none">units</command></term>
	  <listitem>
	  <indexterm>
	    <primary>units</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>conversion</secondary>
	  </indexterm>
	    <para>This utility converts between different <firstterm>units
	      of measure</firstterm>. While normally invoked in interactive
	      mode, <command>units</command> may find use in a
	      script.</para>
	    <example xml:id="unitconversion">
	      <title>Converting meters to miles</title>
	      <programlisting>#!/bin/bash
# unit-conversion.sh
# Must have 'units' utility installed.


convert_units ()  # Takes as arguments the units to convert.
{
  cf=$(units "$1" "$2" | sed --silent -e '1p' | awk '{print $2}')
  # Strip off everything except the actual conversion factor.
  echo "$cf"
}  

Unit1=miles
Unit2=meters
cfactor=`convert_units $Unit1 $Unit2`
quantity=3.73

result=$(echo $quantity*$cfactor | bc)

echo "There are $result $Unit2 in $quantity $Unit1."

#  What happens if you pass incompatible units,
#+ such as "acres" and "miles" to the function?

exit 0

# Exercise: Edit this script to accept command-line parameters,
#           with appropriate error checking, of course.
</programlisting>
	    </example>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="m4ref" /><command moreinfo="none">m4</command></term>
	  <listitem>
	  <indexterm>
	    <primary>m4</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>macro</secondary>
	  </indexterm>
	    <para>A hidden treasure, <command>m4</command> is a
	      powerful macro
		 <footnote><para>A <firstterm>macro</firstterm> is a
		 symbolic constant that expands into a command string
		 or a set of operations on parameters. Simply put,
		 it's a shortcut or abbreviation.</para></footnote>
	      processing filter, virtually a complete language.
	      Although originally written as a pre-processor
	      for <firstterm>RatFor</firstterm>, <command>m4</command>
	      turned out to be useful as a stand-alone utility. In
	      fact, <command>m4</command> combines some of the
	      functionality of <link linkend="evalref">eval</link>,
	      <link linkend="trref">tr</link>, and <link linkend="awkref">awk</link>, in addition to its extensive
	      macro expansion facilities.</para>

	    <para>The April, 2002 issue of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxjournal.com"><citetitle pubwork="journal">Linux Journal</citetitle></link>
	      has a very nice article on <command>m4</command> and
	      its uses.</para>

	    <example xml:id="m4">
	      <title>Using <firstterm>m4</firstterm></title>
	      <programlisting>#!/bin/bash
# m4.sh: Using the m4 macro processor

# Strings
string=abcdA01
echo "len($string)" | m4                            #   7
echo "substr($string,4)" | m4                       # A01
echo "regexp($string,[0-1][0-1],\&amp;Z)" | m4      # 01Z

# Arithmetic
var=99
echo "incr($var)" | m4                              #  100
echo "eval($var / 3)" | m4                          #   33

exit
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="xmessageref" /><command moreinfo="none">xmessage</command></term>
	  <listitem>
	  <indexterm>
	    <primary>xmessage</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>macro</secondary>
	  </indexterm>
	    <para>This X-based variant of
              <link linkend="echoref">echo</link> pops up a message/query
	      window on the desktop.</para>
	    <para>
	      <programlisting>xmessage Left click to continue -button okay</programlisting>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="zenityref" /><command moreinfo="none">zenity</command></term>
	  <listitem>
	  <indexterm>
	    <primary>zenity</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>macro</secondary>
	  </indexterm>
	    <para>The
	      <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://freshmeat.net/projects/zenity">zenity</link>
	      utility is adept at displaying
	      <firstterm>GTK+</firstterm> dialog <link linkend="widgetref">widgets</link> and <link linkend="zenityref2">very suitable for scripting
	      purposes</link>.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="doexecref" /><command moreinfo="none">doexec</command></term>
	  <listitem>
	  <indexterm>
	    <primary>doexec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>executable arg list</secondary>
	  </indexterm>
	    <para>The <command>doexec</command> command enables passing
	      an arbitrary list of arguments to a <firstterm>binary
	      executable</firstterm>. In particular, passing
	      <parameter>argv[0]</parameter> (which corresponds to <link linkend="posparamref1">$0</link> in a script) lets the
	      executable be invoked by various names, and it can then
	      carry out different sets of actions, according to the name
	      by which it was called. What this amounts to is roundabout
	      way of passing options to an executable.</para>

	    <para>For example, the <filename class="directory">/usr/local/bin</filename> directory might
	      contain a binary called <quote>aaa</quote>.  Invoking
	      <command>doexec /usr/local/bin/aaa list</command>
	      would <emphasis>list</emphasis> all those files
	      in the current working directory beginning with an
	      <quote>a</quote>, while invoking (the same executable
	      with) <command>doexec /usr/local/bin/aaa delete </command>
	      would <emphasis>delete</emphasis> those files.</para>

            <note><para>The various behaviors of the executable
              must be defined within the code of the executable itself,
              analogous to something like the following in a shell script:
                <programlisting>case `basename $0` in
"name1" ) do_something;;
"name2" ) do_something_else;;
"name3" ) do_yet_another_thing;;
*       ) bail_out;;
esac</programlisting></para></note>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command moreinfo="none">dialog</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dialog</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dialog</secondary>
	  </indexterm>
	    <para>The <link linkend="dialogref">dialog</link> family of tools
	      provide a method of calling interactive
	      <quote>dialog</quote> boxes from a script. The more
	      elaborate variations of <command>dialog</command> --
	      <command>gdialog</command>, <command>Xdialog</command>,
	      and <command>kdialog</command> -- actually invoke X-Windows
	      <link linkend="widgetref">widgets</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="soxref" /><command moreinfo="none">sox</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sox</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sound</secondary>
	  </indexterm>

	    <para>The <command>sox</command>, or
	      <quote><command>so</command>und
	      e<command>x</command>change</quote> command plays and
	      performs transformations on sound files. In fact,
	      the <filename>/usr/bin/play</filename> executable
	      (now deprecated) is nothing but a shell wrapper for
	      <firstterm>sox</firstterm>.</para>

            <para>For example, <command>sox soundfile.wav
	      soundfile.au</command> changes a WAV sound file into a
	      (Sun audio format) AU sound file.</para>

            <para>Shell scripts are ideally suited for batch-processing
	      <command>sox</command> operations on
	      sound files. For examples, see the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://osl.iu.edu/~tveldhui/radio/"> Linux Radio
	      Timeshift HOWTO</link> and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://savannah.nongnu.org/projects/audiodo">MP3do
	      Project</link>.</para>

	  </listitem>
	</varlistentry>

      </variablelist>


        </section> <!-- End Miscellaneous Commands -->

  </chapter> <!-- External Filters, Programs and Commands -->



  <chapter xml:id="system">
    <title>System and Administrative Commands</title>


      <para>The startup and shutdown scripts in 
	<filename class="directory">/etc/rc.d</filename> illustrate the uses
	(and usefulness) of many of these comands. These are usually
	invoked by <firstterm>root</firstterm> and used for system
	maintenance or emergency filesystem repairs. Use with caution, as
	some of these commands may damage your system if misused.</para>

      <variablelist xml:id="usersgroups">
        <title><anchor xml:id="usersgroups1" />Users and Groups</title>

	<varlistentry>
	  <term><anchor xml:id="usersref" /><command moreinfo="none">users</command></term>
	  <listitem>
	  <indexterm>
	    <primary>users</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>users</secondary>
	  </indexterm>
	    <para>Show all logged on users. This is the approximate
	      equivalent of <command>who -q</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="groupscmdref" /><command moreinfo="none">groups</command></term>
	  <listitem>
	  <indexterm>
	    <primary>groups</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groups</secondary>
	  </indexterm>
	    <para>Lists the current user and the groups she belongs to.
	       This corresponds to the <link linkend="groupsref">$GROUPS</link> internal variable,
	       but gives the group names, rather than the numbers.</para>
	    <screen><prompt>bash$ </prompt><userinput>groups</userinput>
<computeroutput>bozita cdrom cdwriter audio xgrp</computeroutput>

<prompt>bash$ </prompt><userinput>echo $GROUPS</userinput>
<computeroutput>501</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="chownref" /><command moreinfo="none">chown</command></term>
	  <term><anchor xml:id="chgrpref" /><command moreinfo="none">chgrp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>chown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chown</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>chgrp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chgrp</secondary>
	  </indexterm>
	    <para>The <command>chown</command> command changes the
	      ownership of a file or files. This command is a useful
	      method that <firstterm>root</firstterm> can use to
	      shift file ownership from one user to another. An ordinary
	      user may not change the ownership of files, not even her
	      own files.
	         <footnote><para>This is the case on a Linux machine or a UNIX
		   system with disk quotas.</para></footnote>
	      </para>

	  <para>
	      <screen><prompt>root# </prompt><userinput>chown bozo *.txt</userinput>
<computeroutput />
	      </screen>
	    </para>

	    <para>The <command>chgrp</command> command changes the
	      <replaceable>group</replaceable> ownership of a file or
	      files. You must be owner of the file(s) as well as a member
	      of the destination group (or <firstterm>root</firstterm>)
	      to use this operation.
	      <programlisting>chgrp --recursive dunderheads *.data
#  The "dunderheads" group will now own all the "*.data" files
#+ all the way down the $PWD directory tree (that's what "recursive" means).
</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="useraddref" /><command moreinfo="none">useradd</command></term>
	  <term><command moreinfo="none">userdel</command></term>
	  <listitem>
	  <indexterm>
	    <primary>useradd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>useradd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>userdel</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>userdel</secondary>
	  </indexterm>
	    <para>The <command>useradd</command> administrative command
	      adds a user account to the system and creates a home
	      directory for that particular user, if so specified. The
	      corresponding <command>userdel</command> command removes
	      a user account from the system
		 <footnote><para>The <command>userdel</command> command
		   will fail if the particular user being deleted is
		   still logged on.</para></footnote>
	      and deletes associated files.</para>

	    <note><para>The <command>adduser</command> command is a synonym
	      for <command>useradd</command> and is usually a symbolic link to
	      it.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="usermodref" /><command moreinfo="none">usermod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>usermod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usermod</secondary>
	  </indexterm>
	    <para>Modify a user account. Changes may be made to the password,
	      group membership, expiration date, and other attributes of
	      a given user's account. With this command, a user's password
	      may be locked, which has the effect of disabling the
	      account.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="groupmodref" /><command moreinfo="none">groupmod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>groupmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>group</secondary>
	  </indexterm>
	    <para>Modify a given group. The group name and/or ID number may be
	      changed using this command.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="idref" /><command moreinfo="none">id</command></term>
	  <listitem>
	  <indexterm>
	    <primary>id</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>id</secondary>
	  </indexterm>

	    <para>The <command>id</command> command lists the real and
	      effective user IDs and the group IDs of the user
	      associated with the current process. This is the
	      counterpart to the <link linkend="uidref">$UID</link>,
	      <link linkend="euidref">$EUID</link>, and <link linkend="groupsref">$GROUPS</link> internal Bash
	      variables.</para>

	    <screen><prompt>bash$ </prompt><userinput>id</userinput>
<computeroutput>uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</computeroutput>

<prompt>bash$ </prompt><userinput>echo $UID</userinput>
<computeroutput>501</computeroutput></screen>

	    <note><para>The <command>id</command> command shows the
	      <emphasis>effective</emphasis> IDs only when they differ
	      from the <emphasis>real</emphasis> ones.</para></note>

            <para>Also see <xref linkend="amiroot" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lidref" /><command moreinfo="none">lid</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lid</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>group</secondary>
	  </indexterm>
	    <para>The <firstterm>lid</firstterm> (list ID) command
	      shows the group(s) that a given user belongs to, or alternately,
	      the users belonging to a given group. May be invoked only by
	      root.</para>
	  <para>
	      <screen><prompt>root# </prompt><userinput>lid bozo</userinput>
<computeroutput> bozo(gid=500)</computeroutput>


<prompt>root# </prompt><userinput>lid daemon</userinput>
<computeroutput> bin(gid=1)
  daemon(gid=2)
  adm(gid=4)
  lp(gid=7)</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="whoref" /><command moreinfo="none">who</command></term>
	  <listitem>
	  <indexterm>
	    <primary>who</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whoami</secondary>
	  </indexterm>

	    <para>Show all users logged on to the system.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>who</userinput>
<computeroutput>bozo  tty1     Apr 27 17:45
 bozo  pts/0    Apr 27 17:46
 bozo  pts/1    Apr 27 17:47
 bozo  pts/2    Apr 27 17:49
</computeroutput>
	      </screen>
	    </para>

	    <para>The <option>-m</option> gives detailed information about
	      only the current user. Passing any two arguments to
	      <command>who</command> is the equivalent of <command>who
	      -m</command>, as in <command>who am i</command> or <command>who
	      The Man</command>.</para> 
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>who -m</userinput>
<computeroutput>localhost.localdomain!bozo  pts/2    Apr 27 17:49</computeroutput>
	      </screen>
	    </para>


	    <para><anchor xml:id="whoamiref" /><command>whoami</command> is similar to <command>who
	      -m</command>, but only lists the user name.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>whoami</userinput>
<computeroutput>bozo</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="wref" /><command moreinfo="none">w</command></term>
	  <listitem>
	  <indexterm>
	    <primary>w</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>w</secondary>
	  </indexterm>
	    <para>Show all logged on users and the processes belonging to them. This is
	      an extended version of <command>who</command>. The output of <command>w</command>
	      may be piped to <link linkend="grepref">grep</link> to find
	      a specific user and/or process.</para>

	    <screen><prompt>bash$ </prompt><userinput>w | grep startx</userinput>
<computeroutput>bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lognameref" /><command moreinfo="none">logname</command></term>
	  <listitem>
	  <indexterm>
	    <primary>logname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logname</secondary>
	  </indexterm>

	    <para>Show current user's login name (as found in
	      <filename>/var/run/utmp</filename>). This is a
	      near-equivalent to <link linkend="whoamiref">whoami</link>,
	      above.</para>

	    <screen><prompt>bash$ </prompt><userinput>logname</userinput>
<computeroutput>bozo</computeroutput>

<prompt>bash$ </prompt><userinput>whoami</userinput>
<computeroutput>bozo</computeroutput></screen>	    

            <para>However . . .</para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>su</userinput>
<computeroutput>Password: ......</computeroutput>

<prompt>bash# </prompt><userinput>whoami</userinput>
<computeroutput>root</computeroutput>
<prompt>bash# </prompt><userinput>logname</userinput>
<computeroutput>bozo</computeroutput></screen>	    
	    </para>

	      
	    <note><para>While <command>logname</command> prints the name
	      of the logged in user, <command>whoami</command> gives the
	      name of the user attached to the current process. As we have
	      just seen, sometimes these are not the same.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="suref" /><command moreinfo="none">su</command></term>
	  <listitem>
	  <indexterm>
	    <primary>su</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>su</secondary>
	  </indexterm>
	    <para>Runs a program or script as a
	      <command>s</command>ubstitute <command>u</command>ser.
	      <command>su rjones</command> starts a shell as user
	      <emphasis>rjones</emphasis>. A naked <command>su</command>
	      defaults to <firstterm>root</firstterm>.  See <xref linkend="fifo" />.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sudoref" /><command moreinfo="none">sudo</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sudo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sudo</secondary>
	  </indexterm>
	    <para>Runs a command as <firstterm>root</firstterm> (or
	      another user). This may be used in a script, thus permitting
	      a <firstterm>regular user</firstterm> to run the script.</para>

	      <para><programlisting>#!/bin/bash

# Some commands.
sudo cp /root/secretfile /home/bozo/secret
# Some more commands.</programlisting></para>
	    
	    <para>The file <filename>/etc/sudoers</filename> holds
	      the names of users permitted to invoke
	      <command>sudo</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="passwdref" /><command moreinfo="none">passwd</command></term>
	  <listitem>
	  <indexterm>
	    <primary>passwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>password</secondary>
	  </indexterm>

	    <para>Sets, changes, or manages a user's password.</para>

	    <para>The <command>passwd</command> command can be used in
	      a script, but probably <emphasis>should not</emphasis> be.</para>

	    <example xml:id="setnewpw">
	      <title>Setting a new password</title>
	      <programlisting>#!/bin/bash
#  setnew-password.sh: For demonstration purposes only.
#                      Not a good idea to actually run this script.
#  This script must be run as root.

ROOT_UID=0         # Root has $UID 0.
E_WRONG_USER=65    # Not root?

E_NOSUCHUSER=70
SUCCESS=0


if [ "$UID" -ne "$ROOT_UID" ]
then
  echo; echo "Only root can run this script."; echo
  exit $E_WRONG_USER
else
  echo
  echo "You should know better than to run this script, root."
  echo "Even root users get the blues... "
  echo
fi  


username=bozo
NEWPASSWORD=security_violation

# Check if bozo lives here.
grep -q "$username" /etc/passwd
if [ $? -ne $SUCCESS ]
then
  echo "User $username does not exist."
  echo "No password changed."
  exit $E_NOSUCHUSER
fi  

echo "$NEWPASSWORD" | passwd --stdin "$username"
#  The '--stdin' option to 'passwd' permits
#+ getting a new password from stdin (or a pipe).

echo; echo "User $username's password changed!"

# Using the 'passwd' command in a script is dangerous.

exit 0
</programlisting>
	    </example>

            <para>The <command>passwd</command> command's <option>-l</option>,
	      <option>-u</option>, and <option>-d</option> options permit
	      locking, unlocking, and deleting a user's password. Only
	      <firstterm>root</firstterm> may use these options.</para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="acref" /><command moreinfo="none">ac</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>accounting</secondary>
	  </indexterm>
	    <para>Show users' logged in time, as read from
	      <filename>/var/log/wtmp</filename>. This is one of the GNU
	      accounting utilities.</para>
	    <screen><prompt>bash$ </prompt><userinput>ac</userinput>
<computeroutput>        total       68.08</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lastref" /><command moreinfo="none">last</command></term>
	  <listitem>
	  <indexterm>
	    <primary>last</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logged in</secondary>
	  </indexterm>

	    <para>List <emphasis>last</emphasis> logged in users, as read from
	      <filename>/var/log/wtmp</filename>. This command can also
	      show remote logins.</para>

            <para>For example, to show the last few times the system
	      rebooted:</para>

	    <screen><prompt>bash$ </prompt><userinput>last reboot</userinput>
<computeroutput>reboot   system boot  2.6.9-1.667      Fri Feb  4 18:18          (00:02)    
 reboot   system boot  2.6.9-1.667      Fri Feb  4 15:20          (01:27)    
 reboot   system boot  2.6.9-1.667      Fri Feb  4 12:56          (00:49)    
 reboot   system boot  2.6.9-1.667      Thu Feb  3 21:08          (02:17)    
 . . .

 wtmp begins Tue Feb  1 12:50:09 2005</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="newgrpref" /><command moreinfo="none">newgrp</command></term>
	  <listitem>
	  <indexterm>
	    <primary>newgrp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>group</secondary>
	  </indexterm>
	    <para>Change user's <firstterm>group ID</firstterm> without
	      logging out. This permits access to the new group's
	      files. Since users may be members of multiple groups
	      simultaneously, this command finds only limited use.</para>

            <note><para>Kurt Glaesemann points out that the
	      <firstterm>newgrp</firstterm> command could prove helpful
	      in setting the default group permissions for files a user
	      writes. However, the <link linkend="chgrpref">chgrp</link>
	      command might be more convenient for this purpose.</para></note>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="terminalssys">
        <title><anchor xml:id="terminalssys1" />Terminals</title>

	<varlistentry>
	  <term><anchor xml:id="ttyref" /><command moreinfo="none">tty</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tty</secondary>
	  </indexterm>
	    <para>Echoes the name (filename) of the current user's terminal.
	      Note that each separate <firstterm>xterm</firstterm>
	      window counts as a different terminal.</para>
	    <screen><prompt>bash$ </prompt><userinput>tty</userinput>
<computeroutput>/dev/pts/1</computeroutput></screen>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sttyref" /><command moreinfo="none">stty</command></term>
	  <listitem>
	  <indexterm>
	    <primary>stty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>stty</secondary>
	  </indexterm>
	    <para>Shows and/or changes terminal settings. This complex
	      command, used in a script, can control terminal behavior
	      and the way output displays. See the info page, and study
	      it carefully.</para>

	    <example xml:id="erase">
	      <title>Setting an <firstterm>erase</firstterm> character</title>
	      <programlisting>#!/bin/bash
# erase.sh: Using "stty" to set an erase character when reading input.

echo -n "What is your name? "
read name                      #  Try to backspace
                               #+ to erase characters of input.
                               #  Problems?
echo "Your name is $name."

stty erase '#'                 #  Set "hashmark" (#) as erase character.
echo -n "What is your name? "
read name                      #  Use # to erase last character typed.
echo "Your name is $name."

exit 0

# Even after the script exits, the new key value remains set.
# Exercise: How would you reset the erase character to the default value?
</programlisting>
	    </example>

	    <example xml:id="secretpw">
	      <title><firstterm>secret password</firstterm>:
	      Turning off terminal echoing </title>
	      <programlisting>#!/bin/bash
# secret-pw.sh: secret password

echo
echo -n "Enter password "
read passwd
echo "password is $passwd"
echo -n "If someone had been looking over your shoulder, "
echo "your password would have been compromised."

echo &amp;&amp; echo  # Two line-feeds in an "and list."


stty -echo    # Turns off screen echo.
#   May also be done with
#   read -sp passwd
#   A big Thank You to Leigh James for pointing this out.

echo -n "Enter password again "
read passwd
echo
echo "password is $passwd"
echo

stty echo     # Restores screen echo.

exit 0

# Do an 'info stty' for more on this useful-but-tricky command.
</programlisting>
	    </example>

	    <para>A creative use of <command>stty</command> is detecting a
	      user keypress (without hitting
	      <keycap>ENTER</keycap>).</para>

	    <example xml:id="keypress">
	      <title>Keypress detection</title>
	      <programlisting>#!/bin/bash
# keypress.sh: Detect a user keypress ("hot keys").

echo

old_tty_settings=$(stty -g)   # Save old settings (why?).
stty -icanon
Keypress=$(head -c1)          # or $(dd bs=1 count=1 2&gt; /dev/null)
                              # on non-GNU systems

echo
echo "Key pressed was \""$Keypress"\"."
echo

stty "$old_tty_settings"      # Restore old settings.

# Thanks, Stephane Chazelas.

exit 0
</programlisting>
	    </example>

	    <para>Also see <xref linkend="timeout" /> and <xref linkend="stopwatch" />.</para>


	    <para><anchor xml:id="terminalsref" /></para>
	    <sidebar><title>terminals and modes</title>

	    <para>Normally, a terminal works in the
	      <firstterm>canonical</firstterm> mode.  When a user hits a
	      key, the resulting character does not immediately go to
	      the program actually running in this terminal.  A buffer
	      local to the terminal stores keystrokes. When the user
	      hits the <keycap>ENTER</keycap> key, this sends all the
	      stored keystrokes to the program running.  There is even
	      a basic line editor inside the terminal.</para>

	    <para>
	        <screen><prompt>bash$ </prompt><userinput>stty -a</userinput>
<computeroutput>speed 9600 baud; rows 36; columns 96; line = 0;
 intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
 start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
 ...
 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</computeroutput>
                </screen>
	    </para>

            <para>Using canonical mode, it is possible to redefine the
              special keys for the local terminal line editor.

	        <screen>
<prompt>bash$ </prompt><userinput>cat &gt; filexxx</userinput>
<userinput>wha&lt;ctl-W&gt;I&lt;ctl-H&gt;foo bar&lt;ctl-U&gt;hello world&lt;ENTER&gt;</userinput>
<userinput>&lt;ctl-D&gt;</userinput>
<prompt>bash$ </prompt><userinput>cat filexxx</userinput>
<computeroutput>hello world</computeroutput>		
<prompt>bash$ </prompt><userinput>wc -c &lt; filexxx</userinput>
<computeroutput>12</computeroutput>		
                </screen>

              The process controlling the terminal receives only 12
              characters (11 alphabetic ones, plus a newline), although
              the user hit 26 keys.
            </para>

            <para>In non-canonical (<quote>raw</quote>) mode, every
              key hit (including special editing keys such as
              <keycap>ctl-H</keycap>) sends a character immediately to
              the controlling process.</para>


            <para>The Bash prompt disables both <option>icanon</option>
              and <option>echo</option>, since it replaces the basic
              terminal line editor with its own more elaborate one. For
              example, when you hit <keycap>ctl-A</keycap> at the Bash
              prompt, there's no <keycap>^A</keycap> echoed by the
              terminal, but Bash gets a <keycap>\1</keycap> character,
              interprets it, and moves the cursor to the begining of
              the line.</para>

	    <para><emphasis>Stphane Chazelas</emphasis></para>  

	    </sidebar>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="settermref" /><command moreinfo="none">setterm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>setterm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>

	    <para>Set certain terminal attributes. This command writes
	      to its terminal's <filename>stdout</filename> a string that
	      changes the behavior of that terminal.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>setterm -cursor off</userinput>
<computeroutput>bash$</computeroutput>
	      </screen>
	    </para>

	    <para>The <command>setterm</command> command can be used within a
	      script to change the appearance of text written to
	      <filename>stdout</filename>, although there are certainly
	      <link linkend="colorizingref">better tools</link> available
	      for this purpose.</para>

	    <para><programlisting>setterm -bold on
echo bold hello

setterm -bold off
echo normal hello</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="tsetref" /><command moreinfo="none">tset</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tset</secondary>
	  </indexterm>
	    <para>Show or initialize terminal settings. 
	      This is a less capable version of
	      <command>stty</command>.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>tset -r</userinput>
<computeroutput>Terminal type is xterm-xfree86.
 Kill is control-U (^U).
 Interrupt is control-C (^C).</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="setserialref" /><command moreinfo="none">setserial</command></term>
	  <listitem>
	  <indexterm>
	    <primary>setserial</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>serial</secondary>
	  </indexterm>

	    <para>Set or display serial port parameters. This command must be
	      run by <firstterm>root</firstterm> and is usually found in a
	      system setup script.</para>

	    <para><programlisting># From /etc/pcmcia/serial script:

IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`
setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="gettyref" /><command moreinfo="none">getty</command></term>
	  <term><anchor xml:id="agettyref" /><command moreinfo="none">agetty</command></term>
	  <listitem>
	  <indexterm>
	    <primary>getty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getty</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>agetty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>agetty</secondary>
	  </indexterm>
	    <para>The initialization process for a terminal uses
	      <command>getty</command> or <command>agetty</command>
	      to set it up for login by a user. These commands are not
	      used within user shell scripts. Their scripting counterpart
	      is <command>stty</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mesgref" /><command moreinfo="none">mesg</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mesg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mesg</secondary>
	  </indexterm>
	    <para>Enables or disables write access to the current user's
	      terminal.  Disabling access would prevent another user
	      on the network to <link linkend="writeref">write</link>
	      to the terminal.</para>

	    <tip><para>It can be quite annoying to have a message
	      about ordering pizza suddenly appear in the middle of
	      the text file you are editing. On a multi-user network,
	      you might therefore wish to disable write access to your
	      terminal when you need to avoid interruptions.</para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="wallref" /><command moreinfo="none">wall</command></term>
	  <listitem>
	  <indexterm>
	    <primary>wall</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wall</secondary>
	  </indexterm>
	    <para>This is an acronym for <quote><link linkend="writeref">write</link> all,</quote> i.e., sending
	      a message to all users at every terminal logged into the
	      network. It is primarily a system administrator's tool,
	      useful, for example, when warning everyone that the
	      system will shortly go down due to a problem (see <xref linkend="ex70" />).</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>wall System going down for maintenance in 5 minutes!</userinput>
<computeroutput>Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...

 System going down for maintenance in 5 minutes!</computeroutput>
	      </screen>
	    </para>

	    <note><para>If write access to a particular terminal has been
	      disabled with <command>mesg</command>, then
	      <command>wall</command> cannot send a message to
	      that terminal.</para></note>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="statisticssys">
        <title><anchor xml:id="statisticssys1" />Information and Statistics</title>

	<varlistentry>
	  <term><anchor xml:id="unameref" /><command moreinfo="none">uname</command></term>
	  <listitem>
	  <indexterm>
	    <primary>uname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uname</secondary>
	  </indexterm>
	    <para>Output system specifications (OS, kernel version,
	      etc.) to <filename>stdout</filename>.  Invoked with the
	      <option>-a</option> option, gives verbose system info
	      (see <xref linkend="ex41" />). The <option>-s</option>
	      option shows only the OS type.</para>

	    <screen><prompt>bash$ </prompt><userinput>uname</userinput>
<computeroutput>Linux</computeroutput>

<prompt>bash$ </prompt><userinput>uname -s</userinput>
<computeroutput>Linux</computeroutput>


<prompt>bash$ </prompt><userinput>uname -a</userinput>
<computeroutput>Linux iron.bozo 2.6.15-1.2054_FC5 #1 Tue Mar 14 15:48:33 EST 2006
 i686 i686 i386 GNU/Linux</computeroutput></screen>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="archref" /><command moreinfo="none">arch</command></term>
	  <listitem>
	  <indexterm>
	    <primary>arch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arch</secondary>
	  </indexterm>
	    <para>Show system architecture.
	      Equivalent to <command>uname -m</command>. See <xref linkend="casecmd" />.</para>
	    <screen><prompt>bash$ </prompt><userinput>arch</userinput>
<computeroutput>i686</computeroutput>

<prompt>bash$ </prompt><userinput>uname -m</userinput>
<computeroutput>i686</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lastcommref" /><command moreinfo="none">lastcomm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lastcomm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>last</secondary>
	  </indexterm>
	    <para>Gives information about previous commands, as stored
	      in the <filename>/var/account/pacct</filename> file. Command
	      name and user name can be specified by options. This is
	      one of the GNU accounting utilities.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lastlogref" /><command moreinfo="none">lastlog</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lastlog</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>last</secondary>
	  </indexterm>
	    <para>List the last login time of all system users. This
	      references the <filename>/var/log/lastlog</filename>
	      file.</para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>lastlog</userinput>
<computeroutput>root          tty1                      Fri Dec  7 18:43:21 -0700 2001
 bin                                     **Never logged in**
 daemon                                  **Never logged in**
 ...
 bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001</computeroutput>



<prompt>bash$ </prompt><userinput>lastlog | grep root</userinput>
<computeroutput>root          tty1                      Fri Dec  7 18:43:21 -0700 2001</computeroutput>
	      </screen>
	      </para>

	      <caution><para>This command will fail if the user invoking
		it does not have read permission for the
		<filename>/var/log/lastlog</filename> file.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lsofref" /><command moreinfo="none">lsof</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lsof</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lsof</secondary>
	  </indexterm>
	    <para>List open files. This command outputs a detailed
	      table of all currently open files and gives information
	      about their owner, size, the processes associated with
	      them, and more. Of course, <command>lsof</command> may
	      be piped to <link linkend="grepref">grep</link> and/or
	      <link linkend="awkref">awk</link> to parse and analyze
	      its results.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>lsof</userinput>
<computeroutput>COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
 init         1    root  mem    REG        3,5   30748    30303 /sbin/init
 init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
 init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
 cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
 ...</computeroutput>
	      </screen>
	    </para>

	    <para>The <command>lsof</command> command is a useful,
	      if complex administrative tool. If you are unable to
	      dismount a filesystem and get an error message that it is
	      still in use, then running <firstterm>lsof</firstterm> helps
	      determine which files are still open on that filesystem. The
	      <option>-i</option> option lists open network socket files,
	      and this can help trace intrusion or hack attempts.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>lsof -an -i tcp</userinput>
<computeroutput>COMMAND  PID USER  FD  TYPE DEVICE SIZE NODE NAME
 firefox 2330 bozo  32u IPv4   9956       TCP 66.0.118.137:57596-&gt;67.112.7.104:http ...
 firefox 2330 bozo  38u IPv4  10535       TCP 66.0.118.137:57708-&gt;216.79.48.24:http ...</computeroutput>
	      </screen>
	    </para>

	    <para>See <xref linkend="ipaddresses" /> for an effective use
              of <command>lsof</command>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="straceref" /><command moreinfo="none">strace</command></term>
	  <listitem>
	  <indexterm>
	    <primary>strace</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>trace</secondary>
	  </indexterm>
	    <para><command>S</command>ystem <command>trace</command>:
	      diagnostic and debugging tool for tracing <firstterm>system
	      calls</firstterm> and signals. This command and
	      <command>ltrace</command>, following, are useful for
	      diagnosing why a given program or package fails to
	      run . . . perhaps due to missing libraries or related
	      causes.</para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>strace df</userinput>
<computeroutput>execve("/bin/df", ["df"], [/* 45 vars */]) = 0
 uname({sys="Linux", node="bozo.localdomain", ...}) = 0
 brk(0)                                  = 0x804f5e4

 ...</computeroutput>
	    </screen>
	    </para>

	    <para>This is the Linux equivalent of
	      the Solaris <command>truss</command> command.</para> 

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="ltraceref" /><command moreinfo="none">ltrace</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ltrace</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>trace</secondary>
	  </indexterm>
	    <para><command>L</command>ibrary <command>trace</command>:
	      diagnostic and debugging tool that traces <firstterm>library calls</firstterm>
	      invoked by a given command.</para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>ltrace df</userinput>
<computeroutput>__libc_start_main(0x804a910, 1, 0xbfb589a4, 0x804fb70, 0x804fb68 &lt;unfinished ...&gt;
 setlocale(6, "")                                 = "en_US.UTF-8"
bindtextdomain("coreutils", "/usr/share/locale") = "/usr/share/locale"
textdomain("coreutils")                          = "coreutils"
__cxa_atexit(0x804b650, 0, 0, 0x8052bf0, 0xbfb58908) = 0
getenv("DF_BLOCK_SIZE")                          = NULL

 ...</computeroutput>
	    </screen>
	    </para>

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor xml:id="ncref" /><command moreinfo="none">nc</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nc</secondary>
	  </indexterm>

	    <para>The <command>nc</command> (<firstterm>netcat</firstterm>)
	      utility is a complete toolkit for connecting to and
	      listening to TCP and UDP ports. It is useful as a diagnostic
	      and testing tool and as a component in simple script-based HTTP
	      clients and servers.</para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>nc localhost.localdomain 25</userinput>
<computeroutput>220 localhost.localdomain ESMTP Sendmail 8.13.1/8.13.1;
 Thu, 31 Mar 2005 15:41:35 -0700</computeroutput></screen>
	    </para>

	    <para>A real-life <link linkend="netcatexample">usage
	      example</link>.</para>

            <example xml:id="iscan">
              <title>Checking a remote server for
              <firstterm>identd</firstterm></title>
              <programlisting>#! /bin/sh
## Duplicate DaveG's ident-scan thingie using netcat. Oooh, he'll be p*ssed.
## Args: target port [port port port ...]
## Hose stdout _and_ stderr together.
##
##  Advantages: runs slower than ident-scan, giving remote inetd less cause
##+ for alarm, and only hits the few known daemon ports you specify.
##  Disadvantages: requires numeric-only port args, the output sleazitude,
##+ and won't work for r-services when coming from high source ports.
# Script author: Hobbit &lt;hobbit@avian.org&gt;
# Used in ABS Guide with permission.

# ---------------------------------------------------
E_BADARGS=65       # Need at least two args.
TWO_WINKS=2        # How long to sleep.
THREE_WINKS=3
IDPORT=113         # Authentication "tap ident" port.
RAND1=999
RAND2=31337
TIMEOUT0=9
TIMEOUT1=8
TIMEOUT2=4
# ---------------------------------------------------

case "${2}" in
  "" ) echo "Need HOST and at least one PORT." ; exit $E_BADARGS ;;
esac

# Ping 'em once and see if they *are* running identd.
nc -z -w $TIMEOUT0 "$1" $IDPORT || \
{ echo "Oops, $1 isn't running identd." ; exit 0 ; }
#  -z scans for listening daemons.
#     -w $TIMEOUT = How long to try to connect.

# Generate a randomish base port.
RP=`expr $$ % $RAND1 + $RAND2`

TRG="$1"
shift

while test "$1" ; do
  nc -v -w $TIMEOUT1 -p ${RP} "$TRG" ${1} &lt; /dev/null &gt; /dev/null &amp;
  PROC=$!
  sleep $THREE_WINKS
  echo "${1},${RP}" | nc -w $TIMEOUT2 -r "$TRG" $IDPORT 2&gt;&amp;1
  sleep $TWO_WINKS

# Does this look like a lamer script or what . . . ?
# ABS Guide author comments: "Ain't really all that bad . . .
#+                            kinda clever, actually."

  kill -HUP $PROC
  RP=`expr ${RP} + 1`
  shift
done

exit $?

#  Notes:
#  -----

#  Try commenting out line 30 and running this script
#+ with "localhost.localdomain 25" as arguments.

#  For more of Hobbit's 'nc' example scripts,
#+ look in the documentation:
#+ the /usr/share/doc/nc-X.XX/scripts directory.
</programlisting>
            </example>

	    <para>
	      And, of course, there's Dr. Andrew Tridgell's notorious
	      one-line script in the BitKeeper Affair:
	        <programlisting>echo clone | nc thunk.org 5000 &gt; e2fsprogs.dat</programlisting>
	    </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="freeref" /><command moreinfo="none">free</command></term>
	  <listitem>
	  <indexterm>
	    <primary>free</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>free</secondary>
	  </indexterm>
	    <para>Shows memory and cache usage in tabular form. The
	      output of this command lends itself to parsing, using
	      <link linkend="grepref">grep</link>, <link linkend="awkref">awk</link> or <command>Perl</command>. The
	      <command>procinfo</command> command shows all the
	      information that <command>free</command> does, and much
	      more.</para>

	    <screen><prompt>bash$ </prompt><command>free</command>
<computeroutput>                total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</computeroutput></screen>

            <para>To show unused RAM memory:</para>
	    <screen><prompt>bash$ </prompt><command>free | grep Mem | awk '{ print $4 }'</command>
<computeroutput>1880</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="procinforef" /><command moreinfo="none">procinfo</command></term>
	  <listitem>
	  <indexterm>
	    <primary>procinfo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>procinfo</secondary>
	  </indexterm>
	    <para>Extract and list information and statistics from the
	      <link linkend="devprocref"><filename class="directory">/proc</filename>
	      pseudo-filesystem</link>. This gives a very extensive and
	      detailed listing.</para>

	    <screen><prompt>bash$ </prompt><userinput>procinfo | grep Bootup</userinput>
<computeroutput>Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829</computeroutput>
</screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lsdevref" /><command moreinfo="none">lsdev</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lsdev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>device</secondary>
	  </indexterm>
	    <para>List devices, that is, show installed hardware.</para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>lsdev</userinput>
<computeroutput>Device            DMA   IRQ  I/O Ports
 ------------------------------------------------
 cascade             4     2 
 dma                          0080-008f
 dma1                         0000-001f
 dma2                         00c0-00df
 fpu                          00f0-00ff
 ide0                     14  01f0-01f7 03f6-03f6
 ...</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="duref" /><command moreinfo="none">du</command></term>
	  <listitem>
	  <indexterm>
	    <primary>du</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>du</secondary>
	  </indexterm>
	    <para>Show (disk) file usage, recursively. Defaults to current
	      working directory, unless otherwise specified.</para>

	    <screen><prompt>bash$ </prompt><command>du -ach</command>
<computeroutput>1.0k    ./wi.sh
 1.0k    ./tst.sh
 1.0k    ./random.file
 6.0k    .
 6.0k    total</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="dfref" /><command moreinfo="none">df</command></term>
	  <listitem>
	  <indexterm>
	    <primary>df</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>df</secondary>
	  </indexterm>
	    <para>Shows filesystem usage in tabular form.</para>

	    <screen><prompt>bash$ </prompt><command>df</command>
<computeroutput>Filesystem           1k-blocks      Used Available Use% Mounted on
 /dev/hda5               273262     92607    166547  36% /
 /dev/hda8               222525    123951     87085  59% /home
 /dev/hda7              1408796   1075744    261488  80% /usr</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="dmesgref" /><command moreinfo="none">dmesg</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dmesg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dmesg</secondary>
	  </indexterm>
	    <para>Lists all system bootup messages to
	      <filename>stdout</filename>. Handy for debugging and
	      ascertaining which device drivers were installed
	      and which system interrupts in use. The output
	      of <command>dmesg</command> may, of course, be
	      parsed with <link linkend="grepref">grep</link>,
	      <link linkend="sedref">sed</link>, or <link linkend="awkref">awk</link> from within a script.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>dmesg | grep hda</userinput>
<computeroutput>Kernel command line: ro root=/dev/hda2
 hda: IBM-DLGA-23080, ATA DISK drive
 hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
 hda: hda1 hda2 hda3 &lt; hda5 hda6 hda7 &gt; hda4</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="statref" /><command moreinfo="none">stat</command></term>
	  <listitem>
	  <indexterm>
	    <primary>stat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>stat</secondary>
	  </indexterm>
	    <para>Gives detailed and verbose <emphasis>stat</emphasis>istics 
	      on a given file (even a directory or device file) or set
	      of files.</para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>stat test.cru</userinput>
<computeroutput>  File: "test.cru"
   Size: 49970        Allocated Blocks: 100          Filetype: Regular File
   Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
 Device:  3,8   Inode: 18185     Links: 1    
 Access: Sat Jun  2 16:40:24 2001
 Modify: Sat Jun  2 16:40:24 2001
 Change: Sat Jun  2 16:40:24 2001</computeroutput>
	      </screen>
	    </para>

	    <para>If the target file does not exist, <command>stat</command>
	      returns an error message.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>stat nonexistent-file</userinput>
<computeroutput>nonexistent-file: No such file or directory</computeroutput>
	      </screen>
	    </para>

	    <para>In a script, you can use <command>stat</command> to extract
	      information about files (and filesystems) and set variables
	      accordingly.</para>

	    <para>
	      <programlisting>#!/bin/bash
# fileinfo2.sh

# Per suggestion of Jol Bourquard and . . .
# http://www.linuxquestions.org/questions/showthread.php?t=410766


FILENAME=testfile.txt
file_name=$(stat -c%n "$FILENAME")   # Same as "$FILENAME" of course.
file_owner=$(stat -c%U "$FILENAME")
file_size=$(stat -c%s "$FILENAME")
#  Certainly easier than using "ls -l $FILENAME"
#+ and then parsing with sed.
file_inode=$(stat -c%i "$FILENAME")
file_type=$(stat -c%F "$FILENAME")
file_access_rights=$(stat -c%A "$FILENAME")

echo "File name:          $file_name"
echo "File owner:         $file_owner"
echo "File size:          $file_size"
echo "File inode:         $file_inode"
echo "File type:          $file_type"
echo "File access rights: $file_access_rights"

exit 0

sh fileinfo2.sh

File name:          testfile.txt
File owner:         bozo
File size:          418
File inode:         1730378
File type:          regular file
File access rights: -rw-rw-r--</programlisting>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="vmstatref" /><command moreinfo="none">vmstat</command></term>
	  <listitem>
	  <indexterm>
	    <primary>vmstat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>virtual memory</secondary>
	  </indexterm>
	    <para>Display virtual memory statistics.</para>
	    <para>
	    <screen><prompt>bash$ </prompt><userinput>vmstat</userinput>
<computeroutput>   procs                      memory    swap          io system         cpu
 r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
 0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89</computeroutput>
	    </screen>
	    </para>
  
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="uptimeref" /><command moreinfo="none">uptime</command></term>
	  <listitem>
	  <indexterm>
	    <primary>uptime</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uptime</secondary>
	  </indexterm>

	    <para>Shows how long the system has been running, along with
	      associated statistics.</para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>uptime</userinput>
<computeroutput>10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27</computeroutput></screen>
	    </para>

            <note><para>A <firstterm>load average</firstterm> of 1 or less
	      indicates that the system handles processes immediately. A load
	      average greater than 1 means that processes are being queued. When
	      the load average gets above 3 (on a single-core processor),
	      then system performance is significantly degraded.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="hnameref" /><command moreinfo="none">hostname</command></term>
	  <listitem>
	  <indexterm>
	    <primary>hostname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hostname</secondary>
	  </indexterm>

	    <para>Lists the system's host name. This command sets the host
	      name in an <filename class="directory">/etc/rc.d</filename>
	      setup script (<filename>/etc/rc.d/rc.sysinit</filename>
	      or similar).  It is equivalent to <command>uname
	      -n</command>,  and a counterpart to the <link linkend="hostnameref">$HOSTNAME</link> internal
	      variable.</para>

	    <screen><prompt>bash$ </prompt><userinput>hostname</userinput>
<computeroutput>localhost.localdomain</computeroutput>

<prompt>bash$ </prompt><userinput>echo $HOSTNAME</userinput>
<computeroutput>localhost.localdomain</computeroutput></screen>

	    <para>Similar to the <command>hostname</command> command are the
	      <command>domainname</command>,
	      <command>dnsdomainname</command>,
	      <command>nisdomainname</command>, and
	      <command>ypdomainname</command> commands. Use these to
	      display or set the system DNS or NIS/YP domain name. Various
	      options to <command>hostname</command> also perform these
	      functions.</para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="hostidref" /><command moreinfo="none">hostid</command></term>
	  <listitem>
	  <indexterm>
	    <primary>hostid</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>host id</secondary>
	  </indexterm>

	    <para>Echo a 32-bit hexadecimal numerical identifier for the
	      host machine.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>hostid</userinput>
<computeroutput>7f0100</computeroutput></screen>
	    </para>

	    <note>
	    <para>This command allegedly fetches a <quote>unique</quote>
	      serial number for a particular system. Certain
	      product registration procedures use this number
	      to brand a particular user license. Unfortunately,
	      <command>hostid</command> only returns the machine
	      network address in hexadecimal, with pairs of bytes
	      transposed.</para>

	    <para>The network address of a typical non-networked Linux
	      machine, is found in <filename>/etc/hosts</filename>.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>cat /etc/hosts</userinput>
<computeroutput>127.0.0.1               localhost.localdomain localhost</computeroutput>
</screen>
	    </para>

	    <para>As it happens, transposing the bytes of
	      <userinput>127.0.0.1</userinput>, we get
	      <userinput>0.127.1.0</userinput>, which translates in
	      hex to <userinput>007f0100</userinput>, the exact equivalent
	      of what <command>hostid</command> returns, above. There
	      exist only a few million other Linux machines with this
	      identical <firstterm>hostid</firstterm>.</para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sarref" /><command moreinfo="none">sar</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>system activity report</secondary>
	  </indexterm>
	    <para>Invoking <command>sar</command> (System Activity Reporter)
	      gives a very detailed rundown on system statistics. The
	      Santa Cruz Operation (<quote>Old</quote> SCO) released
	      <command>sar</command> as Open Source in June, 1999.</para>

	    <para>This command is not part of the base Linux distribution,
	      but may be obtained as part of the<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://perso.wanadoo.fr/sebastien.godard/">
	      sysstat utilities</link> package, written by <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:sebastien.godard@wanadoo.fr">Sebastien
	      Godard</link>.</para>

	    <screen>
<prompt>bash$ </prompt><userinput>sar</userinput>
<computeroutput>Linux 2.4.9 (brooks.seringas.fr) 	09/26/03

10:30:00          CPU     %user     %nice   %system   %iowait     %idle
10:40:00          all      2.21     10.90     65.48      0.00     21.41
10:50:00          all      3.36      0.00     72.36      0.00     24.28
11:00:00          all      1.12      0.00     80.77      0.00     18.11
Average:          all      2.23      3.63     72.87      0.00     21.27

14:32:30          LINUX RESTART

15:00:00          CPU     %user     %nice   %system   %iowait     %idle
15:10:00          all      8.59      2.40     17.47      0.00     71.54
15:20:00          all      4.07      1.00     11.95      0.00     82.98
15:30:00          all      0.79      2.94      7.56      0.00     88.71
Average:          all      6.33      1.70     14.71      0.00     77.26</computeroutput>
           </screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="readelfref" /><command moreinfo="none">readelf</command></term>
	  <listitem>
	  <indexterm>
	    <primary>elf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>statistics</secondary>
	  </indexterm>
	    <para>Show information and statistics about a designated
	      <firstterm>elf</firstterm> binary. This is part of the
	      <firstterm>binutils</firstterm> package.</para>
	    <screen><prompt>bash$ </prompt><userinput>readelf -h /bin/bash</userinput>
<computeroutput>ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
   Class:                             ELF32
   Data:                              2's complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   . . .</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="sizeref" /><command moreinfo="none">size</command></term>
	  <listitem>
	  <indexterm>
	    <primary>size</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>segment</secondary>
	  </indexterm>
	    <para>The <command>size [/path/to/binary]</command> command
	      gives the segment sizes of a binary executable or archive file.
	      This is mainly of use to programmers.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>size /bin/bash</userinput>
<computeroutput>   text    data     bss     dec     hex filename
  495971   22496   17392  535859   82d33 /bin/bash</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="syslog">
        <title><anchor xml:id="syslog1" />System Logs</title>

	<varlistentry>
	  <term><anchor xml:id="loggerref" /><command moreinfo="none">logger</command></term>
	  <listitem>
	  <indexterm>
	    <primary>logger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logger</secondary>
	  </indexterm>

	    <para>Appends a user-generated message to the system log
	      (<filename>/var/log/messages</filename>). You do not have
	      to be <firstterm>root</firstterm> to invoke
	      <command>logger</command>.</para>

            <para>
	      <programlisting>logger Experiencing instability in network connection at 23:10, 05/21.
# Now, do a 'tail /var/log/messages'.</programlisting></para>

            <para>By embedding a <command>logger</command> command in a script,
	      it is possible to write debugging information to
	      <filename>/var/log/messages</filename>.</para>

            <para><programlisting>logger -t $0 -i Logging at line "$LINENO".
# The "-t" option specifies the tag for the logger entry.
# The "-i" option records the process ID.

# tail /var/log/message
# ...
# Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.</programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="logrotateref" /><command moreinfo="none">logrotate</command></term>
	  <listitem>
	  <indexterm>
	    <primary>logrotate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logrotate</secondary>
	  </indexterm>

	    <para>This utility manages the system log files, rotating,
	      compressing, deleting, and/or e-mailing them, as appropriate.
	      This keeps the <filename class="directory">/var/log</filename>
	      from getting cluttered with old log files.
	      Usually <link linkend="cronref">cron</link> runs
	      <command>logrotate</command> on a daily basis.</para>

	     <para>Adding an appropriate entry to
	       <filename>/etc/logrotate.conf</filename> makes it possible
	       to manage personal log files, as well as system-wide
	       ones.</para>

	     <note><para>Stefano Falsetto has created <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gnu.org/software/rottlog/">rottlog</link>,
	     which he considers to be an improved version of
	     <command>logrotate</command>.</para></note>

	  </listitem>
	</varlistentry>
	
      </variablelist>


      <variablelist xml:id="jobcontrolsys">
        <title><anchor xml:id="jobcontrolsys1" />Job Control</title>

	<varlistentry>
	  <term><anchor xml:id="ppssref" /><command moreinfo="none">ps</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>

	    <para><replaceable>P</replaceable>rocess
	      <replaceable>S</replaceable>tatistics: lists currently
	      executing processes by owner and PID (process ID). This
	      is usually invoked with <option>ax</option> or
	      <option>aux</option> options,
	      and may be piped to <link linkend="grepref">grep</link>
	      or <link linkend="sedref">sed</link> to search for a
	      specific process (see <xref linkend="ex44" /> and <xref linkend="pidid" />).</para>

	    <screen><prompt>bash$ </prompt><userinput> ps ax | grep sendmail</userinput>
<computeroutput>295 ?	   S	  0:00 sendmail: accepting connections on port 25</computeroutput></screen>

	    <para>To display system processes in graphical <quote>tree</quote>
	      format: <command>ps afjx</command> or
	      <command>ps ax --forest</command>.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="pgrepref" /><command moreinfo="none">pgrep</command></term>
	  <term><anchor xml:id="pkillref" /><command moreinfo="none">pkill</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pgrep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process grep</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pkill</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process kill</secondary>
	  </indexterm>

	    <para>Combining the <command>ps</command> command
	      with <link linkend="grepref">grep</link> or
	      <link linkend="killref">kill</link>.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>ps a | grep mingetty</userinput>
<computeroutput>2212 tty2     Ss+    0:00 /sbin/mingetty tty2
 2213 tty3     Ss+    0:00 /sbin/mingetty tty3
 2214 tty4     Ss+    0:00 /sbin/mingetty tty4
 2215 tty5     Ss+    0:00 /sbin/mingetty tty5
 2216 tty6     Ss+    0:00 /sbin/mingetty tty6
 4849 pts/2    S+     0:00 grep mingetty</computeroutput>


<prompt>bash$ </prompt><userinput>pgrep mingetty</userinput>
<computeroutput>2212 mingetty
 2213 mingetty
 2214 mingetty
 2215 mingetty
 2216 mingetty</computeroutput>
	      </screen>
	    </para>

	    <para>Compare the action of <command>pkill</command> with <link linkend="killallref">killall</link>.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="pstreeref" /><command moreinfo="none">pstree</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pstree</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pstree</secondary>
	  </indexterm>
	    <para>Lists currently executing processes in
	      <quote>tree</quote> format. The <option>-p</option> option
	      shows the PIDs, as well as the process names.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="topref" /><command moreinfo="none">top</command></term>
	  <listitem>
	  <indexterm>
	    <primary>top</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>processes</secondary>
	  </indexterm>

	    <para>Continuously updated display of most cpu-intensive
	      processes. The <option>-b</option> option displays in text
	      mode, so that the output may be parsed or accessed from
	      a script.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>top -b</userinput>
<computeroutput>  8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
 45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
 CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
 Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
 Swap:  157208K av,       0K used,  157208K free                   37244K cached

   PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
   848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
     1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
     2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
   ...</computeroutput>  
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="niceref" /><command moreinfo="none">nice</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nice</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nice</secondary>
	  </indexterm>
	    <para><anchor xml:id="nice2ref" /></para>
	    <para>Run a background job with an altered
	      priority. Priorities run from 19 (lowest) to -20
	      (highest). Only <firstterm>root</firstterm> may set the
	      negative (higher) priorities. Related commands are
	      <command>renice</command> and <command>snice</command>,
	      which change the priority of a running process or
	      processes, and <command>skill</command>, which sends a
	      <link linkend="killref">kill</link> signal to a process
	      or processes.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="nohupref" /><command moreinfo="none">nohup</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nohup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nohup</secondary>
	  </indexterm>
	    <para>Keeps a command running even after user logs off.
	      The command will run as a foreground process unless followed
	      by <token>&amp;</token>.  If you use <command>nohup</command>
	      within a script, consider coupling it with a <link linkend="waitref">wait</link> to avoid creating an
	      <firstterm>orphan</firstterm> or
	      <link linkend="zombieref">zombie</link> process.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="pidofref" /><command moreinfo="none">pidof</command></term>
	  <listitem>
	  <indexterm>
	    <primary>pidof</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process ID</secondary>
	  </indexterm>
	    <para>Identifies <firstterm>process ID (PID)</firstterm> of a
	    running job. Since job control commands, such as <link linkend="killref">kill</link> and <link linkend="nice2ref">renice</link> act on the
	    <firstterm>PID</firstterm> of a process (not its
	    name), it is sometimes necessary to identify that
	    <firstterm>PID</firstterm>. The <command>pidof</command>
	    command is the approximate counterpart to the <link linkend="ppidref">$PPID</link> internal variable.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>pidof xclock</userinput>
<computeroutput>880</computeroutput>
	      </screen>
	    </para>

            <example xml:id="killprocess">
              <title><firstterm>pidof</firstterm> helps kill a process</title>
              <programlisting>#!/bin/bash
# kill-process.sh

NOPROCESS=2

process=xxxyyyzzz  # Use nonexistent process.
# For demo purposes only...
# ... don't want to actually kill any actual process with this script.
#
# If, for example, you wanted to use this script to logoff the Internet,
#     process=pppd

t=`pidof $process`       # Find pid (process id) of $process.
# The pid is needed by 'kill' (can't 'kill' by program name).

if [ -z "$t" ]           # If process not present, 'pidof' returns null.
then
  echo "Process $process was not running."
  echo "Nothing killed."
  exit $NOPROCESS
fi  

kill $t                  # May need 'kill -9' for stubborn process.

# Need a check here to see if process allowed itself to be killed.
# Perhaps another " t=`pidof $process` " or ...


# This entire script could be replaced by
#        kill $(pidof -x process_name)
# or
#        killall process_name
# but it would not be as instructive.

exit 0
</programlisting>
            </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="fuserref" /><command moreinfo="none">fuser</command></term>
	  <listitem>
	  <indexterm>
	    <primary>fuser</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fuser</secondary>
	  </indexterm>
	    <para>Identifies the processes (by PID) that are accessing
	      a given file, set of files, or directory. May also be
	      invoked with the <option>-k</option> option, which kills
	      those processes. This has interesting implications for
	      system security, especially in scripts preventing
	      unauthorized users from accessing system services.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>fuser -u /usr/bin/vim</userinput>
<computeroutput>/usr/bin/vim:         3207e(bozo)</computeroutput>



<prompt>bash$ </prompt><userinput>fuser -u /dev/null</userinput>
<computeroutput>/dev/null:            3009(bozo)  3010(bozo)  3197(bozo)  3199(bozo)</computeroutput>
	      </screen>
	    </para>

           <para>One important application for <command>fuser</command> is
	     when physically inserting or removing storage media, such
	     as CD ROM disks or USB flash drives. Sometimes trying
	     a <link linkend="umountref">umount</link> fails with a
	     <errorname>device is busy</errorname> error message. This
	     means that some user(s) and/or process(es) are accessing
	     the device. An <command>fuser -um /dev/device_name</command>
	     will clear up the mystery, so you can kill any relevant
	     processes.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>umount /mnt/usbdrive</userinput>
<computeroutput>umount: /mnt/usbdrive: device is busy</computeroutput>



<prompt>bash$ </prompt><userinput>fuser -um /dev/usbdrive</userinput>
<computeroutput>/mnt/usbdrive:        1772c(bozo)</computeroutput>

<prompt>bash$ </prompt><userinput>kill -9 1772</userinput>
<prompt>bash$ </prompt><userinput>umount /mnt/usbdrive</userinput>
	      </screen>
	    </para>

            <para> The <command>fuser</command> command, invoked with the
	      <option>-n</option> option identifies the processes
	      accessing a <firstterm>port</firstterm>. This
	      is especially useful in combination with <link linkend="nmapref">nmap</link>.</para>

	  <para>
	      <screen><prompt>root# </prompt><userinput>nmap localhost.localdomain</userinput>
<computeroutput>PORT     STATE SERVICE
 25/tcp   open  smtp</computeroutput>



<prompt>root# </prompt><userinput>fuser -un tcp 25</userinput>
<computeroutput>25/tcp:               2095(root)</computeroutput>

<prompt>root# </prompt><userinput>ps ax | grep 2095 | grep -v grep</userinput>
<computeroutput>2095 ?        Ss     0:00 sendmail: accepting connections</computeroutput>
	      </screen>
            </para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="cronref" /><command moreinfo="none">cron</command></term>
	  <listitem>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>crond</secondary>
	  </indexterm>

	    <para>Administrative program scheduler, performing such
	      duties as cleaning up and deleting system log files and
	      updating the <database>slocate</database> database. This
	      is the <firstterm>superuser</firstterm> version of <link linkend="atref">at</link> (although each user may have
	      their own <filename>crontab</filename> file which can be
	      changed with the <command>crontab</command> command).
	      It runs as a <link linkend="daemonref">daemon</link>
	      and executes scheduled entries from
	      <filename>/etc/crontab</filename>.</para>

	    <note><para>Some flavors of Linux run
	      <command>crond</command>, Matthew Dillon's version of
	      <command>cron</command>.</para></note>

	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="runcontrolsys">
        <title><anchor xml:id="runcontrolsys1" />Process Control and Booting</title>

	<varlistentry>
	  <term><anchor xml:id="initref" /><command moreinfo="none">init</command></term>
	  <listitem>
	  <indexterm>
	    <primary>init</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>init</secondary>
	  </indexterm>
	    <para><anchor xml:id="inittabref" /></para>
	    <para>The <command>init</command> command is the <link linkend="forkref">parent</link> of all processes. Called
	      in the final step of a bootup, <command>init</command>
	      determines the runlevel of the system from
	      <filename>/etc/inittab</filename>. Invoked by its alias
	      <command>telinit</command>, and by
	      <firstterm>root</firstterm> only.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="telinitref" /><command moreinfo="none">telinit</command></term>
	  <listitem>
	  <indexterm>
	    <primary>telinit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telinit</secondary>
	  </indexterm>
	    <para>Symlinked to <command>init</command>, this is a means of changing the system runlevel,
	      usually done for system maintenance or emergency filesystem
	      repairs. Invoked only by <firstterm>root</firstterm>. This
	      command can be dangerous -- be certain you understand it
	      well before using!</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="runlevelref" /><command moreinfo="none">runlevel</command></term>
	  <listitem>
	  <indexterm>
	    <primary>runlevel</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>runlevel</secondary>
	  </indexterm>
	    <para>Shows the current and last runlevel, that is, whether the system
	      is halted (runlevel <literal>0</literal>), in single-user mode
	      (<literal>1</literal>), in multi-user mode (<literal>2</literal>
	      or <literal>3</literal>), in X Windows (<literal>5</literal>), or
	      rebooting (<literal>6</literal>). This command accesses the
	      <filename>/var/run/utmp</filename> file.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="haltref" /><command moreinfo="none">halt</command></term>
	  <term><anchor xml:id="shutdownref" /><command moreinfo="none">shutdown</command></term>
	  <term><anchor xml:id="rebootref" /><command moreinfo="none">reboot</command></term>
	  <listitem>
	  <indexterm>
	    <primary>halt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>halt</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shutdown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shutdown</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>reboot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reboot</secondary>
	  </indexterm>
	    <para>Command set to shut the system down, usually just prior to a power down.</para>
	    <warning><para>On some Linux distros, the <command>halt</command> command
	      has 755 permissions, so it can be invoked by a non-root user.
	      A careless <firstterm>halt</firstterm> in a terminal or a script
	      may shut down the system!</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="serviceref" /><command moreinfo="none">service</command></term>
	  <listitem>
	  <indexterm>
	    <primary>service</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>service</secondary>
	  </indexterm>
	    <para>Starts or stops a system <firstterm>service</firstterm>.
	    The startup scripts in <filename class="directory">/etc/init.d</filename>
	    and <filename class="directory">/etc/rc.d</filename> use this
	    command to start services at bootup.</para>

    <para><anchor xml:id="iptables01" /></para>

	      <para>
	      <screen><prompt>root# </prompt><userinput>/sbin/service iptables stop</userinput>
<computeroutput>Flushing firewall rules:                                   [  OK  ]
 Setting chains to policy ACCEPT: filter                    [  OK  ]
 Unloading iptables modules:                                [  OK  ]</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="networksys">
        <title><anchor xml:id="networksys1" />Network</title>

	<varlistentry>
	  <term><anchor xml:id="nmapref" /><command moreinfo="none">nmap</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nmap</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>port scan</secondary>
	  </indexterm>
	    <para><command>N</command>etwork <command>map</command>per
	      and port scanner. This command scans a server to
	      locate open ports and the services associated with those
	      ports. It can also report information about packet filters and
	      firewalls. This is an important security tool for locking down
	      a network against hacking attempts.</para>
	    <para><programlisting>#!/bin/bash

SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
PORT_NUMBER=25                         # SMTP port.

nmap $SERVER | grep -w "$PORT_NUMBER"  # Is that particular port open?
#              grep -w matches whole words only,
#+             so this wouldn't match port 1025, for example.

exit 0

# 25/tcp     open        smtp</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="ifconfigref" /><command moreinfo="none">ifconfig</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ifconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ifconfig</secondary>
	  </indexterm>
	    <para>Network <firstterm>interface configuration</firstterm>
	      and tuning utility.</para>

	      <screen><prompt>bash$ </prompt><userinput>ifconfig -a</userinput>
<computeroutput>lo        Link encap:Local Loopback
           inet addr:127.0.0.1  Mask:255.0.0.0
           UP LOOPBACK RUNNING  MTU:16436  Metric:1
           RX packets:10 errors:0 dropped:0 overruns:0 frame:0
           TX packets:10 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:0 
           RX bytes:700 (700.0 b)  TX bytes:700 (700.0 b)</computeroutput></screen>

	    <para>The <command>ifconfig</command> command is most often used
	      at bootup to set up the interfaces, or to shut them down
	      when rebooting.</para>

	    <para><programlisting># Code snippets from /etc/rc.d/init.d/network

# ...

# Check that networking is up.
[ ${NETWORKING} = "no" ] &amp;&amp; exit 0

[ -x /sbin/ifconfig ] || exit 0

# ...

for i in $interfaces ; do
  if ifconfig $i 2&gt;/dev/null | grep -q "UP" &gt;/dev/null 2&gt;&amp;1 ; then
    action "Shutting down interface $i: " ./ifdown $i boot
  fi
#  The GNU-specific "-q" option to "grep" means "quiet", i.e.,
#+ producing no output.
#  Redirecting output to /dev/null is therefore not strictly necessary.
       
# ...

echo "Currently active devices:"
echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`
#                            ^^^^^  should be quoted to prevent globbing.
#  The following also work.
#    echo $(/sbin/ifconfig | awk '/^[a-z]/ { print $1 })'
#    echo $(/sbin/ifconfig | sed -e 's/ .*//')
#  Thanks, S.C., for additional comments.</programlisting></para>

	    <para>See also <xref linkend="online" />.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="netstatref" /><command moreinfo="none">netstat</command></term>
	  <listitem>
	  <indexterm>
	    <primary>netstat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>netstat</secondary>
	  </indexterm>

	    <para>Show current network statistics and information, 
	      such as routing tables and active connections. This utility
	      accesses information in <filename>/proc/net</filename>
	      (<xref linkend="devproc" />). See <xref linkend="constat" />.</para>
	    <para><command>netstat -r</command> is equivalent to <link linkend="routeref">route</link>.</para>

	      <screen><prompt>bash$ </prompt><userinput>netstat</userinput>
<computeroutput>Active Internet connections (w/o servers)
 Proto Recv-Q Send-Q Local Address           Foreign Address         State      
 Active UNIX domain sockets (w/o servers)
 Proto RefCnt Flags       Type       State         I-Node Path
 unix  11     [ ]         DGRAM                    906    /dev/log
 unix  3      [ ]         STREAM     CONNECTED     4514   /tmp/.X11-unix/X0
 unix  3      [ ]         STREAM     CONNECTED     4513
 . . .</computeroutput></screen>

            <note><para>A <command>netstat -lptu</command> shows <link linkend="socketref">sockets</link> that are listening
	    to ports, and the associated processes. This can be useful
	    for determining whether a computer has been hacked or
	    compromised.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="iwconfigref" /><command moreinfo="none">iwconfig</command></term>
	  <listitem>
	  <indexterm>
	    <primary>iwconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wireless</secondary>
	  </indexterm>
	    <para>This is the command set for configuring a wireless network.
	      It is the wireless equivalent of <command>ifconfig</command>,
	      above.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="ipref" /><command moreinfo="none">ip</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>routing</secondary>
	  </indexterm>

	    <para>General purpose utility for setting up, changing, and
	      analyzing <firstterm>IP</firstterm> (Internet Protocol)
	      networks and attached devices. This command is part of
	      the <firstterm>iproute2</firstterm> package.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>ip link show</userinput>
<computeroutput>1: lo: &lt;LOOPBACK,UP&gt; mtu 16436 qdisc noqueue 
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 2: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast qlen 1000
     link/ether 00:d0:59:ce:af:da brd ff:ff:ff:ff:ff:ff
 3: sit0: &lt;NOARP&gt; mtu 1480 qdisc noop 
     link/sit 0.0.0.0 brd 0.0.0.0</computeroutput>


<prompt>bash$ </prompt><userinput>ip route list</userinput>
<computeroutput>169.254.0.0/16 dev lo  scope link</computeroutput>
	      </screen>
	    </para>

            <para>Or, in a script:</para>

	    <para><anchor xml:id="ipscript0" />
              <programlisting>#!/bin/bash
# Script by Juan Nicolas Ruiz
# Used with his kind permission.

# Setting up (and stopping) a GRE tunnel.


# --- start-tunnel.sh ---

LOCAL_IP="192.168.1.17"
REMOTE_IP="10.0.5.33"
OTHER_IFACE="192.168.0.100"
REMOTE_NET="192.168.3.0/24"

/sbin/ip tunnel add netb mode gre remote $REMOTE_IP \
  local $LOCAL_IP ttl 255
/sbin/ip addr add $OTHER_IFACE dev netb
/sbin/ip link set netb up
/sbin/ip route add $REMOTE_NET dev netb

exit 0  #############################################

# --- stop-tunnel.sh ---

REMOTE_NET="192.168.3.0/24"

/sbin/ip route del $REMOTE_NET dev netb
/sbin/ip link set netb down
/sbin/ip tunnel del netb

exit 0
</programlisting>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="routeref" /><command moreinfo="none">route</command></term>
	  <listitem>
	  <indexterm>
	    <primary>route</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>route</secondary>
	  </indexterm>

	    <para>Show info about or make changes to the kernel routing table.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>route</userinput>
<computeroutput>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
 127.0.0.0       *               255.0.0.0       U        40 0          0 lo
 default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="iptablesref" /><command moreinfo="none">iptables</command></term>
	  <listitem>
	  <indexterm>
	    <primary>iptables</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>firewall</secondary>
	  </indexterm>


		  <para> The <command>iptables</command> command set is
		  a packet filtering tool used mainly for such security
		  purposes as setting up network firewalls. This
		  is a complex tool, and a detailed explanation of
		  its use is beyond the scope of this document. <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">Oskar
		  Andreasson's tutorial</link> is a reasonable starting
		  point.</para>
      
      <para>See also <link linkend="iptables01">shutting down
        <firstterm>iptables</firstterm></link> and <xref linkend="ipaddresses" />.</para>


	  </listitem>
	</varlistentry>




	<varlistentry>
	  <term><anchor xml:id="chkconfigref" /><command moreinfo="none">chkconfig</command></term>
	  <listitem>
	  <indexterm>
	    <primary>chkconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>network configuration</secondary>
	  </indexterm>

	    <para>Check network and system configuration. This command
	      lists and
	      manages the network and system services started at bootup in
	      the <filename class="directory">/etc/rc?.d</filename>
	      directory.</para>

	    <para>Originally a port from IRIX to Red Hat Linux,
	      <command>chkconfig</command> may not be part of the core
	      installation of some Linux flavors.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>chkconfig --list</userinput>
<computeroutput>atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
 rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
 ...</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="tcpdumpref" /><command moreinfo="none">tcpdump</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tcpdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tcp</secondary>
	  </indexterm>
	    <para>Network packet <quote>sniffer.</quote> This is a tool for
	      analyzing and troubleshooting traffic on a network by dumping
	      packet headers that match specified criteria.</para>

	      <para>Dump ip packet traffic between hosts
	        <emphasis>bozoville</emphasis> and
	        <emphasis>caduceus</emphasis>:</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>tcpdump ip host bozoville and caduceus</userinput>
	      </screen>
	      </para>

	      <para>Of course, the output of <command>tcpdump</command> can be
	        parsed with certain of the previously discussed <link linkend="tpcommandlisting1">text processing
		utilities</link>.</para>
	  </listitem>
	</varlistentry>

      </variablelist>



      <variablelist xml:id="filesystemsys">
        <title><anchor xml:id="filesystemsys1" />Filesystem</title>

	<varlistentry>
	  <term><anchor xml:id="mountref" /><command moreinfo="none">mount</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mount</secondary>
	  </indexterm>
	    <para>Mount a filesystem, usually on an external device,
	      such as a floppy or CDROM. <anchor xml:id="fstabref" />The file
	      <filename>/etc/fstab</filename> provides a handy listing
	      of available filesystems, partitions, and devices,
	      including options, that may be automatically or manually
	      mounted. The file <filename>/etc/mtab</filename> shows
	      the currently mounted filesystems and partitions
	      (including the virtual ones, such as <filename class="directory">/proc</filename>).</para>

	    <para><command>mount -a</command> mounts all filesystems and
	      partitions listed in <filename>/etc/fstab</filename>,
	      except those with a <option>noauto</option>
	      option. At bootup, a startup script in
	      <filename class="directory">/etc/rc.d</filename>
	      (<filename>rc.sysinit</filename> or something similar)
	      invokes this to get everything mounted.</para>


	    <para><programlisting>mount -t iso9660 /dev/cdrom /mnt/cdrom
# Mounts CD ROM. ISO 9660 is a standard CD ROM filesystem.
mount /mnt/cdrom
# Shortcut, if /mnt/cdrom listed in /etc/fstab</programlisting>
     </para>

     <para><anchor xml:id="isomountref0" /></para>
     <para>The versatile <firstterm>mount</firstterm> command can even
       mount an ordinary file on a block device, and the file will
       act as if it were a filesystem. <firstterm>Mount</firstterm>
       accomplishes that by associating the file with a <link linkend="loopbackref">loopback device</link>. One application of
       this is to mount and examine an ISO9660 filesystem image before
       burning it onto a CDR.

	  <footnote><para>For more detail on burning CDRs, see Alex
	    Withers' article, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www2.linuxjournal.com/lj-issues/issue66/3335.html">Creating
	    CDs</link>, in the October, 1999 issue of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxjournal.com"><citetitle pubwork="journal">Linux
	     Journal</citetitle></link>.</para></footnote>

       </para>

	     <example xml:id="isomountref">
	      <title>Checking a CD image</title>
	       <programlisting># As root...

mkdir /mnt/cdtest  # Prepare a mount point, if not already there.

mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # Mount the image.
#                  "-o loop" option equivalent to "losetup /dev/loop0"
cd /mnt/cdtest     # Now, check the image.
ls -alR            # List the files in the directory tree there.
                   # And so forth.</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="umountref" /><command moreinfo="none">umount</command></term>
	  <listitem>
	  <indexterm>
	    <primary>umount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umount</secondary>
	  </indexterm>
	    <para>Unmount a currently mounted filesystem. Before physically removing a
	      previously mounted floppy or CDROM disk, the device must be
	      <command>umount</command>ed, else filesystem corruption may result.
	      <programlisting>umount /mnt/cdrom
# You may now press the eject button and safely remove the disk.</programlisting></para>

	      <note><para>The <command>automount</command> utility, if
		properly installed, can mount and unmount floppies or
		CDROM disks as they are accessed or removed. On
		<quote>multispindle</quote> laptops with swappable
		floppy and optical drives, this can cause problems,
		however.</para></note>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="gnomemountref" /><command moreinfo="none">gnome-mount</command></term>
	  <listitem>
	  <indexterm>
	    <primary>gnome-mount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mount</secondary>
	  </indexterm>
	    <para>The newer Linux distros have deprecated
	    <command>mount</command> and <command>umount</command>.
	    The successor, for command-line mounting of removable storage
	    devices, is <command>gnome-mount</command>. It can take the
	    <option>-d</option> option to mount a <link linkend="devfileref">device file</link> by its listing in
	    <filename class="directory">/dev</filename>.</para>

	    <para>For example, to mount a USB flash drive:</para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>gnome-mount -d /dev/sda1</userinput>
<computeroutput>gnome-mount 0.4</computeroutput>


<prompt>bash$ </prompt><userinput>df</userinput>
<computeroutput>. . .
 /dev/sda1                63584     12034     51550  19% /media/disk</computeroutput>
 </screen>
	    </para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="syncref" /><command moreinfo="none">sync</command></term>
	  <listitem>
	  <indexterm>
	    <primary>sync</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sync</secondary>
	  </indexterm>
	    <para>Forces an immediate write of all updated data from
	      buffers to hard drive (synchronize drive
	      with buffers). While not strictly necessary, a
	      <command>sync</command> assures the sys admin or
	      user that the data just changed will survive a sudden
	      power failure. In the olden days, a <userinput>sync;
	      sync</userinput> (twice, just to make absolutely sure) was a
	      useful precautionary measure before a system reboot.</para>
	    <para>At times, you may wish to force an immediate buffer
	      flush, as when securely deleting a file (see <xref linkend="blotout" />) or when the lights begin to
	      flicker.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="losetupref" /><command moreinfo="none">losetup</command></term>
	  <listitem>
	  <indexterm>
	    <primary>losetup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>losetup</secondary>
	  </indexterm>
	    <para>Sets up and configures <link linkend="loopbackref">
	      loopback devices</link>.</para>

	    <example xml:id="createfs">
	      <title>Creating a filesystem in a file</title>
	      <programlisting>SIZE=1000000  # 1 meg

head -c $SIZE &lt; /dev/zero &gt; file  # Set up file of designated size.
losetup /dev/loop0 file           # Set it up as loopback device.
mke2fs /dev/loop0                 # Create filesystem.
mount -o loop /dev/loop0 /mnt     # Mount it.

# Thanks, S.C.</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="mkswapref" /><command moreinfo="none">mkswap</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mkswap</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkswap</secondary>
	  </indexterm>
	    <para>Creates a swap partition or file. The swap area must
	      subsequently be enabled with
	      <command>swapon</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="swaponref" /><command moreinfo="none">swapon</command></term>
	  <term><anchor xml:id="swapoffref" /><command moreinfo="none">swapoff</command></term>
	  <listitem>
	  <indexterm>
	    <primary>swapon</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>swapon</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>swapoff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>swapoff</secondary>
	  </indexterm>
	    <para>Enable / disable swap partitition or file.
	      These commands usually take effect at bootup and
	      shutdown.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mke2fsref" /><command moreinfo="none">mke2fs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mke2fs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mke2fs</secondary>
	  </indexterm>
	    <para>Create a Linux <firstterm>ext2</firstterm>
	      filesystem. This command must be invoked as
	      <firstterm>root</firstterm>.</para>


	    <example xml:id="adddrv">
	      <title>Adding a new hard drive</title>
	      <programlisting>#!/bin/bash

# Adding a second hard drive to system.
# Software configuration. Assumes hardware already mounted.
# From an article by the author of the ABS Guide.
# In issue #38 of _Linux Gazette_, http://www.linuxgazette.com.

ROOT_UID=0     # This script must be run as root.
E_NOTROOT=67   # Non-root exit error.

if [ "$UID" -ne "$ROOT_UID" ]
then
  echo "Must be root to run this script."
  exit $E_NOTROOT
fi  

# Use with extreme caution!
# If something goes wrong, you may wipe out your current filesystem.


NEWDISK=/dev/hdb         # Assumes /dev/hdb vacant. Check!
MOUNTPOINT=/mnt/newdisk  # Or choose another mount point.


fdisk $NEWDISK
mke2fs -cv $NEWDISK1   # Check for bad blocks (verbose output).
#  Note:           ^     /dev/hdb1, *not* /dev/hdb!
mkdir $MOUNTPOINT
chmod 777 $MOUNTPOINT  # Makes new drive accessible to all users.


# Now, test ...
# mount -t ext2 /dev/hdb1 /mnt/newdisk
# Try creating a directory.
# If it works, umount it, and proceed.

# Final step:
# Add the following line to /etc/fstab.
# /dev/hdb1  /mnt/newdisk  ext2  defaults  1 1

exit
</programlisting>
	    </example>

	    <para>See also <xref linkend="createfs" /> and <xref linkend="ramdisk" />.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="mkdosfsref" /><command moreinfo="none">mkdosfs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mkdosfs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkdosfs</secondary>
	  </indexterm>
	    <para>Create a DOS <firstterm>FAT</firstterm>
              filesystem.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor xml:id="tune2fsref" /><command moreinfo="none">tune2fs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tune2fs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tune2fs</secondary>
	  </indexterm>
	    <para>Tune <firstterm>ext2</firstterm> filesystem. May be
	      used to change filesystem parameters, such as maximum
	      mount count. This must be invoked as
	      <firstterm>root</firstterm>.</para>

	    <warning><para>This is an extremely dangerous command. Use it at
	      your own risk, as you may inadvertently destroy your filesystem.
	      </para></warning>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="dumpe2fsref" /><command moreinfo="none">dumpe2fs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dumpe2fs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dumpe2fs</secondary>
	  </indexterm>
	    <para>Dump (list to <filename>stdout</filename>) very verbose
	      filesystem info. This must be invoked as
	      <firstterm>root</firstterm>.</para>

	    <screen><prompt>root# </prompt><command>dumpe2fs /dev/hda7 | grep 'ount count'</command>
<computeroutput>dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
 Mount count:              6
 Maximum mount count:      20</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="hdparmref" /><command moreinfo="none">hdparm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>hdparm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hard disk parameters</secondary>
	  </indexterm>
	    <para>List or change hard disk parameters. This command must be
	      invoked as <firstterm>root</firstterm>, and it may be
	      dangerous if misused.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="fdiskref" /><command moreinfo="none">fdisk</command></term>
	  <listitem>
	  <indexterm>
	    <primary>fdisk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fdisk</secondary>
	  </indexterm>
	    <para>Create or change a partition table on a storage device,
	      usually a hard drive. This command must be invoked as
	      <firstterm>root</firstterm>.</para>
	    <warning><para>Use this command with extreme caution. If something
	      goes wrong, you may destroy an existing
	      filesystem.</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="fsckref" /><command moreinfo="none">fsck</command></term>
	  <term><anchor xml:id="e2fsckref" /><command moreinfo="none">e2fsck</command></term>
	  <term><anchor xml:id="debugfsref" /><command moreinfo="none">debugfs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>fsck</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fsck</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>e2fsck</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>e2fsck</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>debugfs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>debugfs</secondary>
	  </indexterm>

	    <para>Filesystem check, repair, and debug command set.</para>

	    <para><command>fsck</command>: a front end for checking a UNIX
	      filesystem (may invoke other utilities). The actual
	      filesystem type generally defaults to
	      <firstterm>ext2</firstterm>.</para>

	    <para><command>e2fsck</command>: ext2 filesystem checker.</para>

	    <para><command>debugfs</command>: ext2 filesystem debugger.
	      One of the uses of this versatile, but dangerous command
	      is to (attempt to) recover deleted files. For advanced users
	      only!</para>

	    <caution><para>All of these should be invoked as
	      <firstterm>root</firstterm>, and they can damage or destroy
	      a filesystem if misused.</para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="badblocksref" /><command moreinfo="none">badblocks</command></term>
	  <listitem>
	  <indexterm>
	    <primary>badblocks</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>badblocks</secondary>
	  </indexterm>
	    <para>Checks for bad blocks (physical media flaws) on a
	      storage device.  This command finds use when formatting
	      a newly installed hard drive or testing the integrity
	      of backup media.
	        <footnote><para>The <option>-c</option> option to <link linkend="mke2fsref">mke2fs</link> also invokes a check for bad
		blocks.</para></footnote>
	      As an example, <command>badblocks /dev/fd0</command>
	      tests a floppy disk.</para>

	    <para>The <command>badblocks</command> command
	      may be invoked destructively (overwrite all data) or
	      in non-destructive read-only mode. If <firstterm>root
	      user</firstterm> owns the device to be tested, as is
	      generally the case, then <firstterm>root</firstterm>
	      must invoke this command.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lsusbref" /><command moreinfo="none">lsusb</command></term>
	  <term><command moreinfo="none">usbmodules</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lsusb</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usb</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>usbmodules</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usb</secondary>
	  </indexterm>

	    <para>The <command>lsusb</command> command lists all USB
	      (Universal Serial Bus) buses and the devices hooked up to
	      them.</para>

            <para>The <command>usbmodules</command> command outputs
	      information about the driver modules for connected USB
	      devices.</para>

            <para>
	      <screen><prompt>bash$ </prompt><userinput>lsusb</userinput>
<computeroutput>Bus 001 Device 001: ID 0000:0000  
 Device Descriptor:
   bLength                18
   bDescriptorType         1
   bcdUSB               1.00
   bDeviceClass            9 Hub
   bDeviceSubClass         0 
   bDeviceProtocol         0 
   bMaxPacketSize0         8
   idVendor           0x0000 
   idProduct          0x0000

   . . .</computeroutput>
	      </screen>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lspciref" /><command moreinfo="none">lspci</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lspci</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pci</secondary>
	  </indexterm>
	    <para>Lists <firstterm>pci</firstterm> busses present.</para>

            <para>
	      <screen><prompt>bash$ </prompt><userinput>lspci</userinput>
<computeroutput>00:00.0 Host bridge: Intel Corporation 82845 845
 (Brookdale) Chipset Host Bridge (rev 04)
 00:01.0 PCI bridge: Intel Corporation 82845 845
 (Brookdale) Chipset AGP Bridge (rev 04)
 00:1d.0 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #1) (rev 02)
 00:1d.1 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #2) (rev 02)
 00:1d.2 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #3) (rev 02)
 00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev 42)

   . . .</computeroutput>
	      </screen>
            </para>

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor xml:id="mkbootdiskref" /><command moreinfo="none">mkbootdisk</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mkbootdisk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bootdisk</secondary>
	  </indexterm>
	    <para>Creates a boot floppy which can be used to bring up the
	      system if, for example, the MBR (master boot record) becomes
	      corrupted. Of special interest is the <option>--iso</option>
	      option, which uses <command>mkisofs</command> to create a
	      bootable <firstterm>ISO9660</firstterm> filesystem image
	      suitable for burning a bootable CDR.</para>
	    <para>The <command>mkbootdisk</command> command is actually
	      a Bash script, written by Erik Troan, in the <filename class="directory">/sbin</filename> directory.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mkisofsref" /><command moreinfo="none">mkisofs</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mkisofs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ISO9660</secondary>
	  </indexterm>
	    <para>Creates an <firstterm>ISO9660</firstterm> filesystem
	      suitable for a CDR image.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="chrootref" /><command moreinfo="none">chroot</command></term>
	  <listitem>
	  <indexterm>
	    <primary>chroot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chroot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>root</secondary>
	    <tertiary>change</tertiary>
	  </indexterm>
	    <para>CHange ROOT directory. Normally commands are fetched
	      from <link linkend="pathref">$PATH</link>, relative to
	      <filename class="directory">/</filename>, the default
	      <firstterm>root
	      directory</firstterm>. This changes the
	      <firstterm>root</firstterm> directory to a different one
	      (and also changes the working directory to there).  This is
	      useful for security purposes, for instance when the system
	      administrator wishes to restrict certain users, such as
	      those <link linkend="telnetref">telnetting</link> in,
	      to a secured portion of the filesystem (this is sometimes
	      referred to as confining a guest user to a <quote>chroot
	      jail</quote>). Note that after a <command>chroot</command>,
	      the execution path for system binaries is no longer
	      valid.</para>

	      <para>A <userinput>chroot /opt</userinput> would cause
		references to <filename class="directory">/usr/bin</filename>
		to be translated to <filename class="directory">/opt/usr/bin</filename>. Likewise,
		<userinput>chroot /aaa/bbb /bin/ls</userinput> would
		redirect future instances of <command>ls</command>
		to <filename>/aaa/bbb</filename> as the base directory,
		rather than <filename class="directory">/</filename> as is
		normally the case. An <command>alias XX 'chroot /aaa/bbb
		ls'</command> in a user's <link linkend="sample-bashrc"><filename>~/.bashrc</filename></link>
		effectively restricts which portion of the filesystem
		she may run command <quote>XX</quote> on.</para>


	    <para>The <command>chroot</command> command is also handy
	      when running from an emergency boot floppy 
	      (<command>chroot</command> to <filename>/dev/fd0</filename>),
	      or as an option to <command>lilo</command> when recovering
	      from a system crash. Other uses include installation from a
	      different filesystem (an <link linkend="rpmref">rpm</link>
	      option) or running a readonly filesystem from a CD ROM.
	      Invoke only as <firstterm>root</firstterm>, and use with
	      care.</para>

	    <caution><para>It might be necessary to copy certain system
	      files to a <firstterm>chrooted</firstterm> directory,
	      since the normal <varname>$PATH</varname> can no longer
	      be relied upon.</para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lockfileref" /><command moreinfo="none">lockfile</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lockfile</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lockfile</secondary>
	  </indexterm>
            <para>This utility is part of the <command>procmail</command>
	      package (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.procmail.org">www.procmail.org</link>).
	      It creates a <firstterm>lock file</firstterm>, a
	      <firstterm>semaphore</firstterm> that controls access to
	      a file, device, or resource.</para>

		<sidebar><para><anchor xml:id="semaphoreref" />
		  <userinput>Definition:</userinput>
		  A <firstterm>semaphore</firstterm> is a flag or
		  signal. (The usage originated in railroading, where a
		  colored flag, lantern, or striped movable arm
		  <firstterm>semaphore</firstterm> indicated whether a
		  particular track was in use and therefore unavailable
		  for another train.) A UNIX process can check the
		  appropriate semaphore to determine whether a particular
		  resource is available/accessible.</para></sidebar>

	    <para>The lock file serves as a flag that this particular
	      file, device, or resource is in use by a process (and
	      is therefore <quote>busy</quote>). The presence of a
	      lock file permits only restricted access (or no access)
	      to other processes.</para>

            <para><programlisting>lockfile /home/bozo/lockfiles/$0.lock
# Creates a write-protected lockfile prefixed with the name of the script.

lockfile /home/bozo/lockfiles/${0##*/}.lock
# A safer version of the above, as pointed out by E. Choroba.</programlisting></para>
	      
	    <para>Lock files are used in such applications as protecting 
	      system mail folders from simultaneously being changed
	      by multiple users, indicating that a modem port
	      is being accessed, and showing that an instance of
	      <application>Firefox</application> is using its cache.
	      Scripts may check for the existence of a lock file created
	      by a certain process to check if that process is running.
	      Note that if a script attempts to create a lock file that
	      already exists, the script will likely hang.</para>

	    <para>Normally, applications create and check for lock files
	      in the <filename class="directory">/var/lock</filename>
	      directory.
	         <footnote><para>Since only <firstterm>root</firstterm>
		 has write permission in the <filename class="directory">/var/lock</filename> directory,
		 a user script cannot set a lock file there.</para></footnote>
	      A script can test for the presence of a lock file by
	      something like the following.
	        <programlisting>appname=xyzip
# Application "xyzip" created lock file "/var/lock/xyzip.lock".

if [ -e "/var/lock/$appname.lock" ]
then   #+ Prevent other programs &amp; scripts
       #  from accessing files/resources used by xyzip.
  ...</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="flockref" /><command moreinfo="none">flock</command></term>
	  <listitem>
	  <indexterm>
	    <primary>flock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lock file</secondary>
	  </indexterm>

	    <para>Much less useful than the <command>lockfile</command>
	      command is <command>flock</command>. It sets an
	      <quote>advisory</quote> lock on a file and then executes
	      a command while the lock is on. This is to prevent
	      any other process from setting a lock on that file until
	      completion of the specified command.</para>

	    <para><programlisting>flock $0 cat $0 &gt; lockfile__$0
#  Set a lock on the script the above line appears in,
#+ while listing the script to stdout.</programlisting></para>

            <note><para>Unlike <command>lockfile</command>,
	      <command>flock</command> does <emphasis>not</emphasis>
	      automatically create a lock file.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="mknodref" /><command moreinfo="none">mknod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>mknod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mknod</secondary>
	  </indexterm>
	    <para>Creates block or character <link linkend="devfileref">device files</link> (may be
	      necessary when installing new hardware on the system). The
	      <command>MAKEDEV</command> utility has virtually
	      all of the functionality of <command>mknod</command>,
	      and is easier to use.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="MAKEDEVref" /><command moreinfo="none">MAKEDEV</command></term>
	  <listitem>
	  <indexterm>
	    <primary>MAKEDEV</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>make device file</secondary>
	  </indexterm>

	    <para>Utility for creating device files. It must be run as
	      <firstterm>root</firstterm>, and in the <filename class="directory">/dev</filename> directory. It is a sort
	      of advanced version of <command>mknod</command>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="tmpwatchref" /><command moreinfo="none">tmpwatch</command></term>
	  <listitem>
	  <indexterm>
	    <primary>tmpwatch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tmpwatch</secondary>
	  </indexterm>
	    <para>Automatically deletes files which have not been accessed
	      within a specified period of time. Usually invoked by
	      <link linkend="cronref">cron</link> to remove stale log
	      files.</para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="periphsys">
        <title><anchor xml:id="periphsys1" />Backup</title>

	<varlistentry>
	  <term><anchor xml:id="dumpref" /><command moreinfo="none">dump</command></term>
	  <term><anchor xml:id="restoreref" /><command moreinfo="none">restore</command></term>
	  <listitem>
	  <indexterm>
	    <primary>dump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dump</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>restore</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>restore</secondary>
	  </indexterm>
	    <para>The <command>dump</command> command is an elaborate
	      filesystem backup utility, generally used on larger
	      installations and networks.
		<footnote><para>Operators of single-user Linux systems
		  generally prefer something simpler for backups, such
		  as <command>tar</command>.</para></footnote>
	      It reads raw disk partitions and writes a backup file
	      in a binary format.  Files to be backed up may be saved
	      to a variety of storage media, including disks and tape
	      drives. The <command>restore</command> command restores
	      backups made with <command>dump</command>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="fdformatref" /><command moreinfo="none">fdformat</command></term>
	  <listitem>
	  <indexterm>
	    <primary>fdformat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>floppy</secondary>
	  </indexterm>
	    <para>Perform a low-level format on a floppy disk
	    (<filename>/dev/fd0*</filename>).</para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="sysresources">
        <title><anchor xml:id="sysresources1" />System Resources</title>

	<varlistentry>
	  <term><anchor xml:id="ulimitref" /><command moreinfo="none">ulimit</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ulimit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ulimit</secondary>
	  </indexterm>

	    <para>Sets an <firstterm>upper limit</firstterm> on use
	     of system resources. Usually invoked with the
	     <option>-f</option> option, which sets a limit on file size
	     (<command>ulimit -f 1000</command> limits files to 1 meg
	     maximum).
                <footnote><para>As of the <link linkend="bash4ref">version
                4 update</link> of Bash, the <option>-f</option>
                and <option>-c</option> options take a block size
                of 512 when in <link linkend="posix2ref">POSIX</link>
		mode. Additionally, there are two new options:
		<option>-b</option> for <link linkend="socketref">socket</link> buffer size, and
		<option>-T</option> for the limit on the number of
		<firstterm>threads</firstterm>.</para></footnote>
	     The <option>-t</option> option limits the coredump
	     size (<command>ulimit -c 0</command> eliminates coredumps).
	     Normally, the value of <command>ulimit</command>
	     would be set in <filename>/etc/profile</filename>
	     and/or <filename>~/.bash_profile</filename> (see <xref linkend="files" />).</para>

            <important>

	    <para>Judicious use of <command>ulimit</command> can
	      protect a system against the dreaded <firstterm>fork
	      bomb</firstterm>.</para>

	    <para>
	    <programlisting>#!/bin/bash
# This script is for illustrative purposes only.
# Run it at your own peril -- it WILL freeze your system.

while true  #  Endless loop.
do
  $0 &amp;      #  This script invokes itself . . .
            #+ forks an infinite number of times . . .
            #+ until the system freezes up because all resources exhausted.
done        #  This is the notorious <quote>sorcerer's appentice</quote> scenario.

exit 0      #  Will not exit here, because this script will never terminate.</programlisting>
	    </para>

	    <para>A <command>ulimit -Hu XX</command> (where
	      <emphasis>XX</emphasis> is the user process limit) in
	      <filename>/etc/profile</filename> would abort
	      this script when it exceeded the preset limit.
	    </para>

            </important>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="quotaref" /><command moreinfo="none">quota</command></term>
	  <listitem>
	  <indexterm>
	    <primary>quota</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>quota</secondary>
	  </indexterm>
	    <para>Display user or group disk quotas.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="setquotaref" /><command moreinfo="none">setquota</command></term>
	  <listitem>
	  <indexterm>
	    <primary>setquota</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>quota</secondary>
	  </indexterm>
	    <para>Set user or group disk quotas from the command-line.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="umaskref" /><command moreinfo="none">umask</command></term>
	  <listitem>
	  <indexterm>
	    <primary>umask</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umask</secondary>
	  </indexterm>
	    <para>User file creation permissions
	      <firstterm>mask</firstterm>. Limit the default file
	      attributes for a particular user.  All files created
	      by that user take on the attributes specified by
	      <command>umask</command>. The (octal) value passed to
	      <command>umask</command> defines the file permissions
	      <firstterm>disabled</firstterm>. For example, <command>umask
	      022</command> ensures that new files will have at most
	      755 permissions (777 NAND 022).

                <footnote><para>NAND is the logical
		  <firstterm>not-and</firstterm> operator. Its effect
		  is somewhat similar to subtraction.</para></footnote>

	      Of course, the user may later change the
	      attributes of particular files with <link linkend="chmodref">chmod</link>. The usual practice
	      is to set the value of <command>umask</command>
	      in <filename>/etc/profile</filename> and/or
	      <filename>~/.bash_profile</filename> (see <xref linkend="files" />).</para>

	    <example xml:id="rot13a">
	      <title>Using <firstterm>umask</firstterm> to hide an output file
	        from prying eyes</title>
	      <programlisting>#!/bin/bash
# rot13a.sh: Same as "rot13.sh" script, but writes output to "secure" file.

# Usage: ./rot13a.sh filename
# or     ./rot13a.sh &lt;filename
# or     ./rot13a.sh and supply keyboard input (stdin)

umask 177               #  File creation mask.
                        #  Files created by this script
                        #+ will have 600 permissions.

OUTFILE=decrypted.txt   #  Results output to file "decrypted.txt"
                        #+ which can only be read/written
                        #  by invoker of script (or root).

cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M' &gt; $OUTFILE 
#    ^^ Input from stdin or a file.   ^^^^^^^^^^ Output redirected to file. 

exit 0
</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rdevref" /><command moreinfo="none">rdev</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rdev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rdev</secondary>
	  </indexterm>
	    <para>Get info about or make changes to root device, swap space, or video
	       mode.  The functionality of <command>rdev</command> has generally been taken over by
	       <command>lilo</command>, but <command>rdev</command> remains
	       useful for setting up a ram disk. This is a dangerous command, if misused.
	     </para>
	   </listitem>
	 </varlistentry>
	 
      </variablelist>


      <variablelist xml:id="modulessys">
        <title><anchor xml:id="modulessys1" />Modules</title>

	<varlistentry>
	  <term><anchor xml:id="lsmodref" /><command moreinfo="none">lsmod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>lsmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	    <para>List installed kernel modules.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>lsmod</userinput>
<computeroutput>Module                  Size  Used by
 autofs                  9456   2 (autoclean)
 opl3                   11376   0
 serial_cs               5456   0 (unused)
 sb                     34752   0
 uart401                 6384   0 [sb]
 sound                  58368   0 [opl3 sb uart401]
 soundlow                 464   0 [sound]
 soundcore               2800   6 [sb sound]
 ds                      6448   2 [serial_cs]
 i82365                 22928   2
 pcmcia_core            45984   0 [serial_cs ds i82365]</computeroutput>
	      </screen>
	    </para>
	    <note><para>Doing a <command>cat /proc/modules</command> gives the
	      same information.</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="insmodref" /><command moreinfo="none">insmod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>insmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	    <para>Force installation of a kernel module (use
	      <command>modprobe</command> instead, when possible). Must
	      be invoked as <firstterm>root</firstterm>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rmmodref" /><command moreinfo="none">rmmod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rmmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	    <para>Force unloading of a kernel module. Must be invoked
	      as <firstterm>root</firstterm>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="modproberef" /><command moreinfo="none">modprobe</command></term>
	  <listitem>
	  <indexterm>
	    <primary>modprobe</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	    <para>Module loader that is normally invoked automatically
	      in a startup script. Must be invoked as
	      <firstterm>root</firstterm>.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><anchor xml:id="depmodref" /><command moreinfo="none">depmod</command></term>
	  <listitem>
	  <indexterm>
	    <primary>depmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	    <para>Creates module dependency file. Usually invoked from a
	      startup script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="modinforef" /><command moreinfo="none">modinfo</command></term>
	  <listitem>
	  <indexterm>
	    <primary>modinfo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>

	    <para>Output information about a loadable module.</para>

	      <screen><prompt>bash$ </prompt><userinput>modinfo hid</userinput>
<computeroutput>filename:    /lib/modules/2.4.20-6/kernel/drivers/usb/hid.o
 description: "USB HID support drivers"
 author:      "Andreas Gal, Vojtech Pavlik &lt;vojtech@suse.cz&gt;"
 license:     "GPL"</computeroutput>
	      </screen>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="miscsys">
        <title><anchor xml:id="miscsys1" />Miscellaneous</title>

	<varlistentry>
	  <term><anchor xml:id="envvref" /><command moreinfo="none">env</command></term>
	  <listitem>
	  <indexterm>
	    <primary>env</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>env</secondary>
	  </indexterm>
	    <para>
	      Runs a program or script with certain <link linkend="envref">environmental variables</link>
	      set or changed (without changing the overall system
	      environment). The <option>[varname=xxx]</option>
	      permits changing the environmental variable
	      <varname>varname</varname> for the duration of the
	      script. With no options specified, this command lists all
	      the environmental variable settings.

	    <footnote><para>In Bash and other Bourne shell derivatives, it is
	      possible to set variables in a single command's environment.
	      <programlisting>var1=value1 var2=value2 commandXXX
# $var1 and $var2 set in the environment of 'commandXXX' only.</programlisting>	      
            </para></footnote>
	    </para>

            <note>
	    <para><anchor xml:id="envv2ref" />The first line of a script (the
	      <quote>sha-bang</quote> line) may use <command>env</command>
	      when the path to the shell or interpreter is unknown.</para>

	      <para><programlisting>#! /usr/bin/env perl

print "This Perl script will run,\n";
print "even when I don't know where to find Perl.\n";

# Good for portable cross-platform scripts,
# where the Perl binaries may not be in the expected place.
# Thanks, S.C.</programlisting></para>

            <para>Or even ... </para>
            <para><programlisting>#!/bin/env bash
# Queries the $PATH enviromental variable for the location of bash.
# Therefore ...
# This script will run where Bash is not in its usual place, in /bin.
...</programlisting></para>

	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="lddref" /><command moreinfo="none">ldd</command></term>
	  <listitem>
	  <indexterm>
	    <primary>ldd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ldd</secondary>
	  </indexterm>
	    <para>Show shared lib dependencies for an executable file.</para>
	    <screen><prompt>bash$ </prompt><userinput>ldd /bin/ls</userinput>
<computeroutput>libc.so.6 =&gt; /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x80000000)</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="watchref" /><command moreinfo="none">watch</command></term>
	  <listitem>
	  <indexterm>
	    <primary>watch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>periodic</secondary>
	  </indexterm>
	    <para>Run a command repeatedly, at specified time intervals.</para>
	    <para>The default is two-second intervals, but this may be changed
	      with the <option>-n</option> option.</para>
	    <para><programlisting>watch -n 5 tail /var/log/messages
# Shows tail end of system log, /var/log/messages, every five seconds.</programlisting></para>	    

            <note><para>Unfortunately, <link linkend="piperef">piping</link>
	      the output of <command>watch command</command> to <link linkend="grepref">grep</link> does not work.</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="stripref" /><command moreinfo="none">strip</command></term>
	  <listitem>
	  <indexterm>
	    <primary>strip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>symbol</secondary>
	  </indexterm>
	    <para>Remove the debugging symbolic references from an executable
	      binary. This decreases its size, but makes debugging it
	      impossible.</para>
	    <para>This command often occurs in a <link linkend="makefileref">Makefile</link>,
	      but rarely in a shell script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="nmref" /><command moreinfo="none">nm</command></term>
	  <listitem>
	  <indexterm>
	    <primary>nm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>symbol</secondary>
	  </indexterm>
	    <para>List symbols in an unstripped compiled binary.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="xrandrref" /><command moreinfo="none">xrandr</command></term>
	  <listitem>
	  <indexterm>
	    <primary>xrandr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xrandr</secondary>
	  </indexterm>
	    <para>Command-line tool for manipulating the root window
              of the screen.</para>

	    <example xml:id="backlight">
	      <title><firstterm>Backlight</firstterm>: changes
	        the brightness of the (laptop) screen backlight</title>
	      <programlisting>#!/bin/bash
# backlight.sh
# reldate 02dec2011

#  A bug in Fedora Core 16/17 messes up the keyboard backlight controls.
#  This script is a quick-n-dirty workaround, essentially a shell wrapper
#+ for xrandr. It gives more control than on-screen sliders and widgets.

OUTPUT=$(xrandr | grep LV | awk '{print $1}')   # Get display name!
INCR=.05      # For finer-grained control, set INCR to .03 or .02.

old_brightness=$(xrandr --verbose | grep rightness | awk '{ print $2 }')


if [ -z "$1" ]
then
  bright=1    # If no command-line arg, set brightness to 1.0 (default).

  else
    if [ "$1" = "+" ]
    then
      bright=$(echo "scale=2; $old_brightness + $INCR" | bc)   # +.05

  else
    if [ "$1" = "-" ]
    then
      bright=$(echo "scale=2; $old_brightness - $INCR" | bc)   # -.05

  else
    if [ "$1" = "#" ]   # Echoes current brightness; does not change it.
    then
      bright=$old_brightness

  else
    if [[ "$1" = "h" || "$1" = "H" ]]
    then
      echo
      echo "Usage:"
      echo "$0 [No args]    Sets/resets brightness to default (1.0)."
      echo "$0 +            Increments brightness by 0.5."
      echo "$0 -            Decrements brightness by 0.5."
      echo "$0 #            Echoes current brightness without changing it."
      echo "$0 N (number)   Sets brightness to N (useful range .7 - 1.2)."
      echo "$0 h [H]        Echoes this help message."
      echo "$0 any-other    Gives xrandr usage message."

      bright=$old_brightness

  else
    bright="$1"

      fi
     fi
    fi
  fi
fi


xrandr --output "$OUTPUT" --brightness "$bright"   # See xrandr manpage.
                                                   # As root!
E_CHANGE0=$?
echo "Current brightness = $bright"

exit $E_CHANGE0


# =========== Or, alternately . . . ==================== #

#!/bin/bash
# backlight2.sh
# reldate 20jun2012

#  A bug in Fedora Core 16/17 messes up the keyboard backlight controls.
#  This is a quick-n-dirty workaround, an alternate to backlight.sh.

target_dir=\
/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/backlight/acpi_video0
# Hardware directory.

actual_brightness=$(cat $target_dir/actual_brightness)
max_brightness=$(cat $target_dir/max_brightness)
Brightness=$target_dir/brightness

let "req_brightness = actual_brightness"   # Requested brightness.

if [ "$1" = "-" ]
then     # Decrement brightness 1 notch.
  let "req_brightness = $actual_brightness - 1"
else
  if [ "$1" = "+" ]
  then   # Increment brightness 1 notch.
    let "req_brightness = $actual_brightness + 1"
   fi
fi

if [ $req_brightness -gt $max_brightness ]
then
  req_brightness=$max_brightness
fi   # Do not exceed max. hardware design brightness.

echo

echo "Old brightness = $actual_brightness"
echo "Max brightness = $max_brightness"
echo "Requested brightness = $req_brightness"
echo

# =====================================
echo $req_brightness &gt; $Brightness
# Must be root for this to take effect.
E_CHANGE1=$?   # Successful?
# =====================================

if [ "$?" -eq 0 ]
then
  echo "Changed brightness!"
else
  echo "Failed to change brightness!"
fi

act_brightness=$(cat $Brightness)
echo "Actual brightness = $act_brightness"

scale0=2
sf=100 # Scale factor.
pct=$(echo "scale=$scale0; $act_brightness / $max_brightness * $sf" | bc)
echo "Percentage brightness = $pct%"

exit $E_CHANGE1
</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor xml:id="rdistref" /><command moreinfo="none">rdist</command></term>
	  <listitem>
	  <indexterm>
	    <primary>rdist</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rdist</secondary>
	  </indexterm>
	    <para>Remote distribution client: synchronizes, clones,
	      or backs up a file system on a remote server.</para>
	  </listitem>
	</varlistentry>

      </variablelist>



      <section xml:id="sysscripts">
        <title>Analyzing a System Script</title>

      <para><anchor xml:id="killall2ref" /></para>

      <para>Using our knowledge of administrative commands, let us examine a system
	script. One of the shortest and simplest to understand scripts is
	<quote>killall,</quote>
	   <footnote><para>The <firstterm>killall</firstterm> system
	   script should not be confused with the <link linkend="killallref">killall</link> command in <filename class="directory">/usr/bin</filename>.</para></footnote>
	used to suspend running processes at system shutdown.</para>

	    <example xml:id="ex55">
	      <title><firstterm>killall</firstterm>, from <filename class="directory">/etc/rc.d/init.d</filename></title>
	      <programlisting>#!/bin/sh

# --&gt; Comments added by the author of this document marked by "# --&gt;".

# --&gt; This is part of the 'rc' script package
# --&gt; by Miquel van Smoorenburg, &lt;miquels@drinkel.nl.mugnet.org&gt;.

# --&gt; This particular script seems to be Red Hat / FC specific
# --&gt; (may not be present in other distributions).

#  Bring down all unneeded services that are still running
#+ (there shouldn't be any, so this is just a sanity check)

for i in /var/lock/subsys/*; do
        # --&gt; Standard for/in loop, but since "do" is on same line,
        # --&gt; it is necessary to add ";".
        # Check if the script is there.
        [ ! -f $i ] &amp;&amp; continue
        # --&gt; This is a clever use of an "and list", equivalent to:
        # --&gt; if [ ! -f "$i" ]; then continue

        # Get the subsystem name.
        subsys=${i#/var/lock/subsys/}
        # --&gt; Match variable name, which, in this case, is the file name.
        # --&gt; This is the exact equivalent of subsys=`basename $i`.
	
        # --&gt;  It gets it from the lock file name
        # --&gt;+ (if there is a lock file,
        # --&gt;+ that's proof the process has been running).
        # --&gt;  See the "lockfile" entry, above.


        # Bring the subsystem down.
        if [ -f /etc/rc.d/init.d/$subsys.init ]; then
           /etc/rc.d/init.d/$subsys.init stop
        else
           /etc/rc.d/init.d/$subsys stop
        # --&gt;  Suspend running jobs and daemons.
        # --&gt;  Note that "stop" is a positional parameter,
        # --&gt;+ not a shell builtin.
        fi
done
</programlisting>
	    </example>
      
      <para>That wasn't so bad. Aside from a little fancy footwork with variable
	matching, there is no new material there.</para>

      <formalpara><title>Exercise 1</title>
        <para>In <filename class="directory">/etc/rc.d/init.d</filename>,
	  analyze the <command>halt</command> script. It is a bit longer
	  than <command>killall</command>, but similar in concept. Make
	  a copy of this script somewhere in your home directory and
	  experiment with it (do <emphasis>not</emphasis> run it as
	  <firstterm>root</firstterm>). Do a simulated run
	  with the <option>-vn</option> flags (<userinput>sh
	  -vn scriptname</userinput>). Add extensive
	  comments. Change the	commands to <link linkend="echoref">echos</link>.</para></formalpara>

      <formalpara><title>Exercise 2</title>
      <para>Look at some of the more complex scripts in
	<filename class="directory">/etc/rc.d/init.d</filename>.
	Try to understand at least portions of them. Follow
	the above procedure to analyze them. For some
	additional insight, you might also examine the
	file <filename>sysvinitfiles</filename> in <filename class="directory">/usr/share/doc/initscripts-?.??</filename>,
	which is part of the <quote>initscripts</quote>
	documentation.</para></formalpara>

	</section> <!-- Analyzing a System Script -->

  </chapter> <!-- System and Administrative Commands -->

  </part>

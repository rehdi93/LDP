<part label="2" xml:id="part2" xmlns="http://docbook.org/ns/docbook">
    <title>Basics</title>


  <chapter xml:id="special-chars">
    <title>Special Characters</title>

      <para>What makes a character <firstterm>special</firstterm>?
        If it has a meaning beyond its
        <firstterm>literal meaning</firstterm>, a <link linkend="metameaningref">meta-meaning</link>, then we refer
        to it as a <firstterm>special character</firstterm>. Along
        with commands and <link linkend="keywordref">keywords</link>,
        <firstterm>special characters</firstterm> are building blocks
        of Bash scripts.</para>

      <variablelist xml:id="scharlist">
        <title><anchor xml:id="scharlist1" />Special Characters Found In
          Scripts and Elsewhere</title>

	<varlistentry><term><anchor id="hashmarkref" /><token>#</token></term>
	  <listitem>

	    <indexterm>
	      <primary>#</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>#</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>comment</primary>
	    </indexterm>	  

	    <formalpara><title>Comments</title>
	      <para>Lines beginning with a <token>#</token>
	      (with the exception of <link linkend="magnumref">
	      <token>#!</token></link>) are comments and will
	      <emphasis>not</emphasis> be executed.</para>
	    </formalpara>

	    <para><programlisting># This line is a comment.</programlisting></para>

	    <para>Comments may also occur following the end of a command.</para>
	    
	    <para><programlisting>echo "A comment will follow." # Comment here.
#                            ^ Note whitespace before #</programlisting></para>

	    <para><anchor xml:id="wsbcomm" /> Comments may also follow <link linkend="whitespaceref">whitespace</link> at the beginning
	      of a line.</para>
           <para>
             <programlisting>     # A tab precedes this comment.</programlisting>
	   </para>

	    <para><anchor xml:id="comminpipe" />Comments may even be embedded
              within a <link linkend="piperef">pipe</link>.</para>
	    <para>
<programlisting>initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
# Delete lines containing '#' comment character.
           sed -e 's/\./\. /g' -e 's/_/_ /g'` )
# Excerpted from life.sh script</programlisting>
	    </para>



	    <caution><para>A command may not follow a comment on the
	      same line. There is no method of terminating the comment,
	      in order for <quote>live code</quote> to begin on the same
	      line. Use a new line for the next command.</para></caution>

	    <note><para>Of course, a <link linkend="quotingref">quoted</link>
	    or an <link linkend="escp">escaped</link> <token>#</token>
	    in an <link linkend="echoref">echo</link> statement does
	    <emphasis>not</emphasis> begin a comment. Likewise, a
	    <token>#</token> appears in <link linkend="psub2">certain
	    parameter-substitution constructs</link> and in <link linkend="numconstants"> numerical constant expressions</link>.

	    <programlisting>echo "The # here does not begin a comment."
echo 'The # here does not begin a comment.'
echo The \# here does not begin a comment.
echo The # here begins a comment.

echo ${PATH#*:}       # Parameter substitution, not a comment.
echo $(( 2#101011 ))  # Base conversion, not a comment.

# Thanks, S.C.</programlisting>

	  The standard <link linkend="quotingref">quoting and
	  escape</link> characters (" ' \) escape the #.
	  </para></note>

	  <para>Certain <link linkend="psorex1">pattern matching
	    operations</link> also use the <token>#</token>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry><term><anchor id="semicolonref" /><token>;</token></term>
	  <listitem>

	    <indexterm>
	      <primary>;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>separator</primary>
	    </indexterm>	  
	  
	    <formalpara><title>Command separator [semicolon]</title>
	      <para>Permits putting two or more commands on the same
	        line.</para>
	    </formalpara>

	    <para>
	      <programlisting>echo hello; echo there


if [ -x "$filename" ]; then    #  Note the space after the semicolon.
#+                   ^^
  echo "File $filename exists."; cp $filename $filename.bak
else   #                       ^^
  echo "File $filename not found."; touch $filename
fi; echo "File test complete."</programlisting>
</para>
	    
	    <para>Note that the <quote><token>;</token></quote>
	      <link linkend="findref0">sometimes needs to be
	      <firstterm>escaped</firstterm></link>.</para>

	    </listitem>
	</varlistentry>

	<varlistentry><term><token>;;</token></term>
	  <listitem>

	    <indexterm>
	      <primary>;;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>case</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>;;</primary>
	    </indexterm>	  
	  
	    <formalpara><title>Terminator in a <link linkend="caseesac1">case</link> option [double semicolon]</title>
	      <para><anchor xml:id="doublesemicolon" /></para>
	    </formalpara>

	    <para><programlisting>case "$variable" in
  abc)  echo "\$variable = abc" ;;
  xyz)  echo "\$variable = xyz" ;;
esac</programlisting></para>

	    </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>;;&amp;</token></term>
	  <term><token>;&amp;</token></term>
	  <listitem>
	    <indexterm>
	      <primary>;;&amp;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>;;&amp;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>;&amp;</primary>
	      <secondary>case statement</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>;&amp;</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="ncterm">Terminators</link>
           in a <firstterm>case</firstterm> option (<link linkend="bash4ref">version 4+</link> of Bash).</title>
	      <para />
	    </formalpara>
	  </listitem>
	</varlistentry>



	<varlistentry><term><token>.</token></term>
	  <listitem>

	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>dot command</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>source</primary>
	    </indexterm>	  

	    <para><anchor xml:id="dotref" /></para>
	    <formalpara><title><quote>dot</quote> command [period]</title>
	      <para>Equivalent to <link linkend="sourceref">source</link> (see
		<xref linkend="ex38" />). This is a bash <link linkend="builtinref">builtin</link>.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <listitem>
	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>filename</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>part of a filename</primary>
	    </indexterm>	  

	    <formalpara><title><quote>dot</quote>, as a component of a filename</title>
              <para>When working with filenames, a leading dot is the prefix
		of a <quote>hidden</quote> file, a file that an
		<link linkend="lsref">ls</link> will not normally show.
	        <screen><prompt>bash$ </prompt><userinput>touch .hidden-file</userinput>
<prompt>bash$ </prompt><userinput>ls -l</userinput>	      
<computeroutput>total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</computeroutput>


<prompt>bash$ </prompt><userinput>ls -al</userinput>	      
<computeroutput>total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</computeroutput>
	        </screen>
	      </para>
	    </formalpara>

	      <para><anchor xml:id="dotdirectory" /></para>
	      <para>When considering directory names, <firstterm>a single
		dot</firstterm> represents the current working directory,
		and <firstterm>two dots</firstterm> denote the parent
		directory.</para>

	      <para>
	        <screen>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>/home/bozo/projects</computeroutput>

<prompt>bash$ </prompt><userinput>cd .</userinput>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>/home/bozo/projects</computeroutput>

<prompt>bash$ </prompt><userinput>cd ..</userinput>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>/home/bozo/</computeroutput>
	        </screen>
	      </para>

	      <para>The <firstterm>dot</firstterm> often appears as the
	        destination (directory) of a file movement command,
                in this context meaning <firstterm>current
                directory</firstterm>.</para>
	      
	      <para>
	        <screen>
<prompt>bash$ </prompt><userinput>cp /home/bozo/current_work/junk/* .</userinput>
	        </screen>
		Copy all the <quote>junk</quote> files to
		<link linkend="pwdref">$PWD</link>.</para>

	  </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <listitem>

	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>character match</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>match single character</primary>
	    </indexterm>	  

	    <formalpara><title><quote>dot</quote> character match</title>
	      <para>When <link linkend="regexdot">matching
	        characters</link>, as part of a <link linkend="regexref">regular expression</link>, a
		<quote>dot</quote> <link linkend="regexdot">matches a
		single character</link>.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>"</token></term>
	  <listitem><formalpara><title><link linkend="dblquo">partial
	    quoting</link> [double quote]</title>
	      <para><emphasis>"STRING"</emphasis> preserves (from
	      interpretation) most of the special characters within
	      <emphasis>STRING</emphasis>. See <xref linkend="quoting" />.</para>
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>'</token></term>
	  <listitem><formalpara><title><link linkend="snglquo">full
	    quoting</link> [single quote]</title>
	      <para><emphasis>'STRING'</emphasis> preserves all special
	      characters within <emphasis>STRING</emphasis>. This is a
	      stronger form of quoting than <emphasis>"STRING"</emphasis>.
	      See <xref linkend="quoting" />.</para>
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>,</token></term>
	  <listitem><formalpara><title><link linkend="commaop">comma
	    operator</link></title>
	      <para>The <firstterm>comma operator</firstterm>

		<footnote><para><anchor xml:id="operatordef" />An
		  <firstterm>operator</firstterm> is an agent that carries
		  out an <firstterm>operation</firstterm>. Some examples
		  are the common <link linkend="arops1">arithmetic
		  operators</link>, <command>+ - * /</command>. In
		  Bash, there is some overlap between the concepts
		  of <firstterm>operator</firstterm> and <link linkend="keywordref">keyword</link>.</para></footnote>

	      links together a
		series of arithmetic operations. All are evaluated,
		but only the last one is returned.
	       <programlisting>let "t2 = ((a = 9, 15 / 3))"
# Set "a = 9" and "t2 = 15 / 3"</programlisting>
	      </para>
	    </formalpara>

	    <para><anchor xml:id="commaop2" />The <firstterm>comma</firstterm>
	      operator can also concatenate strings.
	       <programlisting>for file in /{,usr/}bin/*calc
#             ^    Find all executable files ending in "calc"
#+                 in /bin and /usr/bin directories.
do
        if [ -x "$file" ]
        then
          echo $file
        fi
done

# /bin/ipcalc
# /usr/bin/kcalc
# /usr/bin/oidcalc
# /usr/bin/oocalc


# Thank you, Rory Winston, for pointing this out.</programlisting>
	      </para>

          </listitem>

	</varlistentry>

	<varlistentry>
	  <term><token>,</token></term>
	  <term><token>,</token></term>
	  <listitem>
            <formalpara><title><link linkend="casemodparamsub">Lowercase
            conversion</link> in <firstterm>parameter substitution</firstterm>
            (added in <link linkend="bash4ref">version 4</link> of Bash)</title>
            <para /></formalpara>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>\</token></term>
	  <listitem><formalpara><title><link linkend="escp">escape</link> [backslash]</title>
	      <para>A quoting mechanism for single characters.</para>
	    </formalpara>
	      
	      <para><userinput>\X</userinput>
		<firstterm>escapes</firstterm> the character
		<emphasis>X</emphasis>. This has the effect of
		<quote>quoting</quote> <emphasis>X</emphasis>, equivalent
		to <emphasis>'X'</emphasis>.  The <token>\</token> may
		be used to quote <token>"</token> and <token>'</token>,
		so they are expressed literally.</para>
	      <para>See <xref linkend="quoting" /> for an in-depth explanation
	        of escaped characters.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <listitem><formalpara><title>Filename path separator [forward slash]</title>
	      <para>Separates the components of a filename (as in
	        <filename>/home/bozo/projects/Makefile</filename>).</para>
	    </formalpara>
	    <para>This is also the division <link linkend="arops1">arithmetic operator</link>.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="backticksref" /><token>`</token></term>
	  <listitem><formalpara><title><link linkend="commandsubref">command substitution</link></title>
	      <para>The <command>`command`</command> construct makes
		available the output of <command>command</command>
		for assignment to a variable. This is also known as
		<link linkend="backquotesref">backquotes</link> or
		backticks.</para></formalpara> </listitem>
	</varlistentry>

	<varlistentry><term><anchor id="colon0ref" /><token>:</token></term>
	  <listitem>

	    <indexterm>
	      <primary>:</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>:</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>null command</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>true</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>endless loop</primary>
	    </indexterm>	  

	    <para><anchor xml:id="nullref" /></para>
	    <formalpara><title>null command [colon]</title>
	      <para>This is the shell equivalent of a
		<quote>NOP</quote> (<replaceable>no op</replaceable>, a
		do-nothing operation). It may be considered a synonym for
		the shell builtin <link linkend="trueref">true</link>. The
		<quote><token>:</token></quote> command is itself a
		<firstterm>Bash</firstterm> <link linkend="builtinref">builtin</link>, and its <link linkend="exitstatusref">exit status</link> is
		<firstterm>true</firstterm>
		(<returnvalue>0</returnvalue>).</para>
	    </formalpara>

	    <para><programlisting>:
echo $?   # 0</programlisting></para>


	    <para>Endless loop:</para>

	    <para><programlisting>
while :
do
   operation-1
   operation-2
   ...
   operation-n
done

# Same as:
#    while true
#    do
#      ...
#    done</programlisting>
	    </para>

	    <para>Placeholder in if/then test:</para>

	    <para><programlisting>
if condition
then :   # Do nothing and branch ahead
else     # Or else ...
   take-some-action
fi</programlisting>
	    </para>

	    <para>Provide a placeholder where a binary operation is
	      expected, see <xref linkend="arithops" /> and <link linkend="defparam">default parameters</link>.</para>

	    <para><programlisting>: ${username=`whoami`}
# ${username=`whoami`}   Gives an error without the leading :
#                        unless "username" is a command or builtin...

: ${1?"Usage: $0 ARGUMENT"}     # From "usage-message.sh example script.</programlisting>
</para>

	    <para>Provide a placeholder where a command is expected in a
	      <link linkend="heredocref">here document</link>. See <xref linkend="anonheredoc" />.</para>

	    <para>Evaluate string of variables using
		<link linkend="paramsubref">parameter substitution</link>
		(as in <xref linkend="ex6" />).

	    <programlisting>: ${HOSTNAME?} ${USER?} ${MAIL?}
#  Prints error message
#+ if one or more of essential environmental variables not set.</programlisting>
</para>
            
            <para><command><link linkend="exprepl1">Variable expansion / substring
	      replacement</link></command>.</para>
	    
	    <para>In combination with the <token>&gt;</token> <link linkend="ioredirref">redirection operator</link>,
	      truncates a file to zero length, without changing its
	      permissions. If the file did not previously exist,
	      creates it.

	      <programlisting>: &gt; data.xxx   # File "data.xxx" now empty.	      

# Same effect as   cat /dev/null &gt;data.xxx
# However, this does not fork a new process, since ":" is a builtin.</programlisting>
              See also <xref linkend="ex12" />.</para>

	    <para>In combination with the <token>&gt;&gt;</token>
	      redirection operator, has no effect on a pre-existing
	      target file (<userinput>: &gt;&gt; target_file</userinput>).
	      If the file did not previously exist, creates it.</para>

      <note><para><anchor xml:id="regfileref" />This applies to regular files,
        not pipes, symlinks, and certain special files.</para></note>


	    <para>May be used to begin a comment line, although this is not
	      recommended. Using <token>#</token> for a comment turns
	      off error checking for the remainder of that line, so
	      almost anything may appear in a comment. However,
	      this is not the case with
	      <token>:</token>.
	      <programlisting>: This is a comment that generates an error, ( if [ $x -eq 3] ).</programlisting>
	    </para>

	    <para>The <quote><token>:</token></quote> serves as a <link linkend="fieldref">field</link>
	      separator, in <link linkend="datafilesref1"><filename>/etc/passwd</filename></link>,
	      and in the <link linkend="pathref">$PATH</link> variable.
	      <screen><prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</computeroutput></screen>
	    </para>

	    <para><anchor xml:id="colonfname" /></para>
	    <para>A <firstterm>colon</firstterm> is <link linkend="fstrangeref">acceptable as a function name</link>.
              <programlisting>:()
{
  echo "The name of this function is "$FUNCNAME" "
  # Why use a colon as a function name?
  # It's a way of obfuscating your code.
}

:

# The name of this function is :</programlisting>

	     This is not <link linkend="portabilityissues">portable</link>
	     behavior, and therefore not a recommended practice.
             In fact, more recent releases of Bash do not permit
	     this usage. An underscore <command>_</command> works,
	     though.</para>


	    <para><anchor xml:id="coloninfunction" /></para>
		    <para>A <firstterm>colon</firstterm> can serve
			    as a placeholder in an otherwise empty
			    function.</para>
		    <para><programlisting>not_empty ()
{
  :
} # Contains a : (null command), and so is not empty.</programlisting></para>


	  </listitem>
	</varlistentry>

	<varlistentry><term><anchor id="notref" /><token>!</token></term>
	  <listitem>
	  
	    <indexterm>
	      <primary>!</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>!</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>not</primary>
	      <secondary>logical</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>not</primary>
	    </indexterm>	  

	    <formalpara><title>reverse (or negate) the sense of
	      a test or exit status [bang]</title>

	      <para>The <token>!</token> operator inverts the <link linkend="exitstatusref">exit status</link>
		of the command to which it is applied (see
		<xref linkend="negcond" />). It also inverts
		the meaning of a test operator. This can, for
		example, change the sense of <firstterm>equal</firstterm>
		( <link linkend="equalsignref">=</link>
		) to <firstterm>not-equal</firstterm> ( != ). The
		<token>!</token> operator is a Bash <link linkend="keywordref">keyword</link>.</para>

	    </formalpara>
	      <para>In a different context, the <token>!</token>
	        also appears in <link linkend="ivrref">indirect variable
		references</link>.</para>

	      <para>In yet another context, from the <firstterm>command
		line</firstterm>, the <token>!</token> invokes the
		Bash <firstterm>history mechanism</firstterm> (see <xref linkend="histcommands" />). Note that within a script,
		the history mechanism is disabled.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="asteriskref" /><token>*</token></term>
	  <listitem>

	    <indexterm>
	      <primary>*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>*</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>wild card</primary>
	      <secondary>globbing</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>regular expression</primary>
	    </indexterm>	  

            <formalpara><title>wild card [asterisk]</title>

	      <para>The <token>*</token> character serves as a <quote>wild
	        card</quote> for filename expansion in
		<link linkend="globbingref">globbing</link>. By itself,
		it matches every filename in a given directory.</para>
	    </formalpara>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo *</userinput>
<computeroutput>abs-book.xml add-drive.sh agram.sh alias.sh</computeroutput>
	      </screen>
	    </para>
	
              <para><anchor xml:id="asteriskref2" /></para>
	      <para>The <token>*</token> also represents <link linkend="asteriskreg">any number
	      (or zero) characters</link> in a <link linkend="regexref">regular expression</link>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*</token></term>
	  <listitem>

	    <indexterm>
	      <primary>*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>*</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>multiplication</primary>
	      <secondary>exponentiation</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>arithmetic operator</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="arops1">arithmetic operator</link></title>

	      <para>In the context of arithmetic operations, the
	        <token>*</token> denotes multiplication.</para>

	    </formalpara>

	    <para><token>**</token> A double asterisk can represent the
              <link linkend="exponentiationref">exponentiation</link>
              operator or <link linkend="globstarref">extended
              file-match</link> <firstterm>globbing</firstterm>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>?</token></term>
          <listitem>

	    <indexterm>
	      <primary>?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>test</primary>
	      <secondary>operator</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>test token</primary>
	    </indexterm>	  

	    <formalpara><title>test operator</title>
	      <para>Within certain expressions, the <token>?</token> indicates
	        a test for a condition.</para>
	    </formalpara>

	      <para><anchor xml:id="cstrinary" /></para>
	      <para>In a <link linkend="dblparens">double-parentheses
	        construct</link>, the <token>?</token>
		can serve as an element of a C-style
		<firstterm>trinary</firstterm> operator.
		<footnote><para>This is more commonly known
                   as the <firstterm>ternary</firstterm>
                   operator. Unfortunately, <firstterm>ternary</firstterm>
                   is an ugly word. It doesn't roll off
                   the tongue, and it doesn't elucidate. It
                   obfuscates. <firstterm>Trinary</firstterm> is by far
                   the more elegant usage.</para></footnote>
	</para>

	<para><varname>condition</varname><command>?</command><varname>result-if-true</varname><command>:</command><varname>result-if-false</varname></para>

	<para><programlisting>(( var0 = var1&lt;98?9:21 ))
#                ^ ^

# if [ "$var1" -lt 98 ]
# then
#   var0=9
# else
#   var0=21
# fi</programlisting></para>


              <para>In a <link linkend="paramsubref">parameter
	        substitution</link> expression, the <token>?</token>
		<link linkend="qerrmsg">tests whether a variable has been
		set</link>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="wildcardqu" /><token>?</token></term>
	  <listitem>

	    <indexterm>
	      <primary>?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>wild card</primary>
	      <secondary>globbing</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>regular expression</primary>
	    </indexterm>	  

            <formalpara><title>wild card</title>

	      <para><anchor xml:id="quexwc" />The <token>?</token> character
		serves as a single-character <quote>wild card</quote>
		for filename expansion in <link linkend="globbingref">globbing</link>, as well as <link linkend="quexregex">representing one character</link>
		in an <link linkend="extregex">extended regular
		expression</link>.</para>

	    </formalpara>

	  </listitem>
	</varlistentry>

	<varlistentry><term><token>$</token></term>
	  <listitem>

	    <indexterm>
	      <primary>$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>variable substitution</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="varsubn">Variable
              substitution</link> (contents of a variable)</title>
             <para>
	       <programlisting>var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo</programlisting>
	       </para>
	       </formalpara>

		   <para><anchor xml:id="varprefixref" /></para>
	       <para>A <token>$</token> prefixing a variable name
		indicates the <firstterm>value</firstterm> the variable
		holds.</para>

	  </listitem>
	</varlistentry>  

	<varlistentry><term><token>$</token></term>
	  <listitem>

	    <indexterm>
	      <primary>$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>regular expression</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>end of line</primary>
	    </indexterm>	  

	    <formalpara><title>end-of-line</title>
	      <para>In a <link linkend="regexref">regular expression</link>, a
		<quote>$</quote> addresses the <link linkend="dollarsignref">end of a line</link> of
		text.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry><term><token>${}</token></term>
	  <listitem>
	    <indexterm>
	      <primary>${}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>${}</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>parameter substitution</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="paramsubref">Parameter
              substitution</link></title>
             <para /></formalpara>
	  </listitem>
	</varlistentry>  

	<varlistentry><term><token>$' ... '</token></term>
	  <listitem>

	    <indexterm>
	      <primary>$' ... '</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>string expansion</primary>
	    </indexterm>	  
	    <indexterm>
	      <primary>string expansion</primary>
	    </indexterm>	  

	    <formalpara><title><link linkend="strq">Quoted string
                    expansion</link></title>
	      <para>This construct expands single or multiple
		      escaped octal or hex values into ASCII

		      <footnote>
                      <para><anchor xml:id="asciidef" /></para>
                      <para><command>A</command>merican
                        <command>S</command>tandard
                        <command>C</command>ode
			for
                        <command>I</command>nformation
			<command>I</command>nterchange.
			This is a system for encoding text characters
			(alphabetic, numeric, and a limited set of symbols)
			as 7-bit numbers that can be stored and manipulated by
			computers. Many of the ASCII characters are
			represented on a standard keyboard.</para></footnote>
		      
		      or <link linkend="unicoderef">Unicode</link>
		      characters.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>$*</token></term>
	  <term><token>$@</token></term>
	  <listitem>

	    <indexterm>
	      <primary>$*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$*</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>$@</primary>
	      <secondary>positional parameters</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>$@</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="appref">positional
	    parameters</link></title>
	      <para />
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>$?</token></term>
	  <listitem>

	    <indexterm>
	      <primary>$?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>exit status</primary>
	      <secondary>variable</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>exit status</primary>
	    </indexterm>	  

            <formalpara><title>exit status variable</title>
	      <para>The <link linkend="exsref">$? variable</link>
	        holds the <link linkend="exitstatusref">exit status</link>
		of a command, a <link linkend="functionref">function</link>,
		or of the script itself.</para>
	    </formalpara>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="processidref" /><token>$$</token></term>
	  <listitem>
	    <indexterm>
	      <primary>$$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$$</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>process ID</primary>
	      <secondary>variable</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>process ID</primary>
	    </indexterm>	  

            <formalpara><title>process ID variable</title>
	      <para>The <link linkend="proccid">$$ variable</link>
	        holds the <firstterm>process ID</firstterm>
		  <footnote>  
		    <para><anchor xml:id="processiddef" /></para>
		    <para>A <firstterm>PID</firstterm>, or
		      <firstterm>process ID</firstterm>, is a number assigned
		      to a running process. The <firstterm>PID</firstterm>s
		      of running processes may be viewed with a <link linkend="ppssref">ps</link> command.
		      </para>
		      <para><anchor xml:id="processref" /></para>
		      <para>
		      <userinput>Definition:</userinput> A
		      <firstterm>process</firstterm> is a currently
		      executing command (or program), sometimes referred
		      to as a <firstterm>job</firstterm>.  </para>
		  </footnote>
		of the script in which it appears.</para>
	    </formalpara>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="parensref" /><token>()</token></term>

	  <listitem>
	    <formalpara><title>command group</title>
	      <para><programlisting>(a=hello; echo $a)</programlisting></para>
	    </formalpara>

	  <important>
	  
	    <para>A listing of commands within
	      <replaceable>parentheses</replaceable> starts a <link linkend="subshellsref">subshell</link>.</para>

	    <para>Variables inside parentheses, within the subshell, are not
	      visible to the rest of the script. The parent process,
	      the script, <link linkend="parvis">cannot read variables
	      created in the child process</link>, the subshell.
	      <programlisting>a=123
( a=321; )	      

echo "a = $a"   # a = 123
# "a" within parentheses acts like a local variable.</programlisting></para>
	  </important>


	  <formalpara><title>array initialization</title>
	    <para>
	      <anchor xml:id="arrayinit1" />
	      <programlisting>Array=(element1 element2 element3)</programlisting>
	    </para>
	    </formalpara>
	  </listitem>

	</varlistentry>

	<varlistentry>
	  <term><token>{xxx,yyy,zzz,...}</token></term>
	  <listitem>

	    <indexterm>
	      <primary>{xxx,yyy,zzz..}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>{}</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>brace expansion</primary>
	    </indexterm>	  
            <formalpara><title>Brace expansion</title>
			  <para><anchor xml:id="braceexpref" />
<programlisting>echo \"{These,words,are,quoted}\"   # " prefix and suffix
# "These" "words" "are" "quoted"


cat {file1,file2,file3} &gt; combined_file
# Concatenates the files file1, file2, and file3 into combined_file.

cp file22.{txt,backup}
# Copies "file22.txt" to "file22.backup"</programlisting></para>
	    </formalpara>

	  <para>A command may act upon a comma-separated list of file specs within
	  <replaceable>braces</replaceable>.

	     <footnote><para>The shell does the <firstterm>brace
	       expansion</firstterm>. The command itself acts upon the
	       <emphasis>result</emphasis> of the expansion.</para></footnote>
	  
	  Filename expansion (<link linkend="globbingref">globbing</link>)
	  applies to the file specs between the braces.</para>

	  <caution>
	    <para>No spaces allowed within the braces
	    <emphasis>unless</emphasis> the spaces are quoted or escaped.</para>
	    
	    <para><userinput>echo {file1,file2}\ :{\ A," B",' C'}</userinput></para>
	    <para><computeroutput>file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</computeroutput></para>

	   </caution>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="braceexpref33" /><token>{a..z}</token></term>
	  <listitem>
	    <indexterm>
	      <primary>{a..z}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>{}</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>extended brace expansion</primary>
	    </indexterm>	  

	  <formalpara>
	  <title>Extended Brace expansion</title>
	      <para>
<programlisting>echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
# Echoes characters between a and z.

echo {0..3} # 0 1 2 3
# Echoes characters between 0 and 3.


base64_charset=( {A..Z} {a..z} {0..9} + / = )
# Initializing an array, using extended brace expansion.
# From vladz's "base64.sh" example script.</programlisting>
	      </para>
	    </formalpara>

	  <para>The <firstterm>{a..z}</firstterm>
	    <link linkend="braceexpref3">extended brace
	    expansion</link> construction is a feature introduced
	    in <link linkend="bash3ref">version 3</link> of
	    <firstterm>Bash</firstterm>.</para>

	  </listitem>
	</varlistentry>




	<varlistentry>
	  <term><anchor id="codeblockref" /><token>{}</token></term>
	  <listitem>

	    <indexterm>
	      <primary>{}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>{}</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>block of code</primary>
	    </indexterm>	  

	    <formalpara><title>Block of code [curly brackets]</title>
	      <para>Also referred to as an <firstterm>inline group</firstterm>,
		this construct, in effect, creates an <firstterm>anonymous
		function</firstterm> (a function without a
		name). However, unlike in a <quote>standard</quote> <link linkend="functionref">function</link>, the variables
		inside a code block remain visible to the remainder of the
		script.</para></formalpara>

	      <para> <screen><prompt>bash$ </prompt><userinput>{ local a;
	      a=123; }</userinput>
<computeroutput>bash: local: can only be used in a
function</computeroutput>
	      </screen> </para>

	      <para><programlisting>a=123
{ a=321; }
echo "a = $a"   # a = 321   (value inside code block)

# Thanks, S.C.</programlisting></para>


	    <para><anchor xml:id="blockio" /></para>
	    <para>The code block enclosed in braces may have <link linkend="ioredirref">I/O redirected</link> to and from
	      it.</para>

	    <example xml:id="ex8">
	      <title>Code blocks and I/O redirection</title>
	      <programlisting>#!/bin/bash
# Reading lines in /etc/fstab.

File=/etc/fstab

{
read line1
read line2
} &gt; $File

echo "First line in $File is:"
echo "$line1"
echo
echo "Second line in $File is:"
echo "$line2"

exit 0

# Now, how do you parse the separate fields of each line?
# Hint: use awk, or . . .
# . . . Hans-Joerg Diers suggests using the "set" Bash builtin.
</programlisting>
	    </example>

	    <para><anchor xml:id="blockio2" /></para>
	    <example xml:id="rpmcheck">
	      <title>Saving the output of a code block to a file</title>
	      <programlisting>#!/bin/bash
# rpm-check.sh

#  Queries an rpm file for description, listing,
#+ and whether it can be installed.
#  Saves output to a file.
# 
#  This script illustrates using a code block.

SUCCESS=0
E_NOARGS=65

if [ -z "$1" ]
then
  echo "Usage: `basename $0` rpm-file"
  exit $E_NOARGS
fi  

{ # Begin code block.
  echo
  echo "Archive Description:"
  rpm -qpi $1       # Query description.
  echo
  echo "Archive Listing:"
  rpm -qpl $1       # Query listing.
  echo
  rpm -i --test $1  # Query whether rpm file can be installed.
  if [ "$?" -eq $SUCCESS ]
  then
    echo "$1 can be installed."
  else
    echo "$1 cannot be installed."
  fi  
  echo              # End code block.
} &gt; "$1.test"       # Redirects output of everything in block to file.

echo "Results of rpm test in file $1.test"

# See rpm man page for explanation of options.

exit 0
</programlisting>
	    </example>

	    <note><para>Unlike a command group within (parentheses),
	      as above, a code block enclosed by {braces} will
	      <emphasis>not</emphasis> normally launch a <link linkend="subshellsref">subshell</link>.

		<footnote>
		  <para>Exception: a code block in braces as
		  part of a pipe <emphasis>may</emphasis> run as a
		  <link linkend="subshellsref">subshell</link>.</para>

        <para><programlisting>ls | { read firstline; read secondline; }
#  Error. The code block in braces runs as a subshell,
#+ so the output of "ls" cannot be passed to variables within the block.
echo "First line is $firstline; second line is $secondline"  # Won't work.

# Thanks, S.C.</programlisting></para>
		</footnote>

                </para>

		<para>It is possible to <link linkend="iterationref">iterate</link> a code block
                using a <link linkend="nododone">non-standard
                <firstterm>for-loop</firstterm></link>.</para>

                </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>{}</token></term>
	  <listitem>

	  <formalpara><title>placeholder for text</title>
	      <para>Used after <link linkend="xargscurlyref">xargs
		<option>-i</option></link> (<firstterm>replace
		strings</firstterm> option). The <token>{}</token> double
		curly brackets are a placeholder for output text.</para>
	    </formalpara>

              <para><programlisting>ls . | xargs -i -t cp ./{} $1
#            ^^         ^^

# From "ex42.sh" (copydir.sh) example.</programlisting></para>
	  <para><anchor xml:id="semicolonesc" /></para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>{} \;</token></term>
	  <listitem>

	  <formalpara><title>pathname</title>
	      <para>Mostly used in <link linkend="findref">find</link>
		constructs. This is <emphasis>not</emphasis> a shell
		<link linkend="builtinref">builtin</link>.</para>
	    </formalpara>

	    <sidebar><para><anchor xml:id="pathnameref" /></para>
              <para>Definition: A <firstterm>pathname</firstterm>
              is a <firstterm>filename</firstterm> that includes the
              complete <link linkend="pathref">path</link>.  As an example,
              <filename>/home/bozo/Notes/Thursday/schedule.txt</filename>.
              This is sometimes referred to as the <firstterm>absolute
              path</firstterm>.</para></sidebar>

	      <note><para>The <quote><token>;</token></quote> ends
		the <option>-exec</option> option of a
		<command>find</command> command sequence.  It needs
		to be escaped to protect it from interpretation by the
		shell.</para></note>

	  </listitem>
	</varlistentry>



	<varlistentry><term><anchor id="leftbracket" /><token>[ ]</token></term>
	  <listitem>

	    <indexterm>
	      <primary>[]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>[ ]</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>test</primary>
	    </indexterm>	  

            <formalpara><title>test</title>
             <para><anchor xml:id="bracktest" /></para></formalpara>
	     <para><link linkend="ifthen">Test</link> expression between
	       <command>[ ]</command>.	Note that <command>[</command>
	       is part of the shell <firstterm>builtin</firstterm> <link linkend="ttestref">test</link> (and a synonym for it),
	       <emphasis>not</emphasis> a link to the external command
	       <filename>/usr/bin/test</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>[[ ]]</token></term>
	  <listitem>
	    <indexterm>
	      <primary>[[]]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>[[ ]]</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>test</primary>
	    </indexterm>	  

            <formalpara><title>test</title>
             <para /></formalpara>
	     <para>Test expression between <token>[[ ]]</token>. More
	     flexible than the single-bracket <token>[ ]</token> test,
	     this is a shell <link linkend="keywordref">keyword</link>.</para> <para>See the
	     discussion on the <link linkend="dblbrackets">[[ ... ]]
	     construct</link>.</para>
	  </listitem>

	</varlistentry>

	<varlistentry><term><token>[ ]</token></term>
	  <listitem>

	    <indexterm>
	      <primary>[ ]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>array_element[ ]</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>array element</primary>
	    </indexterm>	  

            <formalpara><title>array element</title>
             <para /></formalpara>
	     <para>In the context of an <link linkend="arrayref">array</link>,
	       brackets set off the numbering of each element of that array.
	         <programlisting>Array[1]=slot_1
echo ${Array[1]}</programlisting></para>		 
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>[ ]</token></term>
	  <listitem>

	    <indexterm>
	      <primary>[ ]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>character range</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>regular expression</primary>
	    </indexterm>	  

            <formalpara><title>range of characters</title>
             <para /></formalpara>
	     <para>As part of a <link linkend="regexref">regular
	       expression</link>, brackets delineate a <link linkend="bracketsref">range of characters</link> to
	       match.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><anchor id="bracketarith" /><token>$[ ... ]</token></term>
	  <listitem>

	    <indexterm>
	      <primary>$[ ]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>integer expansion</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>integer arithmetic (obsolete)</primary>
	    </indexterm>	  

            <formalpara><title>integer expansion</title>
             <para /></formalpara>
	     <para>Evaluate integer expression between
	       <token>$[ ]</token>.
               <programlisting>a=3
b=7

echo $[$a+$b]   # 10
echo $[$a*$b]   # 21</programlisting></para>

	     <para>Note that this usage is <emphasis>deprecated</emphasis>,
               and has been replaced by the
               <link linkend="dblparens">(( ... ))</link> construct.</para>
	  </listitem>
	</varlistentry>


	<varlistentry><term><token>(( ))</token></term>
	  <listitem>

	    <indexterm>
	      <primary>(( ))</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>(( ))</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>integer comparison</primary>
	    </indexterm>	  

            <formalpara><title>integer expansion</title>
             <para /></formalpara>
	     <para>Expand and evaluate integer expression between
	       <token>(( ))</token>.</para>
	     <para>See the discussion on the <link linkend="dblparens">(( ... )) construct</link>.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>&gt;</token> <token>&amp;&gt;</token> <token>&gt;&amp;</token> <token>&gt;&gt;</token> <token>&lt;</token> <token>&lt;&gt;</token></term>
	  <listitem>
	    <indexterm>
	      <primary>&gt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gt;&amp;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gt;&gt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>&lt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>&gt;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>&gt;&amp;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>&gt;&gt;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>&lt;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>redirection</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="ioredirref">redirection</link></title>
	      <para />
	    </formalpara>

	    <para><userinput>scriptname &gt;filename</userinput> redirects the output of
	      <filename>scriptname</filename> to file
	      <filename>filename</filename>. Overwrite
	      <filename>filename</filename> if it already exists.</para>

	    <para><anchor xml:id="redirouterror" /></para>
	    <para><userinput>command &amp;&gt;filename</userinput> redirects
	      both the <link linkend="stdinoutdef"><filename>stdout</filename></link>
	      and the
	      <filename>stderr</filename> of <filename>command</filename>
	      to <filename>filename</filename>.</para>


              <note>

              <para>
                <anchor xml:id="devnullredirect" />
	        This is useful for suppressing output when
                testing for a condition. For example, let us
                test whether a certain command exists.
              </para>

              <para>
		    <screen>
<prompt>bash$ </prompt><userinput>type bogus_command &amp;&gt;/dev/null</userinput>
<computeroutput />


<prompt>bash$ </prompt><userinput>echo $?</userinput>
<computeroutput>1</computeroutput>
                    </screen>
              </para>

	      <para>Or in a script:</para>

	      <para><programlisting>command_test () { type "$1" &amp;&gt;/dev/null; }
#                                      ^

cmd=rmdir            # Legitimate command.
command_test $cmd; echo $?   # 0


cmd=bogus_command    # Illegitimate command
command_test $cmd; echo $?   # 1</programlisting></para>

              </note>


	    <para><anchor xml:id="redirouterror2" /></para>
	    <para><userinput>command &gt;&amp;2</userinput> redirects
	      <filename>stdout</filename> of <filename>command</filename>
	      to <filename>stderr</filename>.</para>

	    <para><userinput>scriptname &gt;&gt;filename</userinput> appends
	      the output of <filename>scriptname</filename>
	      to file <filename>filename</filename>. If
	      <filename>filename</filename> does not already exist,
	      it is created.</para>

	    <para><anchor xml:id="redirrw" /></para>
	    <para><userinput>[i]&lt;&gt;filename</userinput>
               opens file <filename>filename</filename> for reading
               and writing, and assigns <link linkend="fdref">file
               descriptor</link> <token>i</token> to it. If
               <filename>filename</filename> does not exist, it is
               created.</para>


	    <formalpara><title><link linkend="processsubref">process substitution</link></title>
	      <para />
	    </formalpara>

	    <para><userinput>(command)&gt;</userinput></para>
	    <para><userinput>&lt;(command)</userinput></para>


	    <para><link linkend="ltref">In a different context</link>,
	      the <quote><token>&lt;</token></quote> and
	      <quote><token>&gt;</token></quote> characters act
	      as <link linkend="scomparison1">string comparison
	      operators</link>.</para>

	    <para><link linkend="intlt">In yet another context</link>,
	      the <quote><token>&lt;</token></quote> and
	      <quote><token>&gt;</token></quote> characters act
	      as <link linkend="icomparison1">integer comparison
	      operators</link>. See also <xref linkend="ex45" />.</para>

	  </listitem>


	</varlistentry>

	<varlistentry>
	  <term><anchor id="heredocrrref" /><token>&lt;&lt;</token></term>
	  <listitem><formalpara><title>redirection used in a <link linkend="heredocref">here document</link></title>
	      <para />
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="herestringref" /><token>&lt;&lt;&lt;</token></term>
	  <listitem><formalpara><title>redirection used in a <link linkend="herestringsref">here string</link></title>
	      <para />
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&lt;</token></term>
	  <term><token>&gt;</token></term>
	  <listitem>

	    <indexterm>
	      <primary>&lt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>&lt;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gt;</primary>
	      <secondary>ASCII comparison</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>&gt;</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="ltref">ASCII
	    comparison</link></title>
	      <para><programlisting>veg1=carrots
veg2=tomatoes

if [[ "$veg1" &lt; "$veg2" ]]
then
  echo "Although $veg1 precede $veg2 in the dictionary,"
  echo -n "this does not necessarily imply anything "
  echo "about my culinary preferences."
else
  echo "What kind of dictionary are you using, anyhow?"
fi</programlisting></para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>\&lt;</token></term>
	  <term><token>\&gt;</token></term>
	  <listitem>

	    <indexterm>
	      <primary>\&lt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>regular expression</primary>
	      <secondary>\&lt;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gt;</primary>
	      <secondary>word boundary</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>&gt;</primary>
	    </indexterm>	  

            <formalpara><title><link linkend="anglebrac">word
	    boundary</link> in a <link linkend="regexref">regular
	    expression</link></title>
	    <para />
	    </formalpara>
	      <para><prompt>bash$ </prompt><userinput>grep '\&lt;the\&gt;' textfile</userinput></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <listitem>
	    <indexterm>
	      <primary>|</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>|</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>pipe</primary>
	    </indexterm>	  

	  <para><anchor xml:id="piperef" /></para>
	  <formalpara><title>pipe</title>
	      <para>Passes the output (<filename>stdout</filename>)
		of a previous command to the input
		(<filename>stdin</filename>) of the next one, or
		to the shell. This is a method of chaining commands
		together.</para>
	    </formalpara>

	    <para>
              <programlisting>echo ls -l | sh
#  Passes the output of "echo ls -l" to the shell,
#+ with the same result as a simple "ls -l".


cat *.lst | sort | uniq
# Merges and sorts all ".lst" files, then deletes duplicate lines.</programlisting>
	    </para>

	    <sidebar>

	    <para>
	      A pipe, as a classic method of interprocess
	      communication, sends the <filename>stdout</filename>
	      of one <link linkend="processref">process</link> to the
	      <filename>stdin</filename> of another. In a typical case,
	      a command, such as <link linkend="catref">cat</link> or
	      <link linkend="echoref">echo</link>, pipes a stream of
	      data to a
	      <anchor xml:id="filterdef" />
	      <firstterm>filter</firstterm>, a command that
	      transforms its input for processing.
		<footnote><para> Even as in olden times a
		<firstterm>philtre</firstterm> denoted a potion alleged
		to have magical transformative powers, so does a UNIX
		<firstterm>filter</firstterm> transform its target in
		(roughly) analogous fashion. (The coder who comes up with a
		<quote>love philtre</quote> that runs on a Linux machine
		will likely win accolades and honors.)</para></footnote>
	      </para>

	    <para>  
	      <userinput>cat $filename1 $filename2 | grep $search_word</userinput>
            </para>

	    <para>For an interesting note on the complexity of using UNIX
	      pipes, see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.faqs.org/faqs/unix-faq/faq/part3/">the UNIX FAQ,
	      Part 3</link>.</para>

	    </sidebar>


	    <para><anchor xml:id="ucref" />The output of a command or commands
	      may be piped to a script.

	      <programlisting>#!/bin/bash
# uppercase.sh : Changes input to uppercase.

tr 'a-z' 'A-Z'
#  Letter ranges must be quoted
#+ to prevent filename generation from single-letter filenames.

exit 0</programlisting>
              Now, let us pipe the output of <command>ls -l</command> to this
	      script.

	      <screen><prompt>bash$ </prompt><userinput>ls -l | ./uppercase.sh</userinput>
<computeroutput>-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</computeroutput>
	      </screen>
	    </para>

	     <note>

	     <para>The <filename>stdout</filename> of each process in
	       a pipe must be read as the <filename>stdin</filename>
	       of the next. If this is not the case, the data stream
	       will <firstterm>block</firstterm>, and the pipe will not
	       behave as expected.
	         <programlisting>cat file1 file2 | ls -l | sort
# The output from "cat file1 file2" disappears.</programlisting>
             </para>

	     <para>A pipe runs as a <link linkend="childref">child
	       process</link>, and therefore cannot alter script
	       variables.
	         <programlisting>variable="initial_value"
echo "new_value" | read variable
echo "variable = $variable"     # variable = initial_value</programlisting>
             </para>

	     <para>If one of the commands in the pipe
	       aborts, this prematurely terminates execution of the
	       pipe. Called a <firstterm>broken pipe</firstterm>, this
	       condition sends a <replaceable>SIGPIPE</replaceable> <link linkend="signald">signal</link>.</para>

	      </note>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&gt;|</token></term>
	  <listitem>
	    <indexterm>
	      <primary>&gt;|</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>&gt;|</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>redirection</primary>
	      <secondary>force</secondary>
	    </indexterm>	  
	    <indexterm>
	      <primary>noclobber</primary>
	    </indexterm>	  

            <formalpara><title>force redirection (even if
		the <link linkend="noclobberref">noclobber option</link>
		is set)</title>
	      <para>This will forcibly overwrite an existing file.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>||</token></term>
	  <listitem>
	  <indexterm>
	    <primary>||</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>||</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>or</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>logical operator</primary>
	  </indexterm>	  

	    <formalpara><title><link linkend="orref">OR logical operator</link></title>
	      <para>In a <link linkend="testconstructs1">test
		construct</link>, the <token>||</token> operator causes
		a return of <returnvalue>0</returnvalue> (success) if
		<emphasis>either</emphasis> of the linked test conditions
		is true.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="bgjob" /><token>&amp;</token></term>
	  <listitem><formalpara><title>Run job in background</title>
	      <para>A command followed by an <token>&amp;</token>
	        will run in the background.</para>
	    </formalpara>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>sleep 10 &amp;</userinput>
<computeroutput>[1] 850</computeroutput>
<computeroutput>[1]+  Done                    sleep 10</computeroutput>
	      </screen>
	    </para>

	    <para>Within a script, commands and even <link linkend="forloopref1">loops</link> may run in the
	      background.</para>

	    <para><anchor xml:id="bgloop0" /></para>
	    <example xml:id="bgloop">
	      <title>Running a loop in the background</title>
	      <programlisting>#!/bin/bash
# background-loop.sh

for i in 1 2 3 4 5 6 7 8 9 10            # First loop.
do
  echo -n "$i "
done &amp; # Run this loop in background.
       # Will sometimes execute after second loop.

echo   # This 'echo' sometimes will not display.

for i in 11 12 13 14 15 16 17 18 19 20   # Second loop.
do
  echo -n "$i "
done  

echo   # This 'echo' sometimes will not display.

# ======================================================

# The expected output from the script:
# 1 2 3 4 5 6 7 8 9 10 
# 11 12 13 14 15 16 17 18 19 20 

# Sometimes, though, you get:
# 11 12 13 14 15 16 17 18 19 20 
# 1 2 3 4 5 6 7 8 9 10 bozo $
# (The second 'echo' doesn't execute. Why?)

# Occasionally also:
# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
# (The first 'echo' doesn't execute. Why?)

# Very rarely something like:
# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 
# The foreground loop preempts the background one.

exit 0

#  Nasimuddin Ansari suggests adding    sleep 1
#+ after the   echo -n "$i"   in lines 6 and 14,
#+ for some real fun.
</programlisting>
	    </example>

	    <caution><para>A command run in the background within a
	      script may cause the script to hang, waiting
	      for a keystroke. Fortunately, there is a <link linkend="waithang">remedy</link> for this.</para></caution>

	    </listitem>
	</varlistentry>

	<varlistentry><term><anchor id="logicaland" /><token>&amp;&amp;</token></term>
	  <listitem>
	  <indexterm>
	    <primary>&amp;&amp;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>&amp;&amp;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>and</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>logical operator</primary>
	  </indexterm>	  

	    <formalpara><title><link linkend="logops1">AND logical
	    operator</link></title>

	      <para>In a <link linkend="testconstructs1">test
		construct</link>, the <token>&amp;&amp;</token> operator causes
		a return of <returnvalue>0</returnvalue> (success) only if
		<emphasis>both</emphasis> the linked test conditions
		are true.</para>

	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dashref" /><token>-</token></term>
	  <listitem><formalpara><title>option, prefix</title>
	      <para>Option flag for a command or filter. Prefix for
		an operator. Prefix for a <link linkend="defparam1">default parameter</link>
		in <link linkend="paramsubref">parameter
		substitution</link>.</para>
	    </formalpara>
	      <para><userinput>COMMAND -[Option1][Option2][...]</userinput></para>
	      <para><userinput>ls -al</userinput></para>
	      <para><userinput>sort -dfu $filename</userinput></para>



	      <para>
	      <programlisting>if [ $file1 -ot $file2 ]
then #      ^
  echo "File $file1 is older than $file2."
fi

if [ "$a" -eq "$b" ]
then #    ^
  echo "$a is equal to $b."
fi

if [ "$c" -eq 24 -a "$d" -eq 47 ]
then #    ^              ^
  echo "$c equals 24 and $d equals 47."
fi


param2=${param1:-$DEFAULTVAL}
#               ^</programlisting>  
	      </para>

	      <para><anchor xml:id="doubledashref" /></para>
	      <para><command>--</command></para>

	      <para>The <firstterm>double-dash</firstterm>
		<option>--</option> prefixes <firstterm>long</firstterm>
		(verbatim) options to commands.</para>

	      <para><userinput>sort --ignore-leading-blanks</userinput></para>

              <para>Used with a <link linkend="builtinref">Bash
	        builtin</link>, it means the <firstterm>end of
		options</firstterm> to that particular command.</para>

		<tip><para>This provides a handy means of removing
		  files whose <emphasis>names begin with a dash</emphasis>.
	      <screen><prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>-rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname</computeroutput>


<prompt>bash$ </prompt><userinput>rm -- -badname</userinput>

<prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>total 0</computeroutput></screen>
	    </para></tip>

	      <para>The <firstterm>double-dash</firstterm> is also used in
	        conjunction with <link linkend="setref">set</link>.</para>

	      <para><userinput>set -- $variable</userinput> (as in <xref linkend="setpos" />)</para>

  
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dashref2" /><token>-</token></term>
	  <listitem>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>from/to stdin/stdout</secondary>
	  </indexterm>	  
	  <formalpara><title>redirection from/to <filename>stdin</filename> or <filename>stdout</filename> [dash]</title>
	    <para><anchor xml:id="coxex" /></para>
	    </formalpara>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>cat -</userinput>
<userinput>abc</userinput>
<computeroutput>abc</computeroutput>

<computeroutput>...</computeroutput>

<userinput>Ctl-D</userinput></screen>
	    </para>

	    <para>As expected, <userinput>cat -</userinput> echoes
	    <filename>stdin</filename>, in this case keyboarded user input,
	    to <filename>stdout</filename>. But, does I/O redirection using
	    <command>-</command> have real-world applications?</para>

	    <para><programlisting>(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)
# Move entire file tree from one directory to another
# [courtesy Alan Cox &lt;a.cox@swansea.ac.uk&gt;, with a minor change]

# 1) cd /source/directory
#    Source directory, where the files to be moved are.
# 2) &amp;&amp;
#   "And-list": if the 'cd' operation successful,
#    then execute the next command.
# 3) tar cf - .
#    The 'c' option 'tar' archiving command creates a new archive,
#    the 'f' (file) option, followed by '-' designates the target file
#    as stdout, and do it in current directory tree ('.').
# 4) |
#    Piped to ...
# 5) ( ... )
#    a subshell
# 6) cd /dest/directory
#    Change to the destination directory.
# 7) &amp;&amp;
#   "And-list", as above
# 8) tar xpvf -
#    Unarchive ('x'), preserve ownership and file permissions ('p'),
#    and send verbose messages to stdout ('v'),
#    reading data from stdin ('f' followed by '-').
#
#    Note that 'x' is a command, and 'p', 'v', 'f' are options.
#
# Whew!



# More elegant than, but equivalent to:
#   cd source/directory
#   tar cf - . | (cd ../dest/directory; tar xpvf -)
#
#     Also having same effect:
# cp -a /source/directory/* /dest/directory
#     Or:
# cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
#     If there are hidden files in /source/directory.
</programlisting></para>

	    <para><programlisting>bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
#  --uncompress tar file--      | --then pass it to "tar"--
#  If "tar" has not been patched to handle "bunzip2",
#+ this needs to be done in two discrete steps, using a pipe.
#  The purpose of the exercise is to unarchive "bzipped" kernel source.
</programlisting></para>
       
          <para>Note that in this context the <quote>-</quote> is not
            itself a Bash operator, but rather an option recognized by
	    certain UNIX utilities that write to
	    <filename>stdout</filename>, such as <command>tar</command>,
	    <command>cat</command>, etc.</para>


	    <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "whatever" | cat -</userinput>
<computeroutput>whatever</computeroutput> </screen>
	    </para>


	    <para>Where a filename is expected,
	      <replaceable>-</replaceable> redirects output to
	      <filename>stdout</filename> (sometimes seen with
	      <userinput>tar cf</userinput>), or accepts input from
	      <filename>stdin</filename>, rather than from a file.
	      <anchor xml:id="filterdash" />
	      This is a method of using a file-oriented utility as a
	      filter in a pipe.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>file</userinput>
<computeroutput>Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</computeroutput>
	      </screen>

	    By itself on the command-line, <link linkend="fileref">file</link> fails with an error message.
	    </para>

	    <para>
	    Add a <quote>-</quote> for a more useful result. This causes the
	      shell to await user input.

	      <screen>
<prompt>bash$ </prompt><userinput>file -</userinput>
<userinput>abc</userinput>
<computeroutput>standard input:              ASCII text</computeroutput>



<prompt>bash$ </prompt><userinput>file -</userinput>
<userinput>#!/bin/bash</userinput>
<computeroutput>standard input:              Bourne-Again shell script text executable</computeroutput>
	      </screen>

	      Now the command accepts input from <filename>stdin</filename>
	        and analyzes it.
	    </para>

	    <para>The <quote>-</quote> can be used to pipe
	      <filename>stdout</filename> to other commands. This permits
	      such stunts as <link linkend="prependref">prepending lines
	      to a file</link>.</para>

	    <para>Using <link linkend="diffref">diff</link> to
	      compare a file with a <emphasis>section</emphasis>
	      of another:</para>

<para><userinput>grep Linux file1 | diff file2 -</userinput></para>	      


            <para>Finally, a real-world example using
	      <replaceable>-</replaceable> with <link linkend="tarref">tar</link>.</para>

	    <example xml:id="ex58">
	      <title>Backup of all files changed in last day</title>
	      <programlisting>#!/bin/bash

#  Backs up all files in current directory modified within last 24 hours
#+ in a "tarball" (tarred and gzipped file).

BACKUPFILE=backup-$(date +%m-%d-%Y)
#                 Embeds date in backup filename.
#                 Thanks, Joshua Tschida, for the idea.
archive=${1:-$BACKUPFILE}
#  If no backup-archive filename specified on command-line,
#+ it will default to "backup-MM-DD-YYYY.tar.gz."

tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar
gzip $archive.tar
echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."


#  Stephane Chazelas points out that the above code will fail
#+ if there are too many files found
#+ or if any filenames contain blank characters.

# He suggests the following alternatives:
# -------------------------------------------------------------------
#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
#      using the GNU version of "find".


#   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
#         portable to other UNIX flavors, but much slower.
# -------------------------------------------------------------------


exit 0
</programlisting>
	    </example>

	    <caution>

	    <para>Filenames beginning with
	      <quote>-</quote> may cause problems when coupled with the
	      <quote>-</quote> redirection operator. A script should
	      check for this and add an appropriate prefix to such
	      filenames, for example <filename>./-FILENAME</filename>,
	      <filename>$PWD/-FILENAME</filename>, or
	      <filename>$PATHNAME/-FILENAME</filename>.</para>

	      <para>If the value of a variable begins with a
	        <replaceable>-</replaceable>, this may likewise create
		problems.
		<programlisting>var="-n"
echo $var		
# Has the effect of "echo -n", and outputs nothing.</programlisting>
              </para>
	      </caution>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>previous working directory</title>
	      <para>A <command>cd -</command> command changes to the
		previous working directory. This uses the
		<link linkend="oldpwd">$OLDPWD</link> <link linkend="envref">environmental variable</link>.</para>
	    </formalpara>
	      <caution><para>Do not confuse the <quote>-</quote> used in this
		sense with the <quote>-</quote> redirection
		operator just discussed. The interpretation of the
		<quote>-</quote> depends on the context in which it
		appears.</para></caution>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>Minus</title>
	      <para>Minus sign in an <link linkend="arops1">arithmetic
	        operation</link>.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=</token></term>
	  <listitem><formalpara><title>Equals</title>
	      <para><link linkend="eqref">Assignment operator</link>
	        <programlisting>a=28
echo $a   # 28</programlisting></para>
	    </formalpara>
	    <para>In a <link linkend="equalsignref">different context</link>,
	      the <quote><token>=</token></quote> is a <link linkend="scomparison1">string comparison</link>
	      operator.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+</token></term>
	  <listitem><formalpara><title>Plus</title>
	      <para>Addition  <link linkend="arops1">arithmetic
	        operator</link>.</para>
	    </formalpara>
	    <para>In a <link linkend="plusref">different context</link>,
	      the <token>+</token> is a <link linkend="regexp">Regular
	      Expression</link> operator.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+</token></term>
	  <listitem><formalpara><title>Option</title>
	      <para>Option flag for a command or filter.</para>
	    </formalpara>
	    <para>Certain commands and <link linkend="builtinref">builtins</link> use the
	      <option>+</option> to enable certain options and the
	      <option>-</option> to disable them. In <link linkend="paramsubref">parameter substitution</link>,
	      the <option>+</option> prefixes an <link linkend="paramaltv">
	      alternate value</link> that a variable expands to.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="modulo00" /><token>%</token></term>
	  <listitem><formalpara><title><link linkend="moduloref">modulo</link></title>
	      <para>Modulo (remainder of a division) <link linkend="arops1">arithmetic
	        operation</link>.</para>
	    </formalpara>
	    <para><programlisting>let "z = 5 % 3"
echo $z  # 2</programlisting></para>
	    <para>In a <link linkend="pctpatref">different context</link>,
	      the <token>%</token> is a <link linkend="psub2">pattern
	      matching</link> operator.</para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="tilderef" /><token>~</token></term>
	  <listitem><formalpara><title>home directory [tilde]</title>

	      <para>This corresponds to the <link linkend="homedirref">$HOME</link> internal variable.

	      <filename>~bozo</filename> is bozo's home directory,
		and <command>ls ~bozo</command> lists the contents of it.
		<token>~/</token> is the current user's home directory,
		and <command>ls ~/</command> lists the contents of it.

	      <screen><prompt>bash$ </prompt><userinput>echo ~bozo</userinput>
<computeroutput>/home/bozo</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~</userinput>
<computeroutput>/home/bozo</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~/</userinput>
<computeroutput>/home/bozo/</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~:</userinput>
<computeroutput>/home/bozo:</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~nonexistent-user</userinput>
<computeroutput>~nonexistent-user</computeroutput>
	      </screen>
	      </para>

	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="workingdirref" /><token>~+</token></term>
	  <listitem><formalpara><title>current working directory</title>
	      <para>This corresponds to the <link linkend="pwdref">$PWD</link> internal variable.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="prevworkingdir" /><token>~-</token></term>
	  <listitem><formalpara><title>previous working directory</title>
	      <para>This corresponds to the <link linkend="oldpwd">$OLDPWD</link> internal variable.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=~</token></term>
	  <listitem><formalpara><title><link linkend="regexmatchref">regular
	  expression match</link></title>
	      <para>This operator was introduced with <link linkend="bash3ref">version 3</link> of Bash.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry><term><anchor id="beglineref" /><token>^</token></term>
	  <listitem>
	  <indexterm>
	    <primary>^</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>^</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>regular expression</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>beginning of line</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>uppercase modification</primary>
	    <secondary>parameter substitution</secondary>
	  </indexterm>	  

	    <formalpara><title>beginning-of-line</title>
	      <para>In a <link linkend="regexref">regular expression</link>, a
		<quote>^</quote> addresses the <link linkend="caretref">beginning of a line</link> of text.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^</token></term>
	  <term><token>^^</token></term>
	  <listitem>
            <formalpara><title><link linkend="casemodparamsub">Uppercase
            conversion</link> in <firstterm>parameter substitution</firstterm>
            (added in <link linkend="bash4ref">version 4</link> of Bash)</title>
            <para /></formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="controlcharref" />Control Characters</term>
	  <listitem>
	  <formalpara><title> change the behavior of the
	        terminal or text display.</title>

	    <para>A control character is a <keycap>CONTROL</keycap>
	      + <keycap>key</keycap> combination (pressed
	      simultaneously).
	      
	      A control character may also
	      be written in <firstterm>octal</firstterm> or
	      <firstterm>hexadecimal</firstterm> notation,
	      following an <firstterm>escape</firstterm>.</para>
	  </formalpara>
	  <para>Control characters are not normally useful inside a
	    script.</para>


	    <itemizedlist xml:id="ctlchar">

	      <listitem>
	        <para><userinput>Ctl-A</userinput></para>
		<para>Moves cursor to beginning of line of text
		  (on the command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-B</userinput></para>
		<para><userinput>Backspace</userinput>
		  (nondestructive).</para>
	      </listitem>

	      <listitem>
	        <para><anchor xml:id="ctlcref" /></para>
	        <para><userinput>Ctl-C</userinput></para>
		<para><userinput>Break</userinput>.
		  Terminate a foreground job.</para>
	      </listitem>

	      <listitem>

	        <para><anchor xml:id="ctldref" /></para>
	        <para><userinput>Ctl-D</userinput></para>
		<para><firstterm>Log out</firstterm> from a shell (similar to
		  <link linkend="exitcommandref">exit</link>).</para>
		<para><userinput>EOF</userinput> (end-of-file). This also
		  terminates input from <filename>stdin</filename>.</para>
                <para>When typing text on the console or in an
                  <firstterm>xterm</firstterm> window,
		  <userinput>Ctl-D</userinput> erases the character under the
		  cursor. When there are no characters present,
		  <userinput>Ctl-D</userinput> logs out of the session, as
		  expected. In an <firstterm>xterm</firstterm> window,
		  this has the effect of closing the window.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-E</userinput></para>
		<para>Moves cursor to end of line of text
		  (on the command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-F</userinput></para>
		<para>Moves cursor forward one character position
		  (on the command-line).</para>
	      </listitem>

	      <listitem>
	        <para><anchor xml:id="ctlgref" /></para>
	        <para><userinput>Ctl-G</userinput></para>
		<para><userinput>BEL</userinput>. On some
		old-time teletype terminals, this would actually ring
		a bell. In an <firstterm>xterm</firstterm> it might
		beep.</para>
	      </listitem>

	      <listitem>
	        <para><anchor xml:id="ctlhref" /></para>
	        <para><userinput>Ctl-H</userinput></para>
		<para><userinput>Rubout</userinput> (destructive backspace).
		  Erases characters the cursor backs over while
		  backspacing.</para>
		<para>
		<programlisting>#!/bin/bash
# Embedding Ctl-H in a string.

a="^H^H"                  # Two Ctl-H's -- backspaces
                          # ctl-V ctl-H, using vi/vim
echo "abcdef"             # abcdef
echo
echo -n "abcdef$a "       # abcd f
#  Space at end  ^              ^  Backspaces twice.
echo
echo -n "abcdef$a"        # abcdef
#  No space at end               ^ Doesn't backspace (why?).
                          # Results may not be quite as expected.
echo; echo

# Constantin Hagemeier suggests trying:
# a=$'\010\010'
# a=$'\b\b'
# a=$'\x08\x08'
# But, this does not change the results.

########################################

# Now, try this.

rubout="^H^H^H^H^H"       # 5 x Ctl-H.

echo -n "12345678"
sleep 2
echo -n "$rubout"
sleep 2</programlisting>
                </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-I</userinput></para>
		<para><userinput>Horizontal tab</userinput>.</para>
	      </listitem>

	      <listitem>
	        <para><anchor xml:id="ctljref" /></para>
	        <para><userinput>Ctl-J</userinput></para>
		<para><userinput>Newline</userinput> (line feed).
		  In a script, may also be expressed in octal notation --
		  '\012' or in hexadecimal -- '\x0a'.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-K</userinput></para>
		<para><userinput>Vertical tab</userinput>.</para>
                <para>When typing text on the console or in an
                  <firstterm>xterm</firstterm> window,
		  <userinput>Ctl-K</userinput> erases from the character
		  under the cursor to end of line. Within a script,
		  <userinput>Ctl-K</userinput> may behave differently,
		  as in Lee Lee Maschmeyer's example, below.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-L</userinput></para>
		<para><userinput>Formfeed</userinput> (clear the terminal
		  screen). In a terminal, this has the same effect as the
		  <link linkend="clearref">clear</link> command. When sent
		  to a printer, a <userinput>Ctl-L</userinput> causes
		  an advance to end of the paper sheet.</para>
	      </listitem>

	      <listitem>
	        <para><anchor xml:id="ctlmref" /></para>
	        <para><userinput>Ctl-M</userinput></para>
		<para><userinput>Carriage return</userinput>.</para>
		<para>
		<programlisting>#!/bin/bash
# Thank you, Lee Maschmeyer, for this example.

read -n 1 -s -p \
$'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
           # Of course, '0d' is the hex equivalent of Control-M.
echo &gt;&amp;2   #  The '-s' makes anything typed silent,
           #+ so it is necessary to go to new line explicitly.

read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
           #  '0a' is the hex equivalent of Control-J, linefeed.
echo &gt;&amp;2

###

read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
echo &gt;&amp;2   #  Control-K is vertical tab.

# A better example of the effect of a vertical tab is:

var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
echo "$var"
#  This works the same way as the above example. However:
echo "$var" | col
#  This causes the right end of the line to be higher than the left end.
#  It also explains why we started and ended with a line feed --
#+ to avoid a garbled screen.

# As Lee Maschmeyer explains:
# --------------------------
#  In the [first vertical tab example] . . . the vertical tab
#+ makes the printing go straight down without a carriage return.
#  This is true only on devices, such as the Linux console,
#+ that can't go "backward."
#  The real purpose of VT is to go straight UP, not down.
#  It can be used to print superscripts on a printer.
#  The col utility can be used to emulate the proper behavior of VT.

exit 0</programlisting>
		</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-N</userinput></para>
		<para>Erases a line of text recalled from
		  <firstterm>history buffer</firstterm>
		    <footnote><para>Bash stores a list of commands
		    previously issued from the command-line
		    in a <firstterm>buffer</firstterm>, or
		    memory space, for recall with the <link linkend="builtinref">builtin</link>
		    <firstterm>history</firstterm>
		    commands.</para></footnote> (on the
		    command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-O</userinput></para>
		<para>Issues a <firstterm>newline</firstterm>
		  (on the command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-P</userinput></para>
		<para>Recalls last command from <firstterm>history
		  buffer</firstterm> (on the command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-Q</userinput></para>
		<para>Resume (<userinput>XON</userinput>).</para>
		<para>This resumes <filename>stdin</filename> in a terminal.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-R</userinput></para>
		<para>Backwards search for text in <firstterm>history
		  buffer</firstterm>
		  (on the command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-S</userinput></para>
		<para>Suspend (<userinput>XOFF</userinput>).</para>
		<para>This freezes <filename>stdin</filename> in a terminal.
		  (Use Ctl-Q to restore input.)</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-T</userinput></para>
		<para>Reverses the position of the character the cursor
		  is on with the previous character (on the
		  command-line).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-U</userinput></para>
		<para>Erase a line of input, from the cursor backward to
		  beginning of line. In some settings,
		  <userinput>Ctl-U</userinput> erases the entire
		  line of input, <emphasis>regardless of cursor
		  position</emphasis>.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-V</userinput></para>
		<para>When inputting text, <userinput>Ctl-V</userinput>
		  permits inserting control characters. For example, the
		  following two are equivalent:
		    <programlisting>echo -e '\x0a'
echo &lt;Ctl-V&gt;&lt;Ctl-J&gt;</programlisting></para>
                <para><userinput>Ctl-V</userinput> is primarily useful from
		within a text editor.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-W</userinput></para>
                <para>When typing text on the console or in an xterm window,
		  <userinput>Ctl-W</userinput> erases from the character
		  under the cursor backwards to the first instance of
		  <link linkend="whitespaceref">whitespace</link>. In
		  some settings, <userinput>Ctl-W</userinput> erases
		  backwards to first non-alphanumeric character.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-X</userinput></para>
		<para>In certain word processing programs,
		  <firstterm>Cuts</firstterm> highlighted text
		  and copies to <firstterm>clipboard</firstterm>.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-Y</userinput></para>
		<para><firstterm>Pastes</firstterm> back text previously
		  erased (with <userinput>Ctl-U</userinput> or
		  <userinput>Ctl-W</userinput>).</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-Z</userinput></para>
		<para><firstterm>Pauses</firstterm> a foreground job.</para>
		<para><firstterm>Substitute</firstterm> operation in certain
		  word processing applications.</para>
		<para><userinput>EOF</userinput> (end-of-file) character
		  in the MSDOS filesystem.</para>
	      </listitem>

	    </itemizedlist>



	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whitespaceref" />Whitespace</term>
	  <listitem>
	  <formalpara>
            <title>functions as a separator between commands and/or
              variables.</title>
	      <para>Whitespace consists of either
		<firstterm>spaces</firstterm>,
		<firstterm>tabs</firstterm>, <firstterm>blank
		lines</firstterm>, or any combination thereof.

		  <footnote><para>A linefeed (<firstterm>newline</firstterm>)
		    is also a whitespace character. This explains
		    why a <firstterm>blank line</firstterm>,
		    consisting only of a linefeed, is considered
		    whitespace.</para></footnote>

		In some contexts, such as <link linkend="wsbad">variable
		assignment</link>, whitespace is not permitted, and
		results in a syntax error.</para>
	    </formalpara>

	  <para>Blank lines have no effect on the action of a script,
	    and are therefore useful for visually separating functional
	    sections.</para>

	  <para><link linkend="ifsref">$IFS</link>, the special variable
	    separating <firstterm>fields</firstterm> of input to certain
	    commands. It defaults to whitespace.</para>

	      <sidebar><para>
	      <anchor xml:id="fieldref" /><userinput>Definition:</userinput>
	      A <firstterm>field</firstterm> is a discrete chunk of data
	      expressed as a string of consecutive characters.
	      Separating each field from adjacent fields is either
	      <firstterm>whitespace</firstterm> or some other designated
	      character (often determined by the <token>$IFS</token>).
	      In some contexts, a field may be called a
	      <firstterm>record</firstterm>.
	      </para></sidebar>

	  <para><anchor xml:id="quotingws" /></para>
	  <para>To preserve <firstterm>whitespace</firstterm>
	  within a string or in a variable, use <link linkend="quotingref">quoting</link>.</para>

	  <para>UNIX <link linkend="filterdef">filters</link>
	    can target and operate on <firstterm>whitespace</firstterm>
	    using the <link linkend="posixref">POSIX</link> character class
	    <link linkend="wsposix">[:space:]</link>.</para>

	  </listitem>
	</varlistentry>


      </variablelist>

  </chapter> <!-- Special characters used in shell scripts -->



  <chapter xml:id="variables">
      <title>Introduction to Variables and Parameters</title>

      <para><firstterm>Variables</firstterm> are how programming and
	scripting languages represent data. A variable is nothing
	more than a <firstterm>label</firstterm>, a name assigned to a
	location or set of locations in computer memory holding an item
	of data.</para>

      <para>Variables appear in arithmetic operations and manipulation of
	quantities, and in string parsing.</para>


     <section xml:id="varsubn">
        <title>Variable Substitution</title>

      <para>The <firstterm>name</firstterm> of a variable is a placeholder
	for its <firstterm>value</firstterm>, the data it holds.
	Referencing (retrieving) its value is called
	<firstterm>variable substitution</firstterm>.</para>

      <variablelist xml:id="dollarsign">

	<varlistentry>
	  <term><token>$</token></term> 
	  <listitem>
          <indexterm>
	    <primary>$</primary>
	  </indexterm> <indexterm>
	    <primary>variable</primary> <secondary>$</secondary>
	  </indexterm> <indexterm>
	    <primary>variable</primary>
	    <secondary>substitution</secondary>
	  </indexterm>


	      <para><anchor xml:id="varnameval" /></para>
	      <para>Let us carefully distinguish between the
		<firstterm>name</firstterm> of a variable
		and its <firstterm>value</firstterm>. If
		<userinput>variable1</userinput> is the name of a
		variable, then <userinput>$variable1</userinput>
		is a reference to its <firstterm>value</firstterm>,
		the data item it contains.
		
		  <footnote>

		    <para><anchor xml:id="lvalueref" />Technically, the
		      <firstterm>name</firstterm> of a variable is called an
		      <firstterm>lvalue</firstterm>, meaning that it appears
		      on the <emphasis>left</emphasis> side of an assignment
		      statment, as in <userinput>VARIABLE=23</userinput>.
		      A variable's <firstterm>value</firstterm> is
		      an <firstterm>rvalue</firstterm>, meaning that
		      it appears on the <emphasis>right</emphasis>
		      side of an assignment statement, as in
		      <userinput>VAR2=$VARIABLE</userinput>.</para>

		    <para><anchor xml:id="pointerref" />A variable's
		      <firstterm>name</firstterm> is, in fact,
		      a <firstterm>reference</firstterm>, a
		      <firstterm>pointer</firstterm> to the memory
		      location(s) where the actual data associated with
		      that variable is kept.</para>

		  </footnote>


		</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>variable1=23</userinput>


<prompt>bash$ </prompt><userinput>echo variable1</userinput>
<computeroutput>variable1</computeroutput>

<prompt>bash$ </prompt><userinput>echo $variable1</userinput>
<computeroutput>23</computeroutput></screen>	      
	      </para>
		
		
              <para>The only times a variable appears <quote>naked</quote>
		-- without the <token>$</token> prefix	-- is when
		declared or assigned, when <firstterm>unset</firstterm>,
		when <link linkend="exportref">exported</link>,
		in an arithmetic expression within <link linkend="dblparens">double parentheses 
                (( ... ))</link>, or in the special case of a variable
                representing a <link linkend="signald">signal</link>
                (see <xref linkend="ex76" />). Assignment may be with an
                <token>=</token> (as in <parameter>var1=27</parameter>),
                in a <link linkend="readref">read</link> statement,
                and at the head of a loop (<parameter>for var2 in 1
                2 3</parameter>).</para>


	    <para><anchor xml:id="dblquo" />Enclosing a referenced value in
	      <firstterm>double quotes</firstterm> (<token>" ... "</token>)
	      does not interfere with variable substitution. This is
	      called <firstterm>partial quoting</firstterm>, sometimes
	      referred to as <quote>weak quoting.</quote> <anchor xml:id="snglquo" />Using single quotes (<token>' ... '</token>)
	      causes the variable name to be used literally, and no
	      substitution will take place. This is <firstterm>full
	      quoting</firstterm>, sometimes referred to as 'strong
	      quoting.' See <xref linkend="quoting" /> for a
	      detailed discussion.</para>

	    <para>Note that <userinput>$variable</userinput> is actually a
	      simplified form of
	      <userinput>${variable}</userinput>. In contexts
	      where the <userinput>$variable</userinput> syntax
	      causes an error, the longer form may work (see <xref linkend="Parameter-Substitution" />, below).</para>

	    <para><anchor xml:id="varunsetting" /></para>
	    <example xml:id="ex9">
	      <title>Variable assignment and substitution</title>
	      <programlisting>#!/bin/bash
# ex9.sh

# Variables: assignment and substitution

a=375
hello=$a
#   ^ ^

#-------------------------------------------------------------------------
# No space permitted on either side of = sign when initializing variables.
# What happens if there is a space?

#  "VARIABLE =value"
#           ^
#% Script tries to run "VARIABLE" command with one argument, "=value".

#  "VARIABLE= value"
#            ^
#% Script tries to run "value" command with
#+ the environmental variable "VARIABLE" set to "".
#-------------------------------------------------------------------------


echo hello    # hello
# Not a variable reference, just the string "hello" ...

echo $hello   # 375
#    ^          This *is* a variable reference.
echo ${hello} # 375
#               Likewise a variable reference, as above.

# Quoting . . .
echo "$hello"    # 375
echo "${hello}"  # 375

echo

hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# As we see, echo $hello   and   echo "$hello"   give different results.
# =======================================
# Quoting a variable preserves whitespace.
# =======================================

echo

echo '$hello'  # $hello
#    ^      ^
#  Variable referencing disabled (escaped) by single quotes,
#+ which causes the "$" to be interpreted literally.

# Notice the effect of different types of quoting.


hello=    # Setting it to a null value.
echo "\$hello (null value) = $hello"      # $hello (null value) =
#  Note that setting a variable to a null value is not the same as
#+ unsetting it, although the end result is the same (see below).

# --------------------------------------------------------------

#  It is permissible to set multiple variables on the same line,
#+ if separated by white space.
#  Caution, this may reduce legibility, and may not be portable.

var1=21  var2=22  var3=$V3
echo
echo "var1=$var1   var2=$var2   var3=$var3"

# May cause problems with legacy versions of "sh" . . .

# --------------------------------------------------------------

echo; echo

numbers="one two three"
#           ^   ^
other_numbers="1 2 3"
#               ^ ^
#  If there is whitespace embedded within a variable,
#+ then quotes are necessary.
#  other_numbers=1 2 3                  # Gives an error message.
echo "numbers = $numbers"
echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
#  Escaping the whitespace also works.
mixed_bag=2\ ---\ Whatever
#           ^    ^ Space after escape (\).

echo "$mixed_bag"         # 2 --- Whatever

echo; echo

echo "uninitialized_variable = $uninitialized_variable"
# Uninitialized variable has null value (no value at all!).
uninitialized_variable=   #  Declaring, but not initializing it --
                          #+ same as setting it to a null value, as above.
echo "uninitialized_variable = $uninitialized_variable"
                          # It still has a null value.

uninitialized_variable=23       # Set it.
unset uninitialized_variable    # Unset it.
echo "uninitialized_variable = $uninitialized_variable"
                                # uninitialized_variable =
                                # It still has a null value.
echo

exit 0
</programlisting>
	    </example>

	    <caution>

            <para><anchor xml:id="uninitvar1" /></para>
	    <para>An uninitialized variable has a
	      <quote>null</quote> value -- no assigned value at all
	      (<emphasis>not</emphasis> zero!).

              <programlisting>if [ -z "$unassigned" ]
then
  echo "\$unassigned is NULL."
fi     # $unassigned is NULL.</programlisting></para>
	      
	    <para>Using a variable before
	      assigning a value to it may cause problems.
	      It is nevertheless possible to perform arithmetic operations
	      on an uninitialized variable.

	        <programlisting>echo "$uninitialized"                                # (blank line)
let "uninitialized += 5"                             # Add 5 to it.
echo "$uninitialized"                                # 5

#  Conclusion:
#  An uninitialized variable has no value,
#+ however it evaluates as 0 in an arithmetic operation.</programlisting>

              See also <xref linkend="selfsource" />.</para>

	      </caution>

	  </listitem>
	</varlistentry>
      </variablelist>
    </section> <!-- Variable Substitution -->  


    <section xml:id="varassignment">
      <title>Variable Assignment</title>

      <variablelist>
	<varlistentry>
	  <term><anchor id="eqref" /><token>=</token></term>
	  <listitem>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>assignment</secondary>
	  </indexterm>

	  <para>the assignment operator (<emphasis>no space before
	    and after</emphasis>)</para>


	    <caution>
	    <para>Do not confuse this with <link linkend="equalsignref">=</link> and
	      <link linkend="equalref">-eq</link>, which
	      <link linkend="ifthen">test</link>,
	      rather than assign!</para>

	    <para>Note that <token>=</token> can be either
	      an <firstterm>assignment</firstterm> or a
	      <firstterm>test</firstterm> operator, depending on
	      context.</para>
	    </caution>


	<para><anchor xml:id="ex15_0" /></para>
	<example xml:id="ex15">
	  <title>Plain Variable Assignment</title>
	  <programlisting>#!/bin/bash
# Naked variables

echo

# When is a variable "naked", i.e., lacking the '$' in front?
# When it is being assigned, rather than referenced.

# Assignment
a=879
echo "The value of \"a\" is $a."

# Assignment using 'let'
let a=16+5
echo "The value of \"a\" is now $a."

echo

# In a 'for' loop (really, a type of disguised assignment):
echo -n "Values of \"a\" in the loop are: "
for a in 7 8 9 11
do
  echo -n "$a "
done

echo
echo

# In a 'read' statement (also a type of assignment):
echo -n "Enter \"a\" "
read a
echo "The value of \"a\" is now $a."

echo

exit 0
</programlisting>
	</example>

	<para><anchor xml:id="ex16_0" /></para>
	<example xml:id="ex16">
	  <title>Variable Assignment, plain and fancy</title>
	  <programlisting>#!/bin/bash

a=23              # Simple case
echo $a
b=$a
echo $b

# Now, getting a little bit fancier (command substitution).

a=`echo Hello!`   # Assigns result of 'echo' command to 'a' ...
echo $a
#  Note that including an exclamation mark (!) within a
#+ command substitution construct will not work from the command-line,
#+ since this triggers the Bash "history mechanism."
#  Inside a script, however, the history functions are disabled by default.

a=`ls -l`         # Assigns result of 'ls -l' command to 'a'
echo $a           # Unquoted, however, it removes tabs and newlines.
echo
echo "$a"         # The quoted variable preserves whitespace.
                  # (See the chapter on "Quoting.")

exit 0
</programlisting>
	</example>

	    <para><anchor xml:id="commandsubref0" /></para>

	    <para>Variable assignment using the <firstterm>$(...)</firstterm>
	      mechanism (a newer method than <link linkend="backquotesref">backquotes</link>). This is
	      likewise a form of <link linkend="commandsubref">command
	      substitution</link>.</para>

	    <para><programlisting># From /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)</programlisting></para>
	  </listitem>
	</varlistentry>
      </variablelist>

    </section> <!-- Variable Assignment -->

    <section xml:id="untyped">
      <title>Bash Variables Are Untyped</title>
      
      <para><anchor xml:id="bvuntyped" /></para>
      <para>Unlike many other programming languages, Bash does not segregate
	its variables by <quote>type.</quote> Essentially, <emphasis>Bash
	variables are character strings</emphasis>, but, depending on
	context, Bash permits arithmetic operations and comparisons on
	variables. The determining factor is whether the value of a
	variable contains only digits.</para>

	    <example xml:id="intorstring">
	      <title>Integer or string?</title>
	      <programlisting>#!/bin/bash
# int-or-string.sh

a=2334                   # Integer.
let "a += 1"
echo "a = $a "           # a = 2335
echo                     # Integer, still.


b=${a/23/BB}             # Substitute "BB" for "23".
                         # This transforms $b into a string.
echo "b = $b"            # b = BB35
declare -i b             # Declaring it an integer doesn't help.
echo "b = $b"            # b = BB35

let "b += 1"             # BB35 + 1
echo "b = $b"            # b = 1
echo                     # Bash sets the "integer value" of a string to 0.

c=BB34
echo "c = $c"            # c = BB34
d=${c/BB/23}             # Substitute "23" for "BB".
                         # This makes $d an integer.
echo "d = $d"            # d = 2334
let "d += 1"             # 2334 + 1
echo "d = $d"            # d = 2335
echo


# What about null variables?
e=''                     # ... Or e="" ... Or e=
echo "e = $e"            # e =
let "e += 1"             # Arithmetic operations allowed on a null variable?
echo "e = $e"            # e = 1
echo                     # Null variable transformed into an integer.

# What about undeclared variables?
echo "f = $f"            # f =
let "f += 1"             # Arithmetic operations allowed?
echo "f = $f"            # f = 1
echo                     # Undeclared variable transformed into an integer.
#
# However ...
let "f /= $undecl_var"   # Divide by zero?
#   let: f /= : syntax error: operand expected (error token is " ")
# Syntax error! Variable $undecl_var is not set to zero here!
#
# But still ...
let "f /= 0"
#   let: f /= 0: division by 0 (error token is "0")
# Expected behavior.


#  Bash (usually) sets the "integer value" of null to zero
#+ when performing an arithmetic operation.
#  But, don't try this at home, folks!
#  It's undocumented and probably non-portable behavior.


# Conclusion: Variables in Bash are untyped,
#+ with all attendant consequences.

exit $?
</programlisting>
	    </example>	    

      <para>Untyped variables are both a blessing and a curse. They permit
	more flexibility in scripting and make it easier to grind out
	lines of code (and give you enough rope to hang yourself!).
	However, they likewise permit subtle errors to creep in
	and encourage sloppy programming habits.</para>

      <para>To lighten the burden of keeping track of variable
        types in a script, Bash <emphasis>does</emphasis> permit
	<link linkend="declareref">declaring</link> variables.</para>

    </section> <!-- Bash Variables Are Untyped-->


    <section xml:id="othertypesv">
      <title>Special Variable Types</title>

      <variablelist>

	<varlistentry>
	  <term><replaceable>Local variables</replaceable></term>
	  <listitem>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>

	  <para>Variables <link linkend="scoperef">visible</link> only within a <link linkend="codeblockref">code block</link> or function (see
	    also <link linkend="localref">local variables</link> in
	    <link linkend="functionref">functions</link>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="envref" /><replaceable>Environmental variables</replaceable></term>
	  <listitem>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>environmental</secondary>
	  </indexterm>

	  <para>Variables that affect the behavior of the shell and
	      user interface</para>

	      <note>

	      <para>In a more general context, each <link linkend="processref">process</link> has an
		<quote>environment</quote>, that is, a group of
		variables that the process may reference. In this sense,
		the shell behaves like any other process.</para>

	      <para>Every time a shell starts, it creates shell variables that
		correspond to its own environmental variables. Updating
		or adding new environmental variables causes the
		shell to update its environment, and all the shell's
		<firstterm>child processes</firstterm> (the commands it
		executes) inherit this environment.</para>

	      </note>

	      <caution>
	      <para>The space allotted to the environment is limited.
	        Creating too many environmental variables or ones that use up
		excessive space may cause problems.</para>

	      <para>
	          <screen>
<prompt>bash$ </prompt><userinput>eval "`seq 10000 | sed -e 's/.*/export var&amp;=ZZZZZZZZZZZZZZ/'`"</userinput>

<prompt>bash$ </prompt><userinput>du</userinput>
<computeroutput>bash: /usr/bin/du: Argument list too long</computeroutput>
	          </screen>
	      </para>

	      <para>Note: this <quote>error</quote> has been fixed, as of
	        kernel version 2.6.23.</para>
	      <para>(Thank you, Stéphane Chazelas for the clarification,
	        and for providing the above example.)</para>
	      </caution>

	    <para>If a script sets environmental variables, they need to be
	      <quote>exported,</quote> that is, reported to the
	      <firstterm>environment</firstterm> local to
	      the script. This is the function of the <link linkend="exportref">export</link> command.</para>

            <anchor xml:id="childref" />
	    <note>
	    <para>A script can <command>export</command> variables only
	      to child <link linkend="processref">processes</link>,
	      that is, only to commands or processes which that
	      particular script initiates. A script invoked from
	      the command-line <replaceable>cannot</replaceable>
	      export variables back to the command-line environment.
	      <emphasis><link linkend="forkref">Child processes</link>
	      cannot export variables back to the parent processes that
	      spawned them.</emphasis></para>
	    <para><anchor xml:id="childref2" /><userinput>Definition:</userinput>
	      A <firstterm>child process</firstterm> is a
	      subprocess launched by another process, its <link linkend="parentref">parent</link>.</para>
	    </note>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="posparamref1" /><replaceable>Positional parameters</replaceable></term>
	  <listitem>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>

	    <para>Arguments passed to the script from the command
	      line
		<footnote><para>Note that <link linkend="passedargs"><firstterm>functions</firstterm>
		also take positional parameters</link>.</para></footnote>
	      : <varname>$0</varname>, <varname>$1</varname>,
	      <varname>$2</varname>, <varname>$3</varname> . . .</para>
	      
	    <para><anchor xml:id="scrnameparam" /><varname>$0</varname> is
	       the name of the script itself,
	      <varname>$1</varname> is the first argument,
	      <varname>$2</varname> the second, <varname>$3</varname>
	      the third, and so forth.

	      <footnote>
	      <para><anchor xml:id="arg0" />The process calling the
		script sets the <varname>$0</varname> parameter. By
		convention, this parameter is the name of the script. See
		the <link linkend="manref">manpage</link> (manual page)
		for <command>execv</command>.</para>
	      <para>From the <firstterm>command-line</firstterm>, however,
	        <varname>$0</varname> is the name of the shell.
	      <screen><prompt>bash$ </prompt><userinput>echo $0</userinput>
<computeroutput>bash</computeroutput>

<prompt>tcsh% </prompt><userinput>echo $0</userinput>
<computeroutput>tcsh</computeroutput></screen></para>
              </footnote>

	      <anchor xml:id="bracketnotation" />
	      After <varname>$9</varname>, the arguments must be enclosed
	      in brackets, for example, <varname>${10}</varname>,
	      <varname>${11}</varname>, <varname>${12}</varname>.</para>

	    <para>The special variables <link linkend="appref">$* and $@</link>
	      denote <emphasis>all</emphasis> the positional parameters.</para>

	    <example xml:id="ex17">
	      <title>Positional Parameters</title>
	      <programlisting>#!/bin/bash

# Call this script with at least 10 parameters, for example
# ./scriptname 1 2 3 4 5 6 7 8 9 10
MINPARAMS=10

echo

echo "The name of this script is \"$0\"."
# Adds ./ for current directory
echo "The name of this script is \"`basename $0`\"."
# Strips out path name info (see 'basename')

echo

if [ -n "$1" ]              # Tested variable is quoted.
then
 echo "Parameter #1 is $1"  # Need quotes to escape #
fi 

if [ -n "$2" ]
then
 echo "Parameter #2 is $2"
fi 

if [ -n "$3" ]
then
 echo "Parameter #3 is $3"
fi 

# ...


if [ -n "${10}" ]  # Parameters &gt; $9 must be enclosed in {brackets}.
then
 echo "Parameter #10 is ${10}"
fi 

echo "-----------------------------------"
echo "All the command-line parameters are: "$*""

if [ $# -lt "$MINPARAMS" ]
then
  echo
  echo "This script needs at least $MINPARAMS command-line arguments!"
fi  

echo

exit 0
</programlisting>
	    </example>

	    <para><firstterm>Bracket notation</firstterm> for positional
	      parameters leads to a fairly simple way of referencing
	      the <emphasis>last</emphasis> argument passed to a
	      script on the command-line. This also requires <link linkend="varrefnew">indirect referencing</link>.</para>

            <para><anchor xml:id="lastargref" /></para>
	    <para><programlisting>args=$#           # Number of args passed.
lastarg=${!args}
# Note: This is an *indirect reference* to $args ...


# Or:       lastarg=${!#}             (Thanks, Chris Monson.)
# This is an *indirect reference* to the $# variable.
# Note that lastarg=${!$#} doesn't work.
</programlisting></para>


	    <para>Some scripts can perform different operations,
	      depending on which name they are invoked with. For this
	      to work, the script needs to check <varname>$0</varname>,
	      the name it was invoked by.

	      <footnote><para>If the the script is <link linkend="sourceref">sourced</link> or <link linkend="symlinkref">symlinked</link>, then
                 this will not work. It is safer to check <link linkend="bashsourceref">$BASH_Source</link>.</para></footnote>
	      
	      There must also exist symbolic links to all the alternate
	      names of the script. See <xref linkend="hellol" />.</para>

	      <para><anchor xml:id="nullvar" /></para>
	    <tip><para>If a script expects a command-line parameter
	      but is invoked without one, this may cause a <firstterm>null
	      variable assignment</firstterm>, generally an undesirable
	      result. One way to prevent this is to append an extra
	      character to both sides of the assignment statement using
	      the expected positional parameter.  </para></tip>

	      <programlisting>variable1_=$1_  # Rather than variable1=$1
# This will prevent an error, even if positional parameter is absent.

critical_argument01=$variable1_

# The extra character can be stripped off later, like so.
variable1=${variable1_/_/}
# Side effects only if $variable1_ begins with an underscore.
# This uses one of the parameter substitution templates discussed later.
# (Leaving out the replacement pattern results in a deletion.)

#  A more straightforward way of dealing with this is
#+ to simply test whether expected positional parameters have been passed.
if [ -z $1 ]
then
  exit $E_MISSING_POS_PARAM
fi


#  However, as Fabian Kreutz points out,
#+ the above method may have unexpected side-effects.
#  A better method is parameter substitution:
#         ${1:-$DefaultVal}
#  See the "Parameter Substition" section
#+ in the "Variables Revisited" chapter.
</programlisting>

	      <para>---</para>

	    <example xml:id="ex18">
	      <title><firstterm>wh</firstterm>, <firstterm>
                whois</firstterm> domain name lookup</title>
	      <programlisting>#!/bin/bash
# ex18.sh

# Does a 'whois domain-name' lookup on any of 3 alternate servers:
#                    ripe.net, cw.net, radb.net

# Place this script -- renamed 'wh' -- in /usr/local/bin

# Requires symbolic links:
# ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
# ln -s /usr/local/bin/wh /usr/local/bin/wh-apnic
# ln -s /usr/local/bin/wh /usr/local/bin/wh-tucows

E_NOARGS=75


if [ -z "$1" ]
then
  echo "Usage: `basename $0` [domain-name]"
  exit $E_NOARGS
fi

# Check script name and call proper server.
case `basename $0` in    # Or:    case ${0##*/} in
    "wh"       ) whois $1@whois.tucows.com;;
    "wh-ripe"  ) whois $1@whois.ripe.net;;
    "wh-apnic" ) whois $1@whois.apnic.net;;
    "wh-cw"    ) whois $1@whois.cw.net;;
    *          ) echo "Usage: `basename $0` [domain-name]";;
esac 

exit $?
</programlisting>
	    </example>

	      <para>---</para>

	    <para><anchor xml:id="shiftref" /></para>
	    <para>
	      <indexterm>
		<primary>shift</primary>
	      </indexterm>
	      <indexterm>
		<primary>command</primary>
		<secondary>shift</secondary>
	      </indexterm>
	      The <command>shift</command> command reassigns the positional
	      parameters, in effect shifting them to the left one notch.</para>
	      
	    <para><varname>$1</varname> &lt;--- <varname>$2</varname>, <varname>$2</varname> &lt;--- <varname>$3</varname>, <varname>$3</varname> &lt;--- <varname>$4</varname>, etc.</para>

	    <para>The old <varname>$1</varname> disappears, but
	      <emphasis><varname>$0</varname> (the script name)
	      does not change</emphasis>. If you use a large number of
	      positional parameters to a script, <command>shift</command>
	      lets you access those past <literal>10</literal>, although
	      <link linkend="bracketnotation">{bracket} notation</link>
	      also permits this.</para>

	    <example xml:id="ex19">
	      <title>Using <firstterm>shift</firstterm></title>
	      <programlisting>#!/bin/bash
# shft.sh: Using 'shift' to step through all the positional parameters.

#  Name this script something like shft.sh,
#+ and invoke it with some parameters.
#+ For example:
#             sh shft.sh a b c def 83 barndoor

until [ -z "$1" ]  # Until all parameters used up . . .
do
  echo -n "$1 "
  shift
done

echo               # Extra linefeed.

# But, what happens to the "used-up" parameters?
echo "$2"
#  Nothing echoes!
#  When $2 shifts into $1 (and there is no $3 to shift into $2)
#+ then $2 remains empty.
#  So, it is not a parameter *copy*, but a *move*.

exit

#  See also the echo-params.sh script for a "shiftless"
#+ alternative method of stepping through the positional params.
</programlisting>
	    </example>

          <para>The <command>shift</command> command can take a numerical
	    parameter indicating how many positions to shift.</para>

          <para><programlisting>#!/bin/bash
# shift-past.sh

shift 3    # Shift 3 positions.
#  n=3; shift $n
#  Has the same effect.

echo "$1"

exit 0

# ======================== #


$ sh shift-past.sh 1 2 3 4 5
4

#  However, as Eleni Fragkiadaki, points out,
#+ attempting a 'shift' past the number of
#+ positional parameters ($#) returns an exit status of 1,
#+ and the positional parameters themselves do not change.
#  This means possibly getting stuck in an endless loop. . . .
#  For example:
#      until [ -z "$1" ]
#      do
#         echo -n "$1 "
#         shift 20    #  If less than 20 pos params,
#      done           #+ then loop never ends!
#
# When in doubt, add a sanity check. . . .
#           shift 20 || break
#                    ^^^^^^^^</programlisting></para>

          <note><para>The <command>shift</command> command works in a similar
	    fashion on parameters passed to a <link linkend="functionref">function</link>.  See <xref linkend="multiplication" />.</para></note>

	  </listitem>
	</varlistentry>
      </variablelist>

    </section> <!-- Special Variable Types -->  


  </chapter> <!-- Variables -->



  <chapter xml:id="quoting">
    <title>Quoting</title>
    
      <para><anchor xml:id="quotingref" /></para>

      <indexterm>
	<primary>"</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>"</secondary>
      </indexterm>
      <indexterm>
	<primary>'</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>'</secondary>
      </indexterm>
      <indexterm>
	<primary>quote</primary>
      </indexterm>
      <indexterm>
	<primary>\</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>\</secondary>
      </indexterm>
      <indexterm>
	<primary>escape</primary>
      </indexterm>
      <para>Quoting means just that, bracketing a string in quotes. This
	has the effect of protecting <link linkend="scharlist1">special
	characters</link> in the string from reinterpretation
	or expansion by the shell or shell script. (A character
	is <quote>special</quote> if it has an interpretation
	other than its literal meaning. For example, the <link linkend="asteriskref">asterisk *</link> represents
	a <firstterm>wild card</firstterm> character in 
	<link linkend="globbingref">globbing</link> and <link linkend="regexref">Regular Expressions</link>).</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>ls -l [Vv]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
 -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
 -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh
</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l '[Vv]*'</userinput>
<computeroutput>ls: [Vv]*: No such file or directory</computeroutput></screen>	      
	      </para>

      <para><anchor xml:id="quotingdef" /></para>
      <sidebar><para>In everyday speech or writing, when we
      <quote>quote</quote> a phrase, we set it apart and give it special
      meaning. In a Bash script, when we <firstterm>quote</firstterm> a
      string, we set it apart and protect its <firstterm>literal</firstterm>
      meaning.</para></sidebar>

      <para>Certain programs and utilities reinterpret or expand
	special characters in a quoted string. An important use of
	quoting is protecting a command-line parameter from the shell,
	but still letting the calling program expand it.</para>

              <para>
	      <screen><prompt>bash$ </prompt><userinput>grep '[Ff]irst' *.txt</userinput>
<computeroutput>file1.txt:This is the first line of file1.txt.
 file2.txt:This is the First line of file2.txt.</computeroutput></screen>
	      </para>

	<para>Note that the unquoted <userinput>grep [Ff]irst *.txt</userinput>
	  works under the Bash shell.
	    <footnote><para>Unless there is a file named
	    <filename>first</filename> in the current working directory. Yet
	    another reason to <firstterm>quote</firstterm>. (Thank you, Harald
	    Koenig, for pointing this out.</para></footnote>
	  </para>


      <para>Quoting can also suppress <link linkend="echoref">echo's</link>
        <quote>appetite</quote> for newlines.</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $(ls -l)</userinput>
<computeroutput>total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh</computeroutput>


<prompt>bash$ </prompt><userinput>echo "$(ls -l)"</userinput>
<computeroutput>total 8
 -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
 -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh</computeroutput></screen>
	      </para>


      <section xml:id="quotingvar">
	<title>Quoting Variables</title>


      <para>When referencing a variable, it is generally advisable to
	enclose its name in double quotes.
	This prevents reinterpretation of all special characters within
	the quoted string -- except <token>$</token>, <token>`</token>
	(backquote), and <token>\</token> (escape).

	    <footnote>

		    <para><anchor xml:id="quotingbsl" /></para>
	    <para>Encapsulating <quote>!</quote> within double
	      quotes gives an error when used <emphasis>from the command
	      line</emphasis>. This is interpreted as a <link linkend="histcommands">history command</link>. Within a script,
	      though, this problem does not occur, since the Bash history
	      mechanism is disabled then.</para>

	    <para>Of more concern is the <emphasis>apparently</emphasis>
		    inconsistent behavior of <replaceable>\</replaceable>
		    within double quotes, and especially following an
	      <command>echo -e</command> command.</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo hello\!</userinput>
<computeroutput>hello!</computeroutput>
<prompt>bash$ </prompt><userinput>echo "hello\!"</userinput>
<computeroutput>hello\!</computeroutput>


<prompt>bash$ </prompt><userinput>echo \</userinput>
<computeroutput>&gt;</computeroutput>
<prompt>bash$ </prompt><userinput>echo "\"</userinput>
<computeroutput>&gt;</computeroutput>
<prompt>bash$ </prompt><userinput>echo \a</userinput>
<computeroutput>a</computeroutput>
<prompt>bash$ </prompt><userinput>echo "\a"</userinput>
<computeroutput>\a</computeroutput>


<prompt>bash$ </prompt><userinput>echo x\ty</userinput>
<computeroutput>xty</computeroutput>
<prompt>bash$ </prompt><userinput>echo "x\ty"</userinput>
<computeroutput>x\ty</computeroutput>

<prompt>bash$ </prompt><userinput>echo -e x\ty</userinput>
<computeroutput>xty</computeroutput>
<prompt>bash$ </prompt><userinput>echo -e "x\ty"</userinput>
<computeroutput>x       y</computeroutput>
	      </screen>
	      </para>

	      <para>Double quotes following an <firstterm>echo</firstterm>
                <emphasis>sometimes</emphasis> escape
                <replaceable>\</replaceable>. Moreover, the
                <option>-e</option> option to <firstterm>echo</firstterm>
                causes the <quote>\t</quote> to be interpreted as a
                <firstterm>tab</firstterm>.</para>

            <para>(Thank you, Wayne Pollock, for pointing this out, and Geoff
	      Lee and Daniel Barclay for explaining it.) </para>
	      
	      </footnote>
	
	Keeping <token>$</token> as a special character within
	double quotes permits referencing a quoted variable
	(<replaceable>"$variable"</replaceable>), that is, replacing the
	variable with its value (see <xref linkend="ex9" />, above).</para>

      <para><anchor xml:id="wsquo" /></para>
      <para>Use double quotes to prevent word splitting.

	      <footnote><para><anchor xml:id="wsplitref" /><quote>Word
	      splitting,</quote> in this context, means dividing
	      a character string into separate and discrete
	      arguments.</para></footnote>

	An argument enclosed in double quotes presents
	itself as a single word, even if it contains <link linkend="whitespaceref">whitespace</link> separators.</para>


<para><anchor xml:id="varsplitting" /></para>
<para><programlisting>List="one two three"

for a in $List     # Splits the variable in parts at whitespace.
do
  echo "$a"
done
# one
# two
# three

echo "---"

for a in "$List"   # Preserves whitespace in a single variable.
do #     ^     ^
  echo "$a"
done
# one two three</programlisting></para>

      <para>A more elaborate example:</para>

<para><programlisting>variable1="a variable containing five words"
COMMAND This is $variable1    # Executes COMMAND with 7 arguments:
# "This" "is" "a" "variable" "containing" "five" "words"

COMMAND "This is $variable1"  # Executes COMMAND with 1 argument:
# "This is a variable containing five words"


variable2=""    # Empty.

COMMAND $variable2 $variable2 $variable2
                # Executes COMMAND with no arguments. 
COMMAND "$variable2" "$variable2" "$variable2"
                # Executes COMMAND with 3 empty arguments. 
COMMAND "$variable2 $variable2 $variable2"
                # Executes COMMAND with 1 argument (2 spaces). 

# Thanks, Stéphane Chazelas.
</programlisting></para>


      <tip><para>Enclosing the arguments to an <command>echo</command>
	statement in double quotes is necessary only when word splitting
	or preservation of <link linkend="whitespaceref">whitespace</link>
	is an issue.</para></tip>

	    <example xml:id="weirdvars">
	      <title>Echoing Weird Variables</title>
	      <programlisting>#!/bin/bash
# weirdvars.sh: Echoing weird variables.

echo

var="'(]\\{}\$\""
echo $var        # '(]\{}$"
echo "$var"      # '(]\{}$"     Doesn't make a difference.

echo

IFS='\'
echo $var        # '(] {}$"     \ converted to space. Why?
echo "$var"      # '(]\{}$"

# Examples above supplied by Stephane Chazelas.

echo

var2="\\\\\""
echo $var2       #   "
echo "$var2"     # \\"
echo
# But ... var2="\\\\"" is illegal. Why?
var3='\\\\'
echo "$var3"     # \\\\
# Strong quoting works, though.


# ************************************************************ #
# As the first example above shows, nesting quotes is permitted.

echo "$(echo '"')"           # "
#    ^           ^


# At times this comes in useful.

var1="Two bits"
echo "\$var1 = "$var1""      # $var1 = Two bits
#    ^                ^

# Or, as Chris Hiestand points out ...

if [[ "$(du "$My_File1")" -gt "$(du "$My_File2")" ]]
#     ^     ^         ^ ^     ^     ^         ^ ^
then
  ...
fi
# ************************************************************ #
</programlisting>
	    </example>

      <para>Single quotes (<token>' '</token>) operate similarly to double
	quotes, but do not permit referencing variables, since
	the special meaning of <token>$</token> is turned off.
	Within single quotes, <emphasis>every</emphasis> special
	character except <token>'</token> gets interpreted literally.
	Consider single quotes (<quote>full quoting</quote>) to be a
	stricter method of quoting than double quotes (<quote>partial
	quoting</quote>).</para>

      <note><para>Since even the escape character (<token>\</token>)
	gets a literal interpretation within single quotes, trying to
	enclose a single quote within single quotes will not yield the
	expected result.
	<programlisting>echo "Why can't I write 's between single quotes"

echo

# The roundabout method.
echo 'Why can'\''t I write '"'"'s between single quotes'
#    |-------|  |----------|   |-----------------------|
# Three single-quoted strings, with escaped and quoted single quotes between.

# This example courtesy of Stéphane Chazelas.</programlisting>
      </para></note>

      </section> <!-- Quoting Variables -->



      <section xml:id="escapingsection">
	<title>Escaping</title>

      <para><anchor xml:id="escp" /><firstterm>Escaping</firstterm> is a method
	of quoting single characters. The <token>escape</token>
	(<token>\</token>) preceding a character tells the shell to
	interpret that character literally.</para>

      <caution><para>With certain commands and utilities, such as <link linkend="echoref">echo</link> and <link linkend="sedref">sed</link>, escaping a character may have the
	opposite effect - it can toggle on a special meaning for that
	character.</para></caution>

      <variablelist xml:id="specialmeanings">
	<title><anchor xml:id="spm" />Special meanings of certain
	escaped characters</title>

	<varlistentry>
	<term>used with <command moreinfo="none">echo</command> and
	<command moreinfo="none">sed</command></term>
	<listitem><para /></listitem>
	</varlistentry>

	<varlistentry><term><token>\n</token></term>
	  <listitem>
	  <indexterm>
	    <primary>\n</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\n</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>newline</primary>
	  </indexterm>
            <para>means newline</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\r</token></term>
	  <listitem>
	  <indexterm>
	    <primary>\r</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\r</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>carriage return</primary>
	  </indexterm>
          <para>means return</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\t</token></term>
	  <listitem>
	  <indexterm>
	    <primary>\t</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\t</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tabulation</primary>
	  </indexterm>
	  <para>means tab</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\v</token></term>
	  <listitem>
	  <indexterm>
	    <primary>\v</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\v</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vertical tabulation</primary>
	  </indexterm>
	  <para> means vertical tab</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\b</token></term>
	  <listitem>
	  <indexterm>
	    <primary>\b</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\b</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>backspace</primary>
	  </indexterm>
	  <para>means backspace</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\a</token></term>
	<listitem>
	  <indexterm>
	    <primary>\a</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\a</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>alert</primary>
	  </indexterm>
	  <indexterm>
	    <primary>beep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>flash</primary>
	  </indexterm>
          <para>means <firstterm>alert</firstterm> (beep or flash)</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\0xx</token></term>
	<listitem>
	  <indexterm>
	    <primary>\0xx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\0nn</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>octal ASCII</primary>
	  </indexterm>
	  <para><anchor xml:id="octalref" />translates to the
              octal <link linkend="asciidef">ASCII</link>
              equivalent of <replaceable>0nn</replaceable>, where
              <replaceable>nn</replaceable> is a string of digits</para>

      <important>
	    <para><anchor xml:id="strq" /></para>
             <para>The <userinput>$' ... '</userinput>
             <link linkend="quotingref">quoted</link> string-expansion
              construct is a mechanism that uses escaped octal or hex values
	      to assign ASCII characters to variables, e.g.,
	      <command>quote=$'\042'</command>.</para>
      </important>

      <example xml:id="escaped">
	<title>Escaped Characters</title>
	<programlisting>#!/bin/bash
# escaped.sh: escaped characters

#############################################################
### First, let's show some basic escaped-character usage. ###
#############################################################

# Escaping a newline.
# ------------------

echo ""

echo "This will print
as two lines."
# This will print
# as two lines.

echo "This will print \
as one line."
# This will print as one line.

echo; echo

echo "============="


echo "\v\v\v\v"      # Prints \v\v\v\v literally.
# Use the -e option with 'echo' to print escaped characters.
echo "============="
echo "VERTICAL TABS"
echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
echo "=============="

echo "QUOTATION MARK"
echo -e "\042"       # Prints " (quote, octal ASCII character 42).
echo "=============="



# The $'\X' construct makes the -e option unnecessary.

echo; echo "NEWLINE and (maybe) BEEP"
echo $'\n'           # Newline.
echo $'\a'           # Alert (beep).
                     # May only flash, not beep, depending on terminal.

# We have seen $'\nnn" string expansion, and now . . .

# =================================================================== #
# Version 2 of Bash introduced the $'\nnn' string expansion construct.
# =================================================================== #

echo "Introducing the \$\' ... \' string-expansion construct . . . "
echo ". . . featuring more quotation marks."

echo $'\t \042 \t'   # Quote (") framed by tabs.
# Note that  '\nnn' is an octal value.

# It also works with hexadecimal values, in an $'\xhhh' construct.
echo $'\t \x22 \t'  # Quote (") framed by tabs.
# Thank you, Greg Keraunen, for pointing this out.
# Earlier Bash versions allowed '\x022'.

echo


# Assigning ASCII characters to a variable.
# ----------------------------------------
quote=$'\042'        # " assigned to a variable.
echo "$quote Quoted string $quote and this lies outside the quotes."

echo

# Concatenating ASCII chars in a variable.
triple_underline=$'\137\137\137'  # 137 is octal ASCII code for '_'.
echo "$triple_underline UNDERLINE $triple_underline"

echo

ABC=$'\101\102\103\010'           # 101, 102, 103 are octal A, B, C.
echo $ABC

echo

escape=$'\033'                    # 033 is octal for escape.
echo "\"escape\" echoes as $escape"
#                                   no visible output.

echo

exit 0
</programlisting>
      </example>

      <para>A more elaborate example:</para>
      <example xml:id="bashek">
	<title>Detecting key-presses</title>
	<programlisting>#!/bin/bash
# Author: Sigurd Solaas, 20 Apr 2011
# Used in ABS Guide with permission.
# Requires version 4.2+ of Bash.

key="no value yet"
while true; do
  clear
  echo "Bash Extra Keys Demo. Keys to try:"
  echo
  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  echo "* The four arrow keys"
  echo "* Tab, enter, escape, and space key"
  echo "* The letter and number keys, etc."
  echo
  echo "    d = show date/time"
  echo "    q = quit"
  echo "================================"
  echo

 # Convert the separate home-key to home-key_num_7:
 if [ "$key" = $'\x1b\x4f\x48' ]; then
  key=$'\x1b\x5b\x31\x7e'
  #   Quoted string-expansion construct. 
 fi

 # Convert the separate end-key to end-key_num_1.
 if [ "$key" = $'\x1b\x4f\x46' ]; then
  key=$'\x1b\x5b\x34\x7e'
 fi

 case "$key" in
  $'\x1b\x5b\x32\x7e')  # Insert
   echo Insert Key
  ;;
  $'\x1b\x5b\x33\x7e')  # Delete
   echo Delete Key
  ;;
  $'\x1b\x5b\x31\x7e')  # Home_key_num_7
   echo Home Key
  ;;
  $'\x1b\x5b\x34\x7e')  # End_key_num_1
   echo End Key
  ;;
  $'\x1b\x5b\x35\x7e')  # Page_Up
   echo Page_Up
  ;;
  $'\x1b\x5b\x36\x7e')  # Page_Down
   echo Page_Down
  ;;
  $'\x1b\x5b\x41')  # Up_arrow
   echo Up arrow
  ;;
  $'\x1b\x5b\x42')  # Down_arrow
   echo Down arrow
  ;;
  $'\x1b\x5b\x43')  # Right_arrow
   echo Right arrow
  ;;
  $'\x1b\x5b\x44')  # Left_arrow
   echo Left arrow
  ;;
  $'\x09')  # Tab
   echo Tab Key
  ;;
  $'\x0a')  # Enter
   echo Enter Key
  ;;
  $'\x1b')  # Escape
   echo Escape Key
  ;;
  $'\x20')  # Space
   echo Space Key
  ;;
  d)
   date
  ;;
  q)
  echo Time to quit...
  echo
  exit 0
  ;;
  *)
   echo You pressed: \'"$key"\'
  ;;
 esac

 echo
 echo "================================"

 unset K1 K2 K3
 read -s -N1 -p "Press a key: "
 K1="$REPLY"
 read -s -N2 -t 0.001
 K2="$REPLY"
 read -s -N1 -t 0.001
 K3="$REPLY"
 key="$K1$K2$K3"

done

exit $?
</programlisting>
      </example>
	      
           <para>See also <xref linkend="ex77" />.</para>

	</listitem>
	</varlistentry>

	<varlistentry><term><token>\"</token></term>
	<listitem>
	  <indexterm>
	    <primary>\"</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\"</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>quote</primary>
	  </indexterm>
          <para> gives the quote its literal meaning</para>
	<para><programlisting>echo "Hello"                     # Hello
echo "\"Hello\" ... he said."    # "Hello" ... he said.</programlisting></para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\$</token></term>
	<listitem>
	  <indexterm>
	    <primary>\$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dollar</primary>
	  </indexterm>
	  <para>gives the dollar sign its literal meaning
	      (variable name following <token>\$</token> will not be
	      referenced)</para>
            <para><programlisting>echo "\$variable01"           # $variable01
echo "The book cost \$7.98."  # The book cost $7.98.</programlisting></para>
	  </listitem>
	  </varlistentry>

	<varlistentry><term><token>\\</token></term>
	<listitem>
	  <indexterm>
	    <primary>\\</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\\</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>double backslash</primary>
	  </indexterm>
	  <para>gives the backslash its literal meaning</para>
	    <para><programlisting>echo "\\"  # Results in \

# Whereas . . .

echo "\"   # Invokes secondary prompt from the command-line.
           # In a script, gives an error message.

# However . . .

echo '\'   # Results in \</programlisting></para>

	  </listitem>
	  </varlistentry>
	</variablelist>

      <note>
      <para>The behavior of <token>\</token> depends on whether
	it is escaped, <link linkend="snglquo">strong-quoted</link>,
	<link linkend="dblquo">weak-quoted</link>, or appearing within
	<link linkend="commandsubref">command substitution</link> or a
	<link linkend="heredocref">here document</link>.

	<programlisting>                      #  Simple escaping and quoting
echo \z               #  z
echo \\z              # \z
echo '\z'             # \z
echo '\\z'            # \\z
echo "\z"             # \z
echo "\\z"            # \z

                      #  Command substitution
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo "\z"`      # \z
echo `echo "\\z"`     # \z

                      # Here document
cat &lt;&lt;EOF              
\z                      
EOF                   # \z

cat &lt;&lt;EOF              
\\z                     
EOF                   # \z

# These examples supplied by Stéphane Chazelas.</programlisting>
      </para>

      <para>Elements of a string assigned to a variable may be escaped, but
        the escape character alone may not be assigned to a variable.
	<programlisting>variable=\
echo "$variable"
# Will not work - gives an error message:
# test.sh: : command not found
# A "naked" escape cannot safely be assigned to a variable.
#
#  What actually happens here is that the "\" escapes the newline and
#+ the effect is        variable=echo "$variable"
#+                      invalid variable assignment

variable=\
23skidoo
echo "$variable"        #  23skidoo
                        #  This works, since the second line
                        #+ is a valid variable assignment.

variable=\ 
#        \^    escape followed by space
echo "$variable"        # space

variable=\\
echo "$variable"        # \

variable=\\\
echo "$variable"
# Will not work - gives an error message:
# test.sh: \: command not found
#
#  First escape escapes second one, but the third one is left "naked",
#+ with same result as first instance, above.

variable=\\\\
echo "$variable"        # \\
                        # Second and fourth escapes escaped.
                        # This is o.k.</programlisting>
      </para>
      
      </note>   



      <para>Escaping a space can prevent word splitting in a command's argument list.
        <programlisting>file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
# List of files as argument(s) to a command.

# Add two files to the list, and list all.
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo "-------------------------------------------------------------------------"

# What happens if we escape a couple of spaces?
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# Error: the first three files concatenated into a single argument to 'ls -l'
#        because the two escaped spaces prevent argument (word) splitting.</programlisting>
</para>


      <para><anchor xml:id="escnewline" /></para>
      <para>The <token>escape</token> also provides a means of writing a
	multi-line command. Normally, each separate line constitutes
	a different command, but an <token>escape</token> at the end
	of a line <emphasis>escapes the newline character</emphasis>,
	and the command sequence continues on to the next line.</para>
      <para><programlisting>(cd /source/directory &amp;&amp; tar cf - . ) | \
(cd /dest/directory &amp;&amp; tar xpvf -)
# Repeating Alan Cox's directory tree copy command,
# but split into two lines for increased legibility.

# As an alternative:
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# See note below.
# (Thanks, Stéphane Chazelas.)</programlisting>
        
	<note><para>If a script line ends with a <token>|</token>, a pipe
	  character, then a <token>\</token>, an escape, is not strictly
	  necessary. It is, however, good programming practice to always
	  escape the end of a line of code that continues to the
	  following line.</para></note></para>

	<para><programlisting>echo "foo
bar" 
#foo
#bar

echo

echo 'foo
bar'    # No difference yet.
#foo
#bar

echo

echo foo\
bar     # Newline escaped.
#foobar

echo

echo "foo\
bar"     # Same here, as \ still interpreted as escape within weak quotes.
#foobar

echo

echo 'foo\
bar'     # Escape character \ taken literally because of strong quoting.
#foo\
#bar

# Examples suggested by Stéphane Chazelas.</programlisting></para>

      </section> <!-- Escaping -->


  </chapter> <!-- Quoting -->


  <chapter xml:id="exit-status">
    <title>Exit and Exit Status</title>

    <epigraph>
      <para>... there are dark corners in the Bourne shell, and people use all
      of them.</para>
      <para>--Chet Ramey</para>
    </epigraph>
    
      <para><anchor xml:id="exitcommandref" />The 
	<command>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  exit
	</command> 
	command terminates a script, just as in a <command>C</command>
	program. It can also return a value, which is available to the
	script's parent process.</para>


      <para><anchor xml:id="exitstatusref" />Every command returns an 
	<firstterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  exit status
	</firstterm> 
	(sometimes referred to as a 
	<firstterm>
	  <indexterm>
	    <primary>return status</primary>
	  </indexterm>
	  return status
	</firstterm> or <firstterm>exit code</firstterm>).
	<anchor xml:id="exitsuccess" />
	A successful command returns a <returnvalue>0</returnvalue>, while
	an unsuccessful one returns a <returnvalue>non-zero</returnvalue>
	value that usually can be interpreted as an <firstterm>error
	code</firstterm>. Well-behaved UNIX commands, programs, and
	utilities return a <returnvalue>0</returnvalue> exit code upon
	successful completion, though there are some exceptions.</para>

      <para><anchor xml:id="functxstr" /></para>
      <para>Likewise, <link linkend="functionref">functions</link>
	within a script and the script itself return an exit
	status. The last command executed in the function or
	script determines the exit status. Within a script, an
	<userinput>exit <replaceable>nnn</replaceable></userinput>
	command may be used to deliver an
	<returnvalue><replaceable>nnn</replaceable></returnvalue>
	exit status to the shell
	(<returnvalue><replaceable>nnn</replaceable></returnvalue>
	must be an integer in the <returnvalue>0</returnvalue> -
	<returnvalue>255</returnvalue> range).</para>

      <note>

      <para>When a script ends with an <command>exit</command> that has
	no parameter, the exit status of the script is the exit status
	of the last command executed in the script (previous to the
	<command>exit</command>).</para>

      <para><programlisting>#!/bin/bash

COMMAND_1

. . .

COMMAND_LAST

# Will exit with status of last command.

exit</programlisting></para>

      <para>The equivalent of a bare <command>exit</command> is
        <command>exit $?</command> or even just omitting the
	<command>exit</command>.</para>

      <para><programlisting>#!/bin/bash

COMMAND_1

. . .

COMMAND_LAST

# Will exit with status of last command.

exit $?</programlisting></para>

      <para><programlisting>#!/bin/bash

COMMAND1

. . . 

COMMAND_LAST

# Will exit with status of last command.</programlisting></para>
	
	</note>

      <para><anchor xml:id="exsref" /></para>

      <para>
	<varname>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm> <indexterm>
	    <primary>variable</primary> <secondary>$?</secondary>
	  </indexterm> $?</varname> reads the exit status of the last
	    command executed. After a function returns,
	    <varname>$?</varname> gives the exit status of the last
	    command executed in the function. This is Bash's way of giving
	    functions a <quote>return value.</quote>
	    
	      <footnote><para>In those instances when there is no <link linkend="returnref">return</link>
	      terminating the function.</para></footnote>
      </para>
	    
      <para><anchor xml:id="pipeex" />Following the execution of a <link linkend="piperef">pipe</link>, a <varname>$?</varname>
        gives the exit status of the last command executed.</para>
        

      <para>After a script terminates, a <varname>$?</varname> from the
	    command-line gives the exit status of the script, that is, the
	    last command executed in the script, which is, by convention,
	    <userinput>0</userinput> on success or an integer in the
	    range <returnvalue>1 - 255</returnvalue> on error.</para>

      <example xml:id="ex5">
	<title>exit / exit status</title>
	<programlisting>#!/bin/bash

echo hello
echo $?    # Exit status 0 returned because command executed successfully.

lskdf      # Unrecognized command.
echo $?    # Non-zero exit status returned -- command failed to execute.

echo

exit 113   # Will return 113 to shell.
           # To verify this, type "echo $?" after script terminates.

#  By convention, an 'exit 0' indicates success,
#+ while a non-zero exit value means an error or anomalous condition.
#  See the "Exit Codes With Special Meanings" appendix.
</programlisting>
      </example>
      
      <para><link linkend="xstatvarref">$?</link> is especially useful
        for testing the result of a command in a script (see <xref linkend="filecomp" /> and <xref linkend="lookup" />).</para>

      <note>
      <para>The <link linkend="notref">!</link>, the <firstterm>logical
	not</firstterm> qualifier, reverses the outcome of a test or
	command, and this affects its <link linkend="exitstatusref">exit
	status</link>.

	<example xml:id="negcond">
	<title>Negating a condition using <token>!</token></title>
	<programlisting>true    # The "true" builtin.
echo "exit status of \"true\" = $?"     # 0

! true
echo "exit status of \"! true\" = $?"   # 1
# Note that the "!" needs a space between it and the command.
#    !true   leads to a "command not found" error
#
# The '!' operator prefixing a command invokes the Bash history mechanism.

true
!true
# No error this time, but no negation either.
# It just repeats the previous command (true).


# =========================================================== #
# Preceding a _pipe_ with ! inverts the exit status returned.
ls | bogus_command     # bash: bogus_command: command not found
echo $?                # 127

! ls | bogus_command   # bash: bogus_command: command not found
echo $?                # 0
# Note that the ! does not change the execution of the pipe.
# Only the exit status changes.
# =========================================================== #

# Thanks, Stéphane Chazelas and Kristopher Newsome.</programlisting>
        </example>

      </para>
      </note>


      <caution><para>Certain exit status codes have <link linkend="exitcodesref">reserved meanings</link> and should not
	be user-specified in a script.	</para></caution>


  </chapter> <!-- Exit and Exit status -->


  <chapter xml:id="tests">
    <title>Tests</title>

      <para><anchor xml:id="ifthen" /></para>

      <indexterm>
	<primary>if</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>if</secondary>
      </indexterm>
      <indexterm>
	<primary>then</primary>
      </indexterm>
      <indexterm>
	<primary>else</primary>
      </indexterm>
      <indexterm>
	<primary>else if</primary>
      </indexterm>
      <indexterm>
	<primary>elif</primary>
      </indexterm>

        <para>Every reasonably complete programming language can test
	  for a condition, then act according to the result of the
	  test. Bash has the <link linkend="ttestref">test</link>
	  command, various <link linkend="dblbrackets">bracket</link>
	  and <link linkend="dblparenstst">parenthesis</link> operators,
	  and the <command>if/then</command> construct.</para>

      <section xml:id="testconstructs">
	<title>Test Constructs</title>

	<para><anchor xml:id="testconstructs1" /></para>

      <itemizedlist xml:id="testingref">

        <listitem>
	<para>An <command>if/then</command> construct tests whether the
	  <link linkend="exitstatusref">exit status</link> of a list
	  of commands is <returnvalue>0</returnvalue> (since 0 means
	  <quote>success</quote> by UNIX convention), and if so, executes
	  one or more commands.</para>
	</listitem>

        <listitem>
	<para>There exists a dedicated command called <command>
	[</command> (<link linkend="leftbracket">left bracket</link>
	special character). It is a synonym for <command>test</command>,
	and a <link linkend="builtinref">builtin</link> for efficiency
	reasons. This command considers its arguments as comparison
	expressions or file tests and returns an exit status corresponding
	to the result of the comparison (0 for true, 1 for false).</para>
	</listitem>

        <listitem>
	<para>With version 2.02, Bash introduced the <link linkend="dblbrackets">[[ ... ]]</link> <firstterm>extended
	  test command</firstterm>, which performs comparisons
	  in a manner more familiar to programmers from other
	  languages. Note that <command>[[</command> is a <link linkend="keywordref">keyword</link>, not a command.</para>

	<para>Bash sees <userinput>[[ $a -lt $b ]]</userinput> as a
	  single element, which returns an exit status.</para>
        </listitem>

        <listitem>
	<para><anchor xml:id="dblparenstst" /></para>
	<para>The <link linkend="dblparens">(( ... ))</link> and <link linkend="letref">let ...</link> constructs return an
          <link linkend="exitstatusref">exit status</link>,
	  <emphasis>according to whether the arithmetic expressions they
	  evaluate expand to a non-zero value</emphasis>. These
	  <link linkend="arithexpref">arithmetic-expansion</link>
	  constructs may therefore be used to perform <link linkend="icomparison1">arithmetic comparisons</link>.</para>

        <para>
        <programlisting>(( 0 &amp;&amp; 1 ))                 # Logical AND
echo $?     # 1     ***
# And so ...
let "num = (( 0 &amp;&amp; 1 ))"
echo $num   # 0
# But ...
let "num = (( 0 &amp;&amp; 1 ))"
echo $?     # 1     ***


(( 200 || 11 ))              # Logical OR
echo $?     # 0     ***
# ...
let "num = (( 200 || 11 ))"
echo $num   # 1
let "num = (( 200 || 11 ))"
echo $?     # 0     ***


(( 200 | 11 ))               # Bitwise OR
echo $?                      # 0     ***
# ...
let "num = (( 200 | 11 ))"
echo $num                    # 203
let "num = (( 200 | 11 ))"
echo $?                      # 0     ***

# The "let" construct returns the same exit status
#+ as the double-parentheses arithmetic expansion.</programlisting>	    
	  </para>

          <caution><para><anchor xml:id="arxs" />Again, note that the
	  <firstterm>exit status</firstterm> of an arithmetic expression
	  is <emphasis>not</emphasis> an error value.
	  <programlisting>var=-2 &amp;&amp; (( var+=2 ))
echo $?                   # 1

var=-2 &amp;&amp; (( var+=2 )) &amp;&amp; echo $var
                          # Will not echo $var!</programlisting>
          </para></caution>

        </listitem>

        <listitem>
          <para><anchor xml:id="ifgrepref" /></para>

	  <para>An <command>if</command> can test any command, not just
	    conditions enclosed within brackets.</para>


   <para><programlisting>if cmp a b &amp;&gt; /dev/null  # Suppress output.
then echo "Files a and b are identical."
else echo "Files a and b differ."
fi

# The very useful "if-grep" construct:
# ----------------------------------- 
if grep -q Bash file
  then echo "File contains at least one occurrence of Bash."
fi

word=Linux
letter_sequence=inu
if echo "$word" | grep -q "$letter_sequence"
# The "-q" option to grep suppresses output.
then
  echo "$letter_sequence found in $word"
else
  echo "$letter_sequence not found in $word"
fi


if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
  then echo "Command succeeded."
  else echo "Command failed."
fi</programlisting>
          </para>
        </listitem>

        <listitem>


	  <para><emphasis>These last two examples
	  courtesy of Stéphane Chazelas.</emphasis></para>

        </listitem>


      </itemizedlist>



      <example xml:id="ex10">
	<title>What is truth?</title>
	<programlisting>#!/bin/bash

#  Tip:
#  If you're unsure how a certain condition might evaluate,
#+ test it in an if-test.

echo

echo "Testing \"0\""
if [ 0 ]      # zero
then
  echo "0 is true."
else          # Or else ...
  echo "0 is false."
fi            # 0 is true.

echo

echo "Testing \"1\""
if [ 1 ]      # one
then
  echo "1 is true."
else
  echo "1 is false."
fi            # 1 is true.

echo

echo "Testing \"-1\""
if [ -1 ]     # minus one
then
  echo "-1 is true."
else
  echo "-1 is false."
fi            # -1 is true.

echo

echo "Testing \"NULL\""
if [ ]        # NULL (empty condition)
then
  echo "NULL is true."
else
  echo "NULL is false."
fi            # NULL is false.

echo

echo "Testing \"xyz\""
if [ xyz ]    # string
then
  echo "Random string is true."
else
  echo "Random string is false."
fi            # Random string is true.

echo

echo "Testing \"\$xyz\""
if [ $xyz ]   # Tests if $xyz is null, but...
              # it's only an uninitialized variable.
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
fi            # Uninitialized variable is false.

echo

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]            # More pedantically correct.
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
fi            # Uninitialized variable is false.

echo


xyz=          # Initialized, but set to null value.

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]
then
  echo "Null variable is true."
else
  echo "Null variable is false."
fi            # Null variable is false.


echo


# When is "false" true?

echo "Testing \"false\""
if [ "false" ]              #  It seems that "false" is just a string ...
then
  echo "\"false\" is true." #+ and it tests true.
else
  echo "\"false\" is false."
fi            # "false" is true.

echo

echo "Testing \"\$false\""  # Again, uninitialized variable.
if [ "$false" ]
then
  echo "\"\$false\" is true."
else
  echo "\"\$false\" is false."
fi            # "$false" is false.
              # Now, we get the expected result.

#  What would happen if we tested the uninitialized variable "$true"?

echo

exit 0
</programlisting>
      </example>

      <formalpara><title>Exercise</title>
	<para>Explain the behavior of <xref linkend="ex10" />, above.</para>
      </formalpara>
      
      <para><anchor xml:id="elseref" /><programlisting>if [ condition-true ]
then
   command 1
   command 2
   ...
else  # Or else ...
      # Adds default code block executing if original condition tests false.
   command 3
   command 4
   ...
fi</programlisting>
      </para>

      <note>
      <para>When <firstterm>if</firstterm> and <firstterm>then</firstterm>
	are on same line in a condition test, a semicolon must
	terminate the <firstterm>if</firstterm> statement.  Both
	<firstterm>if</firstterm> and <firstterm>then</firstterm>
	are <link linkend="keywordref">keywords</link>.  Keywords (or
	commands) begin statements, and before a new statement on the
	same line begins, the old one must terminate.</para>

      <para><programlisting>if [ -x "$filename" ]; then</programlisting></para>
      </note>

      <variablelist xml:id="elifref">
        <title><anchor xml:id="elifref1" />Else if and elif</title>
	<varlistentry>
          <term><token>elif</token></term>
	  <listitem>
	    <para><userinput>elif</userinput> is a contraction
	      for <firstterm>else if</firstterm>. The effect is to nest an
	      inner <token>if/then</token> construct within an outer
	      one.</para>

	    <para><programlisting>if [ condition1 ]
then
   command1
   command2
   command3
elif [ condition2 ]
# Same as else if
then
   command4
   command5
else
   default-command
fi</programlisting>
	      </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>[</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>[</secondary>
      </indexterm>
      <indexterm>
	<primary>]</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>]</secondary>
      </indexterm>
	<anchor xml:id="ifref2" />
	The <userinput>if test condition-true</userinput> construct is the
	exact equivalent of <userinput>if [ condition-true ]</userinput>.
	As it happens, the left bracket, <command>[</command> , is a
	<firstterm>token</firstterm>

	<footnote><para><anchor xml:id="tokenref" />A
	<firstterm>token</firstterm> is a symbol or short
	string with a special meaning attached to it (a <link linkend="metameaningref">meta-meaning</link>). In Bash,
	certain tokens, such as <command>[</command> and <link linkend="dotref">. (dot-command)</link>, may expand to
	<firstterm>keywords</firstterm> and commands.</para></footnote>

	which invokes the <command>test</command> command.  The closing
	right bracket, <command>]</command> , in an if/test should not
	therefore be strictly necessary, however newer versions of Bash
	require it.</para>

	<para><anchor xml:id="ttestref" /></para>
	<note><para>The <command>test</command> command is a Bash <link linkend="builtinref">builtin</link> which tests file
	  types and compares strings. Therefore, in a Bash script,
	  <command>test</command> does <emphasis>not</emphasis> call
	  the external <filename>/usr/bin/test</filename> binary,
	  which is part of the <firstterm>sh-utils</firstterm>
	  package. Likewise, <command>[</command> does not call
	  <filename>/usr/bin/[</filename>, which is linked to
	  <filename>/usr/bin/test</filename>.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>type test</userinput>
<computeroutput>test is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type '['</userinput>
<computeroutput>[ is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type '[['</userinput>
<computeroutput>[[ is a shell keyword</computeroutput>
<prompt>bash$ </prompt><userinput>type ']]'</userinput>
<computeroutput>]] is a shell keyword</computeroutput>
<prompt>bash$ </prompt><userinput>type ']'</userinput>
<computeroutput>bash: type: ]: not found</computeroutput>
	      </screen>
	    </para>
	    
	<para><anchor xml:id="usrbintest" /></para>
	<para>If, for some reason, you wish to use
	  <filename>/usr/bin/test</filename> in a Bash script,
	  then specify it by full pathname.</para>
	    
	    </note>
      

      <example xml:id="ex11">
	<title>Equivalence of <firstterm>test</firstterm>,
	  <filename>/usr/bin/test</filename>, <token>[ ]</token>,
	  and <filename>/usr/bin/[</filename></title>
	<programlisting>#!/bin/bash

echo

if test -z "$1"
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if /usr/bin/test -z "$1"      # Equivalent to "test" builtin.
#  ^^^^^^^^^^^^^              # Specifying full pathname.
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if [ -z "$1" ]                # Functionally identical to above code blocks.
#   if [ -z "$1"                should work, but...
#+  Bash responds to a missing close-bracket with an error message.
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo


if /usr/bin/[ -z "$1" ]       # Again, functionally identical to above.
# if /usr/bin/[ -z "$1"       # Works, but gives an error message.
#                             # Note:
#                               This has been fixed in Bash, version 3.x.
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

exit 0
</programlisting>
      </example>


      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>[[</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>[[</secondary>
      </indexterm>
      <indexterm>
	<primary>]]</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>]]</secondary>
      </indexterm>


      <sidebar>

      <para><anchor xml:id="dblbrackets" />The <token>[[  ]]</token> construct
	is the more versatile Bash version of <token>[	]</token>. This
	is the <firstterm>extended test command</firstterm>, adopted from
	<firstterm>ksh88</firstterm>.</para>

      <para>*  *  *</para>

      <para>No filename expansion or word splitting takes place
	between <token>[[</token> and <token>]]</token>, but there is
	parameter expansion and command substitution.

	<programlisting>file=/etc/passwd

if [[ -e $file ]]
then
  echo "Password file exists."
fi</programlisting>
      </para>


      <para>Using the <command>[[ ... ]]</command> test construct,
	rather than <command>[ ... ]</command> can prevent many
	logic errors in scripts. For example, the <token>&amp;&amp;</token>,
	<token>||</token>, <token>&lt;</token>, and <token>&gt;</token>
	operators work within a <token>[[  ]]</token> test, despite
	giving an error within a <token>[  ]</token> construct.</para>


      <para><anchor xml:id="dblbraev" /></para>
      <para><firstterm>Arithmetic evaluation</firstterm> of octal /
        hexadecimal constants takes place automatically within a
	<token>[[ ... ]]</token> construct.
	<programlisting># [[ Octal and hexadecimal evaluation ]]
# Thank you, Moritz Gronbach, for pointing this out.


decimal=15
octal=017   # = 15 (decimal)
hex=0x0f    # = 15 (decimal)

if [ "$decimal" -eq "$octal" ]
then
  echo "$decimal equals $octal"
else
  echo "$decimal is not equal to $octal"       # 15 is not equal to 017
fi      # Doesn't evaluate within [ single brackets ]!


if [[ "$decimal" -eq "$octal" ]]
then
  echo "$decimal equals $octal"                # 15 equals 017
else
  echo "$decimal is not equal to $octal"
fi      # Evaluates within [[ double brackets ]]!

if [[ "$decimal" -eq "$hex" ]]
then
  echo "$decimal equals $hex"                  # 15 equals 0x0f
else
  echo "$decimal is not equal to $hex"
fi      # [[ $hexadecimal ]] also evaluates!</programlisting>
      </para>

      </sidebar>


      <note>
      <para>Following an <command>if</command>, neither the
        <command>test</command> command nor the test brackets ( [ ] or [[ ]] )
	are strictly necessary.

	<programlisting>dir=/home/bozo

if cd "$dir" 2&gt;/dev/null; then   # "2&gt;/dev/null" hides error message.
  echo "Now in $dir."
else
  echo "Can't change to $dir."
fi</programlisting>

        The "if COMMAND" construct returns the exit status of COMMAND.
</para>

	
	<para>Similarly, a condition within test brackets may stand alone
	  without an <command>if</command>, when used in combination
	  with a <link linkend="listconsref">list construct</link>.

	  <programlisting>var1=20
var2=22
[ "$var1" -ne "$var2" ] &amp;&amp; echo "$var1 is not equal to $var2"

home=/home/bozo
[ -d "$home" ] || echo "$home directory does not exist."</programlisting></para>
	  </note>


      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>((</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>))</secondary>
      </indexterm>
      <indexterm>
	<primary>((</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>))</secondary>
      </indexterm>

      <para><anchor xml:id="dblprx" />The <link linkend="dblparens">(( ))
	construct</link> expands and evaluates an arithmetic
	expression. If the expression evaluates as zero, it returns
	an <link linkend="exitstatusref">exit status</link> of
	<returnvalue>1</returnvalue>, or <quote>false</quote>. A non-zero
	expression returns an exit status of <returnvalue>0</returnvalue>,
	or <quote>true</quote>. This is in marked contrast to using
	the <command>test</command> and <token>[ ]</token> constructs
	previously discussed.</para>

        <example xml:id="arithtests">
	  <title>Arithmetic Tests using <token>(( ))</token></title>
	  <programlisting>#!/bin/bash
# arith-tests.sh
# Arithmetic tests.

# The (( ... )) construct evaluates and tests numerical expressions.
# Exit status opposite from [ ... ] construct!

(( 0 ))
echo "Exit status of \"(( 0 ))\" is $?."         # 1

(( 1 ))
echo "Exit status of \"(( 1 ))\" is $?."         # 0

(( 5 &gt; 4 ))                                      # true
echo "Exit status of \"(( 5 &gt; 4 ))\" is $?."     # 0

(( 5 &gt; 9 ))                                      # false
echo "Exit status of \"(( 5 &gt; 9 ))\" is $?."     # 1

(( 5 == 5 ))                                     # true
echo "Exit status of \"(( 5 == 5 ))\" is $?."    # 0
# (( 5 = 5 ))  gives an error message.

(( 5 - 5 ))                                      # 0
echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1

(( 5 / 4 ))                                      # Division o.k.
echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0

(( 1 / 2 ))                                      # Division result &lt; 1.
echo "Exit status of \"(( 1 / 2 ))\" is $?."     # Rounded off to 0.
                                                 # 1

(( 1 / 0 )) 2&gt;/dev/null                          # Illegal division by 0.
#           ^^^^^^^^^^^
echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1

# What effect does the "2&gt;/dev/null" have?
# What would happen if it were removed?
# Try removing it, then rerunning the script.

# ======================================= #

# (( ... )) also useful in an if-then test.

var1=5
var2=4

if (( var1 &gt; var2 ))
then #^      ^      Note: Not $var1, $var2. Why?
  echo "$var1 is greater than $var2"
fi     # 5 is greater than 4

exit 0
</programlisting>
        </example>

      </section> <!-- Test Constructs -->


      <section xml:id="fto">
	<title>File test operators</title>

	<variablelist>
	  <title><anchor xml:id="rtif" />Returns true if...</title>
	  <varlistentry>
	    <term><token>-e</token></term>
	    <listitem><para>file exists</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-a</token></term>
	    <listitem><para>file exists</para>
	    <para>This is identical in effect to <token>-e</token>.
	      It has been <quote>deprecated,</quote>

	        <footnote><para>
		Per the 1913 edition of <emphasis>Webster's
		Dictionary</emphasis>:
		<programlisting>Deprecate
...

To pray against, as an evil;
to seek to avert by prayer;
to desire the removal of;
to seek deliverance from;
to express deep regret for;
to disapprove of strongly.</programlisting>
	        </para></footnote>
	      
	      and its use is
	      discouraged.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><anchor id="regularfile" /><token>-f</token></term>
	    <listitem><para>file is a <replaceable>regular</replaceable>
	      file (not a directory or <link linkend="devfileref">device
	      file</link>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-s</token></term>
	    <listitem><para>file is not zero size</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-d</token></term>
	    <listitem><para>file is a directory</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-b</token></term>
	    <listitem>
	    <para>file is a <link linkend="blockdevref">block
	    device</link></para>
	    <para><anchor xml:id="blockdevtest" /></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-c</token></term>
	    <listitem><para><anchor xml:id="chardevtest" />file is a <link linkend="chardevref">character device</link></para>
            <para><programlisting>device0="/dev/sda2"    # /   (root directory)
if [ -b "$device0" ]
then
  echo "$device0 is a block device."
fi

# /dev/sda2 is a block device.



device1="/dev/ttyS1"   # PCMCIA modem card.
if [ -c "$device1" ]
then
  echo "$device1 is a character device."
fi

# /dev/ttyS1 is a character device.</programlisting></para>
          </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-p</token></term>
	    <listitem>
              <para>file is a <link linkend="piperef">pipe</link></para>
	      <para><programlisting>function show_input_type()
{
   [ -p /dev/fd/0 ] &amp;&amp; echo PIPE || echo STDIN
}

show_input_type "Input"                           # STDIN
echo "Input" | show_input_type                    # PIPE

# This example courtesy of Carl Anderson.</programlisting></para>
            </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-h</token></term>
	    <listitem><para>file is a <link linkend="symlinkref">symbolic
	      link</link></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-L</token></term>
	    <listitem><para>file is a symbolic link</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-S</token></term>
	    <listitem><para>file is a <link linkend="socketref">socket</link></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-t</token></term>
	    <listitem>

	    <para><anchor xml:id="termtest" />file (<link linkend="fdref">descriptor</link>) is
	      associated with a terminal device</para>

	    <para>This test option <link linkend="ii2test"> may be used
	      to check</link> whether the <filename>stdin</filename>
	      <userinput>[ -t 0 ]</userinput> or
	      <filename>stdout</filename> <userinput>[ -t 1 ]</userinput>
	      in a given script is a terminal.</para>

	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-r</token></term>
	    <listitem><para>file has read permission (<emphasis>for the
	      user running the test</emphasis>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-w</token></term>
	    <listitem><para>file has write permission (for the user running
	      the test)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-x</token></term>
	    <listitem><para>file has execute permission (for the user running
	    the test)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-g</token></term>
	    <listitem>
	    <para>set-group-id (sgid) flag set on file or directory</para>
	    <para>If a directory has the <replaceable>sgid</replaceable>
	      flag set, then a file created within that directory belongs
	      to the group that owns the directory, not necessarily to
	      the group of the user who created the file. This may be
	      useful for a directory shared by a workgroup.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-u</token></term>
	    <listitem>
	    <para><anchor xml:id="suidref" /></para>
	    <para>set-user-id (suid) flag set on file</para>
	    <para>A binary owned by <firstterm>root</firstterm>
	      with <replaceable>set-user-id</replaceable> flag set
	      runs with <firstterm>root</firstterm> privileges, even
	      when an ordinary user invokes it.
	      
		<footnote><para>Be aware that <firstterm>suid</firstterm>
		  binaries may open security holes. The
		  <firstterm>suid</firstterm> flag has no effect on
		  shell scripts.</para></footnote>

	      This is useful for executables (such as
	      <command>pppd</command> and <command>cdrecord</command>)
	      that need to access system hardware. Lacking the
	      <firstterm>suid</firstterm> flag, these binaries could not
	      be invoked by a <firstterm>non-root</firstterm> user.</para>

	      <para>
	      <screen>
	      <computeroutput>-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd</computeroutput>
	      </screen>
	      </para>

	      <para>A file with the <replaceable>suid</replaceable>
		flag set shows an <firstterm>s</firstterm> in its
		permissions.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-k</token></term>
	    <listitem>

	    <para><replaceable>sticky bit</replaceable> set</para>

	    <para>Commonly known as the <firstterm>sticky bit,</firstterm>
	      the <firstterm>save-text-mode</firstterm> flag is a special
	      type of file permission. If a file has this flag set,
	      that file will be kept in cache memory, for quicker access.
	        <footnote><para>On Linux systems, the sticky
		  bit is no longer used for files, only on
		  directories.</para></footnote>
	      If set on a directory, it restricts write permission.
	      Setting the sticky bit adds a <firstterm>t</firstterm>
	      to the permissions on the file or directory listing.
	      This restricts altering or deleting specific files 
	      in that directory to the owner of those files.</para>

	      <para>
	      <screen>
	      <computeroutput>drwxrwxrwt    7 root         1024 May 19 21:26 tmp/</computeroutput>
	      </screen>
	      </para>
	    
	      <para>If a user does not own a directory that has the sticky
		bit set, but has write permission in that directory, she
		can only delete those files that she owns in it. This
		keeps users from inadvertently overwriting or deleting
		each other's files in a publicly accessible directory,
		such as <filename class="directory">/tmp</filename>.
		(The <firstterm>owner</firstterm> of the directory or
		<firstterm>root</firstterm> can, of course, delete or
		rename files there.)</para>

	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-O</token></term>
	    <listitem><para>you are owner of file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-G</token></term>
	    <listitem><para>group-id of file same as yours</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-N</token></term>
	    <listitem><para>file modified since it was last read</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -nt f2</token></term>
	    <listitem><para>file <replaceable>f1</replaceable> is newer than
		<replaceable>f2</replaceable></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ot f2</token></term>
	    <listitem><para>file <replaceable>f1</replaceable> is older than
		<replaceable>f2</replaceable></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ef f2</token></term>
	    <listitem><para>files <replaceable>f1</replaceable> and
		<replaceable>f2</replaceable> are hard links to the same
		file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>!</token></term>
	    <listitem><para><quote>not</quote> -- reverses the sense of the
	    tests above (returns true if condition absent).</para></listitem>
	  </varlistentry>
	</variablelist>

	<example xml:id="brokenlink">
	  <title>Testing for broken links</title>
	  <programlisting>#!/bin/bash
# broken-link.sh
# Written by Lee bigelow &lt;ligelowbee@yahoo.com&gt;
# Used in ABS Guide with permission.

#  A pure shell script to find dead symlinks and output them quoted
#+ so they can be fed to xargs and dealt with :)
#+ eg. sh broken-link.sh /somedir /someotherdir|xargs rm
#
#  This, however, is a better method:
#
#  find "somedir" -type l -print0|\
#  xargs -r0 file|\
#  grep "broken symbolic"|
#  sed -e 's/^\|: *broken symbolic.*$/"/g'
#
#+ but that wouldn't be pure Bash, now would it.
#  Caution: beware the /proc file system and any circular links!
################################################################


#  If no args are passed to the script set directories-to-search 
#+ to current directory.  Otherwise set the directories-to-search 
#+ to the args passed.
######################

[ $# -eq 0 ] &amp;&amp; directorys=`pwd` || directorys=$@


#  Setup the function linkchk to check the directory it is passed 
#+ for files that are links and don't exist, then print them quoted.
#  If one of the elements in the directory is a subdirectory then 
#+ send that subdirectory to the linkcheck function.
##########

linkchk () {
    for element in $1/*; do
      [ -h "$element" -a ! -e "$element" ] &amp;&amp; echo \"$element\"
      [ -d "$element" ] &amp;&amp; linkchk $element
    # Of course, '-h' tests for symbolic link, '-d' for directory.
    done
}

#  Send each arg that was passed to the script to the linkchk() function
#+ if it is a valid directoy.  If not, then print the error message
#+ and usage info.
##################
for directory in $directorys; do
    if [ -d $directory ]
	then linkchk $directory
	else 
	    echo "$directory is not a directory"
	    echo "Usage: $0 dir1 dir2 ..."
    fi
done

exit $?
</programlisting>
	</example>

	<para><xref linkend="cookies" />, <xref linkend="bingrep" />,
	  <xref linkend="fileinfo" />, <xref linkend="ramdisk" />, and <xref linkend="mailformat" /> also illustrate uses of the file test
	  operators.</para>


      </section> <!-- File test operators -->

      <section xml:id="comparison-ops">
	<title>Other Comparison Operators</title>

	<para>A <firstterm>binary</firstterm> comparison operator
	  compares two variables or quantities. <emphasis>Note
	  that integer and string comparison use a different set of
	  operators.</emphasis></para>

	<variablelist xml:id="icomparison">
	  <title><anchor xml:id="icomparison1" />integer comparison</title>

	  <varlistentry>
	    <term><anchor id="equalref" /><token>-eq</token></term>
	    <listitem>
	    <para>is equal to</para>
	    <para><userinput>if [ "$a" -eq "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="nequalref" /><token>-ne</token></term>
	    <listitem>
	    <para>is not equal to</para>
	    <para><userinput>if [ "$a" -ne "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="gt0ref" /><token>-gt</token></term>
	    <listitem>
	    <para>is greater than</para>
	    <para><userinput>if [ "$a" -gt "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="ge0ref" /><token>-ge</token></term>
	    <listitem>
	    <para>is greater than or equal to</para>
	    <para><userinput>if [ "$a" -ge "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="lt0ref" /><token>-lt</token></term>
	    <listitem>
	    <para>is less than</para>
	    <para><userinput>if [ "$a" -lt "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="le0ref" /><token>-le</token></term>
	    <listitem>
	    <para>is less than or equal to</para>
	    <para><userinput>if [ "$a" -le "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="intlt" /><token>&lt;</token></term>
	    <listitem>
	    <para>is less than (within <link linkend="dblparens">double
	      parentheses</link>)</para>
	    <para><userinput>(("$a" &lt; "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="lteq" /><token>&lt;=</token></term>
	    <listitem>
	    <para>is less than or equal to (within double parentheses)</para>
	    <para><userinput>(("$a" &lt;= "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="intgt" /><token>&gt;</token></term>
	    <listitem>
	    <para>is greater than (within double parentheses)</para>
	    <para><userinput>(("$a" &gt; "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="gteq" /><token>&gt;=</token></term>
	    <listitem>
	    <para>is greater than or equal to (within double parentheses)</para>
	    <para><userinput>(("$a" &gt;= "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>
	  
	</variablelist>
	
	<variablelist xml:id="scomparison">
	  <title><anchor xml:id="scomparison1" />string comparison</title>
	  <varlistentry>
	    <term><token>=</token></term>
	    <listitem>
	    <para><anchor xml:id="equalsignref" /></para>
	    <para>is equal to</para>
	    <para><userinput>if [ "$a" = "$b" ]</userinput></para>

	    <caution><para>Note the <link linkend="whitespaceref">whitespace</link>
              framing the <command>=</command>.</para>
              <para><userinput>if [ "$a"="$b" ]</userinput> is
              <emphasis>not</emphasis> equivalent to the
              above.</para></caution>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="scomparison2" /><token>==</token></term>
	    <listitem>
	      <para>is equal to</para>
	      <para><userinput>if [ "$a" == "$b" ]</userinput></para>
	      <para>This is a synonym for <token>=</token>.</para>

	      <note><para>
	      The <token>==</token> comparison operator behaves differently
	      within a <link linkend="dblbrackets">double-brackets</link>
	      test than within single brackets.
              <programlisting>[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
[[ $a == "z*" ]] # True if $a is equal to z* (literal matching).

[ $a == z* ]     # File globbing and word splitting take place.
[ "$a" == "z*" ] # True if $a is equal to z* (literal matching).

# Thanks, Stéphane Chazelas</programlisting>
              </para></note>

	      </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><anchor id="notequal" /><token>!=</token></term>
	    <listitem>
	    <para>is not equal to</para>
	    <para><userinput>if [ "$a" != "$b" ]</userinput></para>
	    <para>This operator uses pattern matching within a <link linkend="dblbrackets">[[ ... ]]</link> construct.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="ltref" /><token>&lt;</token></term>
	    <listitem>
		    <para>is less than, in <link linkend="asciidef">ASCII</link> alphabetical
		    order</para>
	    <para><userinput>if [[ "$a" &lt; "$b" ]]</userinput></para>
	    <para><userinput>if [ "$a" \&lt; "$b" ]</userinput></para>
	    <para>Note that the <quote>&lt;</quote> needs to be
	      <link linkend="escp">escaped</link> within a
	      <userinput>[  ]</userinput> construct.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="gtref" /><token>&gt;</token></term>
	    <listitem>
	    <para>is greater than, in ASCII alphabetical order</para>
	    <para><userinput>if [[ "$a" &gt; "$b" ]]</userinput></para>
	    <para><userinput>if [ "$a" \&gt; "$b" ]</userinput></para>
	    <para>Note that the <quote>&gt;</quote> needs to be
	      escaped within a <userinput>[  ]</userinput> construct.</para>  
	    <para>See <xref linkend="bubble" /> for an application of this
	      comparison operator.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="stringnull" /><token>-z</token></term>
	    <listitem>
	      <para>string is <firstterm>null</firstterm>,
	        that is, has zero length</para>
                <para><programlisting> String=''   # Zero-length ("null") string variable.

if [ -z "$String" ]
then
  echo "\$String is null."
else
  echo "\$String is NOT null."
fi     # $String is null.</programlisting></para>
	     </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="stringnotnull" /><token>-n</token></term>
	    <listitem>
	      <para>string is not <firstterm>null.</firstterm></para>
	    
	      <caution><para>The <userinput>-n</userinput> test
		requires that the string be quoted within the
		test brackets. Using an unquoted string with
		<firstterm>! -z</firstterm>, or even just the
		unquoted string alone within test brackets (see <xref linkend="strtest" />) normally works, however, this is
		an unsafe practice. <emphasis>Always</emphasis> quote
		a tested string.
		  <footnote><para>As S.C. points out, in a compound test,
		    even quoting the string variable might not
		    suffice. <userinput>[ -n "$string" -o "$a" = "$b" ]</userinput>
		    may cause an error with some versions of Bash if
		    <varname>$string</varname> is empty. The safe way
		    is to append an extra character to possibly empty variables,
		    <userinput>[ "x$string" != x -o "x$a" = "x$b" ]</userinput>
		    (the <quote>x's</quote> cancel out).</para></footnote>
		</para></caution>
            </listitem>
	    </varlistentry>



	</variablelist>
	
	<example xml:id="ex13">
	  <title>Arithmetic and string comparisons</title>
	  <programlisting>#!/bin/bash

a=4
b=5

#  Here "a" and "b" can be treated either as integers or strings.
#  There is some blurring between the arithmetic and string comparisons,
#+ since Bash variables are not strongly typed.

#  Bash permits integer operations and comparisons on variables
#+ whose value consists of all-integer characters.
#  Caution advised, however.

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# In this particular instance, both "-ne" and "!=" work.

echo

exit 0
</programlisting>
	</example>

	<example xml:id="strtest">
	  <title>Testing whether a string is <firstterm>null</firstterm></title>
	  <programlisting>#!/bin/bash
#  str-test.sh: Testing null strings and unquoted strings,
#+ but not strings and sealing wax, not to mention cabbages and kings . . .

# Using   if [ ... ]

# If a string has not been initialized, it has no defined value.
# This state is called "null" (not the same as zero!).

if [ -n $string1 ]    # string1 has not been declared or initialized.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Wrong result.
# Shows $string1 as not null, although it was not initialized.

echo

# Let's try it again.

if [ -n "$string1" ]  # This time, $string1 is quoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Quote strings within test brackets!

echo

if [ $string1 ]       # This time, $string1 stands naked.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # This works fine.
# The [ ... ] test operator alone detects whether the string is null.
# However it is good practice to quote it (if [ "$string1" ]).
#
# As Stephane Chazelas points out,
#    if [ $string1 ]    has one argument, "]"
#    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 


echo


string1=initialized

if [ $string1 ]       # Again, $string1 stands unquoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Again, gives correct result.
# Still, it is better to quote it ("$string1"), because . . .


string1="a = b"

if [ $string1 ]       # Again, $string1 stands unquoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Not quoting "$string1" now gives wrong result!

exit 0   # Thank you, also, Florian Wisser, for the "heads-up".
</programlisting>
	</example>
      
	<example xml:id="ex14">
	  <title><firstterm>zmore</firstterm></title>
	  <programlisting>#!/bin/bash
# zmore

# View gzipped files with 'more' filter.

E_NOARGS=85
E_NOTFOUND=86
E_NOTGZIP=87

if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
# $1 can exist, but be empty:  zmore "" arg2 arg3
then
  echo "Usage: `basename $0` filename" &gt;&amp;2
  # Error message to stderr.
  exit $E_NOARGS
  # Returns 85 as exit status of script (error code).
fi  

filename=$1

if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
then
  echo "File $filename not found!" &gt;&amp;2   # Error message to stderr.
  exit $E_NOTFOUND
fi  

if [ ${filename##*.} != "gz" ]
# Using bracket in variable substitution.
then
  echo "File $1 is not a gzipped file!"
  exit $E_NOTGZIP
fi  

zcat $1 | more

# Uses the 'more' filter.
# May substitute 'less' if desired.

exit $?   # Script returns exit status of pipe.
#  Actually "exit $?" is unnecessary, as the script will, in any case,
#+ return the exit status of the last command executed.
</programlisting>
	</example>

	<variablelist xml:id="ccomparison">  
	  <title><anchor xml:id="ccomparison1" />compound comparison</title>

	  <varlistentry>
	    <term><anchor id="compoundand" /><token>-a</token></term>
	    <listitem>
	      <para>logical and</para>
	      <para><replaceable>exp1 -a exp2</replaceable> returns true if
		<emphasis>both</emphasis> exp1 and exp2 are true.</para>
	    </listitem>
            </varlistentry>

	  <varlistentry>
	    <term><anchor id="compoundor" /><token>-o</token></term>
	    <listitem>
	      <para>logical or </para>
	      <para><replaceable>exp1 -o exp2</replaceable> returns
		true if either exp1 <emphasis>or</emphasis> exp2 is
		true.</para>
	    </listitem>
	    </varlistentry>
	</variablelist>

       <para>
         These are similar to the Bash comparison operators
	 <command>&amp;&amp;</command> and <command>||</command>, used
	 within <link linkend="dblbrackets">double brackets</link>.
	   <programlisting>[[ condition1 &amp;&amp; condition2 ]]</programlisting>
       </para>

       <para>
	 The <command>-o</command> and <command>-a</command> operators
	 work with the <link linkend="ttestref">test</link> command or
	 occur within single test brackets.
         <programlisting>if [ "$expr1" -a "$expr2" ]
then
  echo "Both expr1 and expr2 are true."
else
  echo "Either expr1 or expr2 is false."
fi</programlisting>
	   </para>

	   <caution>
           <para>But, as <emphasis>rihad</emphasis> points out:
<programlisting>[ 1 -eq 1 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # true
[ 1 -eq 2 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # (no output)
# ^^^^^^^ False condition. So far, everything as expected.

# However ...
[ 1 -eq 2 -a -n "`echo true 1&gt;&amp;2`" ]       # true
# ^^^^^^^ False condition. So, why "true" output?

# Is it because both condition clauses within brackets evaluate?
[[ 1 -eq 2 &amp;&amp; -n "`echo true 1&gt;&amp;2`" ]]     # (no output)
# No, that's not it.

# Apparently &amp;&amp; and || "short-circuit" while -a and -o do not.</programlisting>
	   </para>
           </caution>

       <para>Refer to <xref linkend="andor" />, <xref linkend="twodim" />,
	 and <xref linkend="whx" /> to see compound comparison operators
	 in action.</para>

      </section> <!-- Comparison operators (binary) -->

      <section xml:id="nestedifthen">
        <title>Nested <replaceable>if/then</replaceable> Condition Tests</title>

       <para>Condition tests using the <replaceable>if/then</replaceable>
	 construct may be nested. The net result is equivalent to using the
	 <link linkend="logops1"><firstterm>&amp;&amp;</firstterm></link> compound
	 comparison operator.</para>

       <para><programlisting>a=3

if [ "$a" -gt 0 ]
then
  if [ "$a" -lt 5 ]
  then
    echo "The value of \"a\" lies somewhere between 0 and 5."
  fi
fi

# Same result as:

if [ "$a" -gt 0 ] &amp;&amp; [ "$a" -lt 5 ]
then
  echo "The value of \"a\" lies somewhere between 0 and 5."
fi</programlisting></para>

       <para><xref linkend="cards" /> and <xref linkend="backlight" />
         demonstrate nested <replaceable>if/then</replaceable> condition
         tests.</para>

      </section> <!-- Nested if/then Tests -->

      <section xml:id="testtest">
        <title>Testing Your Knowledge of Tests</title>

      <para>The systemwide <filename>xinitrc</filename> file can be used
	to launch the X server. This file contains quite a number
	of <firstterm>if/then</firstterm> tests. The following
	is excerpted from an <quote>ancient</quote> version of
	<filename>xinitrc</filename> (<firstterm>Red Hat 7.1</firstterm>,
	or thereabouts).</para>

      <para><programlisting>if [ -f $HOME/.Xclients ]; then
  exec $HOME/.Xclients
elif [ -f /etc/X11/xinit/Xclients ]; then
  exec /etc/X11/xinit/Xclients
else
     # failsafe settings.  Although we should never get here
     # (we provide fallbacks in Xclients as well) it can't hurt.
     xclock -geometry 100x100-5+5 &amp;
     xterm -geometry 80x50-50+150 &amp;
     if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
             netscape /usr/share/doc/HTML/index.html &amp;
     fi
fi</programlisting></para>     

     <para>Explain the <firstterm>test</firstterm> constructs in the
       above snippet, then examine an updated version of the
       file, <filename>/etc/X11/xinit/xinitrc</filename>, and
       analyze the <firstterm>if/then</firstterm> test constructs
       there. You may need to refer ahead to the discussions of <link linkend="grepref">grep</link>, <link linkend="sedref">sed</link>,
       and <link linkend="regexref">regular expressions</link>.</para>


      </section> <!-- Testing Your Knowledge of Tests -->

  </chapter> <!-- Tests -->



  <chapter xml:id="operations">
    <title>Operations and Related Topics</title>


     <section xml:id="ops">
      <title>Operators</title>

      <variablelist xml:id="asnop">
        <title><anchor xml:id="asnop1" />assignment</title>

	<varlistentry>
	  <term><replaceable>variable assignment</replaceable></term>
	  <listitem><para>Initializing or changing the value of a variable</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>=</term>
	  <listitem>
	    <indexterm>
	      <primary>=</primary>
	    </indexterm>
	    <indexterm>
	      <primary>operation</primary>
	      <secondary>=</secondary>
	    </indexterm>
	    <para>All-purpose assignment operator, which works for both
	      arithmetic and string assignments.</para>

	    <para>
	      <programlisting>var=27
category=minerals  # No spaces allowed after the "=".</programlisting>
	    </para>

            <caution>
	    <para>Do not confuse the <quote>=</quote> assignment
	      operator with the <link linkend="equalsignref">= test
	      operator</link>.</para>

	    <para>
	      <programlisting>#   =  as a test operator

if [ "$string1" = "$string2" ]
then
   command
fi

#  if [ "X$string1" = "X$string2" ] is safer,
#+ to prevent an error message should one of the variables be empty.
#  (The prepended "X" characters cancel out.)</programlisting>
	    </para>
	    </caution>


	  </listitem>
	</varlistentry>
      </variablelist>

	<indexterm>
	  <primary>expr</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>expr</secondary>
	</indexterm>
	<indexterm>
	  <primary>let</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>let</secondary>
	</indexterm>


      <variablelist xml:id="arops">
        <title><anchor xml:id="arops1" />arithmetic operators</title>

	<varlistentry>
	  <term><token>+</token></term>
	  <listitem>
	  <indexterm>
	    <primary>+</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>addition</primary>
	  </indexterm>
	  <indexterm>
	    <primary>plus</primary>
	  </indexterm>
            <para>plus</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <listitem>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>subtraction</primary>
	  </indexterm>
	  <indexterm>
	    <primary>minus</primary>
	  </indexterm>
	    <para>minus</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*</token></term>
	  <listitem>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>multiplication</primary>
	  </indexterm>
	    <para>multiplication</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <listitem>
	  <indexterm>
	    <primary>/</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>division</primary>
	  </indexterm>
	    <para>division</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="exponentiationref" /><token>**</token></term>
	  <listitem>
	  <indexterm>
	    <primary>**</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>**</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exponentiation</primary>
	  </indexterm>

	  <para>exponentiation</para>

	  <para>
	    <programlisting># Bash, version 2.02, introduced the "**" exponentiation operator.

let "z=5**3"    # 5 * 5 * 5
echo "z = $z"   # z = 125</programlisting>
          </para>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="moduloref" /><token>%</token></term>
	  <listitem>
	  <indexterm>
	    <primary>%</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>modulo</primary>
	  </indexterm>

	  <para>modulo, or mod (returns the
	    <firstterm>remainder</firstterm> of an integer division
	    operation)</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>expr 5 % 3</userinput>
<computeroutput>2</computeroutput>
	      </screen>
	      <emphasis>5/3 = 1, with remainder 2</emphasis>
	    </para>

	  <para>This operator finds use in, among other things,
	    generating numbers within a specific range (see <xref linkend="ex21" /> and <xref linkend="randomtest" />) and
	    formatting program output (see <xref linkend="qfunction" /> and
	    <xref linkend="collatz" />). It can even be used to generate
	    prime numbers, (see <xref linkend="primes" />). Modulo turns
	    up surprisingly often in numerical recipes.</para>

	    <example xml:id="gcd">
	      <title>Greatest common divisor</title>
	      <programlisting>#!/bin/bash
# gcd.sh: greatest common divisor
#         Uses Euclid's algorithm

#  The "greatest common divisor" (gcd) of two integers
#+ is the largest integer that will divide both, leaving no remainder.

#  Euclid's algorithm uses successive division.
#    In each pass,
#+      dividend &lt;---  divisor
#+      divisor  &lt;---  remainder
#+   until remainder = 0.
#    The gcd = dividend, on the final pass.
#
#  For an excellent discussion of Euclid's algorithm, see
#+ Jim Loy's site, http://www.jimloy.com/number/euclids.htm.


# ------------------------------------------------------
# Argument check
ARGS=2
E_BADARGS=85

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` first-number second-number"
  exit $E_BADARGS
fi
# ------------------------------------------------------


gcd ()
{

  dividend=$1             #  Arbitrary assignment.
  divisor=$2              #! It doesn't matter which of the two is larger.
                          #  Why not?

  remainder=1             #  If an uninitialized variable is used inside
                          #+ test brackets, an error message results.

  until [ "$remainder" -eq 0 ]
  do    #  ^^^^^^^^^^  Must be previously initialized!
    let "remainder = $dividend % $divisor"
    dividend=$divisor     # Now repeat with 2 smallest numbers.
    divisor=$remainder
  done                    # Euclid's algorithm

}                         # Last $dividend is the gcd.


gcd $1 $2

echo; echo "GCD of $1 and $2 = $dividend"; echo


# Exercises :
# ---------
# 1) Check command-line arguments to make sure they are integers,
#+   and exit the script with an appropriate error message if not.
# 2) Rewrite the gcd () function to use local variables.

exit 0
</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="arithopscomb" /><token>+=</token></term>
	  <listitem>
	  <indexterm>
	    <primary>+=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>plus-equal</primary>
	  </indexterm>
            <para><firstterm>plus-equal</firstterm> (increment variable
            by a constant)

            <footnote><para>In a different context, <command>+=</command> can
              serve as a <firstterm>string concatenation</firstterm>
              operator. This can be useful for <link linkend="pathappend">modifying <firstterm>environmental
              variables</firstterm></link>.</para></footnote>

	    </para>

	    <para><userinput>let "var += 5"</userinput> results in
	      <parameter>var</parameter> being incremented by
	      <literal>5</literal>.</para>
            
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-=</token></term>
	  <listitem>
	  <indexterm>
	    <primary>-=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>minus-equal</primary>
	  </indexterm>
            <para><firstterm>minus-equal</firstterm> (decrement
	    variable by a constant)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*=</token></term>
	  <listitem>
	  <indexterm>
	    <primary>*=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>times-equal</primary>
	  </indexterm>
	    <para><firstterm>times-equal</firstterm> (multiply
	    variable by a constant)</para>
	    <para><userinput>let "var *= 4"</userinput> results in <parameter>var</parameter>
	    being multiplied by <literal>4</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/=</token></term>
	  <listitem>
	  <indexterm>
	    <primary>/=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slash-equal</primary>
	  </indexterm>
	    <para><firstterm>slash-equal</firstterm> (divide
	    variable by a constant)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%=</token></term>
	  <listitem>
	  <indexterm>
	    <primary>%=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>mod-equal</primary>
	  </indexterm>
	    <para><firstterm>mod-equal</firstterm>
	    (<firstterm>remainder</firstterm>
	    of dividing variable by a constant)</para>

      <para><emphasis>Arithmetic operators often occur in an
        <link linkend="exprref">expr</link> or <link linkend="letref">let</link> expression.</emphasis></para>

	    <example xml:id="arithops">
	      <title>Using Arithmetic Operations</title>
	      <programlisting>#!/bin/bash
# Counting to 11 in 10 different ways.

n=1; echo -n "$n "

let "n = $n + 1"   # let "n = n + 1"  also works.
echo -n "$n "


: $((n = $n + 1))
#  ":" necessary because otherwise Bash attempts
#+ to interpret "$((n = $n + 1))" as a command.
echo -n "$n "

(( n = n + 1 ))
#  A simpler alternative to the method above.
#  Thanks, David Lombard, for pointing this out.
echo -n "$n "

n=$(($n + 1))
echo -n "$n "

: $[ n = $n + 1 ]
#  ":" necessary because otherwise Bash attempts
#+ to interpret "$[ n = $n + 1 ]" as a command.
#  Works even if "n" was initialized as a string.
echo -n "$n "

n=$[ $n + 1 ]
#  Works even if "n" was initialized as a string.
#* Avoid this type of construct, since it is obsolete and nonportable.
#  Thanks, Stephane Chazelas.
echo -n "$n "

# Now for C-style increment operators.
# Thanks, Frank Wang, for pointing this out.

let "n++"          # let "++n"  also works.
echo -n "$n "

(( n++ ))          # (( ++n ))  also works.
echo -n "$n "

: $(( n++ ))       # : $(( ++n )) also works.
echo -n "$n "

: $[ n++ ]         # : $[ ++n ] also works
echo -n "$n "

echo

exit 0
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>

      <para><anchor xml:id="intvarref" /></para>
      <note>
      <para>Integer variables in older versions of Bash were signed
	<firstterm>long</firstterm> (32-bit) integers, in the range of
	-2147483648 to 2147483647. An operation that took a variable
	outside these limits gave an erroneous result.</para>

      <para>
	  <programlisting>echo $BASH_VERSION   # 1.14

a=2147483646
echo "a = $a"        # a = 2147483646
let "a+=1"           # Increment "a".
echo "a = $a"        # a = 2147483647
let "a+=1"           # increment "a" again, past the limit.
echo "a = $a"        # a = -2147483648
                     #      ERROR: out of range,
                     # +    and the leftmost bit, the sign bit,
                     # +    has been set, making the result negative.</programlisting>
	</para>
	
	<para>As of version &gt;= 2.05b, Bash supports 64-bit integers.</para>
	</note>

      <caution>
      
      <para><anchor xml:id="nofloatingpoint" /></para>
      <para>Bash does not understand floating point arithmetic. It
        treats numbers containing a decimal point as strings.</para>

      <para>
        <programlisting>a=1.5

let "b = $a + 1.3"  # Error.
# t2.sh: let: b = 1.5 + 1.3: syntax error in expression
#                            (error token is ".5 + 1.3")

echo "b = $b"       # b=1</programlisting>
      </para>

      <para>Use <link linkend="bcref">bc</link> in scripts that need floating
	point calculations or math library functions.</para></caution>



      <formalpara><title>bitwise operators</title>
      <para>The bitwise operators seldom make an appearance in shell scripts.
	Their chief use seems to be manipulating and testing values read
	from ports or <link linkend="socketref">sockets</link>. <quote>Bit
	flipping</quote> is more relevant to compiled languages, such
	as C and C++, which provide direct access to system
	hardware. However, see <emphasis>vladz's</emphasis>
	ingenious use of bitwise operators in his
	<firstterm>base64.sh</firstterm> (<xref linkend="base64" />)
	script. </para></formalpara>

      <variablelist xml:id="bitwsops">
        <title><anchor xml:id="bitwsops1" />bitwise operators</title>

	<varlistentry>
	  <term><token>&lt;&lt;</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&lt;&lt;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&lt;&lt;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left shift</primary>
	  </indexterm>
	    <para>bitwise left shift (multiplies by <literal>2</literal>
	      for each shift position)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&lt;&lt;=</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&lt;&lt;=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&lt;&lt;=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left-shift-equal</primary>
	  </indexterm>
          
            <para><firstterm>left-shift-equal</firstterm></para>
	    <para><userinput>let "var &lt;&lt;= 2"</userinput> results in <parameter>var</parameter>
	    left-shifted <literal>2</literal> bits (multiplied by <literal>4</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&gt;&gt;</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&gt;&gt;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&gt;&gt;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right shift</primary>
	  </indexterm>
	    <para>bitwise right shift (divides by <literal>2</literal>
	      for each shift position)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&gt;&gt;=</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&gt;&gt;=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&gt;&gt;=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right-shift-equal</primary>
	  </indexterm>
	    <para><firstterm>right-shift-equal</firstterm>
	    (inverse of <token>&lt;&lt;=</token>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&amp;</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&amp;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&amp;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	    <para>bitwise AND</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&amp;=</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&amp;=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&amp;=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>and-equal</primary>
	  </indexterm>
	    <para>bitwise <firstterm>AND-equal</firstterm></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	    <para>bitwise OR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|=</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>|=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR-equal</primary>
	  </indexterm>
	    <para>bitwise <firstterm>OR-equal</firstterm></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>~</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>~</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>negate</primary>
	  </indexterm>
	    <para>bitwise NOT</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>^</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR</primary>
	  </indexterm>
	    <para>bitwise XOR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^=</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>^=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR-equal</primary>
	  </indexterm>
	    <para>bitwise <firstterm>XOR-equal</firstterm></para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist xml:id="logops">
        <title><anchor xml:id="logops1" />logical (boolean) operators</title>

	<varlistentry>
	  <term><token>!</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operator</primary>
	    <secondary>!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>NOT</primary>
	  </indexterm>
	    <para>NOT</para>
           <para><programlisting>if [ ! -f $FILENAME ]
then
  ...</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&amp;&amp;</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>&amp;&amp;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operator</primary>
	    <secondary>&amp;&amp;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	    <para>AND</para>
	    <para><programlisting>if [ $condition1 ] &amp;&amp; [ $condition2 ]
#  Same as:  if [ $condition1 -a $condition2 ]
#  Returns true if both condition1 and condition2 hold true...

if [[ $condition1 &amp;&amp; $condition2 ]]    # Also works.
#  Note that &amp;&amp; operator not permitted <emphasis>inside brackets</emphasis>
#+ of [ ... ] construct.</programlisting></para>

	  <note><para><token>&amp;&amp;</token> may also be used, depending on context,
	    in an <link linkend="listconsref">and list</link>
	    to concatenate commands.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="orref" /><token>||</token></term>
	  <listitem> 
	  <indexterm>
	    <primary>||</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operator</primary>
	    <secondary>||</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	    <para>OR</para>
	    <para><programlisting>if [ $condition1 ] || [ $condition2 ]
# Same as:  if [ $condition1 -o $condition2 ]
# Returns true if either condition1 or condition2 holds true...

if [[ $condition1 || $condition2 ]]    # Also works.
#  Note that || operator not permitted <emphasis>inside brackets</emphasis>
#+ of a [ ... ] construct.</programlisting></para>

	  <note><para>Bash tests the <link linkend="exitstatusref">exit
	    status</link> of each statement linked with a logical
	    operator.</para></note>

	<example xml:id="andor">
	  <title>Compound Condition Tests Using &amp;&amp; and ||</title>
       	    <programlisting>#!/bin/bash

a=24
b=47

if [ "$a" -eq 24 ] &amp;&amp; [ "$b" -eq 47 ]
then
  echo "Test #1 succeeds."
else
  echo "Test #1 fails."
fi

# ERROR:   if [ "$a" -eq 24 &amp;&amp; "$b" -eq 47 ]
#+         attempts to execute  ' [ "$a" -eq 24 '
#+         and fails to finding matching ']'.
#
#  Note:  if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]]  works.
#  The double-bracket if-test is more flexible
#+ than the single-bracket version.       
#    (The "&amp;&amp;" has a different meaning in line 17 than in line 6.)
#    Thanks, Stephane Chazelas, for pointing this out.


if [ "$a" -eq 98 ] || [ "$b" -eq 47 ]
then
  echo "Test #2 succeeds."
else
  echo "Test #2 fails."
fi


#  The -a and -o options provide
#+ an alternative compound condition test.
#  Thanks to Patrick Callahan for pointing this out.


if [ "$a" -eq 24 -a "$b" -eq 47 ]
then
  echo "Test #3 succeeds."
else
  echo "Test #3 fails."
fi


if [ "$a" -eq 98 -o "$b" -eq 47 ]
then
  echo "Test #4 succeeds."
else
  echo "Test #4 fails."
fi


a=rhino
b=crocodile
if [ "$a" = rhino ] &amp;&amp; [ "$b" = crocodile ]
then
  echo "Test #5 succeeds."
else
  echo "Test #5 fails."
fi

exit 0
</programlisting>
	 </example>   

	    <para>The <token>&amp;&amp;</token> and <token>||</token> operators also
	      find use in an arithmetic context.</para>
	      
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))</userinput>
<computeroutput>1 0 1 0</computeroutput>
	      </screen>
	    </para>
	      
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="miscop">
        <title><anchor xml:id="miscop1" />miscellaneous operators</title>

	<varlistentry>
	  <term><anchor id="commaop" /><token>,</token></term>
	  <listitem>
	  <indexterm>
	    <primary>,</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>,</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>linking</primary>
	  </indexterm>

	    <para>Comma operator</para>
	    <para>The <command>comma operator</command> chains together
	      two or more arithmetic operations. All the operations are
	      evaluated (with possible <firstterm>side
	      effects</firstterm>.
	        <footnote><para><firstterm>Side effects</firstterm>
		are, of course, unintended -- and usually undesirable --
		consequences.</para></footnote>
             </para>

	     <para>
	     <programlisting>let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
echo "t1 = $t1"           ^^^^^^  # t1 = 11
# Here t1 is set to the result of the last operation. Why?

let "t2 = ((a = 9, 15 / 3))"      # Set "a" and calculate "t2".
echo "t2 = $t2    a = $a"         # t2 = 5    a = 9</programlisting>
	     </para>

	     <para>The comma operator finds use mainly in <link linkend="forloopref1">for loops</link>. See <xref linkend="forloopc" />.</para>

	  </listitem>

	</varlistentry>
      </variablelist>

    </section> <!-- Operators -->

    <section xml:id="Numerical-Constants">
      <title>Numerical Constants</title>

      <para><anchor xml:id="numconstants" />A shell script interprets a number
	as decimal (base 10), unless that number has a
	special prefix or notation. A number preceded by a
	<replaceable>0</replaceable> is <replaceable>octal</replaceable>
	(base 8). A number preceded by <replaceable>0x</replaceable>
	is <replaceable>hexadecimal</replaceable> (base 16). A number
	with an embedded <replaceable>#</replaceable> evaluates as
	<replaceable>BASE#NUMBER</replaceable> (with range and notational
	restrictions).</para>

	    <example xml:id="numbers">
	      <title>Representation of numerical constants</title>
	      <programlisting>#!/bin/bash
# numbers.sh: Representation of numbers in different bases.

# Decimal: the default
let "dec = 32"
echo "decimal number = $dec"             # 32
# Nothing out of the ordinary here.


# Octal: numbers preceded by '0' (zero)
let "oct = 032"
echo "octal number = $oct"               # 26
# Expresses result in decimal.
# --------- ------ -- -------


# Hexadecimal: numbers preceded by '0x' or '0X'
let "hex = 0x32"
echo "hexadecimal number = $hex"         # 50

echo $((0x9abc))                         # 39612
#     ^^      ^^   double-parentheses arithmetic expansion/evaluation
# Expresses result in decimal.



# Other bases: BASE#NUMBER
# BASE between 2 and 64.
# NUMBER must use symbols within the BASE range, see below.


let "bin = 2#111100111001101"
echo "binary number = $bin"              # 31181

let "b32 = 32#77"
echo "base-32 number = $b32"             # 231

let "b64 = 64#@_"
echo "base-64 number = $b64"             # 4031
# This notation only works for a limited range (2 - 64) of ASCII characters.
# 10 digits + 26 lowercase characters + 26 uppercase characters + @ + _


echo

echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
                                         # 1295 170 44822 3375


#  Important note:
#  --------------
#  Using a digit out of range of the specified base notation
#+ gives an error message.

let "bad_oct = 081"
# (Partial) error message output:
#  bad_oct = 081: value too great for base (error token is "081")
#              Octal numbers use only digits in the range 0 - 7.

exit $?   # Exit value = 1 (error)

# Thanks, Rich Bartell and Stephane Chazelas, for clarification.
</programlisting>
	    </example>

    </section> <!-- Numerical-Constants -->

      <section xml:id="dblparens">
        <title>The Double-Parentheses Construct</title>

	<para><anchor xml:id="dblparensref" /></para>

	<para>Similar to the <link linkend="letref">let</link> command,
	  the <command>(( ... ))</command> construct permits
	  arithmetic expansion and evaluation. In its simplest
	  form, <userinput>a=$(( 5 + 3 ))</userinput> would set
	  <userinput>a</userinput> to <userinput>5 + 3</userinput>, or
	  <userinput>8</userinput>. However, this double-parentheses
	  construct is also a mechanism for allowing C-style
	  manipulation of variables in Bash, for example,
	  <varname>(( var++ ))</varname>.</para>

        <para><anchor xml:id="plusplusref" /></para>

      <example xml:id="cvars">
	<title>C-style manipulation of variables</title>
	<programlisting>#!/bin/bash
# c-vars.sh
# Manipulating a variable, C-style, using the (( ... )) construct.


echo

(( a = 23 ))  #  Setting a value, C-style,
              #+ with spaces on both sides of the "=".
echo "a (initial value) = $a"   # 23

(( a++ ))     #  Post-increment 'a', C-style.
echo "a (after a++) = $a"       # 24

(( a-- ))     #  Post-decrement 'a', C-style.
echo "a (after a--) = $a"       # 23


(( ++a ))     #  Pre-increment 'a', C-style.
echo "a (after ++a) = $a"       # 24

(( --a ))     #  Pre-decrement 'a', C-style.
echo "a (after --a) = $a"       # 23

echo

########################################################
#  Note that, as in C, pre- and post-decrement operators
#+ have different side-effects.

n=1; let --n &amp;&amp; echo "True" || echo "False"  # False
n=1; let n-- &amp;&amp; echo "True" || echo "False"  # True

#  Thanks, Jeroen Domburg.
########################################################

echo

(( t = a&lt;45?7:11 ))   # C-style trinary operator.
#       ^  ^ ^
echo "If a &lt; 45, then t = 7, else t = 11."  # a = 23
echo "t = $t "                              # t = 7

echo


# -----------------
# Easter Egg alert!
# -----------------
#  Chet Ramey seems to have snuck a bunch of undocumented C-style
#+ constructs into Bash (actually adapted from ksh, pretty much).
#  In the Bash docs, Ramey calls (( ... )) shell arithmetic,
#+ but it goes far beyond that.
#  Sorry, Chet, the secret is out.

# See also "for" and "while" loops using the (( ... )) construct.

# These work only with version 2.04 or later of Bash.

exit
</programlisting>
      </example>

        <para>See also <xref linkend="forloopc" /> and <xref linkend="numbers" />.</para>

      </section> <!-- The Double-Parentheses Construct  -->

    <section xml:id="opprecedence">
      <title>Operator Precedence</title>

      <para><anchor xml:id="opprecedence1" /></para>

      <para>
        In a script, operations execute in order of
        <firstterm>precedence</firstterm>: the higher precedence operations
	execute <emphasis>before</emphasis> the lower precedence ones.
	  <footnote><para><firstterm>Precedence</firstterm>, in this context,
	    has approximately the same meaning as
	    <firstterm>priority</firstterm></para></footnote>
      </para>

             <table>
	<title>Operator Precedence</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Operator</entry>
	      <entry>Meaning</entry>
	      <entry>Comments</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option /></entry>
	      <entry />
	      <entry><command>HIGHEST PRECEDENCE</command></entry>
	    </row>
	    <row>
	      <entry><option>var++ var--</option></entry>
	      <entry>post-increment, post-decrement</entry>
	      <entry><link linkend="cstyle">C-style</link> operators</entry>
	    </row>
	    <row>
	      <entry><option>++var --var</option></entry>
	      <entry>pre-increment, pre-decrement</entry>
	      <entry />
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>! ~</option></entry>
	      <entry><link linkend="notref">negation</link></entry>
	      <entry>logical / bitwise, inverts sense of following
	        operator</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>**</option></entry>
	      <entry><link linkend="exponentiationref">exponentiation</link></entry>
	      <entry><link linkend="arops1">arithmetic
	        operation</link></entry>
	    </row>
	    <row>
	      <entry><option>* / %</option></entry>
	      <entry>multiplication, division, modulo</entry>
	      <entry>arithmetic operation</entry>
	    </row>
	    <row>
	      <entry><option>+ -</option></entry>
	      <entry>addition, subtraction</entry>
	      <entry>arithmetic operation</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>&lt;&lt; &gt;&gt;</option></entry>
	      <entry>left, right shift</entry>
	      <entry><link linkend="bitwsops1">bitwise</link></entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>-z -n</option></entry>
	      <entry><firstterm>unary</firstterm> comparison</entry>
	      <entry>string is/is-not <link linkend="stringnull">null</link></entry>
	    </row>
	    <row>
	      <entry><option>-e -f -t -x, etc.</option></entry>
	      <entry><firstterm>unary</firstterm> comparison</entry>
	      <entry><link linkend="fto">file-test</link></entry>
	    </row>
	    <row>
	      <entry><option>&lt; -lt &gt; -gt &lt;= -le &gt;= -ge</option></entry>
	      <entry><firstterm>compound</firstterm> comparison</entry>
	      <entry>string and integer</entry>
	    </row>
	    <row>
	      <entry><option>-nt -ot -ef</option></entry>
	      <entry><firstterm>compound</firstterm> comparison</entry>
	      <entry>file-test</entry>
	    </row>
	    <row>
	      <entry><option>== -eq <link linkend="notequal">!=</link>
	       -ne</option></entry>
	      <entry>equality / inequality</entry>
	      <entry>test operators, string and integer</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>&amp;</option></entry>
	      <entry>AND</entry>
	      <entry>bitwise</entry>
	    </row>
	    <row>
	      <entry><option>^</option></entry>
	      <entry>XOR</entry>
	      <entry><firstterm>exclusive</firstterm> OR, bitwise</entry>
	    </row>
	    <row>
	      <entry><option>|</option></entry>
	      <entry>OR</entry>
	      <entry>bitwise</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>&amp;&amp; -a</option></entry>
	      <entry>AND</entry>
	      <entry><link linkend="logops1">logical</link>,
	        <firstterm>compound</firstterm>
	        comparison</entry>
	    </row>
	    <row>
	      <entry><option>|| -o</option></entry>
	      <entry>OR</entry>
	      <entry>logical, <firstterm>compound</firstterm>
	        comparison</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>?:</option></entry>
	      <entry><link linkend="cstrinary">trinary
	        operator</link></entry>
	      <entry>C-style</entry>
	    </row>
	    <row>
	      <entry><option>=</option></entry>
	      <entry><link linkend="eqref">assignment</link></entry>
	      <entry>(do not confuse with equality
	        <firstterm>test</firstterm>)</entry>
	    </row>
	    <row>
	      <entry><option>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;=</option></entry>
	      <entry><link linkend="arithopscomb">combination
	        assignment</link></entry>
	      <entry>times-equal, divide-equal, mod-equal, etc.</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>,</option></entry>
	      <entry><link linkend="commaop">comma</link></entry>
	      <entry>links a sequence of operations</entry>
	    </row>
	    <row>
	      <entry><option /></entry>
	      <entry />
	      <entry><command>LOWEST PRECEDENCE</command></entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>	


      <para>In practice, all you really need to remember is the
      following:</para>

      <itemizedlist>
	<listitem>
	<para>The <quote>My Dear Aunt Sally</quote> mantra (<emphasis>multiply,
	  divide, add, subtract</emphasis>) for the familiar <link linkend="arops1">arithmetic operations</link>.</para>
	</listitem>
	<listitem>
	<para>The <firstterm>compound</firstterm> logical operators,
	  <command>&amp;&amp;</command>, <command>||</command>, <command>-a</command>,
	  and <command>-o</command> have low precedence.</para>
	</listitem>
	<listitem>
	<para>The order of evaluation of equal-precedence operators is
	  usually <firstterm>left-to-right</firstterm>.</para>
	</listitem>
      </itemizedlist>

	<para>Now, let's utilize our knowledge of operator precedence to
	  analyze a couple of lines from the
	  <filename>/etc/init.d/functions file</filename>, as found in
	  the <firstterm>Fedora Core</firstterm> Linux distro.</para>

	<para><programlisting>while [ -n "$remaining" -a "$retry" -gt 0 ]; do

# This looks rather daunting at first glance.


# Separate the conditions:
while [ -n "$remaining" -a "$retry" -gt 0 ]; do
#       --condition 1-- ^^ --condition 2-

#  If variable "$remaining" is not zero length
#+      AND (-a)
#+ variable "$retry" is greater-than zero
#+ then
#+ the [ expresion-within-condition-brackets ] returns success (0)
#+ and the while-loop executes an iteration.
#  ==============================================================
#  Evaluate "condition 1" and "condition 2" ***before***
#+ ANDing them. Why? Because the AND (-a) has a lower precedence
#+ than the -n and -gt operators,
#+ and therefore gets evaluated *last*.

#################################################################

if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then


# Again, separate the conditions:
if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then
#    --condition 1--------- ^^ --condition 2-----

#  If file "/etc/sysconfig/i18n" exists
#+      AND (-a)
#+ variable $NOLOCALE is zero length
#+ then
#+ the [ test-expresion-within-condition-brackets ] returns success (0)
#+ and the commands following execute.
#
#  As before, the AND (-a) gets evaluated *last*
#+ because it has the lowest precedence of the operators within
#+ the test brackets.
#  ==============================================================
#  Note:
#  ${NOLOCALE:-} is a parameter expansion that seems redundant.
#  But, if $NOLOCALE has not been declared, it gets set to *null*,
#+ in effect declaring it.
#  This makes a difference in some contexts.</programlisting></para>

      <tip>
      <para>To avoid confusion or error in a complex sequence of test
        operators, break up the sequence into bracketed sections.
      <programlisting>if [ "$v1" -gt "$v2"  -o  "$v1" -lt "$v2"  -a  -e "$filename" ]
# Unclear what's going on here...

if [[ "$v1" -gt "$v2" ]] || [[ "$v1" -lt "$v2" ]] &amp;&amp; [[ -e "$filename" ]]
# Much better -- the condition tests are grouped in logical sections.</programlisting>
      </para>
      </tip>

      </section> <!-- Operator Precedence -->

  </chapter> <!-- Operations -->

  </part>

<part label="3" xml:id="part3" xmlns="http://docbook.org/ns/docbook">
    <title>Beyond the Basics</title>


  <chapter xml:id="variables2">
      <title>Another Look at Variables</title>

	<para>Used properly, variables can add power and flexibility
	  to scripts. This requires learning their subtleties and
	  nuances.</para>


    <section xml:id="internalvariables">  
      <title>Internal Variables</title>

      <variablelist xml:id="internalvariables1">
	
	<varlistentry>
	  <term><replaceable><link linkend="builtinref">Builtin</link> variables:</replaceable></term>
	  <listitem><para>variables affecting bash script behavior</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="bashvarref" /><varname>$BASH</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$BASH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to bash</primary>
	  </indexterm>

            <para>The path to the <firstterm>Bash</firstterm>
	    binary itself
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH</userinput>
<computeroutput>/bin/bash</computeroutput></screen>
	    </para>
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="bashenvref" /><varname>$BASH_ENV</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$BASH_ENV</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_ENV</secondary>
	  </indexterm>
            <para>An <link linkend="envref">environmental
	  variable</link> pointing to a Bash startup file to be read
	  when a script is invoked</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="bashsubshellref" /><varname>$BASH_SUBSHELL</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$BASH_SUBSHELL</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>subshell</secondary>
	  </indexterm>
	    <para>A variable indicating the <link linkend="subshellsref">subshell</link> level. This is a
	      new addition to Bash, <link linkend="bash3ref">version 3</link>.</para>
	    <para>See <xref linkend="subshell" /> for usage.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="bashpidref" /><varname>$BASHPID</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$BASHPID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>process ID</secondary>
	  </indexterm>
	    <para><firstterm>Process ID</firstterm>
            of the current instance of Bash. This is not the same as the
            <link linkend="proccid">$$</link> variable, but it often
            gives the same result.</para>
	  <para>
		  <screen>
<prompt>bash4$ </prompt><userinput>echo $$</userinput>
<computeroutput>11015</computeroutput>


<prompt>bash4$ </prompt><userinput>echo $BASHPID</userinput>
<computeroutput>11015</computeroutput>


<prompt>bash4$ </prompt><userinput>ps ax | grep bash4</userinput>
<computeroutput>11015 pts/2    R      0:00 bash4</computeroutput>
	      </screen>
	    </para>
	    <para><anchor xml:id="bashpidref2" />But ...</para>
	    <para><programlisting>
#!/bin/bash4

echo "\$\$ outside of subshell = $$"                              # 9602
echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602

echo

( echo "\$\$ inside of subshell = $$"                             # 9602
  echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
  echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
  # Note that $$ returns PID of parent process.
</programlisting></para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><varname>$BASH_VERSINFO[n]</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$BASH_VERSINFO</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>version information</secondary>
	  </indexterm>
	  <para>A 6-element <link linkend="arrayref">array</link>
	    containing version information about the installed release
	    of Bash. This is similar to <varname>$BASH_VERSION</varname>,
	    below, but a bit more detailed.</para>
	  <para>
	  <programlisting># Bash version info:

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done  

# BASH_VERSINFO[0] = 3                      # Major version no.
# BASH_VERSINFO[1] = 00                     # Minor version no.
# BASH_VERSINFO[2] = 14                     # Patch level.
# BASH_VERSINFO[3] = 1                      # Build version.
# BASH_VERSINFO[4] = release                # Release status.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                            # (same as $MACHTYPE).</programlisting>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_VERSION</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$BASH_VERSION</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_VERSION</secondary>
	  </indexterm>
            <para>The version of Bash installed on the system</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>3.2.25(1)-release</computeroutput>
	      </screen>
	    </para>

	  <para>
	      <screen><prompt>tcsh% </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>BASH_VERSION: Undefined variable.</computeroutput>
	      </screen>
	    </para>

	  <para>Checking $BASH_VERSION is a good method of determining which
	    shell is running. <link linkend="shellvarref">$SHELL</link>
	    does not necessarily give the correct answer.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="cdpathref" /><varname>$CDPATH</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$CDPATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$CDPATH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cd path</primary>
	  </indexterm>
	  <indexterm>
	    <primary>cd</primary>
	    <secondary>path</secondary>
	  </indexterm>
            <para>A colon-separated list of search paths
	    available to the <link linkend="cdref">cd</link>
	    command, similar in function to the <link linkend="pathref">$PATH</link> variable for binaries.
            The <varname>$CDPATH</varname> variable may be set in the
	    local <link linkend="bashrc"><filename>~/.bashrc</filename></link>
	    file.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cd bash-doc</userinput>
<computeroutput>bash: cd: bash-doc: No such file or directory</computeroutput>


<prompt>bash$ </prompt><userinput>CDPATH=/usr/share/doc</userinput>
<prompt>bash$ </prompt><userinput>cd bash-doc</userinput>
<computeroutput>/usr/share/doc/bash-doc</computeroutput>


<prompt>bash$ </prompt><userinput>echo $PWD</userinput>
<computeroutput>/usr/share/doc/bash-doc</computeroutput>
	      </screen>
           </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="dirstackref" /><varname>$DIRSTACK</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$DIRSTACK</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$DIRSTACK</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory stack</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>stack</secondary>
	  </indexterm>
            <para>The top value in the directory stack

              <footnote><para><anchor xml:id="stackdefref" />
              A <firstterm>stack register</firstterm>
              is a set of consecutive memory locations, such that
	      the values stored (<firstterm>pushed</firstterm>)
	      are retrieved (<firstterm>popped</firstterm>)
	      in <emphasis>reverse</emphasis> order. The last
	      value stored is the first retrieved. This is
	      sometimes called a <replaceable>LIFO</replaceable>
	      (<firstterm>last-in-first-out</firstterm>) or
	      <firstterm>pushdown</firstterm> stack.</para></footnote>

	    (affected by <link linkend="pushdref">pushd</link> and <link linkend="popdref">popd</link>)</para> <para>This builtin
	    variable corresponds to the <link linkend="dirsd">dirs</link>
	    command, however <command>dirs</command> shows the entire
	    contents of the directory stack.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$EDITOR</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$EDITOR</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EDITOR</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>editor</primary>
	  </indexterm>
	    <para>The default editor invoked by a script, usually
	      <command>vi</command> or <command>emacs</command>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="euidref" /><varname>$EUID</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$EUID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EUID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>effective user ID</primary>
	  </indexterm>
	    <para><quote>effective</quote> user ID number</para>
	    <para>Identification number of whatever identity the
	      current user has assumed, perhaps by means of <link linkend="suref">su</link>.</para>
	    <caution><para>The <varname>$EUID</varname> is not necessarily
	      the same as the <link linkend="uidref">$UID</link>.</para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$FUNCNAME</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$FUNCNAME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>function</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>name</primary>
	  </indexterm>
	    <para>Name of the current function</para>
	    <para><programlisting>xyz23 ()
{
  echo "$FUNCNAME now executing."  # xyz23 now executing.
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # Null value outside a function.</programlisting>
            </para>

            <para>See also <xref linkend="usegetopt" />.</para>

	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><varname>$GLOBIGNORE</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$GLOBIGNORE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>globbing</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ignore</primary>
	  </indexterm>
            <para>A list of filename patterns to be excluded from
	    matching in <link linkend="globbingref">globbing</link>.</para>
	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><anchor id="groupsref" /><varname>$GROUPS</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$GROUPS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$GROUPS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>groups</primary>
	  </indexterm>
	    <para>Groups current user belongs to</para>
	    <para>This is a listing (array) of the group id numbers for
	      current user, as  recorded in
	      <link linkend="datafilesref1"><filename>/etc/passwd</filename></link>
	      and <filename>/etc/group</filename>.
	    </para>

	    <para>
	      <screen>
<prompt>root# </prompt><userinput>echo $GROUPS</userinput>
<computeroutput>0</computeroutput>


<prompt>root# </prompt><userinput>echo ${GROUPS[1]}</userinput>
<computeroutput>1</computeroutput>


<prompt>root# </prompt><userinput>echo ${GROUPS[5]}</userinput>
<computeroutput>6</computeroutput>
	      </screen>
	      </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="homedirref" /><varname>$HOME</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$HOME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>home directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>home</secondary>
	  </indexterm>
	    <para>Home directory of the user, usually <filename class="directory">/home/username</filename> (see <xref linkend="ex6" />)</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="hostnameref" /><varname>$HOSTNAME</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$HOSTNAME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOSTNAME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>system name</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>name</secondary>
	  </indexterm>
	  <para>The <link linkend="hnameref">hostname</link> command
	    assigns the system host name at bootup in an init script.
	    However, the <function>gethostname()</function> function
	    sets the Bash internal variable <varname>$HOSTNAME</varname>.
	    See also <xref linkend="ex6" />.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$HOSTTYPE</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$HOSTTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOSTTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>host type</primary>
	  </indexterm>
	    <para>host type</para>
	    <para>Like <link linkend="machtyperef">$MACHTYPE</link>,
	      identifies the system hardware.</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $HOSTTYPE</userinput>
<computeroutput>i686</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ifsref" /><varname>$IFS</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$IFS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IFS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>internal field separator</primary>
	  </indexterm>
	    <para>internal field separator</para>

            <para>This variable determines how Bash recognizes <link linkend="fieldref">fields</link>, or word boundaries,
	      when it interprets character strings.</para>

	    <para><anchor xml:id="ifsws" /></para>
	    <para>$IFS defaults to <link linkend="whitespaceref">whitespace</link> (space,
	      tab, and newline), but may be changed, for example,
	      to parse a comma-separated data file. Note that
	      <link linkend="appref">$*</link> uses the first
	      character held in <varname>$IFS</varname>. See <xref linkend="weirdvars" />.</para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo "$IFS"</userinput>
<computeroutput>

</computeroutput>
<computeroutput>(With $IFS set to default, a blank line displays.)</computeroutput>
	      


<prompt>bash$ </prompt><userinput>echo "$IFS" | cat -vte</userinput>
<computeroutput> ^I$
 $</computeroutput>
<computeroutput>(Show whitespace: here a single space, ^I [horizontal tab],
  and newline, and display "$" at end-of-line.)</computeroutput>



<prompt>bash$ </prompt><userinput>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</userinput>
<computeroutput>w:x:y:z</computeroutput>
<computeroutput>(Read commands from string and assign any arguments to pos params.)</computeroutput>
	      </screen>
	  </para>

	  <para>Set <varname>$IFS</varname> to eliminate whitespace
		  in <link linkend="pathnameref">pathnames</link>.
<programlisting>IFS="$(printf '\n\t')"   # Per David Wheeler.</programlisting>
	  </para>

	  <caution><para><varname>$IFS</varname> does not handle whitespace
	    the same as it does other characters.

	  <example xml:id="ifsh">
	    <title>$IFS and whitespace</title>
	    <programlisting>#!/bin/bash
# ifs.sh


var1="a+b+c"
var2="d-e-f"
var3="g,h,i"

IFS=+
# The plus sign will be interpreted as a separator.
echo $var1     # a b c
echo $var2     # d-e-f
echo $var3     # g,h,i

echo

IFS="-"
# The plus sign reverts to default interpretation.
# The minus sign will be interpreted as a separator.
echo $var1     # a+b+c
echo $var2     # d e f
echo $var3     # g,h,i

echo

IFS=","
# The comma will be interpreted as a separator.
# The minus sign reverts to default interpretation.
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g h i

echo

IFS=" "
# The space character will be interpreted as a separator.
# The comma reverts to default interpretation.
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g,h,i

# ======================================================== #

# However ...
# $IFS treats whitespace differently than other characters.

output_args_one_per_line()
{
  for arg
  do
    echo "[$arg]"
  done #  ^    ^   Embed within brackets, for your viewing pleasure.
}

echo; echo "IFS=\" \""
echo "-------"

IFS=" "
var=" a  b c   "
#    ^ ^^   ^^^
output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
# [a]
# [b]
# [c]


echo; echo "IFS=:"
echo "-----"

IFS=:
var=":a::b:c:::"               # Same pattern as above,
#    ^ ^^   ^^^                #+ but substituting ":" for " "  ...
output_args_one_per_line $var
# []
# [a]
# []
# [b]
# [c]
# []
# []

# Note "empty" brackets.
# The same thing happens with the "FS" field separator in awk.


echo

exit
</programlisting>
	  </example>

	  </para></caution>

	  <para>(Many thanks, St√©phane Chazelas, for clarification
	  and above examples.)</para>

	   <para>See also <xref linkend="isspammer" />, <xref linkend="bingrep" />, and <xref linkend="mailboxgrep" />
             for instructive examples of using
             <varname>$IFS</varname>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$IGNOREEOF</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$IGNOREEOF</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IGNOREEOF</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Ignore EOF</primary>
	  </indexterm>
            <para>Ignore EOF: how many end-of-files (control-D)
	    the shell will ignore before logging out.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$LC_COLLATE</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$LC_COLLATE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$LC_COLLATE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lowercase collate</primary>
	  </indexterm>

	  <para>Often set in the <link linkend="sample-bashrc"><filename>.bashrc</filename></link>
	    or <filename>/etc/profile</filename> files, this
	    variable controls collation order in filename
	    expansion and pattern matching. If mishandled,
	    <varname>LC_COLLATE</varname> can cause unexpected results in
	    <link linkend="globbingref">filename globbing</link>.</para>

	  <note><para>As of version 2.05 of Bash,
	    filename globbing no longer distinguishes between lowercase
	    and uppercase letters in a character range between
	    brackets. For example, <command>ls [A-M]*</command>
	    would match both <filename>File1.txt</filename>
	    and <filename>file1.txt</filename>. To revert to
	    the customary behavior of bracket matching, set
	    <varname>LC_COLLATE</varname> to <option>C</option>
	    by an <userinput>export LC_COLLATE=C</userinput>
	    in <filename>/etc/profile</filename> and/or
	    <filename>~/.bashrc</filename>.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$LC_CTYPE</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$LC_CTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$LC_CTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lowercase character type</primary>
	  </indexterm>

	  <para>This internal variable controls character interpretation
	    in <link linkend="globbingref">globbing</link> and pattern
	    matching.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="linenoref" /><varname>$LINENO</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$LINENO</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$LINENO</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>line number</primary>
	  </indexterm>
            <para>This variable is the line number of the shell
	    script in which this variable appears. It has significance only
	    within the script in which it appears, and is chiefly useful for
	    debugging purposes.</para>
	  <para><programlisting># *** BEGIN DEBUG BLOCK ***
last_cmd_arg=$_  # Save it.

echo "At line number $LINENO, variable \"v1\" = $v1"
echo "Last command argument processed = $last_cmd_arg"
# *** END DEBUG BLOCK ***</programlisting></para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="machtyperef" /><varname>$MACHTYPE</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$MACHTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$MACHTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>machine type</primary>
	  </indexterm>
            <para>machine type</para>
	    <para>Identifies the system hardware.</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $MACHTYPE</userinput>
<computeroutput>i686</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="oldpwd" /><varname>$OLDPWD</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$OLDPWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OLDPWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>previous working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
            <para>Old working directory
	  (<quote>OLD-Print-Working-Directory</quote>,
	    previous directory you were in).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$OSTYPE</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$OSTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OSTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>os type</primary>
	  </indexterm>
	    <para>operating system type</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $OSTYPE</userinput>
<computeroutput>linux</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="pathref" /><varname>$PATH</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to binaries</primary>
	  </indexterm>
	    <para>Path to binaries, usually 
	      <filename class="directory">/usr/bin/</filename>, 
	      <filename class="directory">/usr/X11R6/bin/</filename>, 
	      <filename class="directory">/usr/local/bin</filename>, etc.</para>

	    <para>When given a command, the shell automatically does
	      a hash table search on the directories listed in the
	      <firstterm>path</firstterm> for the executable. The path
	      is stored in the <link linkend="envref">environmental
	      variable</link>, <varname>$PATH</varname>, a list
	      of directories, separated by colons. Normally,
	      the system stores the <varname>$PATH</varname>
	      definition in <filename>/etc/profile</filename>
	      and/or <link linkend="sample-bashrc"><filename>~/.bashrc</filename></link>
	      (see <xref linkend="files" />).</para>

	      <para><screen><prompt>bash$ </prompt><command>echo $PATH</command>
<computeroutput>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</computeroutput></screen>
              </para>

	    <para><userinput>PATH=${PATH}:/opt/bin</userinput> appends
	      the <filename class="directory">/opt/bin</filename>
	      directory to the current path. In a script, it may be
	      expedient to temporarily add a directory to the path
	      in this way. When the script exits, this restores the
	      original <varname>$PATH</varname> (a child process, such
	      as a script, may not change the environment of the parent
	      process, the shell).</para>

	    <para><anchor xml:id="currentwdref" /></para>
	    <note><para>The current <quote>working directory</quote>, 
	      <filename class="directory">./</filename>, is usually
	      omitted from the <varname>$PATH</varname> as a security
	      measure.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="pipestatusref" /><varname>$PIPESTATUS</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PIPESTATUS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>pipe</secondary>
	  </indexterm>
	  <para><link linkend="arrayref">Array</link> variable holding
            <link linkend="exitstatusref">exit status</link>(es) of
	    last executed <firstterm>foreground</firstterm> <link linkend="piperef">pipe</link>.</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo $PIPESTATUS</userinput>
<computeroutput>0</computeroutput>

<prompt>bash$ </prompt><userinput>ls -al | bogus_command</userinput>
<computeroutput>bash: bogus_command: command not found</computeroutput>
<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[1]}</userinput>
<computeroutput>127</computeroutput>

<prompt>bash$ </prompt><userinput>ls -al | bogus_command</userinput>
<computeroutput>bash: bogus_command: command not found</computeroutput>
<prompt>bash$ </prompt><userinput>echo $?</userinput>
<computeroutput>127</computeroutput>
	      </screen>
	      </para>


	      <para>The members of the <varname>$PIPESTATUS</varname>
		array hold the exit status of each respective command
		executed in a pipe. <varname>$PIPESTATUS[0]</varname>
		holds the exit status of the first command in the pipe,
		<varname>$PIPESTATUS[1]</varname> the exit status of
		the second command, and so on.</para>


	      <caution>
	      <para>
	      The <varname>$PIPESTATUS</varname> variable
              may contain an erroneous <errorcode>0</errorcode> value
              in a login shell (in releases prior to 3.0 of Bash).
              </para>

	      <para>
	      <screen>
<prompt>tcsh% </prompt><userinput>bash</userinput>

<prompt>bash$ </prompt><userinput>who | grep nobody | sort</userinput>
<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[*]}</userinput>
<computeroutput>0</computeroutput>
	      </screen>
	      </para>


	      <para>
	      The above lines contained in a script would produce the expected
	      <computeroutput>0 1 0</computeroutput> output.
              </para>

	      <para>
	      Thank you, Wayne Pollock for pointing this out and supplying the
	      above example.
	      </para>

	      </caution>


	      <note>

	      <para>The <varname>$PIPESTATUS</varname> variable gives
	        unexpected results in some contexts.</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>3.00.14(1)-release</computeroutput>

<prompt>bash$ </prompt><userinput>$ ls | bogus_command | wc</userinput>
<computeroutput>bash: bogus_command: command not found
 0       0       0</computeroutput>

<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[@]}</userinput>
<computeroutput>141 127 0</computeroutput>
	      </screen>
	      </para>

	      <para>Chet Ramey attributes the above output to the behavior of
		<link linkend="lsref">ls</link>. If <firstterm>ls</firstterm>
		writes to a <firstterm>pipe</firstterm> whose output is not
		read, then <replaceable>SIGPIPE</replaceable> kills it,
		and its <link linkend="exitstatusref">exit status</link>
		is <returnvalue>141</returnvalue>. Otherwise
		its exit status is <returnvalue>0</returnvalue>,
		as expected. This likewise is the case for <link linkend="trref">tr</link>.</para>

		</note>

		<note>
		  <para><varname>$PIPESTATUS</varname> is a
		    <quote>volatile</quote> variable. It needs to be
		    captured immediately after the pipe in question, before
		    any other command intervenes.</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>$ ls | bogus_command | wc</userinput>
<computeroutput>bash: bogus_command: command not found
 0       0       0</computeroutput>

<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[@]}</userinput>
<computeroutput>0 127 0</computeroutput>

<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[@]}</userinput>
<computeroutput>0</computeroutput>
	      </screen>
	      </para>
		</note>

		<note>
		  <para>The <link linkend="pipefailref">pipefail option</link>
		    may be useful in cases where
		    <varname>$PIPESTATUS</varname> does not give the desired
		    information.</para>
		</note>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ppidref" /><varname>$PPID</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PPID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PPID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>process ID</primary>
	  </indexterm>
	    <para />
	    <para>The <varname>$PPID</varname> of a process is
	    the process ID (<varname>pid</varname>) of its parent process.

	      <footnote>
	        <para>The PID of the currently running script is
		  <varname>$$</varname>, of course.</para>
              </footnote>
	      </para>

	    <para>Compare this with the <link linkend="pidofref">pidof</link> command.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PROMPT_COMMAND</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PROMPT_COMMAND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>prompt</secondary>
	  </indexterm>
	    <para>A variable holding a command to be executed
	      just before the primary prompt, <varname>$PS1</varname>
	      is to be displayed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ps1ref" /><varname>$PS1</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PS1</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS1</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	  </indexterm>
	    <para>This is the main prompt, seen at the command-line.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="secpromptref" /><varname>$PS2</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PS2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS2</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>secondary</secondary>
	  </indexterm>
	    <para>The secondary prompt, seen when additional input is
	      expected. It displays as <quote>&gt;</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS3</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PS3</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS3</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>tertiary</secondary>
	  </indexterm>
	  <para>The tertiary prompt, displayed in a
	    <link linkend="selectref">select</link> loop (see <xref linkend="ex31" />).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS4</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PS4</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS4</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>quartenary</secondary>
	  </indexterm>
	  <para>The quartenary prompt, shown at the beginning of
	    each line of output when invoking a script with the
	    <token>-x</token> <emphasis>[verbose trace]</emphasis>
	    <link linkend="optionsref">option</link>. It displays as
	    <quote>+</quote>.</para>

            <para>As a debugging aid, it may be useful to embed diagnostic
	    information in <varname>$PS4</varname>.
<programlisting>P4='$(read time junk &lt; /proc/$$/schedstat; echo "@@@ $time @@@ " )'
# Per suggestion by Erik Brandsberg.
set -x
# Various commands follow ...</programlisting></para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="pwdref" /><varname>$PWD</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <para>Working directory (directory you are in at the time)</para>
	  <para>This is the analog to the <link linkend="pwd2ref">pwd</link>
	    builtin command.</para>
          <para><programlisting>#!/bin/bash

E_WRONG_DIRECTORY=85

clear # Clear the screen.

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo "Deleting stale files in $TargetDirectory."

if [ "$PWD" != "$TargetDirectory" ]
then    # Keep from wiping out wrong directory by accident.
  echo "Wrong directory!"
  echo "In $PWD, rather than $TargetDirectory!"
  echo "Bailing out!"
  exit $E_WRONG_DIRECTORY
fi  

rm -rf *
rm .[A-Za-z0-9]*    # Delete dotfiles.
# rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
# (shopt -s dotglob; rm -f *)   will also work.
# Thanks, S.C. for pointing this out.

#  A filename (`basename`) may contain all characters in the 0 - 255 range,
#+ except "/".
#  Deleting files beginning with weird characters, such as -
#+ is left as an exercise. (Hint: rm ./-weirdname or rm -- -weirdname)
result=$?   # Result of delete operations. If successful = 0.

echo
ls -al              # Any files left?
echo "Done."
echo "Old files deleted in $TargetDirectory."
echo

# Various other operations here, as necessary.

exit $result
</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="replyref" /><varname>$REPLY</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$REPLY</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$REPLY</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>default value of read</primary>
	  </indexterm>
	  <indexterm>
	    <primary>reply</primary>
	    <secondary>read</secondary>
	  </indexterm>
	    <para>The default value when a variable is not
	    supplied to <link linkend="readref">read</link>. Also
	    applicable to <link linkend="selectref">select</link> menus,
	    but only supplies the item number of the variable chosen,
	    not the value of the variable itself.</para>
	     <para><programlisting>#!/bin/bash
# reply.sh

# REPLY is the default value for a 'read' command.

echo
echo -n "What is your favorite vegetable? "
read

echo "Your favorite vegetable is $REPLY."
#  REPLY holds the value of last "read" if and only if
#+ no variable supplied.

echo
echo -n "What is your favorite fruit? "
read fruit
echo "Your favorite fruit is $fruit."
echo "but..."
echo "Value of \$REPLY is still $REPLY."
#  $REPLY is still set to its previous value because
#+ the variable $fruit absorbed the new "read" value.

echo

exit 0
</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SECONDS</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$SECONDS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SECONDS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seconds execution time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>runtime</primary>
	    <secondary>seconds</secondary>
	  </indexterm>
	    <para>The number of seconds the script has been running.</para>
	     <para><programlisting>#!/bin/bash

TIME_LIMIT=10
INTERVAL=1

echo
echo "Hit Control-C to exit before $TIME_LIMIT seconds."
echo

while [ "$SECONDS" -le "$TIME_LIMIT" ]
do   #   $SECONDS is an internal shell variable.
  if [ "$SECONDS" -eq 1 ]
  then
    units=second
  else  
    units=seconds
  fi

  echo "This script has been running $SECONDS $units."
  #  On a slow or overburdened machine, the script may skip a count
  #+ every once in a while.
  sleep $INTERVAL
done

echo -e "\a"  # Beep!

exit 0
</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SHELLOPTS</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$SHELLOPTS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SHELLOPTS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shell options</primary>
	  </indexterm>
	    <para>The list of enabled shell <link linkend="optionsref">options</link>, a readonly variable.
	      <screen><prompt>bash$ </prompt><userinput>echo $SHELLOPTS</userinput>
<computeroutput>braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="shlvlref" /><varname>$SHLVL</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$SHLVL</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SHLVL</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shell level</primary>
	  </indexterm>
	  
	    <para>Shell level, how deeply Bash is nested.
	      <footnote><para>
		Somewhat analogous to <link linkend="recursionref">recursion</link>, in this context
		<firstterm>nesting</firstterm> refers to a pattern
		embedded within a larger pattern. One of the definitions
		of <firstterm>nest</firstterm>, according to the 1913
		edition of <emphasis>Webster's Dictionary</emphasis>,
		illustrates this beautifully: <quote><emphasis>A collection of
		boxes, cases, or the like, of graduated size, each put
		within the one next larger.</emphasis></quote>
	      </para></footnote>
	    If, at the command-line, $SHLVL is 1, then in a script it
	    will increment to 2.</para>

	    <note><para>This variable is <link linkend="subshnlevref">
	      <emphasis>not</emphasis> affected by
	      subshells</link>. Use <link linkend="bashsubshellref">$BASH_SUBSHELL</link> when you
	      need an indication of subshell nesting.</para></note>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="tmoutref" /><varname>$TMOUT</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$TMOUT</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$TMOUT</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>timeout interval</primary>
	  </indexterm>
	  <para>If the <replaceable>$TMOUT</replaceable>
	  environmental variable is set to a non-zero value
	  <varname>time</varname>, then the shell prompt will time out
	  after <varname>$time</varname> seconds. This will cause a
	  logout.</para>


	  <para>As of version 2.05b of Bash, it is now possible to use
	    <replaceable>$TMOUT</replaceable> in a script in combination
	    with <link linkend="readref">read</link>.</para>

	  <para>
	  <programlisting># Works in scripts for Bash, versions 2.05b and later.

TMOUT=3    # Prompt times out at three seconds.

echo "What is your favorite song?"
echo "Quickly now, you only have $TMOUT seconds to answer!"
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # Default response.
fi

echo "Your favorite song is $song."</programlisting>
	  </para>


	  <para><anchor xml:id="timingloop" /></para>
	  <para>There are other, more complex, ways of implementing
	    timed input in a script. One alternative is to set up
	    a timing loop to signal the script when it times out.
	    This also requires a signal handling routine to <link linkend="trapref1">trap</link> (see <xref linkend="ex76" />)
	    the interrupt generated by the timing loop (whew!).</para>

	    <example xml:id="tmdin">
	      <title>Timed Input</title>
	      <programlisting>#!/bin/bash
# timed-input.sh

# TMOUT=3    Also works, as of newer versions of Bash.

TIMER_INTERRUPT=14
TIMELIMIT=3  # Three seconds in this instance.
             # May be set to different value.

PrintAnswer()
{
  if [ "$answer" = TIMEOUT ]
  then
    echo $answer
  else       # Don't want to mix up the two instances. 
    echo "Your favorite veggie is $answer"
    kill $!  #  Kills no-longer-needed TimerOn function
             #+ running in background.
             #  $! is PID of last job running in background.
  fi

}  


TimerOn()
{
  sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;
  # Waits 3 seconds, then sends sigalarm to script.
}  


Int14Vector()
{
  answer="TIMEOUT"
  PrintAnswer
  exit $TIMER_INTERRUPT
}  

trap Int14Vector $TIMER_INTERRUPT
# Timer interrupt (14) subverted for our purposes.

echo "What is your favorite vegetable "
TimerOn
read answer
PrintAnswer


#  Admittedly, this is a kludgy implementation of timed input.
#  However, the "-t" option to "read" simplifies this task.
#  See the "t-out.sh" script.
#  However, what about timing not just single user input,
#+ but an entire script?

#  If you need something really elegant ...
#+ consider writing the application in C or C++,
#+ using appropriate library functions, such as 'alarm' and 'setitimer.'

exit 0
</programlisting>
	    </example>	    

	  <para><anchor xml:id="sttyto" /></para>
	  <para>An alternative is using <link linkend="sttyref">stty</link>.</para>

	    <example xml:id="timeout">
	      <title>Once more, timed input</title>
	      <programlisting>#!/bin/bash
# timeout.sh

#  Written by Stephane Chazelas,
#+ and modified by the document author.

INTERVAL=5                # timeout interval

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # or just  read $varname
  stty "$old_tty_settings"
  # See man page for "stty."
}

echo; echo -n "What's your name? Quick! "
timedout_read $INTERVAL your_name

#  This may not work on every terminal type.
#  The maximum timeout depends on the terminal.
#+ (it is often 25.5 seconds).

echo

if [ ! -z "$your_name" ]  # If name input before timeout ...
then
  echo "Your name is $your_name."
else
  echo "Timed out."
fi

echo

# The behavior of this script differs somewhat from "timed-input.sh."
# At each keystroke, the counter resets.

exit 0
</programlisting>
	    </example>	    

	  <para>Perhaps the simplest method is using the
	    <option>-t</option> option to <link linkend="readref">read</link>.</para>
	    
	    <example xml:id="tout">
	      <title>Timed <firstterm>read</firstterm></title>
	      <programlisting>#!/bin/bash
# t-out.sh [time-out]
# Inspired by a suggestion from "syngin seven" (thanks).


TIMELIMIT=4         # 4 seconds

read -t $TIMELIMIT variable &lt;&amp;1
#                           ^^^
#  In this instance, "&lt;&amp;1" is needed for Bash 1.x and 2.x,
#  but unnecessary for Bash 3+.

echo

if [ -z "$variable" ]  # Is null?
then
  echo "Timed out, variable still unset."
else  
  echo "variable = $variable"
fi  

exit 0
</programlisting>
	    </example>	    
	   

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="uidref" /><varname>$UID</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$UID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$UID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>user ID</primary>
	  </indexterm>
            <para>User ID number</para>

	    <para>Current user's user identification number, as
	      recorded in <link linkend="datafilesref1"><filename>/etc/passwd</filename></link></para>

	    <para>This is the current user's real id, even if she has
	      temporarily assumed another identity through <link linkend="suref">su</link>. <varname>$UID</varname> is a
	      readonly variable, not subject to change from the command
	      line or within a script, and is the counterpart to the
	      <link linkend="idref">id</link> builtin.</para>

            <example xml:id="amiroot">
	      <title>Am I root?</title>
	      <programlisting>#!/bin/bash
# am-i-root.sh:   Am I root or not?

ROOT_UID=0   # Root has $UID 0.

if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
then
  echo "You are root."
else
  echo "You are just an ordinary user (but mom loves you just the same)."
fi

exit 0


# ============================================================= #
# Code below will not execute, because the script already exited.

# An alternate method of getting to the root of matters:

ROOTUSER_NAME=root

username=`id -nu`              # Or...   username=`whoami`
if [ "$username" = "$ROOTUSER_NAME" ]
then
  echo "Rooty, toot, toot. You are root."
else
  echo "You are just a regular fella."
fi
</programlisting>
            </example>

	    <para>See also <xref linkend="ex2" />.</para>


	<!-- Nest note within last entry  -->
	<note>
	<para>The variables <varname>$ENV</varname>,
	  <varname>$LOGNAME</varname>, <varname>$MAIL</varname>,
	  <varname>$TERM</varname>, <varname>$USER</varname>, and
	  <varname>$USERNAME</varname> are <emphasis>not</emphasis>
	  Bash <link linkend="builtinref">builtins</link>. These are,
	  however, often set as <link linkend="envref">environmental variables</link> in
	  one of the <link linkend="filesref1">Bash</link> or
	  <firstterm>login</firstterm> startup files. <anchor xml:id="shellvarref" /><varname>$SHELL</varname>,
	  the name of the user's login shell, may be set from
	  <filename>/etc/passwd</filename> or in an <quote>init</quote>
	  script, and it is likewise not a Bash builtin.</para>
	      <para>
	      <screen>
<prompt>tcsh% </prompt><userinput>echo $LOGNAME</userinput>
<computeroutput>bozo</computeroutput>
<prompt>tcsh% </prompt><userinput>echo $SHELL</userinput>
<computeroutput>/bin/tcsh</computeroutput>
<prompt>tcsh% </prompt><userinput>echo $TERM</userinput>
<computeroutput>rxvt</computeroutput>

<prompt>bash$ </prompt><userinput>echo $LOGNAME</userinput>
<computeroutput>bozo</computeroutput>
<prompt>bash$ </prompt><userinput>echo $SHELL</userinput>
<computeroutput>/bin/tcsh</computeroutput>
<prompt>bash$ </prompt><userinput>echo $TERM</userinput>
<computeroutput>rxvt</computeroutput>
	      </screen>
	      </para>
	  </note>

	<!-- Nest note after $USER  -->

	  </listitem>
	</varlistentry>


      </variablelist>

	<!-- Last entry of intrinsic BASH variables -->

      <variablelist xml:id="posparmslist">
        <title>Positional Parameters</title>

	<varlistentry>
	  <term><anchor id="posparamref" /><varname>$0</varname>, <varname>$1</varname>,
	  <varname>$2</varname>, etc.</term>
	  <listitem>
	  <indexterm>
	    <primary>$0</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$0</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	    <para>Positional parameters, passed from command
	      line to script, passed to a function, or <link linkend="setref">set</link> to a variable (see <xref linkend="ex17" /> and <xref linkend="ex34" />)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="clacountref" /><varname>$#</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>number of</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>number of</tertiary>
	  </indexterm>
            <para>Number of command-line arguments
		<footnote><para>The words <quote>argument</quote>
		and <quote>parameter</quote> are often used
		interchangeably. In the context of this document, they
		have the same precise meaning: <emphasis>a variable passed
		to a script or function.</emphasis></para></footnote>
	    or positional parameters (see <xref linkend="ex4" />)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="appref" /><varname>$*</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>all</tertiary>
	  </indexterm>
	  <para>All of the positional parameters, seen as a single
	    word, <command>"$*"</command> is equivalent to 
	    <command>"$1${IFS:0:1}$2${IFS:0:1}$3..."</command>
	  </para>
	  <note><para><quote><varname>$*</varname></quote> must be
	    quoted.</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="appref2" /><varname>$@</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$@</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>

	  <para>Same as <token>$*</token>, but each parameter is a
	    quoted string, that is, the parameters are passed on
	    intact, without interpretation or expansion. This means,
	    among other things, that each parameter in the argument
	    list is seen as a separate word, <command>"$@"</command>
	    is equivalent to <command>"$1" "$2" ...</command>
	  </para>

	  <note><para>Of course, <quote><varname>$@</varname></quote>
	    should be quoted.</para></note>

	    <example xml:id="arglist">
	      <title><firstterm>arglist</firstterm>: Listing arguments
	      with $* and $@</title>
	      <programlisting>#!/bin/bash
# arglist.sh
# Invoke this script with several arguments, such as "one two three" ...

E_BADARGS=85

if [ ! -n "$1" ]
then
  echo "Usage: `basename $0` argument1 argument2 etc."
  exit $E_BADARGS
fi  

echo

index=1          # Initialize count.

echo "Listing args with \"\$*\":"
for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $* sees all arguments as single word. 
echo "Entire arg list seen as single word."

echo

index=1          # Reset count.
                 # What happens if you forget to do this?

echo "Listing args with \"\$@\":"
for arg in "$@"
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $@ sees arguments as separate words. 
echo "Arg list seen as separate words."

echo

index=1          # Reset count.

echo "Listing args with \$* (unquoted):"
for arg in $*
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # Unquoted $* sees arguments as separate words. 
echo "Arg list seen as separate words."

exit 0
</programlisting>
	    </example>   

	    <para>Following a <command>shift</command>, the
	      <varname>$@</varname> holds the remaining command-line
	      parameters, lacking the previous <varname>$1</varname>,
	      which was lost.
	        <programlisting>#!/bin/bash
# Invoke with ./scriptname 1 2 3 4 5

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# Each "shift" loses parameter $1.
# "$@" then contains the remaining parameters.</programlisting>
            </para>


	    <para>The <varname>$@</varname> special parameter finds
	      use as a tool for filtering input into shell scripts. The
	      <command>cat "$@"</command> construction accepts input
	      to a script either from <filename>stdin</filename> or
	      from files given as parameters to the script. See <xref linkend="rot13" /> and <xref linkend="cryptoquote" />.</para>


	    <caution><para>The <varname>$*</varname> and <varname>$@</varname>
	      parameters sometimes display inconsistent and
	      puzzling behavior, depending on the setting of <link linkend="ifsref">$IFS</link>.</para></caution>

	    <example xml:id="incompat">
	      <title>Inconsistent <varname>$*</varname> and <varname>$@</varname> behavior</title>
	      <programlisting>#!/bin/bash

#  Erratic behavior of the "$*" and "$@" internal Bash variables,
#+ depending on whether or not they are quoted.
#  Demonstrates inconsistent handling of word splitting and linefeeds.


set -- "First one" "second" "third:one" "" "Fifth: :one"
# Setting the script arguments, $1, $2, $3, etc.

echo

echo 'IFS unchanged, using "$*"'
c=0
for i in "$*"               # quoted
do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
                            # Echo args.
done
echo ---

echo 'IFS unchanged, using $*'
c=0
for i in $*                 # unquoted
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

IFS=:
echo 'IFS=":", using "$*"'
c=0
for i in "$*"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $*'
c=0
for i in $*
do echo "$((c+=1)): [$i]"
done
echo ---

var=$*
echo 'IFS=":", using "$var" (var=$*)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var=$*)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

var="$*"
echo 'IFS=":", using $var (var="$*")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var="$*")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

var=$@
echo 'IFS=":", using $var (var=$@)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var=$@)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

var="$@"
echo 'IFS=":", using "$var" (var="$@")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var="$@")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done

echo

# Try this script with ksh or zsh -y.

exit 0

#  This example script written by Stephane Chazelas,
#+ and slightly modified by the document author.
</programlisting>
	    </example>	    

	    <note><para>The <command>$@</command> and <command>$*</command>
	      parameters differ only when between double quotes.</para></note>

	    <example xml:id="ifsempty">
	      <title><varname>$*</varname> and <varname>$@</varname> when
	        <varname>$IFS</varname> is empty</title>
	      <programlisting>#!/bin/bash

#  If $IFS set, but empty,
#+ then "$*" and "$@" do not echo positional params as expected.

mecho ()       # Echo positional parameters.
{
echo "$1,$2,$3";
}


IFS=""         # Set, but empty.
set a b c      # Positional parameters.

mecho "$*"     # abc,,
#                   ^^
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho "$@"     # a,b,c

#  The behavior of $* and $@ when $IFS is empty depends
#+ on which Bash or sh version being run.
#  It is therefore inadvisable to depend on this "feature" in a script.


# Thanks, Stephane Chazelas.

exit
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

    </variablelist>	

      <variablelist xml:id="otherspecparams">
        <title>Other Special Parameters</title>

	<varlistentry>
	  <term><anchor id="flpref" /><varname>$-</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>flags</primary>
	  </indexterm>
	    <para>Flags passed to script (using <link linkend="setref">set</link>). See <xref linkend="ex34" />.</para>
	    <caution><para>This was originally a <firstterm>ksh</firstterm>
	      construct adopted into Bash, and unfortunately it does not
	      seem to work reliably in Bash scripts. One possible use
	      for it is to have a script <link linkend="iitest">self-test
	      whether it is interactive</link>.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="pidvarref" /><varname>$!</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>last job background</secondary>
	  </indexterm>

	    <para><link linkend="processiddef">PID</link> (process ID) of last
	      job run in background</para>

	    <para>
	      <programlisting>LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" &gt;&gt; "$LOG"
# So they can be monitored, and killed as necessary.
echo &gt;&gt; "$LOG"

# Logging commands.

echo -n "PID of \"$COMMAND1\":  " &gt;&gt; "$LOG"
${COMMAND1} &amp;
echo $! &gt;&gt; "$LOG"
# PID of "sleep 100":  1506

# Thank you, Jacques Lederer, for suggesting this.</programlisting>
            </para>

            <para>Using <varname>$!</varname> for job control:</para>

            <para>
	      <programlisting>possibly_hanging_job &amp; { sleep ${TIMEOUT}; eval 'kill -9 $!' &amp;&gt; /dev/null; }
# Forces completion of an ill-behaved program.
# Useful, for example, in init scripts.

# Thank you, Sylvain Fourmanoit, for this creative use of the "!" variable.</programlisting>

            </para>

            <para>Or, alternately:</para>

            <para>
              <programlisting># This example by Matthew Sage.
# Used with permission.

TIMEOUT=30   # Timeout value in seconds
count=0

possibly_hanging_job &amp; {
        while ((count &lt; TIMEOUT )); do
                eval '[ ! -d "/proc/$!" ] &amp;&amp; ((count = TIMEOUT))'
                # /proc is where information about running processes is found.
                # "-d" tests whether it exists (whether directory exists).
                # So, we're waiting for the job in question to show up.
                ((count++))
                sleep 1
        done
        eval '[ -d "/proc/$!" ] &amp;&amp; kill -15 $!'
        # If the hanging job is running, kill it.
}

#  -------------------------------------------------------------- #

#  However, this may not work as specified if another process
#+ begins to run after the "hanging_job" . . .
#  In such a case, the wrong job may be killed.
#  Ariel Meragelman suggests the following fix.

TIMEOUT=30
count=0
# Timeout value in seconds
possibly_hanging_job &amp; {

while ((count &lt; TIMEOUT )); do
  eval '[ ! -d "/proc/$lastjob" ] &amp;&amp; ((count = TIMEOUT))'
  lastjob=$!
  ((count++))
  sleep 1
done
eval '[ -d "/proc/$lastjob" ] &amp;&amp; kill -15 $lastjob'

}

exit</programlisting>
	    </para>


	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="underscoreref" /><varname>$_</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$_</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$_</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>underscore</primary>
	    <secondary>last argument</secondary>
	  </indexterm>
	      <para>Special variable set to final argument of previous command
	        executed.</para>


      <example xml:id="uscref">
	<title>Underscore variable</title>
        <programlisting>#!/bin/bash

echo $_              #  /bin/bash
                     #  Just called /bin/bash to run the script.
                     #  Note that this will vary according to
                     #+ how the script is invoked.

du &gt;/dev/null        #  So no output from command.
echo $_              #  du

ls -al &gt;/dev/null    #  So no output from command.
echo $_              #  -al  (last argument)

:
echo $_              #  :</programlisting></example>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="xstatvarref" /><varname>$?</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
            <para><link linkend="exitstatusref">Exit status</link>
	    of a command, <link linkend="functionref">function</link>,
	    or the script itself (see <xref linkend="max" />)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="proccid" /><varname>$$</varname></term>
	  <listitem>
	  <indexterm>
	    <primary>$$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>of script</secondary>
	  </indexterm>
            <para>Process ID (<firstterm>PID</firstterm>) of
            the script itself.

	      <footnote><para>Within a script, inside a subshell,
              <varname>$$</varname> <link linkend="bashpidref">returns
              the PID of the script</link>, not the
              subshell.</para></footnote>

            The <varname>$$</varname> variable often
	    finds use in scripts to construct <quote>unique</quote>
	    temp file names (see <xref linkend="online" />, <xref linkend="derpm" />, and <xref linkend="selfdestruct" />).
	    This is usually simpler than invoking <link linkend="mktempref">mktemp</link>.</para>

	  </listitem>
	</varlistentry>

    </variablelist>	


    </section> <!-- Internal Variables -->



      <section xml:id="declareref">
	<title>Typing variables: <command>declare</command> or
	  <command>typeset</command></title>

	<indexterm>
	  <primary>declare</primary>
	</indexterm>
	<indexterm>
	  <primary>typeset</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>declare</secondary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>typeset</secondary>
	</indexterm>
	
	<para><anchor xml:id="declare1ref" /></para>

	<para>The <firstterm>declare</firstterm> or
	  <firstterm>typeset</firstterm> <link linkend="builtinref">builtins</link>, which are exact synonyms,
	  permit modifying the properties of variables. This is
	  a very weak form of the <firstterm>typing</firstterm>

	    <footnote>

	    <para><anchor xml:id="typingref" />In this context,
	    <firstterm>typing</firstterm>
	    a variable means to classify it and restrict its properties.
	    For example, a variable <firstterm>declared</firstterm>
	    or <firstterm>typed</firstterm> as an integer
	    is no longer available for <link linkend="stringopstab">string
	    operations</link>.</para>

	    <para><programlisting>declare -i intvar

intvar=23
echo "$intvar"   # 23
intvar=stringval
echo "$intvar"   # 0</programlisting></para>

	    </footnote>

	  available in certain programming languages. The
	  <firstterm>declare</firstterm> command is specific to version
	  2 or later of Bash. The <firstterm>typeset</firstterm> command
	  also works in ksh scripts.</para>

	<variablelist xml:id="declareopsref">
	  <title><anchor xml:id="declareopsref1" />declare/typeset options</title>

	  <varlistentry>
	    <term><token>-r</token>
	    <replaceable>readonly</replaceable></term>
	    <listitem>
	      <para>(<userinput>declare -r var1</userinput> works the same as
		<userinput>readonly var1</userinput>)</para>
	      <para>This is the rough equivalent of the <command>C</command>
		<firstterm>const</firstterm> type qualifier. An attempt
		to change the value of a <firstterm>readonly</firstterm>
		variable fails with an error message.</para>
	      <para><programlisting>declare -r var1=1
echo "var1 = $var1"   # var1 = 1

(( var1++ ))          # x.sh: line 4: var1: readonly variable</programlisting>
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-i</token> <replaceable>integer</replaceable></term>

	    <listitem>

	      <para><programlisting>declare -i number
# The script will treat subsequent occurrences of "number" as an integer.		

number=3
echo "Number = $number"     # Number = 3

number=three
echo "Number = $number"     # Number = 0
# Tries to evaluate the string "three" as an integer.</programlisting></para>
		
              <para>Certain arithmetic operations are permitted
		for declared integer variables without the need
		for <link linkend="exprref">expr</link> or <link linkend="letref">let</link>.</para>

              <para><programlisting>n=6/3
echo "n = $n"       # n = 6/3

declare -i n
n=6/3
echo "n = $n"       # n = 2</programlisting></para>
		
		</listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="arraydeclare" /><token>-a</token>
	    <replaceable>array</replaceable></term>
	    <listitem><para><programlisting>declare -a indices</programlisting></para>
	      <para>The variable <parameter>indices</parameter> will be treated as
		an <link linkend="arrayref">array</link>.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-f</token> <replaceable>function(s)</replaceable></term>
	    <listitem>

	      <para><programlisting>declare -f</programlisting></para>
	      <para>A <userinput>declare -f</userinput> line with no
		arguments in a script causes a listing of all the
		<link linkend="functionref">functions</link> previously
		defined in that script.</para>

	      <para><programlisting>declare -f function_name</programlisting></para>
	      <para>A <userinput>declare -f function_name</userinput>
		in a script lists just the function named.</para>

            </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><token>-x</token> <link linkend="exportref">export</link></term>
	      <listitem><para><programlisting>declare -x var3</programlisting></para>
	      <para>This declares a variable as available for exporting outside the
		environment of the script itself.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-x var=$value</term>
	      <listitem>
	        <para><programlisting>declare -x var3=373</programlisting></para>
		<para>The <command>declare</command> command permits
		  assigning a value to a variable in the same statement
		  as setting its properties.</para>
	      </listitem>
	  </varlistentry>
	      

	</variablelist>

	<example xml:id="ex20">
	  <title>Using <firstterm>declare</firstterm> to type variables</title>
	  <programlisting>#!/bin/bash

func1 ()
{
  echo This is a function.
}

declare -f        # Lists the function above.

echo

declare -i var1   # var1 is an integer.
var1=2367
echo "var1 declared as $var1"
var1=var1+1       # Integer declaration eliminates the need for 'let'.
echo "var1 incremented by 1 is $var1."
# Attempt to change variable declared as integer.
echo "Attempting to change var1 to floating point value, 2367.1."
var1=2367.1       # Results in error message, with no change to variable.
echo "var1 is still $var1"

echo

declare -r var2=13.36         # 'declare' permits setting a variable property
                              #+ and simultaneously assigning it a value.
echo "var2 declared as $var2" # Attempt to change readonly variable.
var2=13.37                    # Generates error message, and exit from script.

echo "var2 is still $var2"    # This line will not execute.

exit 0                        # Script will not exit here.
</programlisting>
	</example>


        <caution>

	<para>Using the <firstterm>declare</firstterm> builtin
	  restricts the <link linkend="scoperef">scope</link>
	  of a variable.


	  <programlisting>foo ()
{
FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar   # Prints bar.</programlisting></para>

      <para>However . . .

	  <programlisting>foo (){
declare FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar  # Prints nothing.


# Thank you, Michael Iatrou, for pointing this out.</programlisting></para>

        </caution>


        <section xml:id="declare2x">
           <title>Another use for <firstterm>declare</firstterm></title>

	   <para>The <firstterm>declare</firstterm> command can be
	     helpful in identifying variables, <link linkend="envref">environmental</link> or otherwise.
	     This can be especially useful with <link linkend="arrayref">arrays</link>.</para>

	   <para>
	      <screen><prompt>bash$ </prompt><userinput>declare | grep HOME</userinput>
<computeroutput>HOME=/home/bozo</computeroutput>


<prompt>bash$ </prompt><userinput>zzy=68</userinput>
<prompt>bash$ </prompt><userinput>declare | grep zzy</userinput>
<computeroutput>zzy=68</computeroutput>


<prompt>bash$ </prompt><userinput>Colors=([0]="purple" [1]="reddish-orange" [2]="light green")</userinput>
<prompt>bash$ </prompt><userinput>echo ${Colors[@]}</userinput>
<computeroutput>purple reddish-orange light green</computeroutput>
<prompt>bash$ </prompt><userinput>declare | grep Colors</userinput>
<computeroutput>Colors=([0]="purple" [1]="reddish-orange" [2]="light green")</computeroutput>
	     </screen>
	   </para>


        </section> <!-- Another use for declare -->

      </section> <!-- Typing variables: declare or typeset -->





      <section xml:id="randomvar">
	<title>$RANDOM: generate random integer</title>

	<indexterm>
	  <primary>$RANDOM</primary>
	</indexterm>
	<indexterm>
	  <primary>variable</primary>
	  <secondary>$RANDOM</secondary>
	</indexterm>

    <epigraph>
      <para>Anyone who attempts to generate random numbers by
        deterministic means is, of course, living in a state of
        sin.</para>
            <para>--John von Neumann</para>
    </epigraph>

	   <para><anchor xml:id="randomvar01" /></para>
	<para><varname>$RANDOM</varname> is an internal Bash <link linkend="functionref">function</link> (not a constant) that
	  returns a <firstterm>pseudorandom</firstterm>

	    <footnote><para>True <quote>randomness,</quote> insofar as
	    it exists at all, can only be found in certain incompletely
	    understood natural phenomena, such as radioactive
	    decay. Computers only <firstterm>simulate</firstterm>
	    randomness, and computer-generated sequences of
	    <quote>random</quote> numbers are therefore referred to as
	    <firstterm>pseudorandom</firstterm>.</para></footnote>

	  integer in the range 0 - 32767. It should
	  <replaceable>not</replaceable> be used to generate an encryption
	  key.</para>

	<example xml:id="ex21">
	  <title>Generating random numbers</title>
	  <programlisting>#!/bin/bash

# $RANDOM returns a different random integer at each invocation.
# Nominal range: 0 - 32767 (signed 16-bit integer).

MAXCOUNT=10
count=1

echo
echo "$MAXCOUNT random numbers:"
echo "-----------------"
while [ "$count" -le $MAXCOUNT ]      # Generate 10 ($MAXCOUNT) random integers.
do
  number=$RANDOM
  echo $number
  let "count += 1"  # Increment count.
done
echo "-----------------"

# If you need a random int within a certain range, use the 'modulo' operator.
# This returns the remainder of a division operation.

RANGE=500

echo

number=$RANDOM
let "number %= $RANGE"
#           ^^
echo "Random number less than $RANGE  ---  $number"

echo



#  If you need a random integer greater than a lower bound,
#+ then set up a test to discard all numbers below that.

FLOOR=200

number=0   #initialize
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
done
echo "Random number greater than $FLOOR ---  $number"
echo

   # Let's examine a simple alternative to the above loop, namely
   #       let "number = $RANDOM + $FLOOR"
   # That would eliminate the while-loop and run faster.
   # But, there might be a problem with that. What is it?



# Combine above two techniques to retrieve random number between two limits.
number=0   #initialize
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
  let "number %= $RANGE"  # Scales $number down within $RANGE.
done
echo "Random number between $FLOOR and $RANGE ---  $number"
echo



# Generate binary choice, that is, "true" or "false" value.
BINARY=2
T=1
number=$RANDOM

let "number %= $BINARY"
#  Note that    let "number &gt;&gt;= 14"    gives a better random distribution
#+ (right shifts out everything except last binary digit).
if [ "$number" -eq $T ]
then
  echo "TRUE"
else
  echo "FALSE"
fi  

echo


# Generate a toss of the dice.
SPOTS=6   # Modulo 6 gives range 0 - 5.
          # Incrementing by 1 gives desired range of 1 - 6.
          # Thanks, Paulo Marcel Coelho Aragao, for the simplification.
die1=0
die2=0
# Would it be better to just set SPOTS=7 and not add 1? Why or why not?

# Tosses each die separately, and so gives correct odds.

    let "die1 = $RANDOM % $SPOTS +1" # Roll first one.
    let "die2 = $RANDOM % $SPOTS +1" # Roll second one.
    #  Which arithmetic operation, above, has greater precedence --
    #+ modulo (%) or addition (+)?


let "throw = $die1 + $die2"
echo "Throw of the dice = $throw"
echo


exit 0
</programlisting>
	</example>

	<example xml:id="pickcard">
	  <title>Picking a random card from a deck</title>
	  <programlisting>#!/bin/bash
# pick-card.sh

# This is an example of choosing random elements of an array.


# Pick a card, any card.

Suites="Clubs
Diamonds
Hearts
Spades"

Denominations="2
3
4
5
6
7
8
9
10
Jack
Queen
King
Ace"

# Note variables spread over multiple lines.


suite=($Suites)                # Read into array variable.
denomination=($Denominations)

num_suites=${#suite[*]}        # Count how many elements.
num_denominations=${#denomination[*]}

echo -n "${denomination[$((RANDOM%num_denominations))]} of "
echo ${suite[$((RANDOM%num_suites))]}


# $bozo sh pick-cards.sh
# Jack of Clubs


# Thank you, "jipe," for pointing out this use of $RANDOM.
exit 0
</programlisting>
	</example>

	<para><anchor xml:id="brownianref" /></para>
	<example xml:id="brownian">
	  <title>Brownian Motion Simulation</title>
	  <programlisting>#!/bin/bash
# brownian.sh
# Author: Mendel Cooper
# Reldate: 10/26/07
# License: GPL3

#  ----------------------------------------------------------------
#  This script models Brownian motion:
#+ the random wanderings of tiny particles in a fluid,
#+ as they are buffeted by random currents and collisions.
#+ This is colloquially known as the "Drunkard's Walk."

#  It can also be considered as a stripped-down simulation of a
#+ Galton Board, a slanted board with a pattern of pegs,
#+ down which rolls a succession of marbles, one at a time.
#+ At the bottom is a row of slots or catch basins in which
#+ the marbles come to rest at the end of their journey.
#  Think of it as a kind of bare-bones Pachinko game.
#  As you see by running the script,
#+ most of the marbles cluster around the center slot.
#+ This is consistent with the expected binomial distribution.
#  As a Galton Board simulation, the script
#+ disregards such parameters as
#+ board tilt-angle, rolling friction of the marbles,
#+ angles of impact, and elasticity of the pegs.
#  To what extent does this affect the accuracy of the simulation?
#  ----------------------------------------------------------------

PASSES=500            #  Number of particle interactions / marbles.
ROWS=10               #  Number of "collisions" (or horiz. peg rows).
RANGE=3               #  0 - 2 output range from $RANDOM.
POS=0                 #  Left/right position.
RANDOM=$$             #  Seeds the random number generator from PID
                      #+ of script.

declare -a Slots      # Array holding cumulative results of passes.
NUMSLOTS=21           # Number of slots at bottom of board.


Initialize_Slots () { # Zero out all elements of the array.
for i in $( seq $NUMSLOTS )
do
  Slots[$i]=0
done

echo                  # Blank line at beginning of run.
  }


Show_Slots () {
echo; echo
echo -n " "
for i in $( seq $NUMSLOTS )   # Pretty-print array elements.
do
  printf "%3d" ${Slots[$i]}   # Allot three spaces per result.
done

echo # Row of slots:
echo " |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|"
echo "                                ||"
echo #  Note that if the count within any particular slot exceeds 99,
     #+ it messes up the display.
     #  Running only(!) 500 passes usually avoids this.
  }


Move () {              # Move one unit right / left, or stay put.
  Move=$RANDOM         # How random is $RANDOM? Well, let's see ...
  let "Move %= RANGE"  # Normalize into range of 0 - 2.
  case "$Move" in
    0 ) ;;                   # Do nothing, i.e., stay in place.
    1 ) ((POS--));;          # Left.
    2 ) ((POS++));;          # Right.
    * ) echo -n "Error ";;   # Anomaly! (Should never occur.)
  esac
  }


Play () {                    # Single pass (inner loop).
i=0
while [ "$i" -lt "$ROWS" ]   # One event per row.
do
  Move
  ((i++));
done

SHIFT=11                     # Why 11, and not 10?
let "POS += $SHIFT"          # Shift "zero position" to center.
(( Slots[$POS]++ ))          # DEBUG: echo $POS

# echo -n "$POS "

  }


Run () {                     # Outer loop.
p=0
while [ "$p" -lt "$PASSES" ]
do
  Play
  (( p++ ))
  POS=0                      # Reset to zero. Why?
done
  }


# --------------
# main ()
Initialize_Slots
Run
Show_Slots
# --------------

exit $?

#  Exercises:
#  ---------
#  1) Show the results in a vertical bar graph, or as an alternative,
#+    a scattergram.
#  2) Alter the script to use /dev/urandom instead of $RANDOM.
#     Will this make the results more random?
#  3) Provide some sort of "animation" or graphic output
#     for each marble played.
</programlisting>
	</example>



	<para>
	<emphasis>Jipe</emphasis> points out a set of techniques for
	generating random numbers within a range.

	<programlisting>#  Generate random number between 6 and 30.
   rnumber=$((RANDOM%25+6))	

#  Generate random number in the same 6 - 30 range,
#+ but the number must be evenly divisible by 3.
   rnumber=$(((RANDOM%30/3+1)*3))

#  Note that this will not work all the time.
#  It fails if $RANDOM%30 returns 0.

#  Frank Wang suggests the following alternative:
   rnumber=$(( RANDOM%27/3*3+6 ))</programlisting>
	</para>


	<para>
	<emphasis>Bill Gradwohl</emphasis> came up with an improved
	formula that works for positive numbers.
	<programlisting>rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))</programlisting>
	</para>

	<para>Here Bill presents a versatile function that returns
	  a random number between two specified values.</para>

	<example xml:id="randombetween">
	  <title>Random between values</title>
	  <programlisting>#!/bin/bash
# random-between.sh
# Random number between two specified values. 
# Script by Bill Gradwohl, with minor modifications by the document author.
# Corrections in lines 187 and 189 by Anthony Le Clezio.
# Used with permission.


randomBetween() {
   #  Generates a positive or negative random number
   #+ between $min and $max
   #+ and divisible by $divisibleBy.
   #  Gives a "reasonably random" distribution of return values.
   #
   #  Bill Gradwohl - Oct 1, 2003

   syntax() {
   # Function embedded within function.
      echo
      echo    "Syntax: randomBetween [min] [max] [multiple]"
      echo
      echo -n "Expects up to 3 passed parameters, "
      echo    "but all are completely optional."
      echo    "min is the minimum value"
      echo    "max is the maximum value"
      echo -n "multiple specifies that the answer must be "
      echo     "a multiple of this value."
      echo    "    i.e. answer must be evenly divisible by this number."
      echo    
      echo    "If any value is missing, defaults area supplied as: 0 32767 1"
      echo -n "Successful completion returns 0, "
      echo     "unsuccessful completion returns"
      echo    "function syntax and 1."
      echo -n "The answer is returned in the global variable "
      echo    "randomBetweenAnswer"
      echo -n "Negative values for any passed parameter are "
      echo    "handled correctly."
   }

   local min=${1:-0}
   local max=${2:-32767}
   local divisibleBy=${3:-1}
   # Default values assigned, in case parameters not passed to function.

   local x
   local spread

   # Let's make sure the divisibleBy value is positive.
   [ ${divisibleBy} -lt 0 ] &amp;&amp; divisibleBy=$((0-divisibleBy))

   # Sanity check.
   if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then 
      syntax
      return 1
   fi

   # See if the min and max are reversed.
   if [ ${min} -gt ${max} ]; then
      # Swap them.
      x=${min}
      min=${max}
      max=${x}
   fi

   #  If min is itself not evenly divisible by $divisibleBy,
   #+ then fix the min to be within range.
   if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then 
      if [ ${min} -lt 0 ]; then
         min=$((min/divisibleBy*divisibleBy))
      else
         min=$((((min/divisibleBy)+1)*divisibleBy))
      fi
   fi

   #  If max is itself not evenly divisible by $divisibleBy,
   #+ then fix the max to be within range.
   if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then 
      if [ ${max} -lt 0 ]; then
         max=$((((max/divisibleBy)-1)*divisibleBy))
      else
         max=$((max/divisibleBy*divisibleBy))
      fi
   fi

   #  ---------------------------------------------------------------------
   #  Now, to do the real work.

   #  Note that to get a proper distribution for the end points,
   #+ the range of random values has to be allowed to go between
   #+ 0 and abs(max-min)+divisibleBy, not just abs(max-min)+1.

   #  The slight increase will produce the proper distribution for the
   #+ end points.

   #  Changing the formula to use abs(max-min)+1 will still produce
   #+ correct answers, but the randomness of those answers is faulty in
   #+ that the number of times the end points ($min and $max) are returned
   #+ is considerably lower than when the correct formula is used.
   #  ---------------------------------------------------------------------

   spread=$((max-min))
   #  Omair Eshkenazi points out that this test is unnecessary,
   #+ since max and min have already been switched around.
   [ ${spread} -lt 0 ] &amp;&amp; spread=$((0-spread))
   let spread+=divisibleBy
   randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))   

   return 0

   #  However, Paulo Marcel Coelho Aragao points out that
   #+ when $max and $min are not divisible by $divisibleBy,
   #+ the formula fails.
   #
   #  He suggests instead the following formula:
   #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))

}

# Let's test the function.
min=-14
max=20
divisibleBy=3


#  Generate an array of expected answers and check to make sure we get
#+ at least one of each answer if we loop long enough.

declare -a answer
minimum=${min}
maximum=${max}
   if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then 
      if [ ${minimum} -lt 0 ]; then
         minimum=$((minimum/divisibleBy*divisibleBy))
      else
         minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
      fi
   fi


   #  If max is itself not evenly divisible by $divisibleBy,
   #+ then fix the max to be within range.

   if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then 
      if [ ${maximum} -lt 0 ]; then
         maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
      else
         maximum=$((maximum/divisibleBy*divisibleBy))
      fi
   fi


#  We need to generate only positive array subscripts,
#+ so we need a displacement that will guarantee
#+ positive results.

disp=$((0-minimum))
for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do
   answer[i+disp]=0
done


# Now loop a large number of times to see what we get.
loopIt=1000   #  The script author suggests 100000,
              #+ but that takes a good long while.

for ((i=0; i&lt;${loopIt}; ++i)); do

   #  Note that we are specifying min and max in reversed order here to
   #+ make the function correct for this case.

   randomBetween ${max} ${min} ${divisibleBy}

   # Report an error if an answer is unexpected.
   [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \
   &amp;&amp; echo MIN or MAX error - ${randomBetweenAnswer}!
   [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \
   &amp;&amp; echo DIVISIBLE BY error - ${randomBetweenAnswer}!

   # Store the answer away statistically.
   answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))
done



# Let's check the results

for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do
   [ ${answer[i+disp]} -eq 0 ] \
   &amp;&amp; echo "We never got an answer of $i." \
   || echo "${i} occurred ${answer[i+disp]} times."
done


exit 0
</programlisting>
	</example>



	<para>Just how random is <varname>$RANDOM</varname>? The best
	  way to test this is to write a script that tracks
	  the distribution of <quote>random</quote> numbers
	  generated by <varname>$RANDOM</varname>. Let's roll a
	  <varname>$RANDOM</varname> die a few times . . .</para>

	<example xml:id="randomtest">
	  <title>Rolling a single die with RANDOM</title>
	  <programlisting>#!/bin/bash
# How random is RANDOM?

RANDOM=$$       # Reseed the random number generator using script process ID.

PIPS=6          # A die has 6 pips.
MAXTHROWS=600   # Increase this if you have nothing better to do with your time.
throw=0         # Number of times the dice have been cast.

ones=0          #  Must initialize counts to zero,
twos=0          #+ since an uninitialized variable is null, NOT zero.
threes=0
fours=0
fives=0
sixes=0

print_result ()
{
echo
echo "ones =   $ones"
echo "twos =   $twos"
echo "threes = $threes"
echo "fours =  $fours"
echo "fives =  $fives"
echo "sixes =  $sixes"
echo
}

update_count()
{
case "$1" in
  0) ((ones++));;   # Since a die has no "zero", this corresponds to 1.
  1) ((twos++));;   # And this to 2.
  2) ((threes++));; # And so forth.
  3) ((fours++));;
  4) ((fives++));;
  5) ((sixes++));;
esac
}

echo


while [ "$throw" -lt "$MAXTHROWS" ]
do
  let "die1 = RANDOM % $PIPS"
  update_count $die1
  let "throw += 1"
done  

print_result

exit $?

#  The scores should distribute evenly, assuming RANDOM is random.
#  With $MAXTHROWS at 600, all should cluster around 100,
#+ plus-or-minus 20 or so.
#
#  Keep in mind that RANDOM is a ***pseudorandom*** generator,
#+ and not a spectacularly good one at that.

#  Randomness is a deep and complex subject.
#  Sufficiently long "random" sequences may exhibit
#+ chaotic and other "non-random" behavior.

# Exercise (easy):
# ---------------
# Rewrite this script to flip a coin 1000 times.
# Choices are "HEADS" and "TAILS."
</programlisting>
	</example>

	<para>As we have seen in the last example, it is best to
	  <firstterm>reseed</firstterm> the <parameter>RANDOM</parameter>
	  generator each time it is invoked. Using the same seed
	  for <parameter>RANDOM</parameter> repeats the same series
	  of numbers.
	    <footnote>
	    <para>The <firstterm>seed</firstterm> of a
	      computer-generated pseudorandom number series
	      can be considered an identification label. For
	      example, think of the pseudorandom series with a
	      seed of <emphasis>23</emphasis> as <replaceable>Series
	      #23</replaceable>.</para>
	    <para>A property of a pseurandom number series is the length of
	      the cycle before it starts repeating itself. A good pseurandom
	      generator will produce series with very long cycles.</para>
	    </footnote>
	  (This mirrors the behavior of the
	  <replaceable>random()</replaceable> function in
	  <firstterm>C</firstterm>.)</para>

	<example xml:id="seedingrandom">
	  <title>Reseeding RANDOM</title>
	  <programlisting>#!/bin/bash
# seeding-random.sh: Seeding the RANDOM variable.
# v 1.1, reldate 09 Feb 2013

MAXCOUNT=25       # How many numbers to generate.
SEED=

random_numbers ()
{
local count=0
local number

while [ "$count" -lt "$MAXCOUNT" ]
do
  number=$RANDOM
  echo -n "$number "
  let "count++"
done  
}

echo; echo

SEED=1
RANDOM=$SEED      # Setting RANDOM seeds the random number generator.
echo "Random seed = $SEED"
random_numbers


RANDOM=$SEED      # Same seed for RANDOM . . .
echo; echo "Again, with same random seed ..."
echo "Random seed = $SEED"
random_numbers    # . . . reproduces the exact same number series.
                  #
                  # When is it useful to duplicate a "random" series?

echo; echo

SEED=2
RANDOM=$SEED      # Trying again, but with a different seed . . .
echo "Random seed = $SEED"
random_numbers    # . . . gives a different number series.

echo; echo

# RANDOM=$$  seeds RANDOM from process id of script.
# It is also possible to seed RANDOM from 'time' or 'date' commands.

# Getting fancy...
SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }'| sed s/^0*//)
#  Pseudo-random output fetched
#+ from /dev/urandom (system pseudo-random device-file),
#+ then converted to line of printable (octal) numbers by "od",
#+ then "awk" retrieves just one number for SEED,
#+ finally "sed" removes any leading zeros.
RANDOM=$SEED
echo "Random seed = $SEED"
random_numbers

echo; echo

exit 0
</programlisting>
	</example>

	<para><anchor xml:id="urandomref" /></para>
	<note>
	<para>The <filename>/dev/urandom</filename> pseudo-device file
	  provides a method of generating much more <quote>random</quote>
	  pseudorandom numbers than the <varname>$RANDOM</varname>
	  variable.  <userinput>dd if=/dev/urandom of=targetfile
	  bs=1 count=XX</userinput> creates a file of well-scattered
	  pseudorandom numbers.  However, assigning these numbers
	  to a variable in a script requires a workaround, such
	  as filtering through <link linkend="odref">od</link>
	  (as in above example, <xref linkend="rnd" />, and
	  <xref linkend="insertionsort" />), or even piping to
	  <link linkend="md5sumref">md5sum</link> (see <xref linkend="horserace" />).</para>

        <para><anchor xml:id="awkrandomref" /></para>
	  
        <para>There are also other ways to generate pseudorandom
          numbers in a script. <command>Awk</command> provides a
	  convenient means of doing this.</para>

	    <example xml:id="random2">
	      <title>Pseudorandom numbers, using <link linkend="awkref">awk</link></title>
	      <programlisting>#!/bin/bash
#  random2.sh: Returns a pseudorandom number in the range 0 - 1,
#+ to 6 decimal places. For example: 0.822725
#  Uses the awk rand() function.

AWKSCRIPT=' { srand(); print rand() } '
#           Command(s)/parameters passed to awk
# Note that srand() reseeds awk's random number generator.


echo -n "Random number between 0 and 1 = "

echo | awk "$AWKSCRIPT"
# What happens if you leave out the 'echo'?

exit 0


# Exercises:
# ---------

# 1) Using a loop construct, print out 10 different random numbers.
#      (Hint: you must reseed the srand() function with a different seed
#+     in each pass through the loop. What happens if you omit this?)

# 2) Using an integer multiplier as a scaling factor, generate random numbers 
#+   in the range of 10 to 100.

# 3) Same as exercise #2, above, but generate random integers this time.
</programlisting>
	    </example>

	<para>The <link linkend="dateref">date</link> command also lends
	  itself to <link linkend="daterandref">generating pseudorandom
	  integer sequences</link>.</para>

	  </note>



      </section> <!-- RANDOM: generate random integer -->


      

  </chapter> <!-- Variables Revisited -->



    <chapter xml:id="manipulatingvars">
      <title>Manipulating Variables</title>

      <section xml:id="String-Manipulation">
        <title>Manipulating Strings</title>

            <para><anchor xml:id="stringmanip" /></para> 

	    <para>Bash supports a surprising number of string manipulation
	      operations.  Unfortunately, these tools lack
	      a unified focus. Some are a subset of <link linkend="paramsubref">parameter substitution</link>, and
	      others fall under the functionality of the UNIX <link linkend="exprref">expr</link> command. This results in
	      inconsistent command syntax and overlap of functionality,
	      not to mention confusion.</para>

      <variablelist xml:id="stringlength">
        <title>String Length</title>

	<varlistentry>
	  <term>${#string}</term>
	  <listitem>
	  <indexterm>
	    <primary>string length</primary>
	    <secondary>parameter substitution</secondary>
	  </indexterm>

            <para />
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr length $string</term>
	  <listitem>
	  <indexterm>
	    <primary>string length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

          <para><anchor xml:id="strlen" />These are the equivalent of
            <firstterm>strlen()</firstterm> in
            <firstterm>C</firstterm>.</para></listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '.*'</term>
	  <listitem>
	  <indexterm>
	    <primary>string length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <para>
	  <programlisting>stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringZ`      # 15
echo `expr "$stringZ" : '.*'`    # 15</programlisting>
	  </para>
	  </listitem>

	</varlistentry>

      </variablelist>

	    <example xml:id="paragraphspace">
	      <title>Inserting a blank line between paragraphs in a text file</title>
	      <programlisting>#!/bin/bash
# paragraph-space.sh
# Ver. 2.1, Reldate 29Jul12 [fixup]

# Inserts a blank line between paragraphs of a single-spaced text file.
# Usage: $0 &lt;FILENAME

MINLEN=60        # Change this value? It's a judgment call.
#  Assume lines shorter than $MINLEN characters ending in a period
#+ terminate a paragraph. See exercises below.

while read line  # For as many lines as the input file has ...
do
  echo "$line"   # Output the line itself.

  len=${#line}
  if [[ "$len" -lt "$MINLEN" &amp;&amp; "$line" =~ [*{\.}]$ ]]
# if [[ "$len" -lt "$MINLEN" &amp;&amp; "$line" =~ \[*\.\] ]]
# An update to Bash broke the previous version of this script. Ouch!
# Thank you, Halim Srama, for pointing this out and suggesting a fix.
    then echo    #  Add a blank line immediately
  fi             #+ after a short line terminated by a period.
done

exit

# Exercises:
# ---------
#  1) The script usually inserts a blank line at the end
#+    of the target file. Fix this.
#  2) Line 17 only considers periods as sentence terminators.
#     Modify this to include other common end-of-sentence characters,
#+    such as ?, !, and ".
</programlisting>
	    </example>

      <variablelist xml:id="lengthsubstring">
        <title>Length of Matching Substring at Beginning of String</title>
	
	<varlistentry>
	  <term><anchor id="exprmatch" />expr match "$string"
	  '$substring'</term>
	  <listitem>
	  <indexterm>
	    <primary>substring length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <para><replaceable>$substring</replaceable> is a <link linkend="regexref">regular expression</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '$substring'</term>
	  <listitem>
	  <indexterm>
	    <primary>substring length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <para><replaceable>$substring</replaceable> is a regular
	    expression.</para>
	  <para>

	  <programlisting>stringZ=abcABC123ABCabc
#       |------|
#       12345678

echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8</programlisting>
          </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="substringindex">
        <title>Index</title>

	<varlistentry>
	  <term><anchor id="substringindex2" />expr index $string
	    $substring</term>
	  <listitem>
	  <indexterm>
	    <primary>substring index</primary>
	    <secondary>expr</secondary>
	  </indexterm>


	  <para>Numerical position in $string of first character in 
	    $substring that matches.</para>

	  <para><programlisting>stringZ=abcABC123ABCabc
#       123456 ...
echo `expr index "$stringZ" C12`             # 6
                                             # C position.

echo `expr index "$stringZ" 1c`              # 3
# 'c' (in #3 position) matches before '1'.</programlisting></para>

	  <para>This is the near equivalent of
            <firstterm>strchr()</firstterm> in
            <firstterm>C</firstterm>.</para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="substringextraction">
        <title>Substring Extraction</title>

	<varlistentry>
	  <term><anchor id="substrextr01" />${string:position}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>extraction</secondary>
	  </indexterm>

	  <para>Extracts substring from <replaceable>$string</replaceable> at
	    <replaceable>$position</replaceable>.</para>
	  <para>If the <varname>$string</varname> parameter is
	    <quote><token>*</token></quote>
	    or <quote><token>@</token></quote>, then this extracts the
	    <link linkend="posparamref">positional parameters</link>,
	       <footnote><para>This applies to either command-line
	       arguments or parameters passed to a <link linkend="functionref">function</link>.</para></footnote>
	    starting at <varname>$position</varname>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="substrextr02" />${string:position:length}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>extraction</secondary>
	  </indexterm>

	  <para>Extracts <replaceable>$length</replaceable> characters
	    of substring from <replaceable>$string</replaceable> at
	    <replaceable>$position</replaceable>.</para>
	  <para>
	  <programlisting>stringZ=abcABC123ABCabc
#       0123456789.....
#       0-based indexing.

echo ${stringZ:0}                            # abcABC123ABCabc
echo ${stringZ:1}                            # bcABC123ABCabc
echo ${stringZ:7}                            # 23ABCabc

echo ${stringZ:7:3}                          # 23A
                                             # Three characters of substring.



# Is it possible to index from the right end of the string?
    
echo ${stringZ:-4}                           # abcABC123ABCabc
# Defaults to full string, as in ${parameter:-default}.
# However . . .

echo ${stringZ:(-4)}                         # Cabc 
echo ${stringZ: -4}                          # Cabc
# Now, it works.
# Parentheses or added space "escape" the position parameter.

# Thank you, Dan Jacobson, for pointing this out.</programlisting>
	  </para>

          <para>The <firstterm>position</firstterm> and
             <firstterm>length</firstterm> arguments can be
	     <quote>parameterized,</quote> that is, represented as a
	     variable, rather than as a numerical constant.</para>

	    <para><anchor xml:id="randstring0" /></para>
	    <example xml:id="randstring">
	      <title>Generating an 8-character <quote>random</quote>
	        string</title>
	      <programlisting>#!/bin/bash
# rand-string.sh
# Generating an 8-character "random" string.

if [ -n "$1" ]  #  If command-line argument present,
then            #+ then set start-string to it.
  str0="$1"
else            #  Else use PID of script as start-string.
  str0="$$"
fi

POS=2  # Starting from position 2 in the string.
LEN=8  # Extract eight characters.

str1=$( echo "$str0" | md5sum | md5sum )
#  Doubly scramble     ^^^^^^   ^^^^^^
#+ by piping and repiping to md5sum.

randstring="${str1:$POS:$LEN}"
# Can parameterize ^^^^ ^^^^

echo "$randstring"

exit $?

# bozo$ ./rand-string.sh my-password
# 1bdd88c4

#  No, this is not recommended
#+ as a method of generating hack-proof passwords.
</programlisting>
	    </example>

          <para><anchor xml:id="substrextrp" /></para>
	  <para>If the <varname>$string</varname> parameter is
	    <quote><token>*</token></quote> or
	    <quote><token>@</token></quote>, then this extracts a maximum
	    of <varname>$length</varname> positional parameters, starting
	    at <varname>$position</varname>.</para>

	  <para>
	  <programlisting>echo ${*:2}          # Echoes second and following positional parameters.
echo ${@:2}          # Same as above.

echo ${*:2:3}        # Echoes three positional parameters, starting at second.</programlisting>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr substr $string $position $length</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>extraction expr</secondary>
	  </indexterm>

	  
	  <para>Extracts <replaceable>$length</replaceable> characters
	    from <replaceable>$string</replaceable> starting at
	    <replaceable>$position</replaceable>.</para>
	  
	  <para>
	  <programlisting>stringZ=abcABC123ABCabc
#       123456789......
#       1-based indexing.

echo `expr substr $stringZ 1 2`              # ab
echo `expr substr $stringZ 4 3`              # ABC</programlisting>
          </para>

	  <para><anchor xml:id="exprparen" /></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr match "$string" '\($substring\)'</term>
	  <listitem>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <para>Extracts <replaceable>$substring</replaceable>
	    at beginning of <replaceable>$string</replaceable>,
	    where <replaceable>$substring</replaceable> is a <link linkend="regexref">regular expression</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '\($substring\)'</term>
	  <listitem>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>


	  <para>Extracts <replaceable>$substring</replaceable>
	    at beginning of <replaceable>$string</replaceable>,
	    where <replaceable>$substring</replaceable> is a regular
	    expression.</para>

	    <para>
	    <programlisting>stringZ=abcABC123ABCabc
#       =======	    

echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
# All of the above forms give an identical result.</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr match "$string" '.*\($substring\)'</term>
	  <listitem>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <para>Extracts <replaceable>$substring</replaceable>
	    at <emphasis>end</emphasis> of
	    <replaceable>$string</replaceable>, where
	    <replaceable>$substring</replaceable> is a regular
	    expression.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '.*\($substring\)'</term>
	  <listitem>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>


	  <para>Extracts <replaceable>$substring</replaceable>
	    at <emphasis>end</emphasis> of <replaceable>$string</replaceable>,
	    where <replaceable>$substring</replaceable> is a regular
	    expression.</para>

	    <para>
	    <programlisting>stringZ=abcABC123ABCabc
#                ======

echo `expr match "$stringZ" '.*\([A-C][A-C][A-C][a-c]*\)'`    # ABCabc
echo `expr "$stringZ" : '.*\(......\)'`                       # ABCabc</programlisting>

	    </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="substringremoval">
        <title>Substring Removal</title>
	
	<varlistentry>
	  <term>${string#substring}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>

	  <para>Deletes shortest match of
	    <replaceable>$substring</replaceable> from
	    <emphasis>front</emphasis> of
	    <replaceable>$string</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string##substring}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>


	  <para>Deletes longest match of
	    <replaceable>$substring</replaceable> from
	    <emphasis>front</emphasis> of
	    <replaceable>$string</replaceable>.</para>

	  <para>  
	  <programlisting>stringZ=abcABC123ABCabc
#       |----|          shortest
#       |----------|    longest

echo ${stringZ#a*C}      # 123ABCabc
# Strip out shortest match between 'a' and 'C'.

echo ${stringZ##a*C}     # abc
# Strip out longest match between 'a' and 'C'.



# You can parameterize the substrings.

X='a*C'

echo ${stringZ#$X}      # 123ABCabc
echo ${stringZ##$X}     # abc
                        # As above.</programlisting>
	  </para>  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string%substring}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>


	  <para>Deletes shortest match of
	    <replaceable>$substring</replaceable> from
	    <emphasis>back</emphasis> of
	    <replaceable>$string</replaceable>.</para>

	  <para>For example:
	    <programlisting># Rename all filenames in $PWD with "TXT" suffix to a "txt" suffix.
# For example, "file1.TXT" becomes "file1.txt" . . .

SUFF=TXT
suff=txt

for i in $(ls *.$SUFF)
do
  mv -f $i ${i%.$SUFF}.$suff
  #  Leave unchanged everything *except* the shortest pattern match
  #+ starting from the right-hand-side of the variable $i . . .
done ### This could be condensed into a "one-liner" if desired.

# Thank you, Rory Winston.</programlisting>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string%%substring}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>


	  <para>Deletes longest match of
	    <replaceable>$substring</replaceable> from
	    <emphasis>back</emphasis> of
	    <replaceable>$string</replaceable>.</para>

	  <para>  
	  <programlisting>stringZ=abcABC123ABCabc
#                    ||     shortest
#        |------------|     longest

echo ${stringZ%b*c}      # abcABC123ABCa
# Strip out shortest match between 'b' and 'c', from back of $stringZ.

echo ${stringZ%%b*c}     # a
# Strip out longest match between 'b' and 'c', from back of $stringZ.</programlisting>
	  </para>  

	  <para>This operator is useful for generating filenames.</para>

	    <example xml:id="cvt">
	      <title>Converting graphic file formats, with filename change</title>
	      <programlisting>#!/bin/bash
#  cvt.sh:
#  Converts all the MacPaint image files in a directory to "pbm" format.

#  Uses the "macptopbm" binary from the "netpbm" package,
#+ which is maintained by Brian Henderson (bryanh@giraffe-data.com).
#  Netpbm is a standard part of most Linux distros.

OPERATION=macptopbm
SUFFIX=pbm          # New filename suffix. 

if [ -n "$1" ]
then
  directory=$1      # If directory name given as a script argument...
else
  directory=$PWD    # Otherwise use current working directory.
fi  
  
#  Assumes all files in the target directory are MacPaint image files,
#+ with a ".mac" filename suffix.

for file in $directory/*    # Filename globbing.
do
  filename=${file%.*c}      #  Strip ".mac" suffix off filename
                            #+ ('.*c' matches everything
			    #+ between '.' and 'c', inclusive).
  $OPERATION $file &gt; "$filename.$SUFFIX"
                            # Redirect conversion to new filename.
  rm -f $file               # Delete original files after converting.   
  echo "$filename.$SUFFIX"  # Log what is happening to stdout.
done

exit 0

# Exercise:
# --------
#  As it stands, this script converts *all* the files in the current
#+ working directory.
#  Modify it to work *only* on files with a ".mac" suffix.



# *** And here's another way to do it. *** #

#!/bin/bash
# Batch convert into different graphic formats.
# Assumes imagemagick installed (standard in most Linux distros).

INFMT=png   # Can be tif, jpg, gif, etc.
OUTFMT=pdf  # Can be tif, jpg, gif, pdf, etc.

for pic in *"$INFMT"
do
  p2=$(ls "$pic" | sed -e s/\.$INFMT//)
  # echo $p2
    convert "$pic" $p2.$OUTFMT
    done

exit $?
</programlisting>
	    </example>

	    <example xml:id="ra2ogg">
	      <title>Converting streaming audio files to
	      <firstterm>ogg</firstterm></title>
	      <programlisting>#!/bin/bash
# ra2ogg.sh: Convert streaming audio files (*.ra) to ogg.

# Uses the "mplayer" media player program:
#      http://www.mplayerhq.hu/homepage
# Uses the "ogg" library and "oggenc":
#      http://www.xiph.org/
#
# This script may need appropriate codecs installed, such as sipr.so ...
# Possibly also the compat-libstdc++ package.


OFILEPREF=${1%%ra}      # Strip off the "ra" suffix.
OFILESUFF=wav           # Suffix for wav file.
OUTFILE="$OFILEPREF""$OFILESUFF"
E_NOARGS=85

if [ -z "$1" ]          # Must specify a filename to convert.
then
  echo "Usage: `basename $0` [filename]"
  exit $E_NOARGS
fi


##########################################################################
mplayer "$1" -ao pcm:file=$OUTFILE
oggenc "$OUTFILE"  # Correct file extension automatically added by oggenc.
##########################################################################

rm "$OUTFILE"      # Delete intermediate *.wav file.
                   # If you want to keep it, comment out above line.

exit $?

#  Note:
#  ----
#  On a Website, simply clicking on a *.ram streaming audio file
#+ usually only downloads the URL of the actual *.ra audio file.
#  You can then use "wget" or something similar
#+ to download the *.ra file itself.


#  Exercises:
#  ---------
#  As is, this script converts only *.ra filenames.
#  Add flexibility by permitting use of *.ram and other filenames.
#
#  If you're really ambitious, expand the script
#+ to do automatic downloads and conversions of streaming audio files.
#  Given a URL, batch download streaming audio files (using "wget")
#+ and convert them on the fly.
</programlisting>
	    </example>

	  <para><anchor xml:id="getoptsimple1" /></para>
	  <para>A simple emulation of <link linkend="getopty">getopt</link>
	    using substring-extraction constructs.</para>

	    <example xml:id="getoptsimple">
	      <title>Emulating <firstterm>getopt</firstterm></title>
	      <programlisting>#!/bin/bash
# getopt-simple.sh
# Author: Chris Morgan
# Used in the ABS Guide with permission.


getopt_simple()
{
    echo "getopt_simple()"
    echo "Parameters are '$*'"
    until [ -z "$1" ]
    do
      echo "Processing parameter of: '$1'"
      if [ ${1:0:1} = '/' ]
      then
          tmp=${1:1}               # Strip off leading '/' . . .
          parameter=${tmp%%=*}     # Extract name.
          value=${tmp##*=}         # Extract value.
          echo "Parameter: '$parameter', value: '$value'"
          eval $parameter=$value
      fi
      shift
    done
}

# Pass all options to getopt_simple().
getopt_simple $*

echo "test is '$test'"
echo "test2 is '$test2'"

exit 0  # See also, UseGetOpt.sh, a modified version of this script.

---

sh getopt_example.sh /test=value1 /test2=value2

Parameters are '/test=value1 /test2=value2'
Processing parameter of: '/test=value1'
Parameter: 'test', value: 'value1'
Processing parameter of: '/test2=value2'
Parameter: 'test2', value: 'value2'
test is 'value1'
test2 is 'value2'

</programlisting>
	    </example>



	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist xml:id="substringreplacement">
        <title>Substring Replacement</title>

	<varlistentry>
	  <term><anchor id="substrrepl00" />${string/substring/replacement}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>

	  <para>
	    Replace first <firstterm>match</firstterm> of
	    <replaceable>$substring</replaceable> with
	    <replaceable>$replacement</replaceable>.
	      <footnote><para>Note that
	      <replaceable>$substring</replaceable> and
	      <replaceable>$replacement</replaceable> may refer to
	      either <firstterm>literal strings</firstterm> or
	      <firstterm>variables</firstterm>, depending on
	      context. See the first usage example.</para></footnote>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="substrrepl01" />${string//substring/replacement}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>


	  <para>Replace all matches of
	    <replaceable>$substring</replaceable> with
	    <replaceable>$replacement</replaceable>.</para>

	  <para>  
	  <programlisting>stringZ=abcABC123ABCabc

echo ${stringZ/abc/xyz}       # xyzABC123ABCabc
                              # Replaces first match of 'abc' with 'xyz'.

echo ${stringZ//abc/xyz}      # xyzABC123ABCxyz
                              # Replaces all matches of 'abc' with # 'xyz'.

echo  ---------------
echo "$stringZ"               # abcABC123ABCabc
echo  ---------------
                              # The string itself is not altered!

# Can the match and replacement strings be parameterized?
match=abc
repl=000
echo ${stringZ/$match/$repl}  # 000ABC123ABCabc
#              ^      ^         ^^^
echo ${stringZ//$match/$repl} # 000ABC123ABC000
# Yes!          ^      ^        ^^^         ^^^

echo

# What happens if no $replacement string is supplied?
echo ${stringZ/abc}           # ABC123ABCabc
echo ${stringZ//abc}          # ABC123ABC
# A simple deletion takes place.</programlisting>
	  </para>  

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="substrrepl02" />${string/#substring/replacement}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>

	  <para>If <replaceable>$substring</replaceable> matches
	    <emphasis>front</emphasis> end of
	    <replaceable>$string</replaceable>, substitute
	    <replaceable>$replacement</replaceable> for
	    <replaceable>$substring</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="substrrepl03" />${string/%substring/replacement}</term>
	  <listitem>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>


	  <para>If <replaceable>$substring</replaceable> matches
	    <emphasis>back</emphasis> end of
	    <replaceable>$string</replaceable>, substitute
	    <replaceable>$replacement</replaceable> for
	    <replaceable>$substring</replaceable>.</para>

	  <para>  
          <programlisting>stringZ=abcABC123ABCabc

echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                  # Replaces front-end match of 'abc' with 'XYZ'.

echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                  # Replaces back-end match of 'abc' with 'XYZ'.</programlisting>
	  </para>  

	  </listitem>
	</varlistentry>

      </variablelist>

    <section xml:id="awkstringmanip">
      <title>Manipulating strings using awk</title>

	  <para><anchor xml:id="awkstringmanip2" /></para>
          <para>A Bash script may invoke the string manipulation facilities of
	    <link linkend="awkref">awk</link> as an alternative to using its
	    built-in operations.</para>

	    <example xml:id="substringex">
	      <title>Alternate ways of extracting and locating substrings</title>
	      <programlisting>#!/bin/bash
# substring-extraction.sh

String=23skidoo1
#      012345678    Bash
#      123456789    awk
# Note different string indexing system:
# Bash numbers first character of string as 0.
# Awk  numbers first character of string as 1.

echo ${String:2:4} # position 3 (0-1-2), 4 characters long
                                         # skid

# The awk equivalent of ${string:pos:length} is substr(string,pos,length).
echo | awk '
{ print substr("'"${String}"'",3,4)      # skid
}
'
#  Piping an empty "echo" to awk gives it dummy input,
#+ and thus makes it unnecessary to supply a filename.

echo "----"

# And likewise:

echo | awk '
{ print index("'"${String}"'", "skid")      # 3
}                                           # (skid starts at position 3)
'   # The awk equivalent of "expr index" ...

exit 0
</programlisting>
	    </example>

    </section> <!-- Manipulating strings using awk -->



    <section xml:id="strfdisc">
      <title>Further Reference</title>
   
     <para>For more on string manipulation in scripts, refer to <xref linkend="Parameter-Substitution" /> and the
       <link linkend="expextrsub">relevant section</link> of the <link linkend="exprref">expr</link> command listing.</para>
       
     <para>Script examples:
      <orderedlist>
         <listitem><para><xref linkend="ex45" /></para></listitem>
	 <listitem><para><xref linkend="length" /></para></listitem>
	 <listitem><para><xref linkend="pattmatching" /></para></listitem>
         <listitem><para><xref linkend="rfe" /></para></listitem>
         <listitem><para><xref linkend="varmatch" /></para></listitem>
         <listitem><para><xref linkend="insertionsort" /></para></listitem>
         <listitem><para><xref linkend="qky" /></para></listitem>
        </orderedlist>
      </para>	 

    </section> <!-- Further Reference-->
    

    </section> <!-- Manipulating Strings -->



    <section xml:id="Parameter-Substitution">
      <title>Parameter Substitution</title>

            <para><anchor xml:id="paramsubref" /></para> 

            <variablelist xml:id="pssub">
	      <title><anchor xml:id="pssub1" />Manipulating and/or expanding variables</title>
	      <varlistentry>
		<term>
		  <userinput moreinfo="none">${parameter}</userinput></term>
		<listitem>

		<para>Same as <replaceable>$parameter</replaceable>, i.e.,
		  value of the variable
		  <replaceable>parameter</replaceable>.
		  In certain contexts, only the less ambiguous
		  <replaceable>${parameter}</replaceable> form
		  works.</para>

		<para>May be used for concatenating variables with strings.</para>

	        <para><programlisting>
your_id=${USER}-on-${HOSTNAME}
echo "$your_id"
#
echo "Old \$PATH = $PATH"
PATH=${PATH}:/opt/bin  # Add /opt/bin to $PATH for duration of script.
echo "New \$PATH = $PATH"
</programlisting></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><anchor id="defparam1" /><userinput moreinfo="none">${parameter-default}</userinput></term>
		<term><userinput moreinfo="none">${parameter:-default}</userinput></term>
		<listitem>
		<para>If parameter not set, use default.</para>
		<para><programlisting>var1=1
var2=2
# var3 is unset.

echo ${var1-$var2}   # 1
echo ${var3-$var2}   # 2
#           ^          Note the $ prefix.



echo ${username-`whoami`}
# Echoes the result of `whoami`, if variable $username is still unset.</programlisting></para>

		<note><para><anchor xml:id="unddr" /><replaceable>${parameter-default}</replaceable>
		  and <replaceable>${parameter:-default}</replaceable>
		  are almost equivalent. The extra <token>:</token> makes
		  a difference only when <parameter>parameter</parameter>
		  has been declared, but is null.  </para></note>

		<para><programlisting>#!/bin/bash
# param-sub.sh

#  Whether a variable has been declared
#+ affects triggering of the default option
#+ even if the variable is null.

username0=
echo "username0 has been declared, but is set to null."
echo "username0 = ${username0-`whoami`}"
# Will not echo.

echo

echo username1 has not been declared.
echo "username1 = ${username1-`whoami`}"
# Will echo.

username2=
echo "username2 has been declared, but is set to null."
echo "username2 = ${username2:-`whoami`}"
#                            ^
# Will echo because of :- rather than just - in condition test.
# Compare to first instance, above.


#

# Once again:

variable=
# variable has been declared, but is set to null.

echo "${variable-0}"    # (no output)
echo "${variable:-1}"   # 1
#               ^

unset variable

echo "${variable-2}"    # 2
echo "${variable:-3}"   # 3

exit 0
</programlisting></para>

		<para>The <firstterm>default parameter</firstterm> construct
		  finds use in providing <quote>missing</quote> command-line
		  arguments in scripts.</para>

		<para>
		  <programlisting>DEFAULT_FILENAME=generic.data
filename=${1:-$DEFAULT_FILENAME}
#  If not otherwise specified, the following command block operates
#+ on the file "generic.data".
#  Begin-Command-Block
#  ...
#  ...
#  ...
#  End-Command-Block



#  From "hanoi2.bash" example:
DISKS=${1:-E_NOPARAM}   # Must specify how many disks.
#  Set $DISKS to $1 command-line-parameter,
#+ or to $E_NOPARAM if that is unset.</programlisting>
		</para>

		<para>See also <xref linkend="ex58" />, <xref linkend="ex73" />, and <xref linkend="collatz" />.</para>

                <para>Compare this method with <link linkend="anddefault">using an <firstterm>and
		  list</firstterm> to supply a default command-line
		  argument</link>.</para>

		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput moreinfo="none">${parameter=default}</userinput></term>
		<term><userinput moreinfo="none">${parameter:=default}</userinput></term>
		<listitem>
		<para><anchor xml:id="defparam" /></para>
		<para>If parameter not set, set it to
		  <firstterm>default</firstterm>.</para>

		<para>Both forms nearly equivalent. The <token>:</token>
		  makes a difference only when <varname>$parameter</varname>
		  has been declared and is null,
		    <footnote>
		    <para>If $parameter is null in a
		      non-interactive script, it will terminate with a <link linkend="exitcodesref"><returnvalue>127</returnvalue>
		      exit status</link> (the Bash error code for
		      <quote>command not found</quote>).</para>
		      </footnote>
		  as above.
		    </para>

		    <para><programlisting>echo ${var=abc}   # abc
echo ${var=xyz}   # abc
# $var had already been set to abc, so it did not change.</programlisting></para>
	      </listitem>
	      </varlistentry>

	      <varlistentry>
		<term><anchor id="paramaltv" /><userinput moreinfo="none">${parameter+alt_value}</userinput></term>
		<term><userinput moreinfo="none">${parameter:+alt_value}</userinput></term>
		<listitem>
		  <para>If parameter set, use
		    <userinput>alt_value</userinput>, else use null
		    string.</para>

		  <para>Both forms nearly equivalent. The <token>:</token>
		    makes a difference only when
		    <parameter>parameter</parameter>
		    has been declared and is null, see below.</para>

		  <para><programlisting>echo "###### \${parameter+alt_value} ########"
echo

a=${param1+xyz}
echo "a = $a"      # a =

param2=
a=${param2+xyz}
echo "a = $a"      # a = xyz

param3=123
a=${param3+xyz}
echo "a = $a"      # a = xyz

echo
echo "###### \${parameter:+alt_value} ########"
echo

a=${param4:+xyz}
echo "a = $a"      # a =

param5=
a=${param5:+xyz}
echo "a = $a"      # a =
# Different result from   a=${param5+xyz}

param6=123
a=${param6:+xyz}
echo "a = $a"      # a = xyz</programlisting></para>

		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><anchor id="qerrmsg" /><userinput moreinfo="none">${parameter?err_msg}</userinput></term>
		<term><userinput moreinfo="none">${parameter:?err_msg}</userinput></term>
		<listitem><para>If parameter set, use it, else print
                <firstterm>err_msg</firstterm> and <emphasis>abort
                the script</emphasis> with an <link linkend="exitstatusref">exit status</link> of
                <errorcode>1</errorcode>.</para>

		<para>Both forms nearly equivalent. The <token>:</token>
		  makes a difference only when <parameter>parameter</parameter>
		  has been declared and is null, as above.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example xml:id="ex6">
	      <title>Using parameter substitution and error messages</title>
	      <programlisting>#!/bin/bash

#  Check some of the system's environmental variables.
#  This is good preventative maintenance.
#  If, for example, $USER, the name of the person at the console, is not set,
#+ the machine will not recognize you.

: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo "Name of the machine is $HOSTNAME."
  echo "You are $USER."
  echo "Your home directory is $HOME."
  echo "Your mail INBOX is located in $MAIL."
  echo
  echo "If you are reading this message,"
  echo "critical environmental variables have been set."
  echo
  echo

# ------------------------------------------------------

#  The ${variablename?} construction can also check
#+ for variables set within the script.

ThisVariable=Value-of-ThisVariable
#  Note, by the way, that string variables may be set
#+ to characters disallowed in their names.
: ${ThisVariable?}
echo "Value of ThisVariable is $ThisVariable".

echo; echo


: ${ZZXy23AB?"ZZXy23AB has not been set."}
#  Since ZZXy23AB has not been set,
#+ then the script terminates with an error message.

# You can specify the error message.
# : ${variablename?"ERROR MESSAGE"}


# Same result with:   dummy_variable=${ZZXy23AB?}
#                     dummy_variable=${ZZXy23AB?"ZXy23AB has not been set."}
#
#                     echo ${ZZXy23AB?} &gt;/dev/null

#  Compare these methods of checking whether a variable has been set
#+ with "set -u" . . .



echo "You will not see this message, because script already terminated."

HERE=0
exit $HERE   # Will NOT exit here.

# In fact, this script will return an exit status (echo $?) of 1.
</programlisting>
	    </example>

	    <example xml:id="usagemessage">
	      <title>Parameter substitution and <quote>usage</quote> messages</title>
	      <programlisting>#!/bin/bash
# usage-message.sh

: ${1?"Usage: $0 ARGUMENT"}
#  Script exits here if command-line parameter absent,
#+ with following error message.
#    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT

echo "These two lines echo only if command-line parameter given."
echo "command-line parameter = \"$1\""

exit 0  # Will exit here only if command-line parameter present.

# Check the exit status, both with and without command-line parameter.
# If command-line parameter present, then "$?" is 0.
# If not, then "$?" is 1.
</programlisting>
	    </example>

	    
	    
            <formalpara><title>Parameter substitution and/or expansion</title>
	      
	      <para><anchor xml:id="psub2" />The following expressions are
		the complement to the <command>match</command>
		<replaceable>in</replaceable> <command>expr</command>
		string operations (see <xref linkend="ex45" />).
		These particular ones are used mostly in parsing file
		path names.</para></formalpara>

	    <variablelist xml:id="psorex">
              <title><anchor xml:id="psorex1" />Variable length / Substring removal</title>

	      <varlistentry>

		<term><userinput moreinfo="none">${#var}</userinput></term>
		<listitem>
		  <para><userinput>String length</userinput> (number
		    of characters in <varname>$var</varname>). For
		    an <link linkend="arrayref">array</link>,
		    <command>${#array}</command> is the length of the
		    first element in the array.</para>

		  <note><para>
		    Exceptions:

		  <itemizedlist>
		    <listitem>
		    <para><anchor xml:id="numposparam" /></para>
		    <para>
		      <command>${#*}</command> and
		      <command>${#@}</command> give the <emphasis>number
		      of positional parameters</emphasis>.
		    </para></listitem>
		  
		    <listitem><para>
		      For an array, <command>${#array[*]}</command> and
		      <command>${#array[@]}</command> give the number
		      of elements in the array.
		    </para></listitem>
		  </itemizedlist>
		  </para></note>

	      <example xml:id="length">
	        <title>Length of a variable</title>
	        <programlisting>#!/bin/bash
# length.sh

E_NO_ARGS=65

if [ $# -eq 0 ]  # Must have command-line args to demo script.
then
  echo "Please invoke this script with one or more command-line arguments."
  exit $E_NO_ARGS
fi  

var01=abcdEFGH28ij
echo "var01 = ${var01}"
echo "Length of var01 = ${#var01}"
# Now, let's try embedding a space.
var02="abcd EFGH28ij"
echo "var02 = ${var02}"
echo "Length of var02 = ${#var02}"

echo "Number of command-line arguments passed to script = ${#@}"
echo "Number of command-line arguments passed to script = ${#*}"

exit 0
</programlisting>
	      </example>	    

		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><anchor id="psorex2" /><userinput moreinfo="none">${var#Pattern}</userinput></term>
		<term><userinput moreinfo="none">${var##Pattern}</userinput></term>

		<listitem>

		<para><anchor xml:id="psorexsh" /></para>
		<para><command>${var#Pattern} </command>
		  Remove from <varname>$var</varname>
		  the <emphasis>shortest</emphasis> part of
		  <varname>$Pattern</varname> that matches
		  the <replaceable>front end</replaceable> of
		  <varname>$var</varname>.
		</para>

		<para><anchor xml:id="psorexlo" /></para>
		<para><command>${var##Pattern} </command>
		  Remove from <varname>$var</varname>
		  the <emphasis>longest</emphasis> part of
		  <varname>$Pattern</varname> that matches
		  the <replaceable>front end</replaceable> of
		  <varname>$var</varname>.
		</para>

		<para>A usage illustration from <xref linkend="daysbetween" />:
		<programlisting># Function from "days-between.sh" example.
# Strips leading zero(s) from argument passed.

strip_leading_zero () #  Strip possible leading zero(s)
{                     #+ from argument passed.
  return=${1#0}       #  The "1" refers to "$1" -- passed arg.
}                     #  The "0" is what to remove from "$1" -- strips zeros.</programlisting>
		</para>

		<para>Manfred Schwarb's more elaborate variation of the
			above:</para>

		<para>
<programlisting>strip_leading_zero2 () # Strip possible leading zero(s), since otherwise
{                      # Bash will interpret such numbers as octal values.
  shopt -s extglob     # Turn on extended globbing.
  local val=${1##+(0)} # Use local variable, longest matching series of 0's.
  shopt -u extglob     # Turn off extended globbing.
  _strip_leading_zero2=${val:-0}
                       # If input was 0, return 0 instead of "".
}</programlisting>
		</para>


		<para>Another usage illustration:</para>
		<para>
<programlisting>echo `basename $PWD`        # Basename of current working directory.
echo "${PWD##*/}"           # Basename of current working directory.
echo
echo `basename $0`          # Name of script.
echo $0                     # Name of script.
echo "${0##*/}"             # Name of script.
echo
filename=test.data
echo "${filename##*.}"      # data
                            # Extension of filename.</programlisting>
		</para>
		  
		  </listitem>

	      </varlistentry>
	      
	      <varlistentry>
		<term><anchor id="pctpatref" /><userinput moreinfo="none">${var%Pattern}</userinput></term>
		<term><userinput moreinfo="none">${var%%Pattern}</userinput></term>

		
		<listitem>
		
		<para><anchor xml:id="pctrep1" /></para>
		<para><command>${var%Pattern}</command>
		  Remove from <varname>$var</varname>
		  the <emphasis>shortest</emphasis> part of
		  <varname>$Pattern</varname> that matches
		  the <replaceable>back end</replaceable> of
		  <varname>$var</varname>.  </para>

		<para><anchor xml:id="pctrep2" /></para>
	        <para><command>${var%%Pattern}</command>
		  Remove from <varname>$var</varname>
		  the <emphasis>longest</emphasis> part of
		  <varname>$Pattern</varname> that matches
		  the <replaceable>back end</replaceable> of
		  <varname>$var</varname>.  </para>
		  
		  </listitem>


	      </varlistentry>
	    </variablelist>
	    
	    <para><link linkend="bash2ref">Version 2</link> of Bash added
	      additional options.</para>

	    <example xml:id="pattmatching">
	      <title>Pattern matching in parameter substitution</title>
	      <programlisting>#!/bin/bash
# patt-matching.sh

# Pattern matching  using the # ## % %% parameter substitution operators.

var1=abcd12345abc6789
pattern1=a*c  # * (wild card) matches everything between a - c.

echo
echo "var1 = $var1"           # abcd12345abc6789
echo "var1 = ${var1}"         # abcd12345abc6789
                              # (alternate form)
echo "Number of characters in ${var1} = ${#var1}"
echo

echo "pattern1 = $pattern1"   # a*c  (everything between 'a' and 'c')
echo "--------------"
echo '${var1#$pattern1}  =' "${var1#$pattern1}"    #         d12345abc6789
# Shortest possible match, strips out first 3 characters  abcd12345abc6789
#                                     ^^^^^               |-|
echo '${var1##$pattern1} =' "${var1##$pattern1}"   #                  6789      
# Longest possible match, strips out first 12 characters  abcd12345abc6789
#                                    ^^^^^                |----------|

echo; echo; echo

pattern2=b*9            # everything between 'b' and '9'
echo "var1 = $var1"     # Still  abcd12345abc6789
echo
echo "pattern2 = $pattern2"
echo "--------------"
echo '${var1%pattern2}  =' "${var1%$pattern2}"     #     abcd12345a
# Shortest possible match, strips out last 6 characters  abcd12345abc6789
#                                     ^^^^                         |----|
echo '${var1%%pattern2} =' "${var1%%$pattern2}"    #     a
# Longest possible match, strips out last 12 characters  abcd12345abc6789
#                                    ^^^^                 |-------------|

# Remember, # and ## work from the left end (beginning) of string,
#           % and %% work from the right end.

echo

exit 0
</programlisting>
	    </example>


	    <example xml:id="rfe">
	      <title>Renaming file extensions<token>:</token></title>
	      <programlisting>#!/bin/bash
# rfe.sh: Renaming file extensions.
#
#         rfe old_extension new_extension
#
# Example:
# To rename all *.gif files in working directory to *.jpg,
#          rfe gif jpg


E_BADARGS=65

case $# in
  0|1)             # The vertical bar means "or" in this context.
  echo "Usage: `basename $0` old_file_suffix new_file_suffix"
  exit $E_BADARGS  # If 0 or 1 arg, then bail out.
  ;;
esac


for filename in *.$1
# Traverse list of files ending with 1st argument.
do
  mv $filename ${filename%$1}$2
  #  Strip off part of filename matching 1st argument,
  #+ then append 2nd argument.
done

exit 0
</programlisting>
	    </example>

	    
	    <variablelist xml:id="exprepl">
	      <title><anchor xml:id="exprepl1" />Variable expansion / Substring
	      replacement</title>
	      
	      <varlistentry>
	      <term />
	      <listitem>
	        <para>These constructs have been adopted from
		  <firstterm>ksh</firstterm>.</para>
	      </listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput moreinfo="none">${var:pos}</userinput></term>
		<listitem>
		  <para>Variable <replaceable>var</replaceable> expanded,
		    starting from offset <replaceable>pos</replaceable>.
		  </para>
		  </listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput moreinfo="none">${var:pos:len}</userinput></term>
		<listitem>
		  <para>Expansion to a max of <replaceable>len</replaceable>
		    characters of variable <replaceable>var</replaceable>, from offset
		    <replaceable>pos</replaceable>. See <xref linkend="pw" />
		    for an example of the creative use of this operator.
		  </para>
		  </listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput moreinfo="none">${var/Pattern/Replacement}</userinput></term>
		<listitem>
		  <para>First match of <replaceable>Pattern</replaceable>,
		    within <replaceable>var</replaceable> replaced with
		    <replaceable>Replacement</replaceable>.</para>
		  <para>If <replaceable>Replacement</replaceable> is
		    omitted, then the first match of
		    <replaceable>Pattern</replaceable> is replaced by
		    <emphasis>nothing</emphasis>, that is, deleted.</para>
		  </listitem>  
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput moreinfo="none">${var//Pattern/Replacement}</userinput></term>
		<listitem>

                  <formalpara><title>Global replacement</title>
		  <para><anchor xml:id="psglob" />
		    All matches of <replaceable>Pattern</replaceable>,
		    within <replaceable>var</replaceable> replaced with
		    <replaceable>Replacement</replaceable>.</para>
		    </formalpara>

		  <para>As above, if <replaceable>Replacement</replaceable>
		    is omitted, then all occurrences of
		    <replaceable>Pattern</replaceable> are replaced by
		    <emphasis>nothing</emphasis>, that is, deleted.</para>
	    
	    <example xml:id="ex7">
	      <title>Using pattern matching to parse arbitrary strings</title>
	      <programlisting>#!/bin/bash

var1=abcd-1234-defg
echo "var1 = $var1"

t=${var1#*-*}
echo "var1 (with everything, up to and including first - stripped out) = $t"
#  t=${var1#*-}  works just the same,
#+ since # matches the shortest string,
#+ and * matches everything preceding, including an empty string.
# (Thanks, Stephane Chazelas, for pointing this out.)

t=${var1##*-*}
echo "If var1 contains a \"-\", returns empty string...   var1 = $t"


t=${var1%*-*}
echo "var1 (with everything from the last - on stripped out) = $t"

echo

# -------------------------------------------
path_name=/home/bozo/ideas/thoughts.for.today
# -------------------------------------------
echo "path_name = $path_name"
t=${path_name##/*/}
echo "path_name, stripped of prefixes = $t"
# Same effect as   t=`basename $path_name` in this particular case.
#  t=${path_name%/}; t=${t##*/}   is a more general solution,
#+ but still fails sometimes.
#  If $path_name ends with a newline, then `basename $path_name` will not work,
#+ but the above expression will.
# (Thanks, S.C.)

t=${path_name%/*.*}
# Same effect as   t=`dirname $path_name`
echo "path_name, stripped of suffixes = $t"
# These will fail in some cases, such as "../", "/foo////", # "foo/", "/".
#  Removing suffixes, especially when the basename has no suffix,
#+ but the dirname does, also complicates matters.
# (Thanks, S.C.)

echo

t=${path_name:11}
echo "$path_name, with first 11 chars stripped off = $t"
t=${path_name:11:5}
echo "$path_name, with first 11 chars stripped off, length 5 = $t"

echo

t=${path_name/bozo/clown}
echo "$path_name with \"bozo\" replaced  by \"clown\" = $t"
t=${path_name/today/}
echo "$path_name with \"today\" deleted = $t"
t=${path_name//o/O}
echo "$path_name with all o's capitalized = $t"
t=${path_name//o/}
echo "$path_name with all o's deleted = $t"

exit 0
</programlisting>
	    </example>

		  </listitem>
	      </varlistentry>	

	      <varlistentry>
		<term><userinput moreinfo="none">${var/#Pattern/Replacement}</userinput></term>
		<listitem>
		  <para>If <firstterm>prefix</firstterm> of
		  <replaceable>var</replaceable> matches
		  <replaceable>Pattern</replaceable>, then substitute
		  <replaceable>Replacement</replaceable> for
		  <replaceable>Pattern</replaceable>.</para>
		</listitem>
	      </varlistentry>	

	      <varlistentry>
		<term><userinput moreinfo="none">${var/%Pattern/Replacement}</userinput></term>
		<listitem>
		  <para>If <firstterm>suffix</firstterm> of
		  <replaceable>var</replaceable> matches
		  <replaceable>Pattern</replaceable>, then substitute
		  <replaceable>Replacement</replaceable> for
		  <replaceable>Pattern</replaceable>.</para>

	    <example xml:id="varmatch">
	      <title>Matching patterns at prefix or suffix of string</title>
	      <programlisting>#!/bin/bash
# var-match.sh:
# Demo of pattern replacement at prefix / suffix of string.

v0=abc1234zip1234abc    # Original variable.
echo "v0 = $v0"         # abc1234zip1234abc
echo

# Match at prefix (beginning) of string.
v1=${v0/#abc/ABCDEF}    # abc1234zip1234abc
                        # |-|
echo "v1 = $v1"         # ABCDEF1234zip1234abc
                        # |----|

# Match at suffix (end) of string.
v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                        #              |-|
echo "v2 = $v2"         # abc1234zip1234ABCDEF
                        #               |----|

echo

#  ----------------------------------------------------
#  Must match at beginning / end of string,
#+ otherwise no replacement results.
#  ----------------------------------------------------
v3=${v0/#123/000}       # Matches, but not at beginning.
echo "v3 = $v3"         # abc1234zip1234abc
                        # NO REPLACEMENT.
v4=${v0/%123/000}       # Matches, but not at end.
echo "v4 = $v4"         # abc1234zip1234abc
                        # NO REPLACEMENT.

exit 0			
</programlisting>
	    </example>

		</listitem>
	      </varlistentry>	

	      <varlistentry>
		<term><anchor id="varprefixm" /><userinput moreinfo="none">${!varprefix*}</userinput></term>
		<term><userinput moreinfo="none">${!varprefix@}</userinput></term>
		<listitem>
		  <para>Matches <emphasis>names</emphasis> of all
		  previously declared variables beginning
		    with <parameter>varprefix</parameter>.
		      <programlisting># This is a variation on indirect reference, but with a * or @.
# Bash, version 2.04, adds this feature.

xyz23=whatever
xyz24=

a=${!xyz*}         #  Expands to *names* of declared variables
# ^ ^   ^           + beginning with "xyz".
echo "a = $a"      #  a = xyz23 xyz24
a=${!xyz@}         #  Same as above.
echo "a = $a"      #  a = xyz23 xyz24

echo "---"

abc23=something_else
b=${!abc*}
echo "b = $b"      #  b = abc23
c=${!b}            #  Now, the more familiar type of indirect reference.
echo $c            #  something_else</programlisting>
                  </para>

		  </listitem>
	      </varlistentry>	

	    </variablelist>

    </section> <!-- Parameter Substitution -->

    </chapter> <!-- Manipulating Variables -->  



  <chapter xml:id="loops">
    <title>Loops and Branches</title>

    <epigraph>
      <para>What needs this iteration, woman?</para>
      <para>--Shakespeare, <replaceable>Othello</replaceable></para>
    </epigraph>


      <para><anchor xml:id="loopref00" /></para>
      <para>Operations on code blocks are the key to structured and organized
        shell scripts. Looping and branching constructs provide the tools for
	accomplishing this.</para>

      <section xml:id="loops1">
        <title>Loops</title>

      <para>A <firstterm>loop</firstterm> is a block of code that
	<firstterm>iterates</firstterm>

	  <footnote><para><anchor xml:id="iterationref" /><firstterm>Iteration</firstterm>:
	  Repeated execution of a command or group of commands, usually --
	  but not always, <firstterm>while</firstterm> a given condition
	  holds, or <firstterm>until</firstterm> a given condition is
	  met.</para></footnote>

	a list of commands
	as long as the <firstterm>loop control condition</firstterm>
	is true.</para>


      <variablelist xml:id="forloopref">
        <title><anchor xml:id="forloopref1" />for loops</title>

	<varlistentry>
	  <term><command moreinfo="none">for <parameter moreinfo="none">arg</parameter> in
	    <replaceable>[list]</replaceable></command></term>
	  <listitem>
	  <indexterm>
	    <primary>for</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>for</secondary>
	  </indexterm>
	    <para>This is the basic looping construct. It differs significantly
	      from its <firstterm>C</firstterm> counterpart.</para>

	    <para><anchor xml:id="doinref" /></para>

	    <para><cmdsynopsis sepchar=" ">
		<command>for</command>
		<arg choice="plain" rep="norepeat"><replaceable>arg</replaceable></arg>
		<arg choice="plain" rep="norepeat">in</arg>
		<arg choice="opt" rep="norepeat"><replaceable>list</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">do</arg><sbr />
		<arg rep="repeat" choice="plain"><replaceable>¬†command(s)</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">done</arg>
	      </cmdsynopsis></para>

            <note><para>During each pass through the loop,
	      <replaceable>arg</replaceable> takes on the
	      value of each successive variable in the
	      <replaceable>list</replaceable>.</para></note>

	    <para><programlisting>for arg in "$var1" "$var2" "$var3" ... "$varN"  
# In pass 1 of the loop, arg = $var1	    
# In pass 2 of the loop, arg = $var2	    
# In pass 3 of the loop, arg = $var3	    
# ...
# In pass N of the loop, arg = $varN

# Arguments in [list] quoted to prevent possible word splitting.</programlisting></para>

	    
	    <para>The argument <replaceable>list</replaceable> may
	    contain <link linkend="asteriskref">wild cards</link>.</para>

	    <para><anchor xml:id="needsemicolon" /></para>
	    <para>If <firstterm>do</firstterm> is on same line as
	      <firstterm>for</firstterm>, there needs to be a semicolon
	      after list.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>for</command>
		<arg choice="plain" rep="norepeat"><replaceable>arg</replaceable></arg>
		<arg choice="plain" rep="norepeat">in</arg>
		<arg choice="opt" rep="norepeat"><replaceable>list</replaceable></arg>
		<arg choice="plain" rep="norepeat">;</arg>
		<arg choice="plain" rep="norepeat">do</arg><sbr />
	      </cmdsynopsis></para>

	    <example xml:id="ex22">
	      <title>Simple <firstterm>for</firstterm> loops</title>
	      <programlisting>#!/bin/bash
# Listing the planets.

for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
do
  echo $planet  # Each planet on a separate line.
done

echo; echo

for planet in "Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
    # All planets on same line.
    # Entire 'list' enclosed in quotes creates a single variable.
    # Why? Whitespace incorporated into the variable.
do
  echo $planet
done

echo; echo "Whoops! Pluto is no longer a planet!"

exit 0
</programlisting>
	    </example>

            
	    <para><anchor xml:id="multparaml" /></para>
	    <para>Each <userinput>[list]</userinput> element
	      may contain multiple parameters. This is useful when
	      processing parameters in groups. In such cases,
	      use the <link linkend="setref">set</link> command
	      (see <xref linkend="ex34" />) to force parsing of each
	      <userinput>[list]</userinput> element and assignment of
	      each component to the positional parameters.</para>

	    <example xml:id="ex22a">
	      <title><firstterm>for</firstterm> loop with two parameters in each
	      [list] element</title>
	      <programlisting>#!/bin/bash
# Planets revisited.

# Associate the name of each planet with its distance from the sun.

for planet in "Mercury 36" "Venus 67" "Earth 93"  "Mars 142" "Jupiter 483"
do
  set -- $planet  #  Parses variable "planet"
                  #+ and sets positional parameters.
  #  The "--" prevents nasty surprises if $planet is null or
  #+ begins with a dash.

  #  May need to save original positional parameters,
  #+ since they get overwritten.
  #  One way of doing this is to use an array,
  #         original_params=("$@")

  echo "$1		$2,000,000 miles from the sun"
  #-------two  tabs---concatenate zeroes onto parameter $2
done

# (Thanks, S.C., for additional clarification.)

exit 0
</programlisting>
	    </example>


	    <para><anchor xml:id="paramli" /></para>
	    <para>A variable may supply the <userinput>[list]</userinput> in a
	      <firstterm>for loop</firstterm>.</para>

	    <example xml:id="fileinfo">
	      <title><emphasis>Fileinfo:</emphasis> operating on a file list
	        contained in a variable</title>
	      <programlisting>#!/bin/bash
# fileinfo.sh

FILES="/usr/sbin/accept
/usr/sbin/pwck
/usr/sbin/chroot
/usr/bin/fakefile
/sbin/badblocks
/sbin/ypbind"     # List of files you are curious about.
                  # Threw in a dummy file, /usr/bin/fakefile.

echo

for file in $FILES
do

  if [ ! -e "$file" ]       # Check if file exists.
  then
    echo "$file does not exist."; echo
    continue                # On to next.
   fi

  ls -l $file | awk '{ print $8 "         file size: " $5 }'  # Print 2 fields.
  whatis `basename $file`   # File info.
  # Note that the whatis database needs to have been set up for this to work.
  # To do this, as root run /usr/bin/makewhatis.
  echo
done  

exit 0
</programlisting>
	    </example>

	    <para><anchor xml:id="paramli2" /></para>
	    <para>The <userinput>[list]</userinput> in a
	      <firstterm>for loop</firstterm> may be parameterized.</para>

	    <example xml:id="fileinfo01">
              <title>Operating on a parameterized file list</title>
	      <programlisting>#!/bin/bash

filename="*txt"

for file in $filename
do
 echo "Contents of $file"
 echo "---"
 cat "$file"
 echo
done
</programlisting>
	    </example>

	    
	    <para><anchor xml:id="liglob" /></para>
	    <para>If the <userinput>[list]</userinput> in a
	      <firstterm>for loop</firstterm> contains wild cards
	      (<token>*</token> and <token>?</token>) used in filename
	      expansion, then <link linkend="globbingref">globbing</link>
	      takes place.</para>

	    <example xml:id="listglob">
	      <title>Operating on files with a <firstterm>for</firstterm> loop</title>
	      <programlisting>#!/bin/bash
# list-glob.sh: Generating [list] in a for-loop, using "globbing" ...
# Globbing = filename expansion.

echo

for file in *
#           ^  Bash performs filename expansion
#+             on expressions that globbing recognizes.
do
  ls -l "$file"  # Lists all files in $PWD (current directory).
  #  Recall that the wild card character "*" matches every filename,
  #+ however, in "globbing," it doesn't match dot-files.

  #  If the pattern matches no file, it is expanded to itself.
  #  To prevent this, set the nullglob option
  #+   (shopt -s nullglob).
  #  Thanks, S.C.
done

echo; echo

for file in [jx]*
do
  rm -f $file    # Removes only files beginning with "j" or "x" in $PWD.
  echo "Removed file \"$file\"".
done

echo

exit 0
</programlisting>
	    </example>


	    <para><anchor xml:id="omitlist" /></para>
	    <para>Omitting the <userinput>in [list]</userinput> part of a
	      <firstterm>for loop</firstterm> causes the loop to operate
	      on <token>$@</token> -- the <link linkend="posparamref">
	      positional parameters</link>. A particularly clever
	      illustration of this is <xref linkend="primes" />. See also <xref linkend="revposparams" />.</para>

	    <example xml:id="ex23">
	      <title>Missing <userinput>in [list]</userinput> in a
		<firstterm>for</firstterm> loop</title>
	      <programlisting>#!/bin/bash

#  Invoke this script both with and without arguments,
#+ and see what happens.

for a
do
 echo -n "$a "
done

#  The 'in list' missing, therefore the loop operates on '$@'
#+ (command-line argument list, including whitespace).

echo

exit 0
</programlisting>
	    </example>


	    <para><anchor xml:id="loopcs" /></para>
	    <para>It is possible to use <link linkend="commandsubref">command substitution</link>
	      to generate the <userinput>[list]</userinput> in a
	      <firstterm>for loop</firstterm>. See also <xref linkend="ex53" />,
	      <xref linkend="symlinks" /> and <xref linkend="base" />.</para>

	    <example xml:id="forloopcmd">
	      <title>Generating the <userinput>[list]</userinput> in
	      a <firstterm>for</firstterm> loop with command substitution</title>
	      <programlisting>#!/bin/bash
#  for-loopcmd.sh: for-loop with [list]
#+ generated by command substitution.

NUMBERS="9 7 3 8 37.53"

for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
do
  echo -n "$number "
done

echo 
exit 0
</programlisting>
	    </example>


	    <para>Here is a somewhat more complex example of using command
	      substitution to create the <userinput>[list]</userinput>.</para>

	    <example xml:id="bingrep">
	      <title>A <firstterm>grep</firstterm> replacement
	        for binary files</title>
	      <programlisting>#!/bin/bash
# bin-grep.sh: Locates matching strings in a binary file.

# A "grep" replacement for binary files.
# Similar effect to "grep -a"

E_BADARGS=65
E_NOFILE=66

if [ $# -ne 2 ]
then
  echo "Usage: `basename $0` search_string filename"
  exit $E_BADARGS
fi

if [ ! -f "$2" ]
then
  echo "File \"$2\" does not exist."
  exit $E_NOFILE
fi  


IFS=$'\012'       # Per suggestion of Anton Filippov.
                  # was:  IFS="\n"
for word in $( strings "$2" | grep "$1" )
# The "strings" command lists strings in binary files.
# Output then piped to "grep", which tests for desired string.
do
  echo $word
done

# As S.C. points out, lines 23 - 30 could be replaced with the simpler
#    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'


#  Try something like  "./bin-grep.sh mem /bin/ls"
#+ to exercise this script.

exit 0
</programlisting>
	    </example>

	    <para>More of the same.</para>

	    <example xml:id="userlist">
	      <title>Listing all users on the system</title>
	      <programlisting>#!/bin/bash
# userlist.sh

PASSWORD_FILE=/etc/passwd
n=1           # User number

for name in $(awk 'BEGIN{FS=":"}{print $1}' &lt; "$PASSWORD_FILE" )
# Field separator = :    ^^^^^^
# Print first field              ^^^^^^^^
# Get input from password file  /etc/passwd  ^^^^^^^^^^^^^^^^^
do
  echo "USER #$n = $name"
  let "n += 1"
done  


# USER #1 = root
# USER #2 = bin
# USER #3 = daemon
# ...
# USER #33 = bozo

exit $?

#  Discussion:
#  ----------
#  How is it that an ordinary user, or a script run by same,
#+ can read /etc/passwd? (Hint: Check the /etc/passwd file permissions.)
#  Is this a security hole? Why or why not?
</programlisting>
	    </example>

	    <para>Yet another example of the <userinput>[list]</userinput>
	      resulting from command substitution.</para>

	    <example xml:id="findstring">
	      <title>Checking all the binaries in a directory for
	      authorship</title>
	      <programlisting>#!/bin/bash
# findstring.sh:
# Find a particular string in the binaries in a specified directory.

directory=/usr/bin/
fstring="Free Software Foundation"  # See which files come from the FSF.

for file in $( find $directory -type f -name '*' | sort )
do
  strings -f $file | grep "$fstring" | sed -e "s%$directory%%"
  #  In the "sed" expression,
  #+ it is necessary to substitute for the normal "/" delimiter
  #+ because "/" happens to be one of the characters filtered out.
  #  Failure to do so gives an error message. (Try it.)
done  

exit $?

#  Exercise (easy):
#  ---------------
#  Convert this script to take command-line parameters
#+ for $directory and $fstring.
</programlisting>
	    </example>

	    <para>A final example of <userinput>[list]</userinput>
	       / command substitution, but this time
	       the <quote>command</quote> is a <link linkend="functionref">function</link>.</para>

            <para><programlisting>generate_list ()
{
  echo "one two three"
}

for word in $(generate_list)  # Let "word" grab output of function.
do
  echo "$word"
done

# one
# two
# three</programlisting></para>


	    <para><anchor xml:id="loopredir" /></para>
	    <para>The output of a <firstterm>for loop</firstterm> may
	      be piped to a command or commands.</para>

	    <example xml:id="symlinks">
	      <title>Listing the <firstterm>symbolic
	        links</firstterm> in a directory</title>
	      <programlisting>#!/bin/bash
# symlinks.sh: Lists symbolic links in a directory.


directory=${1-`pwd`}
#  Defaults to current working directory,
#+ if not otherwise specified.
#  Equivalent to code block below.
# ----------------------------------------------------------
# ARGS=1                 # Expect one command-line argument.
#
# if [ $# -ne "$ARGS" ]  # If not 1 arg...
# then
#   directory=`pwd`      # current working directory
# else
#   directory=$1
# fi
# ----------------------------------------------------------

echo "symbolic links in directory \"$directory\""

for file in "$( find $directory -type l )"   # -type l = symbolic links
do
  echo "$file"
done | sort                                  # Otherwise file list is unsorted.
#  Strictly speaking, a loop isn't really necessary here,
#+ since the output of the "find" command is expanded into a single word.
#  However, it's easy to understand and illustrative this way.

#  As Dominik 'Aeneas' Schnitzer points out,
#+ failing to quote  $( find $directory -type l )
#+ will choke on filenames with embedded whitespace.
#  containing whitespace. 

exit 0


# --------------------------------------------------------
# Jean Helou proposes the following alternative:

echo "symbolic links in directory \"$directory\""
# Backup of the current IFS. One can never be too cautious.
OLDIFS=$IFS
IFS=:

for file in $(find $directory -type l -printf "%p$IFS")
do     #                              ^^^^^^^^^^^^^^^^
       echo "$file"
       done|sort

# And, James "Mike" Conley suggests modifying Helou's code thusly:

OLDIFS=$IFS
IFS='' # Null IFS means no word breaks
for file in $( find $directory -type l )
do
  echo $file
  done | sort

#  This works in the "pathological" case of a directory name having
#+ an embedded colon.
#  "This also fixes the pathological case of the directory name having
#+  a colon (or space in earlier example) as well."

</programlisting>
	    </example>

	    <para>The <filename>stdout</filename> of a loop may be <link linkend="ioredirref">redirected</link> to a file, as this slight
	      modification to the previous example shows.</para>

	    <example xml:id="symlinks2">
	      <title>Symbolic links in a directory, saved to a file</title>
	      <programlisting>#!/bin/bash
# symlinks.sh: Lists symbolic links in a directory.

OUTFILE=symlinks.list                         # save-file

directory=${1-`pwd`}
#  Defaults to current working directory,
#+ if not otherwise specified.


echo "symbolic links in directory \"$directory\"" &gt; "$OUTFILE"
echo "---------------------------" &gt;&gt; "$OUTFILE"

for file in "$( find $directory -type l )"    # -type l = symbolic links
do
  echo "$file"
done | sort &gt;&gt; "$OUTFILE"                     # stdout of loop
#           ^^^^^^^^^^^^^                       redirected to save file.

# echo "Output file = $OUTFILE"

exit $?
</programlisting>
	    </example>

	    <para><anchor xml:id="loopcstyle" /></para>
	    <para>There is an alternative syntax to a <firstterm>for
	      loop</firstterm> that will look very familiar to C
	      programmers. This requires <link linkend="dblparensref">double parentheses</link>.</para>

	    <example xml:id="forloopc">
	      <title>A C-style <firstterm>for</firstterm> loop</title>
	      <programlisting>#!/bin/bash
# Multiple ways to count up to 10.

echo

# Standard syntax.
for a in 1 2 3 4 5 6 7 8 9 10
do
  echo -n "$a "
done  

echo; echo

# +==========================================+

# Using "seq" ...
for a in `seq 10`
do
  echo -n "$a "
done  

echo; echo

# +==========================================+

# Using brace expansion ...
# Bash, version 3+.
for a in {1..10}
do
  echo -n "$a "
done  

echo; echo

# +==========================================+

# Now, let's do the same, using C-like syntax.

LIMIT=10

for ((a=1; a &lt;= LIMIT ; a++))  # Double parentheses, and naked "LIMIT"
do
  echo -n "$a "
done                           # A construct borrowed from ksh93.

echo; echo

# +=========================================================================+

# Let's use the C "comma operator" to increment two variables simultaneously.

for ((a=1, b=1; a &lt;= LIMIT ; a++, b++))
do  # The comma concatenates operations.
  echo -n "$a-$b "
done

echo; echo

exit 0
</programlisting>
	    </example>

	    <para>See also <xref linkend="qfunction" />, <xref linkend="twodim" />, and <xref linkend="collatz" />.</para>

	    <para>---</para>

	    <para>Now, a <firstterm>for loop</firstterm> used in a
	      <quote>real-life</quote> context.</para>

	    <example xml:id="ex24">
	      <title>Using <firstterm>efax</firstterm> in batch mode</title>
	      <programlisting>#!/bin/bash
# Faxing (must have 'efax' package installed).

EXPECTED_ARGS=2
E_BADARGS=85
MODEM_PORT="/dev/ttyS2"   # May be different on your machine.
#                ^^^^^      PCMCIA modem card default port.

if [ $# -ne $EXPECTED_ARGS ]
# Check for proper number of command-line args.
then
   echo "Usage: `basename $0` phone# text-file"
   exit $E_BADARGS
fi


if [ ! -f "$2" ]
then
  echo "File $2 is not a text file."
  #     File is not a regular file, or does not exist.
  exit $E_BADARGS
fi
  

fax make $2              #  Create fax-formatted files from text files.

for file in $(ls $2.0*)  #  Concatenate the converted files.
                         #  Uses wild card (filename "globbing")
			 #+ in variable list.
do
  fil="$fil $file"
done  

efax -d "$MODEM_PORT"  -t "T$1" $fil   # Finally, do the work.
# Trying adding  -o1  if above line fails.


#  As S.C. points out, the for-loop can be eliminated with
#     efax -d /dev/ttyS2 -o1 -t "T$1" $2.0*
#+ but it's not quite as instructive [grin].

exit $?   # Also, efax sends diagnostic messages to stdout.
</programlisting>
	    </example>

	    <note><para><anchor xml:id="nododone" />The
            <link linkend="keywordref">keywords</link>
            <command>do</command> and <command>done</command> delineate
            the <firstterm>for-loop</firstterm> command block. However,
            these may, in certain contexts, be omitted by framing the
            command block within <link linkend="codeblockref">curly
            brackets</link>

	    <programlisting>for((n=1; n&lt;=10; n++)) 
# No do!
{
  echo -n "* $n *"
}
# No done!


# Outputs:
# * 1 ** 2 ** 3 ** 4 ** 5 ** 6 ** 7 ** 8 ** 9 ** 10 *
# And, echo $? returns 0, so Bash does not register an error.


echo


#  But, note that in a classic for-loop:    for n in [list] ...
#+ a terminal semicolon is required.

for n in 1 2 3
{  echo -n "$n "; }
#               ^


# Thank you, YongYe, for pointing this out.</programlisting>
             </para></note>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="whileloopref" /><command moreinfo="none">while</command></term>
	  <listitem>
	  <indexterm>
	    <primary>while</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>while</secondary>
	  </indexterm>
	    <para>This construct tests for a condition at the top of a
	      loop, and keeps looping as long as that condition
	      is true (returns a <returnvalue>0</returnvalue> <link linkend="exitstatusref">exit status</link>).  In contrast
	      to a <link linkend="forloopref1">for loop</link>, a
	      <firstterm>while loop</firstterm> finds use in situations
	      where the number of loop repetitions is not known
	      beforehand.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>while</command>
		<arg choice="opt" rep="norepeat"><replaceable> condition </replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">do</arg><sbr />
		<arg choice="plain" rep="repeat"><replaceable>¬†command(s)</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">done</arg>
	      </cmdsynopsis></para>


	    <para>The bracket construct in a <firstterm>while
	      loop</firstterm> is nothing more than our old friend,
	      the <link linkend="testconstructs1">test brackets</link>
	      used in an <firstterm>if/then</firstterm> test. In fact,
	      a <firstterm>while loop</firstterm> can legally use the
	      more versatile <link linkend="dblbrackets">double-brackets
	      construct</link> (while [[ condition ]]).</para>

	    <para><anchor xml:id="whileneedsemi" /></para>
	    <para><link linkend="needsemicolon">As is the case with
	      <firstterm>for loops</firstterm></link>, placing the
	      <firstterm>do</firstterm> on the same line as the condition
	      test requires a semicolon.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>while</command>
		<arg choice="opt" rep="norepeat"><replaceable> condition </replaceable></arg>
		<arg choice="plain" rep="norepeat">;</arg>
		<arg choice="plain" rep="norepeat">do</arg>
	      </cmdsynopsis></para>
	    
	    <para>Note that the <firstterm>test brackets</firstterm>
	      <link linkend="whilenobrackets">are <emphasis>not</emphasis>
	      mandatory</link> in a <firstterm>while</firstterm> loop.
	      See, for example,  the <link linkend="getoptsx">getopts
	      construct</link>.</para>

	    <example xml:id="ex25">
	      <title>Simple <firstterm>while</firstterm> loop</title>
	      <programlisting>#!/bin/bash

var0=0
LIMIT=10

while [ "$var0" -lt "$LIMIT" ]
#      ^                    ^
# Spaces, because these are "test-brackets" . . .
do
  echo -n "$var0 "        # -n suppresses newline.
  #             ^           Space, to separate printed out numbers.

  var0=`expr $var0 + 1`   # var0=$(($var0+1))  also works.
                          # var0=$((var0 + 1)) also works.
                          # let "var0 += 1"    also works.
done                      # Various other methods also work.

echo

exit 0
</programlisting>
	    </example>
	    
	    <example xml:id="ex26">
	      <title>Another <firstterm>while</firstterm> loop</title>
	      <programlisting>#!/bin/bash

echo
                               # Equivalent to:
while [ "$var1" != "end" ]     # while test "$var1" != "end"
do
  echo "Input variable #1 (end to exit) "
  read var1                    # Not 'read $var1' (why?).
  echo "variable #1 = $var1"   # Need quotes because of "#" . . .
  # If input is 'end', echoes it here.
  # Does not test for termination condition until top of loop.
  echo
done  

exit 0
</programlisting>
	    </example>	    


	    <para><anchor xml:id="whmultcond" /></para>
            <para>A <firstterm>while loop</firstterm> may have multiple
	      conditions. Only the final condition determines when the loop
	      terminates. This necessitates a slightly different loop syntax,
	      however.</para>

	    <example xml:id="ex26a">
	      <title><firstterm>while</firstterm> loop with multiple conditions</title>
	      <programlisting>#!/bin/bash

var1=unset
previous=$var1

while echo "previous-variable = $previous"
      echo
      previous=$var1
      [ "$var1" != end ] # Keeps track of what $var1 was previously.
      # Four conditions on *while*, but only the final one controls loop.
      # The *last* exit status is the one that counts.
do
echo "Input variable #1 (end to exit) "
  read var1
  echo "variable #1 = $var1"
done  

# Try to figure out how this all works.
# It's a wee bit tricky.

exit 0
</programlisting>
	    </example>	    

	    <para><anchor xml:id="wloopcstyle" /></para>
	    <para>As with a <firstterm>for loop</firstterm>, a
	      <firstterm>while loop</firstterm> may employ C-style syntax
	      by using the double-parentheses construct (see also <xref linkend="cvars" />).</para>

	    <example xml:id="whloopc">
	      <title>C-style syntax in a <firstterm>while</firstterm> loop</title>
	      <programlisting>#!/bin/bash
# wh-loopc.sh: Count to 10 in a "while" loop.

LIMIT=10                 # 10 iterations.
a=1

while [ "$a" -le $LIMIT ]
do
  echo -n "$a "
  let "a+=1"
done                     # No surprises, so far.

echo; echo

# +=================================================================+

# Now, we'll repeat with C-like syntax.

((a = 1))      # a=1
# Double parentheses permit space when setting a variable, as in C.

while (( a &lt;= LIMIT ))   #  Double parentheses,
do                       #+ and no "$" preceding variables.
  echo -n "$a "
  ((a += 1))             # let "a+=1"
  # Yes, indeed.
  # Double parentheses permit incrementing a variable with C-like syntax.
done

echo

# C and Java programmers can feel right at home in Bash.

exit 0
</programlisting>
	    </example>

	    <para><anchor xml:id="whilefunc" /></para>
	    <para>
	      Inside its test brackets, a <firstterm>while loop</firstterm>
	      can call a <link linkend="functionref">function</link>.

	      <programlisting>t=0

condition ()
{
  ((t++))

  if [ $t -lt 5 ]
  then
    return 0  # true
  else
    return 1  # false
  fi
}

while condition
#     ^^^^^^^^^
#     Function call -- four loop iterations.
do
  echo "Still going: t = $t"
done

# Still going: t = 1
# Still going: t = 2
# Still going: t = 3
# Still going: t = 4</programlisting>
	    
	    
	    
	    </para>


	    <sidebar><para><anchor xml:id="whilenobrackets" /></para>
            <para>Similar to the <link linkend="ifgrepref">if-test</link>
	      construct, a <firstterm>while</firstterm> loop can omit the test
	      brackets.
	        <programlisting>while condition
do
   command(s) ...
done</programlisting></para></sidebar>

	    <para><anchor xml:id="whilereadref2" /></para>
	    <para>By coupling the power of the <link linkend="readref">read</link> command with a
	      <firstterm>while loop</firstterm>, we get the handy <link linkend="whilereadref">while read</link> construct, useful
	      for reading and parsing files.</para>

	    <para><programlisting>cat $filename |   # Supply input from a file.
while read line   # As long as there is another line to read ...
do
  ...
done

# =========== Snippet from "sd.sh" example script ========== #

  while read value   # Read one data point at a time.
  do
    rt=$(echo "scale=$SC; $rt + $value" | bc)
    (( ct++ ))
  done

  am=$(echo "scale=$SC; $rt / $ct" | bc)

  echo $am; return $ct   # This function "returns" TWO values!
  #  Caution: This little trick will not work if $ct &gt; 255!
  #  To handle a larger number of data points,
  #+ simply comment out the "return $ct" above.
} &lt;"$datafile"   # Feed in data file.</programlisting></para>

	    <para><anchor xml:id="whredir" /></para>
	    <note>
	    <para>A <firstterm>while loop</firstterm> may have its
	      <filename>stdin</filename> <link linkend="redirref">redirected to a file</link> by a
	      <token>&lt;</token> at its end.</para>

	    <para>A <firstterm>while loop</firstterm> may have its
	      <filename>stdin</filename> <link linkend="readpiperef">
	      supplied by a pipe</link>.</para>
	    </note>

	    </listitem>
	  </varlistentry>



	<varlistentry>
	  <term><anchor id="untilloopref" /><command moreinfo="none">until</command></term>
	  <listitem>
	  <indexterm>
	    <primary>until</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>until</secondary>
	  </indexterm>

	    <para>This construct tests for a condition at the top of a loop, and keeps
	      looping as long as that condition is
	      <emphasis>false</emphasis> (opposite of <firstterm>while
	      loop</firstterm>).</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>until</command>
		<arg choice="opt" rep="norepeat"><replaceable> condition-is-true </replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">do</arg><sbr />
		<arg choice="plain" rep="repeat"><replaceable>¬†command(s)</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">done</arg>
	      </cmdsynopsis></para>

	    <para>Note that an <firstterm>until loop</firstterm> tests for the
	      terminating condition at the <emphasis>top</emphasis>
	      of the loop, differing from a similar construct in some
	      programming languages.</para>

	    <para>As is the case with <firstterm>for loops</firstterm>,
	      placing the <firstterm>do</firstterm> on the same line as
	      the condition test requires a semicolon.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>until</command>
		<arg choice="opt" rep="norepeat"><replaceable> condition-is-true </replaceable></arg>
		<arg choice="plain" rep="norepeat">;</arg>
		<arg choice="plain" rep="norepeat">do</arg>
	      </cmdsynopsis></para>

	    <example xml:id="ex27">
	      <title><firstterm>until</firstterm> loop</title>
	      <programlisting>#!/bin/bash

END_CONDITION=end

until [ "$var1" = "$END_CONDITION" ]
# Tests condition here, at top of loop.
do
  echo "Input variable #1 "
  echo "($END_CONDITION to exit)"
  read var1
  echo "variable #1 = $var1"
  echo
done  

#                     ---                        #

#  As with "for" and "while" loops,
#+ an "until" loop permits C-like test constructs.

LIMIT=10
var=0

until (( var &gt; LIMIT ))
do  # ^^ ^     ^     ^^   No brackets, no $ prefixing variables.
  echo -n "$var "
  (( var++ ))
done    # 0 1 2 3 4 5 6 7 8 9 10 


exit 0
</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para><anchor xml:id="chooseloop" /></para>
	<para>How to choose between a <firstterm>for</firstterm> loop or a
	  <firstterm>while</firstterm> loop or
	  <firstterm>until</firstterm> loop? In <command>C</command>,
	  you would typically use a <firstterm>for</firstterm> loop
	  when the number of loop iterations is known beforehand. With
	  <firstterm>Bash</firstterm>, however, the situation is
	  fuzzier. The Bash <firstterm>for</firstterm> loop is more
	  loosely structured and more flexible than its equivalent in
	  other languages. Therefore, feel free to use whatever type
	  of loop gets the job done in the simplest way.</para>

    </section> <!-- Loops -->



      <section xml:id="nestedloops">
        <title>Nested Loops</title>

	<para>A <firstterm>nested loop</firstterm> is a loop within a
	  loop, an inner loop within the body of an outer one. How
	  this works is that the first pass of the outer loop triggers
	  the inner loop, which executes to completion. Then the
	  second pass of the outer loop triggers the inner loop
	  again. This repeats until the outer loop finishes. Of course,
	  a <firstterm>break</firstterm> within either the inner or outer
	  loop would interrupt this process.</para>

	    <example xml:id="nestedloop">
	      <title>Nested Loop</title>
	      <programlisting>#!/bin/bash
# nested-loop.sh: Nested "for" loops.

outer=1             # Set outer loop counter.

# Beginning of outer loop.
for a in 1 2 3 4 5
do
  echo "Pass $outer in outer loop."
  echo "---------------------"
  inner=1           # Reset inner loop counter.

  # ===============================================
  # Beginning of inner loop.
  for b in 1 2 3 4 5
  do
    echo "Pass $inner in inner loop."
    let "inner+=1"  # Increment inner loop counter.
  done
  # End of inner loop.
  # ===============================================

  let "outer+=1"    # Increment outer loop counter. 
  echo              # Space between output blocks in pass of outer loop.
done               
# End of outer loop.

exit 0
</programlisting>
	    </example>	    

	<para>See <xref linkend="bubble" /> for an illustration of nested
	  <link linkend="whileloopref">while loops</link>, and <xref linkend="ex68" /> to see a while loop nested inside an <link linkend="untilloopref">until loop</link>.</para>

    </section> <!-- Nested Loops -->


      <section xml:id="loopcontrol">
        <title>Loop Control</title>

    <epigraph>
      <para>Tournez cent tours, tournez mille tours,</para>
      <para>Tournez souvent et tournez toujours . . .</para>
      <para>--Verlaine, <quote>Chevaux de bois</quote></para>
    </epigraph>

	<variablelist xml:id="brkcont">
	  <title><anchor xml:id="brkcont1" />Commands affecting loop behavior</title>

	<varlistentry>
	  <term><command moreinfo="none">break</command></term>
	  <term><command moreinfo="none">continue</command></term>
	  <listitem>
	  <indexterm>
	    <primary>break</primary>
	  </indexterm>
	  <indexterm>
	    <primary>continue</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>break</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>continue</secondary>
	  </indexterm>
	    <para>The <command>break</command> and <command>continue</command>
	      loop control commands
		<footnote><para>These are shell <link linkend="builtinref">builtins</link>,
		whereas other loop commands, such as <link linkend="whileloopref">while</link> and <link linkend="caseesac1">case</link>, are <link linkend="keywordref">keywords</link>.</para></footnote>
	      correspond exactly to their counterparts in other
	      programming languages. The <command>break</command>
	      command terminates the loop (<emphasis>breaks</emphasis>
	      out of it), while <command>continue</command> causes a jump
	      to the next <link linkend="iterationref">iteration</link>
	      of the loop, skipping all the remaining commands in that
	      particular loop cycle.</para>

	    <example xml:id="ex28">
	      <title>Effects of <firstterm>break</firstterm> and
		<command>continue</command> in a loop</title>
	      <programlisting>#!/bin/bash

LIMIT=19  # Upper limit

echo
echo "Printing Numbers 1 through 20 (but not 3 and 11)."

a=0

while [ $a -le "$LIMIT" ]
do
 a=$(($a+1))

 if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # Excludes 3 and 11.
 then
   continue      # Skip rest of this particular loop iteration.
 fi

 echo -n "$a "   # This will not execute for 3 and 11.
done 

# Exercise:
# Why does the loop print up to 20?

echo; echo

echo Printing Numbers 1 through 20, but something happens after 2.

##################################################################

# Same loop, but substituting 'break' for 'continue'.

a=0

while [ "$a" -le "$LIMIT" ]
do
 a=$(($a+1))

 if [ "$a" -gt 2 ]
 then
   break  # Skip entire rest of loop.
 fi

 echo -n "$a "
done

echo; echo; echo

exit 0
</programlisting>
	    </example>	    

	    <para><anchor xml:id="breakparam" /></para>
            <para>The <command>break</command> command may optionally take a
	      parameter. A plain <command>break</command> terminates
	      only the innermost loop in which it is embedded,
	      but a <command>break N</command> breaks out of
	      <parameter>N</parameter> levels of loop.</para>

	    <example xml:id="breaklevels">
	      <title>Breaking out of multiple loop levels</title>
	      <programlisting>#!/bin/bash
# break-levels.sh: Breaking out of loops.

# "break N" breaks out of N level loops.

for outerloop in 1 2 3 4 5
do
  echo -n "Group $outerloop:   "

  # --------------------------------------------------------
  for innerloop in 1 2 3 4 5
  do
    echo -n "$innerloop "

    if [ "$innerloop" -eq 3 ]
    then
      break  # Try   break 2   to see what happens.
             # ("Breaks" out of both inner and outer loops.)
    fi
  done
  # --------------------------------------------------------

  echo
done  

echo

exit 0
</programlisting>
	    </example>	    

	    <para>The <command>continue</command> command, similar to
	      <command>break</command>, optionally takes a parameter. A
	      plain <command>continue</command> cuts short the
	      current iteration within its loop and begins the next.
	      A <command>continue N</command> terminates all remaining
	      iterations at its loop level and continues with the
	      next iteration at the loop, <option>N</option> levels
	      above.</para>

	    <example xml:id="continuelevels">
	      <title>Continuing at a higher loop level</title>
	      <programlisting>#!/bin/bash
# The "continue N" command, continuing at the Nth level loop.

for outer in I II III IV V           # outer loop
do
  echo; echo -n "Group $outer: "

  # --------------------------------------------------------------------
  for inner in 1 2 3 4 5 6 7 8 9 10  # inner loop
  do

    if [[ "$inner" -eq 7 &amp;&amp; "$outer" = "III" ]]
    then
      continue 2  # Continue at loop on 2nd level, that is "outer loop".
                  # Replace above line with a simple "continue"
                  # to see normal loop behavior.
    fi  

    echo -n "$inner "  # 7 8 9 10 will not echo on "Group III."
  done  
  # --------------------------------------------------------------------

done

echo; echo

# Exercise:
# Come up with a meaningful use for "continue N" in a script.

exit 0
</programlisting>
	    </example>	    

	    <example xml:id="continuenex">
	      <title>Using <firstterm>continue N</firstterm> in an actual task</title>
	      <programlisting># Albert Reiner gives an example of how to use "continue N":
# ---------------------------------------------------------

#  Suppose I have a large number of jobs that need to be run, with
#+ any data that is to be treated in files of a given name pattern
#+ in a directory. There are several machines that access
#+ this directory, and I want to distribute the work over these
#+ different boxen.
#  Then I usually nohup something like the following on every box:

while true
do
  for n in .iso.*
  do
    [ "$n" = ".iso.opts" ] &amp;&amp; continue
    beta=${n#.iso.}
    [ -r .Iso.$beta ] &amp;&amp; continue
    [ -r .lock.$beta ] &amp;&amp; sleep 10 &amp;&amp; continue
    lockfile -r0 .lock.$beta || continue
    echo -n "$beta: " `date`
    run-isotherm $beta
    date
    ls -alF .Iso.$beta
    [ -r .Iso.$beta ] &amp;&amp; rm -f .lock.$beta
    continue 2
  done
  break
done

exit 0

#  The details, in particular the sleep N, are particular to my
#+ application, but the general pattern is:

while true
do
  for job in {pattern}
  do
    {job already done or running} &amp;&amp; continue
    {mark job as running, do job, mark job as done}
    continue 2
  done
  break        # Or something like `sleep 600' to avoid termination.
done

#  This way the script will stop only when there are no more jobs to do
#+ (including jobs that were added during runtime). Through the use
#+ of appropriate lockfiles it can be run on several machines
#+ concurrently without duplication of calculations [which run a couple
#+ of hours in my case, so I really want to avoid this]. Also, as search
#+ always starts again from the beginning, one can encode priorities in
#+ the file names. Of course, one could also do this without `continue 2',
#+ but then one would have to actually check whether or not some job
#+ was done (so that we should immediately look for the next job) or not
#+ (in which case we terminate or sleep for a long time before checking
#+ for a new job).
</programlisting>
	    </example>	    

	    <caution><para>The <command>continue N</command> construct is
	      difficult to understand and tricky to use in any meaningful
	      context. It is probably best avoided.</para></caution>

	  </listitem>
	</varlistentry>

	</variablelist>

    </section> <!-- Loop Control Commands -->



      <section xml:id="testbranch">
        <title>Testing and Branching</title>

	<para>The <command>case</command> and <command>select</command>
	  constructs are technically not loops, since they do not iterate the
	  execution of a code block. Like loops, however, they direct
	  program flow according to conditions at the top or bottom of
	  the block.</para>

	<variablelist xml:id="caseesac">
	  <title><anchor xml:id="caseesac1" />Controlling program flow in a code
	    block</title>

	<varlistentry>
	  <term><command moreinfo="none">case (in) / esac</command></term>
	  <listitem>
	  <indexterm>
	    <primary>case</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>esac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>switch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>

	    <para>The <command>case</command> construct is the shell
	      scripting analog to <replaceable>switch</replaceable>
	      in <command>C/C++</command>.
	      It permits branching to one of a number of code blocks,
	      depending on condition tests. It serves as a kind of
	      shorthand for multiple <token>if/then/else</token>
	      statements and is an appropriate tool for creating
	      menus.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>case</command>
		<arg choice="plain" rep="norepeat">"$<replaceable>variable</replaceable>"</arg>
		<arg choice="plain" rep="norepeat">in</arg><sbr /><sbr />
		<arg choice="plain" rep="norepeat">¬†"$<replaceable>condition1</replaceable>" )</arg><sbr />
		<arg choice="plain" rep="repeat">¬†<replaceable>command</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">¬†;;</arg><sbr /><sbr />
		<arg choice="plain" rep="norepeat">¬†"$<replaceable>condition2</replaceable>" )</arg><sbr />
		<arg choice="plain" rep="repeat">¬†<replaceable>command</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">¬†;;</arg><sbr /><sbr />
		<command>esac</command>
	      </cmdsynopsis></para>

	    <note><para>
	      <itemizedlist>
		<listitem><para>Quoting the variables is not mandatory,
		since word splitting does not take place.</para>
		</listitem>
		<listitem>

		  <para><anchor xml:id="caseparen" />Each test line
                    ends with a right paren <command>)</command>.

  <footnote><para>Pattern-match lines may also <emphasis>start</emphasis>
    with a <command>(</command> left paren to give the layout
    a more structured appearance.</para>
   <para><programlisting>case $( arch ) in   # $( arch ) returns machine architecture.
  ( i386 ) echo "80386-based machine";;
# ^      ^
  ( i486 ) echo "80486-based machine";;
  ( i586 ) echo "Pentium-based machine";;
  ( i686 ) echo "Pentium2+-based machine";;
  (    * ) echo "Other type of machine";;
esac</programlisting></para></footnote>
			  </para>

		</listitem>

		<listitem><para>Each condition block ends
		with a <emphasis>double</emphasis> semicolon
		<token>;;</token>.</para>
		</listitem>
		<listitem><para>If a condition tests
                <firstterm>true</firstterm>, then the associated
		commands execute and the <command>case</command>
		block terminates.</para></listitem>
		<listitem><para>The entire <command>case</command>
		block ends with an <command>esac</command>
		(<wordasword>case</wordasword> spelled backwards).</para>
		  </listitem>
	      </itemizedlist>
	    </para></note>

	    <example xml:id="ex29">
	      <title>Using <firstterm>case</firstterm></title>
	      <programlisting>#!/bin/bash
# Testing ranges of characters.

echo; echo "Hit a key, then hit return."
read Keypress

case "$Keypress" in
  [[:lower:]]   ) echo "Lowercase letter";;
  [[:upper:]]   ) echo "Uppercase letter";;
  [0-9]         ) echo "Digit";;
  *             ) echo "Punctuation, whitespace, or other";;
esac      #  Allows ranges of characters in [square brackets],
          #+ or POSIX ranges in [[double square brackets.

#  In the first version of this example,
#+ the tests for lowercase and uppercase characters were
#+ [a-z] and [A-Z].
#  This no longer works in certain locales and/or Linux distros.
#  POSIX is more portable.
#  Thanks to Frank Wang for pointing this out.

#  Exercise:
#  --------
#  As the script stands, it accepts a single keystroke, then terminates.
#  Change the script so it accepts repeated input,
#+ reports on each keystroke, and terminates only when "X" is hit.
#  Hint: enclose everything in a "while" loop.

exit 0
</programlisting>
	    </example>	    

	    <example xml:id="ex30">
	      <title>Creating menus using <firstterm>case</firstterm></title>
	      <programlisting>#!/bin/bash

# Crude address database

clear # Clear the screen.

echo "          Contact List"
echo "          ------- ----"
echo "Choose one of the following persons:" 
echo
echo "[E]vans, Roland"
echo "[J]ones, Mildred"
echo "[S]mith, Julie"
echo "[Z]ane, Morris"
echo

read person

case "$person" in
# Note variable is quoted.

  "E" | "e" )
  # Accept upper or lowercase input.
  echo
  echo "Roland Evans"
  echo "4321 Flash Dr."
  echo "Hardscrabble, CO 80753"
  echo "(303) 734-9874"
  echo "(303) 734-9892 fax"
  echo "revans@zzy.net"
  echo "Business partner &amp; old friend"
  ;;
# Note double semicolon to terminate each option.

  "J" | "j" )
  echo
  echo "Mildred Jones"
  echo "249 E. 7th St., Apt. 19"
  echo "New York, NY 10009"
  echo "(212) 533-2814"
  echo "(212) 533-9972 fax"
  echo "milliej@loisaida.com"
  echo "Ex-girlfriend"
  echo "Birthday: Feb. 11"
  ;;

# Add info for Smith &amp; Zane later.

          * )
   # Default option.	  
   # Empty input (hitting RETURN) fits here, too.
   echo
   echo "Not yet in database."
  ;;

esac

echo

#  Exercise:
#  --------
#  Change the script so it accepts multiple inputs,
#+ instead of terminating after displaying just one address.

exit 0
</programlisting>
	    </example>	    

	    <para><anchor xml:id="casecl" /></para>
	    <para>An exceptionally clever use of <command>case</command>
	      involves testing for command-line parameters.
	      <programlisting>#! /bin/bash

case "$1" in
  "") echo "Usage: ${0##*/} &lt;filename&gt;"; exit $E_PARAM;;
                      # No command-line parameters,
                      # or first parameter empty.
# Note that ${0##*/} is ${var##pattern} param substitution.
                      # Net result is $0.

  -*) FILENAME=./$1;;   #  If filename passed as argument ($1)
                      #+ starts with a dash,
                      #+ replace it with ./$1
                      #+ so further commands don't interpret it
                      #+ as an option.

  * ) FILENAME=$1;;     # Otherwise, $1.
esac</programlisting></para>

	    <para>Here is a more straightforward example of
	      command-line parameter handling:
	      <programlisting>#! /bin/bash


while [ $# -gt 0 ]; do    # Until you run out of parameters . . .
  case "$1" in
    -d|--debug)
              # "-d" or "--debug" parameter?
              DEBUG=1
              ;;
    -c|--conf)
              CONFFILE="$2"
              shift
              if [ ! -f $CONFFILE ]; then
                echo "Error: Supplied file doesn't exist!"
                exit $E_CONFFILE     # File not found error.
              fi
              ;;
  esac
  shift       # Check next set of parameters.
done

#  From Stefano Falsetto's "Log2Rot" script,
#+ part of his "rottlog" package.
#  Used with permission.</programlisting></para>


	    <example xml:id="casecmd">
	      <title>Using <firstterm>command substitution</firstterm>
	      to generate the <firstterm>case</firstterm> variable</title>
	      <programlisting>#!/bin/bash
# case-cmd.sh: Using command substitution to generate a "case" variable.

case $( arch ) in   # $( arch ) returns machine architecture.
                    # Equivalent to 'uname -m' ...
  i386 ) echo "80386-based machine";;
  i486 ) echo "80486-based machine";;
  i586 ) echo "Pentium-based machine";;
  i686 ) echo "Pentium2+-based machine";;
  *    ) echo "Other type of machine";;
esac

exit 0
</programlisting>
	    </example>	    

	    <para><anchor xml:id="csglob" /></para>
	    <para>A <command>case</command> construct can filter strings for
	      <link linkend="globbingref">globbing</link> patterns.</para>

	    <example xml:id="matchstring">
	      <title>Simple string matching</title>
	      <programlisting>#!/bin/bash
# match-string.sh: Simple string matching
#                  using a 'case' construct.

match_string ()
{ # Exact string match.
  MATCH=0
  E_NOMATCH=90
  PARAMS=2     # Function requires 2 arguments.
  E_BAD_PARAMS=91

  [ $# -eq $PARAMS ] || return $E_BAD_PARAMS

  case "$1" in
  "$2") return $MATCH;;
  *   ) return $E_NOMATCH;;
  esac

}  


a=one
b=two
c=three
d=two


match_string $a     # wrong number of parameters
echo $?             # 91

match_string $a $b  # no match
echo $?             # 90

match_string $b $d  # match
echo $?             # 0


exit 0		    
</programlisting>
	    </example>	    

	    <example xml:id="isalpha">
	      <title>Checking for alphabetic input</title>
	      <programlisting>#!/bin/bash
# isalpha.sh: Using a "case" structure to filter a string.

SUCCESS=0
FAILURE=1   #  Was FAILURE=-1,
            #+ but Bash no longer allows negative return value.

isalpha ()  # Tests whether *first character* of input string is alphabetic.
{
if [ -z "$1" ]                # No argument passed?
then
  return $FAILURE
fi

case "$1" in
  [a-zA-Z]*) return $SUCCESS;;  # Begins with a letter?
  *        ) return $FAILURE;;
esac
}             # Compare this with "isalpha ()" function in C.


isalpha2 ()   # Tests whether *entire string* is alphabetic.
{
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!a-zA-Z]*|"") return $FAILURE;;
               *) return $SUCCESS;;
  esac
}

isdigit ()    # Tests whether *entire string* is numerical.
{             # In other words, tests for integer variable.
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
    *[!0-9]*|"") return $FAILURE;;
              *) return $SUCCESS;;
  esac
}



check_var ()  # Front-end to isalpha ().
{
if isalpha "$@"
then
  echo "\"$*\" begins with an alpha character."
  if isalpha2 "$@"
  then        # No point in testing if first char is non-alpha.
    echo "\"$*\" contains only alpha characters."
  else
    echo "\"$*\" contains at least one non-alpha character."
  fi  
else
  echo "\"$*\" begins with a non-alpha character."
              # Also "non-alpha" if no argument passed.
fi

echo

}

digit_check ()  # Front-end to isdigit ().
{
if isdigit "$@"
then
  echo "\"$*\" contains only digits [0 - 9]."
else
  echo "\"$*\" has at least one non-digit character."
fi

echo

}

a=23skidoo
b=H3llo
c=-What?
d=What?
e=$(echo $b)   # Command substitution.
f=AbcDef
g=27234
h=27a34
i=27.34

check_var $a
check_var $b
check_var $c
check_var $d
check_var $e
check_var $f
check_var     # No argument passed, so what happens?
#
digit_check $g
digit_check $h
digit_check $i


exit 0        # Script improved by S.C.

# Exercise:
# --------
#  Write an 'isfloat ()' function that tests for floating point numbers.
#  Hint: The function duplicates 'isdigit ()',
#+ but adds a test for a mandatory decimal point.
</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor id="selectref" /><command moreinfo="none">select</command></term>
	  <listitem>
	  <indexterm>
	    <primary>select</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>
	    <para>The <command>select</command> construct, adopted from the Korn
	      Shell, is yet another tool for building menus.</para>

	    <para><cmdsynopsis sepchar=" ">
		<command>select</command>
		<arg choice="plain" rep="norepeat"><replaceable>variable</replaceable></arg>
		<arg choice="opt" rep="norepeat">in <replaceable>list</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">do</arg><sbr />
		<arg choice="plain" rep="repeat">¬†<replaceable>command</replaceable></arg><sbr />
		<arg choice="plain" rep="norepeat">¬†break</arg><sbr />
		<arg choice="plain" rep="norepeat">done</arg>
	      </cmdsynopsis></para>
	    
	    <para>This prompts the user to enter one of the choices presented in the
	      variable list.  Note that <command>select</command> uses the
	      <varname>$PS3</varname> prompt (<prompt>#? </prompt>) by default, 
		but this may be changed.</para>
	    
	    <example xml:id="ex31">
	      <title>Creating menus using <firstterm>select</firstterm></title>
	      <programlisting>#!/bin/bash

PS3='Choose your favorite vegetable: ' # Sets the prompt string.
                                       # Otherwise it defaults to #? .

echo

select vegetable in "beans" "carrots" "potatoes" "onions" "rutabagas"
do
  echo
  echo "Your favorite veggie is $vegetable."
  echo "Yuck!"
  echo
  break  # What happens if there is no 'break' here?
done

exit

# Exercise:
# --------
#  Fix this script to accept user input not specified in
#+ the "select" statement.
#  For example, if the user inputs "peas,"
#+ the script would respond "Sorry. That is not on the menu."
</programlisting>
	    </example>	    

	    <para><anchor xml:id="inlistomit" /></para>
	    <para>If <userinput>in <replaceable>list</replaceable></userinput> is
	      omitted, then <command>select</command> uses the list of command
	      line arguments (<varname>$@</varname>) passed to the script or
	      the function containing the <command>select</command>
	      construct.</para>
	      
	    <para>Compare this to the behavior of a 
	      <cmdsynopsis sepchar=" ">
		<command>for</command>
		<arg choice="plain" rep="norepeat"><replaceable>variable</replaceable></arg>
		<arg choice="opt" rep="norepeat">in <replaceable>list</replaceable></arg>
	      </cmdsynopsis>
	      construct with the 
	      <userinput>in <replaceable>list</replaceable></userinput>
	      omitted.</para>

	    <example xml:id="ex32">
	      <title>Creating menus using <firstterm>select</firstterm>
	      in a function</title>
	      <programlisting>#!/bin/bash

PS3='Choose your favorite vegetable: '

echo

choice_of()
{
select vegetable
# [in list] omitted, so 'select' uses arguments passed to function.
do
  echo
  echo "Your favorite veggie is $vegetable."
  echo "Yuck!"
  echo
  break
done
}

choice_of beans rice carrots radishes rutabaga spinach
#         $1    $2   $3      $4       $5       $6
#         passed to choice_of() function

exit 0
</programlisting>
	    </example>	    

	    <para>See also <xref linkend="resistor" />.</para>

	    </listitem>
	  </varlistentry>

      </variablelist>

    </section> <!-- Testing and Branching -->


  </chapter> <!-- Loops -->



  <chapter xml:id="commandsub">
    <title>Command Substitution</title>

      <indexterm>
	<primary>$</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>`</secondary>
      </indexterm>

	   <para>
	     <anchor xml:id="commandsubref" /><command>Command
	     substitution</command> reassigns the output of a command
		<footnote><para>For purposes of <firstterm>command
		substitution</firstterm>, a <command>command</command>
		may be an external system command, an internal scripting
		<link linkend="builtinref">builtin</link>, or even <link linkend="rvt">a script function</link>.</para></footnote>
	     or even multiple commands; it literally plugs the command
	     output into another context.

	        <footnote><para>In a more technically correct sense,
		<firstterm>command substitution</firstterm> extracts the
		<filename>stdout</filename> of a command, then assigns
		it to a variable using the <token>=</token>
		operator.</para></footnote>
	     </para>


	    <para><anchor xml:id="backquotesref" />The classic form of command
	      substitution uses <firstterm>backquotes</firstterm>
	      (`...`). Commands within backquotes (backticks) generate
	      command-line text.

	      <programlisting>script_name=`basename $0`
echo "The name of this script is $script_name."</programlisting></para>


	    <formalpara>
	      <title>The output of commands can be used as arguments to
	      another command, to set a variable, and even for generating
	      the argument list in a <link linkend="forloopref1">for</link>
	      loop.</title>
	      <para />
	    </formalpara>

            <para>
	      <programlisting>rm `cat filename`   # <quote>filename</quote> contains a list of files to delete.
#
# S. C. points out that "arg list too long" error might result.
# Better is              xargs rm -- &lt; filename 
# ( -- covers those cases where <quote>filename</quote> begins with a <quote>-</quote> )

textfile_listing=`ls *.txt`
# Variable contains names of all *.txt files in current working directory.
echo $textfile_listing

textfile_listing2=$(ls *.txt)   # The alternative form of command substitution.
echo $textfile_listing2
# Same result.

# A possible problem with putting a list of files into a single string
# is that a newline may creep in.
#
# A safer way to assign a list of files to a parameter is with an array.
#      shopt -s nullglob    # If no match, filename expands to nothing.
#      textfile_listing=( *.txt )
#
# Thanks, S.C.</programlisting>
            </para>

              <note><para><anchor xml:id="cssubsh" />Command substitution
              invokes a <link linkend="subshellsref">subshell</link>.</para></note>



              <caution><para><anchor xml:id="csws" />Command substitution may
                result in <link linkend="wsplitref">word splitting</link>.
	        <programlisting>COMMAND `echo a b`     # 2 args: a and b

COMMAND "`echo a b`"   # 1 arg: "a b"

COMMAND `echo`         # no arg

COMMAND "`echo`"       # one empty arg


# Thanks, S.C.</programlisting></para>


	      <para><anchor xml:id="cstrnl" /></para>
	      <para>Even when there is no word splitting, command
	        substitution can remove trailing newlines.

		<programlisting># cd "`pwd`"  # This should always work.
# However...

mkdir 'dir with trailing newline
'

cd 'dir with trailing newline
'

cd "`pwd`"  # Error message:
# bash: cd: /tmp/file with trailing newline: No such file or directory

cd "$PWD"   # Works fine.





old_tty_setting=$(stty -g)   # Save old terminal setting.
echo "Hit a key "
stty -icanon -echo           # Disable "canonical" mode for terminal.
                             # Also, disable *local* echo.
key=$(dd bs=1 count=1 2&gt; /dev/null)   # Using 'dd' to get a keypress.
stty "$old_tty_setting"      # Restore old setting. 
echo "You hit ${#key} key."  # ${#variable} = number of characters in $variable
#
# Hit any key except RETURN, and the output is "You hit 1 key."
# Hit RETURN, and it's "You hit 0 key."
# The newline gets eaten in the command substitution.

#Code snippet by St√©phane Chazelas.</programlisting>
              </para>
              </caution>


              <caution>
	      <para>Using <command>echo</command> to output an
		<firstterm>unquoted</firstterm> variable set with command
		substitution removes trailing newlines characters from
		the output of the reassigned command(s). This can cause
		unpleasant surprises.

		<programlisting>dir_listing=`ls -l`
echo $dir_listing     # unquoted

# Expecting a nicely ordered directory listing.

# However, what you get is:
# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh

# The newlines disappeared.


echo "$dir_listing"   # quoted
# -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
# -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
# -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh</programlisting>
              </para>
              </caution>



	     <para>Command substitution even permits setting a variable to the
	       contents of a file, using either <link linkend="ioredirref">redirection</link> or the <link linkend="catref">cat</link> command.</para>

             <para>
	         <programlisting>variable1=`&lt;file1`      #  Set "variable1" to contents of "file1".
variable2=`cat file2`   #  Set "variable2" to contents of "file2".
                        #  This, however, forks a new process,
                        #+ so the line of code executes slower than the above version.

#  Note that the variables may contain embedded whitespace,
#+ or even (horrors), control characters.

#  It is not necessary to explicitly assign a variable.
echo "` &lt;$0`"           # Echoes the script itself to stdout.</programlisting>
             </para>

             <para>
	         <programlisting>#  Excerpts from system file, /etc/rc.d/rc.sysinit
#+ (on a Red Hat Linux installation)


if [ -f /fsckoptions ]; then
        fsckoptions=`cat /fsckoptions`
...
fi
#
#
if [ -e "/proc/ide/${disk[$device]}/media" ] ; then
             hdmedia=`cat /proc/ide/${disk[$device]}/media`
...
fi
#
#
if [ ! -n "`uname -r | grep -- "-"`" ]; then
       ktag="`cat /proc/version`"
...
fi
#
#
if [ $usb = "1" ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
    kbdoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
...
fi</programlisting>
             </para>

	     <caution>
             <para>Do not set a variable to the contents of a
	       <emphasis>long</emphasis> text file unless you have a very good
	       reason for doing so. Do not set a variable to the contents of a
	       <firstterm>binary</firstterm> file, even as a joke.</para>

	    <example xml:id="stupscr">
	      <title>Stupid script tricks</title>
	      <programlisting>#!/bin/bash
# stupid-script-tricks.sh: Don't try this at home, folks.
# From "Stupid Script Tricks," Volume I.

exit 99  ### Comment out this line if you dare.

dangerous_variable=`cat /boot/vmlinuz`   # The compressed Linux kernel itself.

echo "string-length of \$dangerous_variable = ${#dangerous_variable}"
# string-length of $dangerous_variable = 794151
# (Newer kernels are bigger.)
# Does not give same count as 'wc -c /boot/vmlinuz'.

# echo "$dangerous_variable"
# Don't try this! It would hang the script.


#  The document author is aware of no useful applications for
#+ setting a variable to the contents of a binary file.

exit 0
</programlisting>
	    </example>

	     <para>Notice that a <firstterm>buffer overrun</firstterm>
	       does not occur. This is one instance where an interpreted
	       language, such as Bash, provides more protection from
	       programmer mistakes than a compiled language.</para>

	     </caution>


	      <para><anchor xml:id="csvl" /></para>
	      <para>Command substitution permits setting a variable to the
		output of a <link linkend="forloopref1">loop</link>. The
		key to this is grabbing the output of an <link linkend="echoref">echo</link> command within the
		loop.</para>

	    <example xml:id="csubloop">
	      <title>Generating a variable from a loop</title>
	      <programlisting>#!/bin/bash
# csubloop.sh: Setting a variable to the output of a loop.

variable1=`for i in 1 2 3 4 5
do
  echo -n "$i"                 #  The 'echo' command is critical
done`                          #+ to command substitution here.

echo "variable1 = $variable1"  # variable1 = 12345


i=0
variable2=`while [ "$i" -lt 10 ]
do
  echo -n "$i"                 # Again, the necessary 'echo'.
  let "i += 1"                 # Increment.
done`

echo "variable2 = $variable2"  # variable2 = 0123456789

#  Demonstrates that it's possible to embed a loop
#+ inside a variable declaration.

exit 0
</programlisting>
	    </example>



	      <para><anchor xml:id="cstoolset" /></para>
	      <sidebar>
              <para>Command substitution makes it possible to extend the
		toolset available to Bash. It is simply a matter
		of writing a program or script that outputs to
		<filename>stdout</filename> (like a well-behaved UNIX
		tool should) and assigning that output to a variable.</para>

		<para>
		<programlisting>#include &lt;stdio.h&gt;

/*  "Hello, world." C program  */		

int main()
{
  printf( "Hello, world.\n" );
  return (0);
}</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>gcc -o hello hello.c</userinput>
	      </screen>
		</para>

		<para>
                <programlisting>#!/bin/bash
# hello.sh		

greeting=`./hello`
echo $greeting</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>sh hello.sh</userinput>
<computeroutput>Hello, world.</computeroutput>
	        </screen>
	        </para>
	        </sidebar>
	      
	      <note>

	      <para><anchor xml:id="csparens" />The <command>$(...)</command>
		form has superseded backticks for command
		substitution.</para>

	      <para><programlisting>output=$(sed -n /"$1"/p $file)   # From "grp.sh"	example.
	      
# Setting a variable to the contents of a text file.
File_contents1=$(cat $file1)      
File_contents2=$(&lt;$file2)        # Bash permits this also.</programlisting></para>

              <para>The <command>$(...)</command> form of command substitution
	        treats a double backslash in a different way than
		<command>`...`</command>.</para>

              <para>		
	      <screen><prompt>bash$ </prompt><userinput>echo `echo \\`</userinput>
<computeroutput />

<prompt>bash$ </prompt><userinput>echo $(echo \\)</userinput>
<computeroutput>\</computeroutput>
	      </screen>
              </para>		

	      <para><anchor xml:id="csnest" /></para>
              <para>The <command>$(...)</command> form of command
                substitution permits nesting.
		  <footnote>
		    <para>
		    In fact, nesting with backticks is also possible,
		    but only by escaping the inner backticks, as John
		    Default points out.
		      <programlisting>word_count=` wc -w \`echo * | awk '{print $8}'\` `</programlisting>
		    </para>
		  </footnote>
		
		</para>

              <para><programlisting>word_count=$( wc -w $(echo * | awk '{print $8}') )</programlisting>
              </para>

              <para>Or, for something a bit more elaborate . . .</para>

      <example xml:id="agram2">
	<title>Finding anagrams</title>
	<programlisting>#!/bin/bash
# agram2.sh
# Example of nested command substitution.

#  Uses "anagram" utility
#+ that is part of the author's "yawl" word list package.
#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
#  http://bash.deta.in/yawl-0.3.2.tar.gz

E_NOARGS=86
E_BADARG=87
MINLEN=7

if [ -z "$1" ]
then
  echo "Usage $0 LETTERSET"
  exit $E_NOARGS         # Script needs a command-line argument.
elif [ ${#1} -lt $MINLEN ]
then
  echo "Argument must have at least $MINLEN letters."
  exit $E_BADARG
fi



FILTER='.......'         # Must have at least 7 letters.
#       1234567
Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )
#          $(     $(  nested command sub.    ) )
#        (              array assignment         )

echo
echo "${#Anagrams[*]}  7+ letter anagrams found"
echo
echo ${Anagrams[0]}      # First anagram.
echo ${Anagrams[1]}      # Second anagram.
                         # Etc.

# echo "${Anagrams[*]}"  # To list all the anagrams in a single line . . .

#  Look ahead to the Arrays chapter for enlightenment on
#+ what's going on here.

# See also the agram.sh script for an exercise in anagram finding.

exit $?
</programlisting>
      </example>


              </note>


     <para>Examples of command substitution in shell scripts:
       <orderedlist>
         <listitem><para><xref linkend="bingrep" /></para></listitem>
	 <listitem><para><xref linkend="casecmd" /></para></listitem>
	 <listitem><para><xref linkend="seedingrandom" /></para></listitem>
	 <listitem><para><xref linkend="ex57" /></para></listitem>
         <listitem><para><xref linkend="lowercase" /></para></listitem>
	 <listitem><para><xref linkend="grp" /></para></listitem>
	 <listitem><para><xref linkend="ex53" /></para></listitem>
         <listitem><para><xref linkend="ex24" /></para></listitem>
	 <listitem><para><xref linkend="symlinks" /></para></listitem>
	 <listitem><para><xref linkend="stripc" /></para></listitem>
	 <listitem><para><xref linkend="redir4" /></para></listitem>
	 <listitem><para><xref linkend="tree" /></para></listitem>
	 <listitem><para><xref linkend="pidid" /></para></listitem>
	 <listitem><para><xref linkend="monthlypmt" /></para></listitem>
	 <listitem><para><xref linkend="base" /></para></listitem>
	 <listitem><para><xref linkend="altbc" /></para></listitem>
       </orderedlist>
     </para>  

  </chapter> <!-- Command Substitution -->



  <chapter xml:id="arithexp">
    <title>Arithmetic Expansion</title>


      <para><anchor xml:id="arithexpref" />Arithmetic expansion provides a
	powerful tool for performing (integer) arithmetic
	operations in scripts. Translating a string into a
	numerical expression is relatively straightforward using
	<firstterm>backticks</firstterm>, <firstterm>double
	parentheses</firstterm>, or <firstterm>let</firstterm>.</para>

      <variablelist xml:id="arithexpvar">
        <title><anchor xml:id="arithexpvar1" />Variations</title>

	<varlistentry>
	  <term>Arithmetic expansion with <link linkend="backquotesref">backticks</link> (often used in
	  conjunction with <link linkend="exprref">expr</link>)</term> 
          <listitem>
          <indexterm>
	    <primary>arithmetic</primary> <secondary>expansion</secondary>
	  </indexterm> <indexterm>
	    <primary>arithmetic</primary> <secondary>expansion</secondary>
	  </indexterm> 
	    <para><programlisting>z=`expr $z + 3`          # The 'expr' command performs the expansion.</programlisting></para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term>Arithmetic expansion with <link linkend="dblparens">double
	  parentheses</link></term>
	  <term>and using <link linkend="letref">let</link></term>
	  <listitem>
	  <indexterm><primary>double</primary>
	  <secondary>parentheses</secondary></indexterm>
	  <indexterm><primary>let</primary>
	  <secondary>let</secondary></indexterm>



	   <para>The use of <firstterm>backticks</firstterm>
	      (<firstterm>backquotes</firstterm>) in arithmetic
	      expansion has been superseded by <firstterm>double
	      parentheses</firstterm> --
	      <userinput>((...))</userinput> and
	      <userinput>$((...))</userinput> -- and also by the very
	      convenient <link linkend="letref">let</link> construction.</para>

	    <para>
	      <programlisting>z=$(($z+3))
z=$((z+3))                                  #  Also correct.
                                            #  Within double parentheses,
                                            #+ parameter dereferencing
                                            #+ is optional.

# $((EXPRESSION)) is arithmetic expansion.  #  Not to be confused with
                                            #+ command substitution.



# You may also use operations within double parentheses without assignment.

  n=0
  echo "n = $n"                             # n = 0

  (( n += 1 ))                              # Increment.
# (( $n += 1 )) is incorrect!
  echo "n = $n"                             # n = 1


let z=z+3
let "z += 3"  #  Quotes permit the use of spaces in variable assignment.
              #  The 'let' operator actually performs arithmetic evaluation,
              #+ rather than expansion.</programlisting>
	    </para>

     <para>Examples of arithmetic expansion in scripts:
       <orderedlist>
         <listitem><para><xref linkend="ex45" /></para></listitem>
         <listitem><para><xref linkend="ex25" /></para></listitem>
         <listitem><para><xref linkend="ex66" /></para></listitem>
	 <listitem><para><xref linkend="bubble" /></para></listitem>
	 <listitem><para><xref linkend="tree" /></para></listitem>
       </orderedlist>
     </para>  

	  </listitem>
	</varlistentry>

      </variablelist>

  </chapter> <!-- Arithmetic Expansion -->




  <chapter xml:id="Recess-Time">
    <title>Recess Time</title>

            <para><emphasis>
	  This bizarre little intermission gives the reader a chance to
	  relax and maybe laugh a bit.
	    </emphasis></para>

      <blockquote>
	<literallayout>  

	  Fellow Linux user, greetings! You are reading something which
	  will bring you luck and good fortune. Just e-mail a copy of
	  this document to 10 of your friends. Before making the copies,
	  send a 100-line Bash script to the first person on the list
	  at the bottom of this letter. Then delete their name and add
	  yours to the bottom of the list.

	  Don't break the chain! Make the copies within 48 hours.
	  Wilfred P. of Brooklyn failed to send out his ten copies and
	  woke the next morning to find his job description changed
	  to "COBOL programmer." Howard L. of Newport News sent
	  out his ten copies and within a month had enough hardware
	  to build a 100-node Beowulf cluster dedicated to playing
	  <emphasis>Tuxracer</emphasis>. Amelia V. of Chicago laughed at this letter
	  and broke the chain. Shortly thereafter, a fire broke out
	  in her terminal and she now spends her days writing
	  documentation for MS Windows.

	  Don't break the chain!  Send out your ten copies today!

	</literallayout>  
      </blockquote>


	    <para><emphasis>Courtesy 'NIX "fortune cookies", with some
	  alterations and many apologies</emphasis></para>
      
  </chapter> <!-- Recess Time -->


  </part>

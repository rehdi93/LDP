<part label="5" xml:id="part5" xmlns="http://docbook.org/ns/docbook">
    <title>Advanced Topics</title>

    <partintro>
      <para>At this point, we are ready to delve into certain of the
	difficult and unusual aspects of scripting. Along the way, we
	will attempt to <quote>push the envelope</quote> in various
	ways and examine <firstterm>boundary conditions</firstterm>
	(what happens when we move into uncharted territory?).</para>
     </partintro>

  <chapter xml:id="regexp">
      <title>Regular Expressions</title>

    <epigraph>
      <para>. . . the intellectual activity associated with software
        development is largely one of gaining insight.</para>
      <para>--Stowe Boyd</para>
    </epigraph>

      <para><anchor xml:id="regexref" /></para>

      <para>To fully utilize the power of shell scripting, you need to
	master Regular Expressions. Certain commands
	and utilities commonly used in scripts, such
	as <link linkend="grepref">grep</link>, <link linkend="exprref">expr</link>, <link linkend="sedref">sed</link>
	and <link linkend="awkref">awk</link>, interpret and use REs. As of
	<link linkend="bash3ref">version 3</link>, Bash has acquired its
	own <link linkend="regexmatchref">RE-match operator</link>:
	<command>=~</command>.</para>



      <section><title>A Brief Introduction to Regular Expressions</title>

	<para>An expression is a string of characters. Those characters
	  having an interpretation above and beyond their literal
	  meaning are called <firstterm>metacharacters</firstterm>.
	  A quote symbol, for example, may denote speech by a person,
	  <firstterm>ditto</firstterm>, or a meta-meaning

	    <footnote><para><anchor xml:id="metameaningref" />A
	    <firstterm>meta-meaning</firstterm> is the meaning of a
	    term or expression on a higher level of abstraction. For
	    example, the <firstterm>literal</firstterm> meaning
	    of <firstterm>regular expression</firstterm> is an
	    ordinary expression that conforms to accepted usage. The
	    <firstterm>meta-meaning</firstterm> is drastically different,
	    as discussed at length in this chapter.</para></footnote>

	  for the symbols that follow. Regular Expressions are sets
	  of characters and/or metacharacters that match (or specify)
	  patterns.</para>

	<para>A Regular Expression contains one or more of the
	following:</para>

        <itemizedlist>

	  <listitem>
	    <para><firstterm>A character set</firstterm>. These are the
	      characters retaining their literal meaning. The
	      simplest type of Regular Expression consists
	      <emphasis>only</emphasis> of a character set, with no
	      metacharacters.</para>
	  </listitem>

	  <listitem>
	    <para><anchor xml:id="anchorref" /></para>
	    <para><firstterm>An anchor</firstterm>. These designate
	      (<firstterm>anchor</firstterm>) the position in the line of
	      text that the RE is to match. For example, <token>^</token>,
	      and <token>$</token> are anchors.</para>
	  </listitem>

	  <listitem>
	    <para><firstterm>Modifiers</firstterm>. These expand or narrow
	      (<firstterm>modify</firstterm>) the range of text the RE is
	      to match. Modifiers include the asterisk, brackets, and
	      the backslash.</para>
	  </listitem>

        </itemizedlist>


	<para>The main uses for Regular Expressions
	  (<firstterm>RE</firstterm>s) are text searches and string
	  manipulation. An RE <firstterm>matches</firstterm> a single
	  character or a set of characters -- a string or a part of
	  a string.</para>

	<itemizedlist>
	  <listitem>
	    <indexterm>
	      <primary>*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>*</secondary>
	    </indexterm>

	    <para><anchor xml:id="asteriskreg" />The asterisk --
	    <token>*</token> -- matches any number of
	      repeats of the character string or RE preceding it,
	      including <emphasis>zero</emphasis> instances.</para>

	    <para><quote>1133*</quote> matches <replaceable>11 +
	      one or more 3's</replaceable>:
	      <replaceable>113</replaceable>, <replaceable>1133</replaceable>,
	      <replaceable>1133333</replaceable>, and so forth.</para>

	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>

	    <para><anchor xml:id="regexdot" />The <firstterm>dot</firstterm>
	    -- <token>.</token> -- matches
	      any one character, except a newline.
	        <footnote><para>Since <link linkend="sedref">sed</link>, <link linkend="awkref">awk</link>, and <link linkend="grepref">grep</link> process single lines, there
		  will usually not be a newline to match. In those cases where
		  there is a newline in a multiple line expression, the dot
		  will match the newline.
	            <programlisting>#!/bin/bash

sed -e 'N;s/.*/[&amp;]/' &lt;&lt; EOF   # Here Document
line1
line2
EOF
# OUTPUT:
# [line1
# line2]



echo

awk '{ $0=$1 "\n" $2; if (/line.1/) {print}}' &lt;&lt; EOF
line 1
line 2
EOF
# OUTPUT:
# line
# 1


# Thanks, S.C.

exit 0</programlisting></para></footnote>  
	    </para>

	   <para><quote>13.</quote> matches <replaceable>13 + at
	     least one of any character (including a
	     space)</replaceable>: <replaceable>1133</replaceable>,
	     <replaceable>11333</replaceable>, but not
	     <replaceable>13</replaceable> (additional character
	     missing).</para>

	     <para>See <xref linkend="cwsolver" /> for a demonstration
	       of <firstterm>dot single-character</firstterm>
	       matching.</para>
	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>^</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>^</secondary>
	    </indexterm>
	    <para><anchor xml:id="caretref" />The caret -- <token>^</token>
	      -- matches the beginning of a line, but sometimes, depending
	      on context, negates the meaning of a set of characters in
	      an RE.</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <para><anchor xml:id="dollarsignref" /></para>
	    <para>The dollar sign -- <token>$</token> -- at the end of an
	      RE matches the end of a line.</para>
	    <para><quote>XXX$</quote> matches <token>XXX</token> at the
	      end of a line.</para>
	    <para><quote>^$</quote> matches blank lines.</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>[...]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>[...]</secondary>
	    </indexterm>

	    <para><anchor xml:id="bracketsref" /></para>
	    <para>Brackets -- <token>[...]</token> -- enclose a set of characters
	      to match in a single RE.</para>

	    <para><quote>[xyz]</quote> matches any one of the characters
	      <replaceable>x</replaceable>, <replaceable>y</replaceable>,
	      or <replaceable>z</replaceable>.</para>

	    <para><quote>[c-n]</quote> matches any one of the
	      characters in the range <replaceable>c</replaceable>
	      to <replaceable>n</replaceable>.</para>

	    <para><quote>[B-Pk-y]</quote> matches any one of the
	      characters in the ranges <replaceable>B</replaceable>
	      to <replaceable>P</replaceable>
	      and <replaceable>k</replaceable> to
	      <replaceable>y</replaceable>.</para>

	    <para><quote>[a-z0-9]</quote> matches any single lowercase
	      letter or any digit.</para>

	    <para><quote>[^b-d]</quote> matches any character
	      <emphasis>except</emphasis> those in
	      the range <replaceable>b</replaceable> to
	      <replaceable>d</replaceable>. This is an instance of
	      <token>^</token> negating or inverting the meaning
	      of the following RE (taking on a role similar to
	      <token>!</token> in a different context).</para>

	    <para>Combined sequences of bracketed characters match  
	      common word patterns. <quote>[Yy][Ee][Ss]</quote> matches
	      <replaceable>yes</replaceable>, <replaceable>Yes</replaceable>,
	      <replaceable>YES</replaceable>, <replaceable>yEs</replaceable>,
	      and so forth.
	      <quote>[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]</quote>
	      matches any Social Security number.</para>

	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>\</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\</secondary>
	    </indexterm>

	    <para><anchor xml:id="regexbs" /></para>
	    <para>The backslash -- <token>\</token> -- <link linkend="escp">escapes</link> a special character, which
              means that character gets interpreted literally (and is
              therefore no longer <firstterm>special</firstterm>).</para>

	     <para>A <quote>\$</quote> reverts back to its
	       literal meaning of <quote>$</quote>, rather than its
	       RE meaning of end-of-line. Likewise a <quote>\\</quote>
	       has the literal meaning of <quote>\</quote>.</para>
	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>\&lt; \&gt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\&lt; \&gt;</secondary>
	    </indexterm>

	    <para><anchor xml:id="anglebrac" /></para>
	    <para><link linkend="escp">Escaped</link> <quote>angle
	      brackets</quote> -- <token>\&lt;...\&gt;</token> -- mark word
	      boundaries.</para>

	    <para>The angle brackets must be escaped, since otherwise
	      they have only their literal character meaning.</para>

	    <para><quote>\&lt;the\&gt;</quote> matches the word
	      <quote>the,</quote> but not the words <quote>them,</quote>
	      <quote>there,</quote> <quote>other,</quote> etc.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cat textfile</userinput>
<computeroutput>This is line 1, of which there is only one instance.
 This is the only instance of line 2.
 This is line 3, another line.
 This is line 4.</computeroutput>


<prompt>bash$ </prompt><userinput>grep 'the' textfile</userinput>
<computeroutput>This is line 1, of which there is only one instance.
 This is the only instance of line 2.
 This is line 3, another line.</computeroutput>


<prompt>bash$ </prompt><userinput>grep '\&lt;the\&gt;' textfile</userinput>
<computeroutput>This is the only instance of line 2.</computeroutput>
	      </screen>
	    </para>

	  </listitem>

	</itemizedlist>

	<sidebar>
	  <para>The only way to be certain that a particular RE works is to
	    test it.</para>

          <para><programlisting>TEST FILE: tstfile                          # No match.
                                            # No match.
Run   grep "1133*"  on this file.           # Match.
                                            # No match.
                                            # No match.
This line contains the number 113.          # Match.
This line contains the number 13.           # No match.
This line contains the number 133.          # No match.
This line contains the number 1133.         # Match.
This line contains the number 113312.       # Match.
This line contains the number 1112.         # No match.
This line contains the number 113312312.    # Match.
This line contains no numbers at all.       # No match.</programlisting></para>

	      <screen><prompt>bash$ </prompt><userinput>grep "1133*" tstfile</userinput>
<computeroutput>Run   grep "1133*"  on this file.           # Match.
 This line contains the number 113.          # Match.
 This line contains the number 1133.         # Match.
 This line contains the number 113312.       # Match.
 This line contains the number 113312312.    # Match.</computeroutput>
	      </screen>

	</sidebar>

	<itemizedlist>

	  <listitem override="square">
	    <formalpara>
	      <title><anchor xml:id="extregex" />Extended REs</title>

	      <para>Additional metacharacters added to the basic set. Used
		in <link linkend="egrepref">egrep</link>,
		<link linkend="awkref">awk</link>, and <link linkend="perlref">Perl</link>.</para>

	      </formalpara>
	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>

	    <para><anchor xml:id="quexregex" /></para>
	    <para>The question mark -- <token>?</token> -- matches zero or
	      one of the previous RE. It is generally used for matching
	      single characters.</para>

	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>+</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>+</secondary>
	    </indexterm>

	    <para><anchor xml:id="plusref" /></para>
	    <para>The plus -- <token>+</token> -- matches one or more of the
	    previous RE. It serves a role similar to the <token>*</token>, but
	    does <emphasis>not</emphasis> match zero occurrences.</para>

	    <para><programlisting># GNU versions of sed and awk can use "+",
# but it needs to be escaped.

echo a111b | sed -ne '/a1\+b/p'
echo a111b | grep 'a1\+b'
echo a111b | gawk '/a1+b/'
# All of above are equivalent.

# Thanks, S.C.</programlisting></para>

          <para><anchor xml:id="escpcb" /></para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>\{ \}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\{ \}</secondary>
	    </indexterm>

	    <para><link linkend="escp">Escaped</link> <quote>curly
	      brackets</quote> -- <token>\{ \}</token> -- indicate the number
	      of occurrences of a preceding RE to match.</para>


	    <para>It is necessary to escape the curly brackets since
	      they have only their literal character meaning
	      otherwise. This usage is technically not part of the basic
	      RE set.</para>

	    <para><quote>[0-9]\{5\}</quote> matches exactly five digits
	      (characters in the range of 0 to 9).</para>

	    <note>
	    <para>Curly brackets are not available as an RE in the
	      <quote>classic</quote> (non-POSIX compliant) version
	      of <link linkend="awkref">awk</link>.
	      <anchor xml:id="gnugawk" />However, the GNU extended version
	      of <firstterm>awk</firstterm>, <command>gawk</command>,
	      has the <option>--re-interval</option> option that permits
	      them (without being escaped).</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo 2222 | gawk --re-interval '/2{3}/'</userinput>
<computeroutput>2222</computeroutput>
	      </screen>
	    </para>

	    <para><command>Perl</command> and some
	      <command>egrep</command> versions do not require escaping
	      the curly brackets.</para>

	      </note>

	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>()</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>()</secondary>
	    </indexterm>

	    <para><anchor xml:id="parengrps" /></para>
	    <para>Parentheses -- <command>( )</command> -- enclose a group of
	      REs. They are useful with the following
	      <quote><token>|</token></quote> operator and in <link linkend="exprparen">substring extraction</link> using <link linkend="exprref">expr</link>.</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>|</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>|</secondary>
	    </indexterm>

	    <para>The -- <command>|</command> -- <quote>or</quote> RE operator
	      matches any of a set of alternate characters.</para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>egrep 're(a|e)d' misc.txt</userinput>
<computeroutput>People who read seem to be better informed than those who do not.
 The clarinet produces sound by the vibration of its reed.</computeroutput>
	      </screen>
	      </para>
	  </listitem>

	</itemizedlist>

	    <note><para>Some versions of <command>sed</command>,
	      <command>ed</command>, and <command>ex</command> support
	      escaped versions of the extended Regular Expressions
	      described above, as do the GNU utilities.</para></note>


	<itemizedlist>

	  <listitem override="square">

	    <formalpara><title><anchor xml:id="posixref" />POSIX Character Classes</title>
	      <para><userinput>[:class:]</userinput></para></formalpara>

	    <indexterm>
	      <primary>[:</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>:]</secondary>
	    </indexterm>

	    <para>This is an alternate method of specifying a range of
	      characters to match.</para>

	  </listitem>


	  <listitem>

	    <indexterm>
	      <primary>alnum</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>alphabetic numeric</secondary>
	    </indexterm>

	    <para><userinput>[:alnum:]</userinput> matches alphabetic or
	      numeric characters. This is equivalent to
	      <userinput>A-Za-z0-9</userinput>.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>alpha</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>alphabetic</secondary>
	    </indexterm>

	    <para><userinput>[:alpha:]</userinput> matches alphabetic
	      characters. This is equivalent to
	      <userinput>A-Za-z</userinput>.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>blank</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>space tab</secondary>
	    </indexterm>

	    <para><userinput>[:blank:]</userinput> matches a space or a
	      tab.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>cntrl</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>control</secondary>
	    </indexterm>

	    <para><userinput>[:cntrl:]</userinput> matches control
	      characters.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>digit</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>decimal digit</secondary>
	    </indexterm>

	    <para><userinput>[:digit:]</userinput> matches (decimal)
	      digits. This is equivalent to
	      <userinput>0-9</userinput>.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>graph</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>graph</secondary>
	    </indexterm>

	    <para><userinput>[:graph:]</userinput> (graphic printable
		    characters). Matches characters in the range of <link linkend="asciidef">ASCII</link> 33 - 126. This is
		    the same as <userinput>[:print:]</userinput>, below,
		    but excluding the space character.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>lower</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>lowercase</secondary>
	    </indexterm>

	    <para><userinput>[:lower:]</userinput> matches lowercase
	      alphabetic characters. This is equivalent to
	      <userinput>a-z</userinput>.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>print</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>printable</secondary>
	    </indexterm>

	    <para><userinput>[:print:]</userinput> (printable
	      characters). Matches characters in the range of ASCII 32 -
	      126. This is the same as <userinput>[:graph:]</userinput>,
	      above, but adding the space character.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>space</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>whitespace</secondary>
	    </indexterm>

	    <para><anchor xml:id="wsposix" /><userinput>[:space:]</userinput>
	      matches whitespace characters (space and horizontal
	      tab).</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>upper</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>uppercase</secondary>
	    </indexterm>

	    <para><userinput>[:upper:]</userinput> matches uppercase
	      alphabetic characters. This is equivalent to
	      <userinput>A-Z</userinput>.</para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>xdigit</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>hexadecimal</secondary>
	    </indexterm>

	    <para><userinput>[:xdigit:]</userinput> matches hexadecimal
	      digits. This is equivalent to
	      <userinput>0-9A-Fa-f</userinput>.</para>

            <important>
	    <para>POSIX character classes generally require quoting
	      or <link linkend="dblbrackets">double brackets</link>
	      ([[ ]]).</para>
	    </important>  

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep [[:digit:]] test.file</userinput>
<computeroutput>abc=723</computeroutput>
	      </screen>
	    </para>

	    <para><programlisting># ...
if [[ $arow =~ [[:digit:]] ]]   #  Numerical input?
then       #  POSIX char class
  if [[ $acol =~ [[:alpha:]] ]] # Number followed by a letter? Illegal!
# ...
# From ktour.sh example script.</programlisting>
	    </para>

	    <para>These character classes may even be used with <link linkend="globbingref">globbing</link>, to a limited
	      extent.</para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>ls -l ?[[:digit:]][[:digit:]]?</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b</computeroutput>
	      </screen>
	    </para>

	    <para>POSIX character classes are used in
	      <xref linkend="ex49" /> and <xref linkend="lowercase" />.</para>


	  </listitem>

	</itemizedlist>


	<para><link linkend="sedref">Sed</link>, <link linkend="awkref">awk</link>, and <link linkend="perlref">Perl</link>, used as filters in scripts, take
	  REs as arguments when "sifting" or transforming files or I/O
	  streams. See <xref linkend="behead" /> and <xref linkend="tree" />
	  for illustrations of this.</para>

	<para>The standard reference on this complex topic is Friedl's
	  <citetitle pubwork="book">Mastering Regular
	  Expressions</citetitle>. <citetitle pubwork="book">Sed &amp;
	  Awk</citetitle>, by Dougherty and Robbins, also gives a very
	  lucid treatment of REs. See the <xref linkend="biblio" /> for
	  more information on these books.</para>

      </section> <!-- A Brief Introduction to Regular Expressions -->




      <section xml:id="globbingref">
	<title>Globbing</title>

	<para><anchor xml:id="globbingref2" /></para>
	<para>Bash itself cannot recognize Regular Expressions. Inside
	  scripts, it is commands and utilities -- such as
	  <link linkend="sedref">sed</link> and <link linkend="awkref">awk</link> -- that interpret RE's.</para>


	<para>Bash <emphasis>does</emphasis> carry out <firstterm>filename
	  expansion</firstterm>

            <footnote><para><firstterm>Filename expansion</firstterm>
            means expanding filename patterns or templates
            containing special characters. For example,
            <filename>example.???</filename> might expand
            to <filename>example.001</filename> and/or
            <filename>example.txt</filename>.</para></footnote>
	  
	  -- a process known as <firstterm>globbing</firstterm> -- but
	  this does <emphasis>not</emphasis> use the standard RE set.
	  Instead, globbing recognizes and expands <firstterm>wild
	  cards</firstterm>. Globbing interprets the standard wild
	  card characters
	      <footnote><para><anchor xml:id="wildcarddef" />A <firstterm>wild
	      card</firstterm> character, analogous to a wild card in poker,
	      can represent (almost) any other character.</para></footnote>
	  -- <link linkend="asteriskref">*</link> and
	  <link linkend="wildcardqu">?</link>, character lists in
	  square brackets, and certain other special characters (such
	  as <token>^</token> for negating the sense of a match).
          <anchor xml:id="wdotfilewc" />There are important limitations on wild
	  card characters in globbing, however. Strings containing
	  <replaceable>*</replaceable> will not match filenames that
	  start with a dot, as, for example, <link linkend="sample-bashrc"><filename>.bashrc</filename></link>.

	    <footnote>
	    <para>
	    Filename expansion <emphasis>can</emphasis>
	    match dotfiles, but only if the pattern explicitly includes the dot
	    as a literal character.
	        <programlisting>~/[.]bashrc    #  Will not expand to ~/.bashrc
~/?bashrc      #  Neither will this.
               #  Wild cards and metacharacters will NOT
               #+ expand to a dot in globbing.

~/.[b]ashrc    #  Will expand to ~/.bashrc
~/.ba?hrc      #  Likewise.
~/.bashr*      #  Likewise.

# Setting the "dotglob" option turns this off.

# Thanks, S.C.</programlisting>
	    </para>
	    </footnote>
	  
	  Likewise, the <replaceable>?</replaceable> has a different
	  meaning in globbing than as part of an RE.</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l t?.sh</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l [ab]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l [a-c]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l [^ab]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l {b*,c*,*est*}</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</computeroutput>
	      </screen>
	      </para>



	  <para>Bash performs filename expansion on unquoted command-line
	    arguments. The <link linkend="echoref">echo</link> command
	    demonstrates this.</para>

	   <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo *</userinput>
<computeroutput>a.1 b.1 c.1 t2.sh test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>echo t*</userinput>
<computeroutput>t2.sh test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>echo t?.sh</userinput>
<computeroutput>t2.sh</computeroutput>
	      </screen>
	   </para>

	  <note><para>It is possible to modify the way Bash interprets
	    special characters in globbing. A <command>set -f</command>
	    command disables globbing, and the
	    <option>nocaseglob</option> and <option>nullglob</option>
	    options to <link linkend="shoptref">shopt</link> change
	    globbing behavior.</para></note>

	  <para>See also <xref linkend="listglob" />.</para>

          <caution><para><anchor xml:id="handlingfnames" />Filenames with
          embedded <link linkend="whitespaceref">whitespace</link>
	  can cause <firstterm>globbing</firstterm> to choke.
	  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.dwheeler.com/essays/filenames-in-shell.html">David
	  Wheeler</link> shows how to avoid many such pitfalls.</para>

	  <para><programlisting>IFS="$(printf '\n\t')"   # Remove space.

#  Correct glob use:
#  Always use for-loop, prefix glob, check if exists file.
for file in ./* ; do         # Use ./* ... NEVER bare *
  if [ -e "$file" ] ; then   # Check whether file exists.
     COMMAND ... "$file" ...
  fi
done

# This example taken from David Wheeler's site, with permission.</programlisting></para>

          </caution>

      </section> <!-- Globbing -->


  </chapter> <!-- Regular Expressions -->



  <chapter xml:id="here-docs">
    <title>Here Documents</title>

    <epigraph>
      <para>Here and now, boys.</para>
      <para>--Aldous Huxley, <firstterm>Island</firstterm></para>
    </epigraph>
    
      <para><anchor xml:id="heredocref" /></para>

      <indexterm>
	<primary>&lt;&lt;</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>&lt;&lt;</secondary>
      </indexterm>
      
      <para>A <firstterm>here document</firstterm> is a special-purpose
	code block. It uses a form of <link linkend="ioredirref">I/O
	redirection</link> to feed a command list to
	an interactive program or a command, such as <link linkend="ftpref">ftp</link>, <link linkend="catref">cat</link>,
	or the <firstterm>ex</firstterm> text editor.</para>

      <para><programlisting>COMMAND &lt;&lt;InputComesFromHERE
...
...
...
InputComesFromHERE</programlisting></para>


      <para><anchor xml:id="limitstringref" /></para>
      <para>A <firstterm>limit string</firstterm> delineates (frames)
	the command list.  The special symbol <token>&lt;&lt;</token> precedes
	the limit string.  This has the effect of redirecting the output
	of a command block into the <filename>stdin</filename> of the program
	or command. It is similar to <userinput>interactive-program &lt;
	command-file</userinput>, where <filename>command-file</filename>
	contains

	  <programlisting>command #1
command #2
...</programlisting></para>

      <para>The <firstterm>here document</firstterm> equivalent looks
        like this:

      <programlisting>interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString</programlisting></para>

      <para>Choose a <firstterm>limit string</firstterm> sufficiently
	unusual that it will not occur anywhere in the command list and
	confuse matters.</para>

      <para>Note that <firstterm>here documents</firstterm> may sometimes
	be used to good effect with non-interactive utilities and commands,
	such as, for example, <link linkend="wallref">wall</link>.</para>


      <example xml:id="ex70">
	<title><firstterm>broadcast</firstterm>: Sends message to everyone
	logged in</title>
	<programlisting>#!/bin/bash

wall &lt;&lt;zzz23EndOfMessagezzz23
E-mail your noontime orders for pizza to the system administrator.
    (Add an extra dollar for anchovy or mushroom topping.)
# Additional message text goes here.
# Note: 'wall' prints comment lines.
zzz23EndOfMessagezzz23

# Could have been done more efficiently by
#         wall &lt;message-file
#  However, embedding the message template in a script
#+ is a quick-and-dirty one-off solution.

exit
</programlisting>
      </example>


      <para><anchor xml:id="vihere" /></para>
      <para>Even such unlikely candidates as the <firstterm>vi</firstterm>
        text editor lend themselves to <firstterm>here
        documents</firstterm>.</para>

      <example xml:id="ex69">
	<title><firstterm>dummyfile</firstterm>: Creates a 2-line dummy
	file</title>
	<programlisting>#!/bin/bash

# Noninteractive use of 'vi' to edit a file.
# Emulates 'sed'.

E_BADARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

TARGETFILE=$1

# Insert 2 lines in file, then save.
#--------Begin here document-----------#
vi $TARGETFILE &lt;&lt;x23LimitStringx23
i
This is line 1 of the example file.
This is line 2 of the example file.
^[
ZZ
x23LimitStringx23
#----------End here document-----------#

#  Note that ^[ above is a literal escape
#+ typed by Control-V &lt;Esc&gt;.

#  Bram Moolenaar points out that this may not work with 'vim'
#+ because of possible problems with terminal interaction.

exit
</programlisting>
      </example>

      <para>
        The above script could just as effectively have been implemented with
	<command>ex</command>, rather than
	<command>vi</command>. <anchor xml:id="exscriptref" /><firstterm>Here
	documents</firstterm> containing a list of <command>ex</command>
	commands are common enough to form their own category, known as
	<firstterm>ex scripts</firstterm>.

	  <programlisting>#!/bin/bash
#  Replace all instances of "Smith" with "Jones"
#+ in files with a ".txt" filename suffix. 

ORIGINAL=Smith
REPLACEMENT=Jones

for word in $(fgrep -l $ORIGINAL *.txt)
do
  # -------------------------------------
  ex $word &lt;&lt;EOF
  :%s/$ORIGINAL/$REPLACEMENT/g
  :wq
EOF
  # :%s is the "ex" substitution command.
  # :wq is write-and-quit.
  # -------------------------------------
done</programlisting>
	</para>

      <para><anchor xml:id="catscriptref" /></para>
      <para>Analogous to <quote>ex scripts</quote> are <firstterm>cat
        scripts</firstterm>.</para>

      <example xml:id="ex71">
	<title>Multi-line message using <firstterm>cat</firstterm></title>
	<programlisting>#!/bin/bash

#  'echo' is fine for printing single line messages,
#+  but somewhat problematic for message blocks.
#   A 'cat' here document overcomes this limitation.

cat &lt;&lt;End-of-message
-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------
End-of-message

#  Replacing line 7, above, with
#+   cat &gt; $Newfile &lt;&lt;End-of-message
#+       ^^^^^^^^^^
#+ writes the output to the file $Newfile, rather than to stdout.

exit 0


#--------------------------------------------
# Code below disabled, due to "exit 0" above.

# S.C. points out that the following also works.
echo "-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------"
# However, text may not include double quotes unless they are escaped.
</programlisting>
      </example>


      <para><anchor xml:id="limitstrdash" /></para>
      <para>The <option>-</option> option to mark a here document limit string
	(<userinput>&lt;&lt;-LimitString</userinput>) suppresses leading
	tabs (but not spaces) in the output. This may be useful in making
	a script more readable.</para>

      <example xml:id="ex71a">
	<title>Multi-line message, with tabs suppressed</title>
	<programlisting>#!/bin/bash
# Same as previous example, but...

#  The - option to a here document &lt;&lt;-
#+ suppresses leading tabs in the body of the document,
#+ but *not* spaces.

cat &lt;&lt;-ENDOFMESSAGE
	This is line 1 of the message.
	This is line 2 of the message.
	This is line 3 of the message.
	This is line 4 of the message.
	This is the last line of the message.
ENDOFMESSAGE
# The output of the script will be flush left.
# Leading tab in each line will not show.

# Above 5 lines of "message" prefaced by a tab, not spaces.
# Spaces not affected by   &lt;&lt;-  .

# Note that this option has no effect on *embedded* tabs.

exit 0
</programlisting>
      </example>


      <para><anchor xml:id="herepassp" /></para>
      <para>A <firstterm>here document</firstterm> supports parameter and
	command substitution.  It is therefore possible to pass different
	parameters to the body of the here document, changing its output
	accordingly.</para>

      <example xml:id="ex71b">
	<title>Here document with replaceable parameters</title>
	<programlisting>#!/bin/bash
# Another 'cat' here document, using parameter substitution.

# Try it with no command-line parameters,   ./scriptname
# Try it with one command-line parameter,   ./scriptname Mortimer
# Try it with one two-word quoted command-line parameter,
#                           ./scriptname "Mortimer Jones"

CMDLINEPARAM=1     #  Expect at least command-line parameter.

if [ $# -ge $CMDLINEPARAM ]
then
  NAME=$1          #  If more than one command-line param,
                   #+ then just take the first.
else
  NAME="John Doe"  #  Default, if no command-line parameter.
fi  

RESPONDENT="the author of this fine script"  
  

cat &lt;&lt;Endofmessage

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

# This comment shows up in the output (why?).

Endofmessage

# Note that the blank lines show up in the output.
# So does the comment.

exit
</programlisting>
      </example>

      <para><anchor xml:id="hereparamsub" /></para>
      <para>This is a useful script containing a <firstterm>here
        document</firstterm> with parameter substitution.</para>

      <example xml:id="ex72">
	<title>Upload a file pair to <firstterm>Sunsite</firstterm> incoming
	  directory</title>
	<programlisting>#!/bin/bash
# upload.sh

#  Upload file pair (Filename.lsm, Filename.tar.gz)
#+ to incoming directory at Sunsite/UNC (ibiblio.org).
#  Filename.tar.gz is the tarball itself.
#  Filename.lsm is the descriptor file.
#  Sunsite requires "lsm" file, otherwise will bounce contributions.


E_ARGERROR=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` Filename-to-upload"
  exit $E_ARGERROR
fi  


Filename=`basename $1`           # Strips pathname out of file name.

Server="ibiblio.org"
Directory="/incoming/Linux"
#  These need not be hard-coded into script,
#+ but may instead be changed to command-line argument.

Password="your.e-mail.address"   # Change above to suit.

ftp -n $Server &lt;&lt;End-Of-Session
# -n option disables auto-logon

user anonymous "$Password"       #  If this doesn't work, then try:
                                 #  quote user anonymous "$Password"
binary
bell                             # Ring 'bell' after each file transfer.
cd $Directory
put "$Filename.lsm"
put "$Filename.tar.gz"
bye
End-Of-Session

exit 0
</programlisting>
      </example>

      
      <para><anchor xml:id="hereesc" /></para>
      <para>Quoting or escaping the <quote>limit string</quote> at the
        head of a here document disables parameter substitution within its
	body. The reason for this is that <firstterm>quoting/escaping the
	limit string</firstterm> effectively <link linkend="escp">escapes</link> the <token>$</token>,
	<token>`</token>, and <token>\</token> <link linkend="scharlist">special characters</link>, and causes them to
	be interpreted literally. (Thank you, Allen Halsey, for pointing
	this out.)</para>

      <example xml:id="ex71c">
	<title>Parameter substitution turned off</title>
	<programlisting>#!/bin/bash
#  A 'cat' here-document, but with parameter substitution disabled.

NAME="John Doe"
RESPONDENT="the author of this fine script"  

cat &lt;&lt;'Endofmessage'

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

Endofmessage

#   No parameter substitution when the "limit string" is quoted or escaped.
#   Either of the following at the head of the here document would have
#+  the same effect.
#   cat &lt;&lt;"Endofmessage"
#   cat &lt;&lt;\Endofmessage



#   And, likewise:

cat &lt;&lt;"SpecialCharTest"

Directory listing would follow
if limit string were not quoted.
`ls -l`

Arithmetic expansion would take place
if limit string were not quoted.
$((5 + 3))

A a single backslash would echo
if limit string were not quoted.
\\

SpecialCharTest


exit
</programlisting>
      </example>

      <para><anchor xml:id="herelit" /></para>
      <para>Disabling parameter substitution permits outputting literal text.
        Generating scripts or even program code is one use for this.</para>
      
      <example xml:id="generatescript">
	<title>A script that generates another script</title>
	<programlisting>#!/bin/bash
# generate-script.sh
# Based on an idea by Albert Reiner.

OUTFILE=generated.sh         # Name of the file to generate.


# -----------------------------------------------------------
# 'Here document containing the body of the generated script.
(
cat &lt;&lt;'EOF'
#!/bin/bash

echo "This is a generated shell script."
#  Note that since we are inside a subshell,
#+ we can't access variables in the "outside" script.

echo "Generated file will be named: $OUTFILE"
#  Above line will not work as normally expected
#+ because parameter expansion has been disabled.
#  Instead, the result is literal output.

a=7
b=3

let "c = $a * $b"
echo "c = $c"

exit 0
EOF
) &gt; $OUTFILE
# -----------------------------------------------------------

#  Quoting the 'limit string' prevents variable expansion
#+ within the body of the above 'here document.'
#  This permits outputting literal strings in the output file.

if [ -f "$OUTFILE" ]
then
  chmod 755 $OUTFILE
  # Make the generated file executable.
else
  echo "Problem in creating file: \"$OUTFILE\""
fi

#  This method also works for generating
#+ C programs, Perl programs, Python programs, Makefiles,
#+ and the like.

exit 0
</programlisting>
      </example>



      <para><anchor xml:id="herecs" /></para>
      <para>
        It is possible to set a variable from the output of a here document.
	This is actually a devious form of <link linkend="commandsubref">command substitution</link>.
	<programlisting>variable=$(cat &lt;&lt;SETVAR
This variable
runs over multiple lines.
SETVAR
)

echo "$variable"</programlisting>
      </para>


      <para><anchor xml:id="herefunc" /></para>
      <para>A here document can supply input to a function in the same
        script.</para>

	    <example xml:id="hf">
	      <title>Here documents and functions</title>
	      <programlisting>#!/bin/bash
# here-function.sh

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city 
  read state 
  read zipcode
} # This certainly appears to be an interactive function, but . . .


# Supply input to the above function.
GetPersonalData &lt;&lt;RECORD001
Bozo
Bozeman
2726 Nondescript Dr.
Bozeman
MT
21226
RECORD001


echo
echo "$firstname $lastname"
echo "$address"
echo "$city, $state $zipcode"
echo

exit 0
</programlisting>
	    </example>

      <para><anchor xml:id="anonheredoc0" /></para>
      <para>It is possible to use <token>:</token> as a dummy command
        accepting output from a here document. This, in effect, creates an
	<quote>anonymous</quote> here document.</para>

	<example xml:id="anonheredoc">
	  <title><quote>Anonymous</quote> Here Document</title>
	<programlisting>#!/bin/bash

: &lt;&lt;TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # Print error message if one of the variables not set.
TESTVARIABLES

exit $?</programlisting>
       </example>


      <para><anchor xml:id="cblock1" /></para>
      <tip><para>A variation of the above technique permits <quote>commenting
        out</quote> blocks of code.</para></tip>

      <example xml:id="commentblock">
	<title>Commenting out a block of code</title>
	<programlisting>#!/bin/bash
# commentblock.sh

: &lt;&lt;COMMENTBLOCK
echo "This line will not echo."
This is a comment line missing the "#" prefix.
This is another comment line missing the "#" prefix.

&amp;*@!!++=
The above line will cause no error message,
because the Bash interpreter will ignore it.
COMMENTBLOCK

echo "Exit value of above \"COMMENTBLOCK\" is $?."   # 0
# No error shown.
echo


#  The above technique also comes in useful for commenting out
#+ a block of working code for debugging purposes.
#  This saves having to put a "#" at the beginning of each line,
#+ then having to go back and delete each "#" later.
#  Note that the use of colon, above, is optional.

echo "Just before commented-out code block."
#  The lines of code between the double-dashed lines will not execute.
#  ===================================================================
: &lt;&lt;DEBUGXXX
for file in *
do
 cat "$file"
done
DEBUGXXX
#  ===================================================================
echo "Just after commented-out code block."

exit 0



######################################################################
#  Note, however, that if a bracketed variable is contained within
#+ the commented-out code block,
#+ then this could cause problems.
#  for example:


#/!/bin/bash

  : &lt;&lt;COMMENTBLOCK
  echo "This line will not echo."
  &amp;*@!!++=
  ${foo_bar_bazz?}
  $(rm -rf /tmp/foobar/)
  $(touch my_build_directory/cups/Makefile)
COMMENTBLOCK


$ sh commented-bad.sh
commented-bad.sh: line 3: foo_bar_bazz: parameter null or not set

# The remedy for this is to strong-quote the 'COMMENTBLOCK' in line 49, above.

  : &lt;&lt;'COMMENTBLOCK'

# Thank you, Kurt Pfeifle, for pointing this out.
</programlisting>
      </example>


      <para><anchor xml:id="hselfdoc" /></para>
      <tip><para>Yet another twist of this nifty trick makes
        <quote>self-documenting</quote> scripts possible.</para></tip>

      <example xml:id="selfdocument">
	<title>A self-documenting script</title>
	<programlisting>#!/bin/bash
# self-document.sh: self-documenting script
# Modification of "colm.sh".

DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # Request help.
then
  echo; echo "Usage: $0 [directory-name]"; echo
  sed --silent -e '/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p' "$0" |
  sed -e '/DOCUMENTATIONXX$/d'; exit $DOC_REQUEST; fi


: &lt;&lt;DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command-line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX

if [ -z "$1" -o ! -r "$1" ]
then
  directory=.
else
  directory="$1"
fi  

echo "Listing of "$directory":"; echo
(printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
; ls -l "$directory" | sed 1d) | column -t

exit 0
</programlisting>
      </example>

      <para>Using a <link linkend="catscriptref">cat script</link> is an
        alternate way of accomplishing this.</para>

      <para>
      <programlisting>DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # Request help.
then                                       # Use a "cat script" . . .
  cat &lt;&lt;DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command-line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX
exit $DOC_REQUEST
fi</programlisting>
      </para>


      <para>See also <xref linkend="isspammer2" />, <xref linkend="petals" />,
        <xref linkend="qky" />, and <xref linkend="nim" /> for more examples
        of self-documenting scripts.</para>

	  <para><anchor xml:id="heretemp" /></para>
	  <note>
	  <para>Here documents create temporary files, but these
	    files are deleted after opening and are not accessible to
	    any other process.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>bash -c 'lsof -a -p $$ -d0' &lt;&lt; EOF</userinput>
<prompt>&gt; </prompt><userinput>EOF</userinput>
<computeroutput>lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)</computeroutput>
	      </screen>
	  </para>
	  </note>

	<caution><para>Some utilities will not work inside a
	  <firstterm>here document</firstterm>.</para></caution>

         <para><anchor xml:id="indentedls" /></para>

	<warning>

	<para>The closing <firstterm>limit string</firstterm>,
	  on the final line of a here document, must start in the
	  <emphasis>first</emphasis> character position. There can
	  be <emphasis>no leading whitespace</emphasis>. Trailing
	  whitespace after the limit string likewise causes unexpected
	  behavior. The whitespace prevents the limit string from being
	  recognized.
  
          <footnote><para>Except, as Dennis Benzinger points out,
          if <link linkend="limitstrdash">using
          <command>&lt;&lt;-</command> to suppress
          tabs</link>.</para></footnote>
	  
	  </para>

	  
	  
	 <para>
	 <programlisting>#!/bin/bash

echo "----------------------------------------------------------------------"

cat &lt;&lt;LimitString
echo "This is line 1 of the message inside the here document."
echo "This is line 2 of the message inside the here document."
echo "This is the final line of the message inside the here document."
     LimitString
#^^^^Indented limit string. Error! This script will not behave as expected.

echo "----------------------------------------------------------------------"

#  These comments are outside the 'here document',
#+ and should not echo.

echo "Outside the here document."

exit 0

echo "This line had better not echo."  # Follows an 'exit' command.</programlisting>
	 </para>
	  </warning>

	  <caution>
          <para><anchor xml:id="exclls" />Some people very cleverly use a
          single <token>!</token> as a limit string. But, that's not
          necessarily a good idea.</para>
    <para><programlisting># This works.
cat &lt;&lt;!
Hello!
! Three more exclamations !!!
!


# But . . .
cat &lt;&lt;!
Hello!
Single exclamation point follows!
!
!
# Crashes with an error message.


# However, the following will work.
cat &lt;&lt;EOF
Hello!
Single exclamation point follows!
!
EOF
# It's safer to use a multi-character limit string.</programlisting></para>
	  </caution>



	<para>For those tasks too complex for a <firstterm>here
	  document</firstterm>, consider using the
	  <replaceable>expect</replaceable> scripting language, which
	  was specifically designed for feeding input into interactive
	  programs.</para>



      <section><title>Here Strings</title>

	 <para><anchor xml:id="herestringsref" /></para>

	   <blockquote>
	     <literallayout>
A <firstterm>here string</firstterm> can be considered as a stripped-down form of a <firstterm>here document</firstterm>.
It consists of nothing more than <command>COMMAND &lt;&lt;&lt; $WORD</command>,
where <varname>$WORD</varname> is expanded and fed to the <filename>stdin</filename> of <command>COMMAND</command>.
	     </literallayout>
	   </blockquote>

        <para>As a simple example, consider this alternative to the <link linkend="echogrepref">echo-grep</link> construction.</para>

        <para>
	  <programlisting># Instead of:
if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
# etc.

# Try:
if grep -q "txt" &lt;&lt;&lt; "$VAR"
then   #         ^^^
   echo "$VAR contains the substring sequence \"txt\""
fi
# Thank you, Sebastian Kaminski, for the suggestion.</programlisting>
        </para>

	<para><anchor xml:id="hsread" /></para>
        <para>Or, in combination with <link linkend="readref">read</link>:</para>

        <para>
	<programlisting>String="This is a string of words."

read -r -a Words &lt;&lt;&lt; "$String"
#  The -a option to "read"
#+ assigns the resulting values to successive members of an array.

echo "First word in String is:    ${Words[0]}"   # This
echo "Second word in String is:   ${Words[1]}"   # is
echo "Third word in String is:    ${Words[2]}"   # a
echo "Fourth word in String is:   ${Words[3]}"   # string
echo "Fifth word in String is:    ${Words[4]}"   # of
echo "Sixth word in String is:    ${Words[5]}"   # words.
echo "Seventh word in String is:  ${Words[6]}"   # (null)
                                                 # Past end of $String.

# Thank you, Francisco Lobo, for the suggestion.</programlisting>
        </para>

	<para><anchor xml:id="hsloop" />It is, of course, possible to feed
	  the output of a <firstterm>here string</firstterm>
	  into the <filename>stdin</filename> of a <link linkend="loopref00">loop</link>.</para>

<para><programlisting># As Seamus points out . . .

ArrayVar=( element0 element1 element2 {A..D} )

while read element ; do
  echo "$element" 1&gt;&amp;2
done &lt;&lt;&lt; $(echo ${ArrayVar[*]})

# element0 element1 element2 A B C D</programlisting></para>

	<para><anchor xml:id="hspre" /></para>
      <example xml:id="prependex">
	<title>Prepending a line to a file</title>
	<programlisting>#!/bin/bash
# prepend.sh: Add text at beginning of file.
#
#  Example contributed by Kenny Stauffer,
#+ and slightly modified by document author.


E_NOSUCHFILE=85

read -p "File: " file   # -p arg to 'read' displays prompt.
if [ ! -e "$file" ]
then   # Bail out if no such file.
  echo "File $file not found."
  exit $E_NOSUCHFILE
fi

read -p "Title: " title
cat - $file &lt;&lt;&lt;$title &gt; $file.new

echo "Modified file is $file.new"

exit  # Ends script execution.

  from 'man bash':
  Here Strings
  	A variant of here documents, the format is:
  
  		&lt;&lt;&lt;word
  
  	The word is expanded and supplied to the command on its standard input.


  Of course, the following also works:
   sed -e '1i\
   Title: ' $file
</programlisting>
      </example>

      <example xml:id="mailboxgrep">
	<title>Parsing a mailbox</title>
	<programlisting>#!/bin/bash
#  Script by Francisco Lobo,
#+ and slightly modified and commented by ABS Guide author.
#  Used in ABS Guide with permission. (Thank you!)

# This script will not run under Bash versions -lt 3.0.


E_MISSING_ARG=87
if [ -z "$1" ]
then
  echo "Usage: $0 mailbox-file"
  exit $E_MISSING_ARG
fi

mbox_grep()  # Parse mailbox file.
{
    declare -i body=0 match=0
    declare -a date sender
    declare mail header value


    while IFS= read -r mail
#         ^^^^                 Reset $IFS.
#  Otherwise "read" will strip leading &amp; trailing space from its input.

   do
       if [[ $mail =~ ^From  ]]   # Match "From" field in message.
       then
          (( body  = 0 ))           # "Zero out" variables.
          (( match = 0 ))
          unset date

       elif (( body ))
       then
            (( match ))
            #  echo "$mail"
            #  Uncomment above line if you want entire body
            #+ of message to display.

   elif [[ $mail ]]; then
      IFS=: read -r header value &lt;&lt;&lt; "$mail"
      #                          ^^^  "here string"

      case "$header" in
      [Ff][Rr][Oo][Mm] ) [[ $value =~ "$2" ]] &amp;&amp; (( match++ )) ;;
      # Match "From" line.
      [Dd][Aa][Tt][Ee] ) read -r -a date &lt;&lt;&lt; "$value" ;;
      #                                  ^^^
      # Match "Date" line.
      [Rr][Ee][Cc][Ee][Ii][Vv][Ee][Dd] ) read -r -a sender &lt;&lt;&lt; "$value" ;;
      #                                                    ^^^
      # Match IP Address (may be spoofed).
      esac

       else
          (( body++ ))
          (( match  )) &amp;&amp;
          echo "MESSAGE ${date:+of: ${date[*]} }"
       #    Entire $date array             ^
          echo "IP address of sender: ${sender[1]}"
       #    Second field of "Received" line    ^

       fi


    done &lt; "$1" # Redirect stdout of file into loop.
}


mbox_grep "$1"  # Send mailbox file to function.

exit $?

# Exercises:
# ---------
# 1) Break the single function, above, into multiple functions,
#+   for the sake of readability.
# 2) Add additional parsing to the script, checking for various keywords.



$ mailbox_grep.sh scam_mail
  MESSAGE of Thu, 5 Jan 2006 08:00:56 -0500 (EST) 
  IP address of sender: 196.3.62.4
</programlisting>
      </example>

         <para>Exercise: Find other uses for <firstterm>here
           strings</firstterm>, such as, for example, <link linkend="goldenratio">feeding input to
           <firstterm>dc</firstterm></link>.</para>

      </section><!--   Here Strings    -->


  </chapter> <!-- Here Documents -->



  <chapter xml:id="io-redirection">
    <title>I/O Redirection</title>

      <para><anchor xml:id="ioredirref" /></para>

      <para>There are always three default <firstterm>files</firstterm>
         <footnote><para>By convention in UNIX and Linux, data streams
	 and peripherals (<link linkend="devfileref">device files</link>)
	 are treated as files, in a fashion analogous to ordinary
	 files.</para></footnote>
	open, <filename>stdin</filename> (the keyboard),
	<filename>stdout</filename> (the screen), and
	<filename>stderr</filename> (error messages output to the
	screen).  These, and any other open files, can be redirected.
	Redirection simply means capturing output from a file, command,
	program, script, or even code block within a script (see <xref linkend="ex8" /> and <xref linkend="rpmcheck" />) and sending it as
	input to another file, command, program, or script.</para>

      <para><anchor xml:id="fdref" />Each open file gets assigned a file descriptor.	

               <footnote><para><anchor xml:id="fdref1" />A <firstterm>file
		 descriptor</firstterm> is simply a number that
		 the operating system assigns to an open file
		 to keep track of it.  Consider it a simplified
		 type of file pointer. It is analogous
		 to a <firstterm>file handle</firstterm> in
		 <command>C</command>.</para></footnote>

	The file descriptors for <filename>stdin</filename>,
	<filename>stdout</filename>, and <filename>stderr</filename> are
	0, 1, and 2, respectively.  For opening additional files, there
	remain descriptors 3 to 9. It is sometimes useful to assign one of
	these additional file descriptors to <filename>stdin</filename>,
	<filename>stdout</filename>, or <filename>stderr</filename>
	as a temporary duplicate link.
	       <footnote><para>Using <replaceable>file
	       descriptor 5</replaceable> might cause problems.
	       When Bash creates a child process, as with <link linkend="execref">exec</link>, the child inherits
	       fd 5 (see Chet Ramey's archived e-mail, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://groups.google.com/group/gnu.bash.bug/browse_thread/thread/13955daafded3b5c/18c17050087f9f37">
	       SUBJECT: RE:  File descriptor 5 is held open</link>).
	       Best leave this particular fd alone.</para></footnote>
	This simplifies restoration to normal after complex redirection
	and reshuffling (see <xref linkend="redir1" />).</para>

      <para><anchor xml:id="ioredirectionref" /></para>

      <programlisting>   COMMAND_OUTPUT &gt;
      # Redirect stdout to a file.
      # Creates the file if not present, otherwise overwrites it.

      ls -lR &gt; dir-tree.list
      # Creates a file containing a listing of the directory tree.

   : &gt; filename
      # The &gt; truncates file "filename" to zero length.
      # If file not present, creates zero-length file (same effect as 'touch').
      # The : serves as a dummy placeholder, producing no output.

   &gt; filename    
      # The &gt; truncates file "filename" to zero length.
      # If file not present, creates zero-length file (same effect as 'touch').
      # (Same result as ": &gt;", above, but this does not work with some shells.)

   COMMAND_OUTPUT &gt;&gt;
      # Redirect stdout to a file.
      # Creates the file if not present, otherwise appends to it.


      # Single-line redirection commands (affect only the line they are on):
      # --------------------------------------------------------------------

   1&gt;filename
      # Redirect stdout to file "filename."
   1&gt;&gt;filename
      # Redirect and append stdout to file "filename."
   2&gt;filename
      # Redirect stderr to file "filename."
   2&gt;&gt;filename
      # Redirect and append stderr to file "filename."
   &amp;&gt;filename
      # Redirect both stdout and stderr to file "filename."
      # This operator is now functional, as of Bash 4, final release.

   M&gt;N
     # "M" is a file descriptor, which defaults to 1, if not explicitly set.
     # "N" is a filename.
     # File descriptor "M" is redirect to file "N."
   M&gt;&amp;N
     # "M" is a file descriptor, which defaults to 1, if not set.
     # "N" is another file descriptor.

      #==============================================================================

      # Redirecting stdout, one line at a time.
      LOGFILE=script.log

      echo "This statement is sent to the log file, \"$LOGFILE\"." 1&gt;$LOGFILE
      echo "This statement is appended to \"$LOGFILE\"." 1&gt;&gt;$LOGFILE
      echo "This statement is also appended to \"$LOGFILE\"." 1&gt;&gt;$LOGFILE
      echo "This statement is echoed to stdout, and will not appear in \"$LOGFILE\"."
      # These redirection commands automatically "reset" after each line.



      # Redirecting stderr, one line at a time.
      ERRORFILE=script.errors

      bad_command1 2&gt;$ERRORFILE       #  Error message sent to $ERRORFILE.
      bad_command2 2&gt;&gt;$ERRORFILE      #  Error message appended to $ERRORFILE.
      bad_command3                    #  Error message echoed to stderr,
                                      #+ and does not appear in $ERRORFILE.
      # These redirection commands also automatically "reset" after each line.
      #=======================================================================</programlisting>


      <para><anchor xml:id="ioredirectionref1" /></para>

      <programlisting>
   2&gt;&amp;1
      # Redirects stderr to stdout.
      # Error messages get sent to same place as standard output.
        &gt;&gt;filename 2&gt;&amp;1
            bad_command &gt;&gt;filename 2&gt;&amp;1
            # Appends both stdout and stderr to the file "filename" ...
        2&gt;&amp;1 | [command(s)]
            bad_command 2&gt;&amp;1 | awk '{print $5}'   # found
            # Sends stderr through a pipe.
            # |&amp; was added to Bash 4 as an abbreviation for 2&gt;&amp;1 |.

   i&gt;&amp;j
      # Redirects file descriptor <emphasis>i</emphasis> to <emphasis>j</emphasis>.
      # All output of file pointed to by <emphasis>i</emphasis> gets sent to file pointed to by <emphasis>j</emphasis>.

   &gt;&amp;j
      # Redirects, by default, file descriptor <emphasis>1</emphasis> (stdout) to <emphasis>j</emphasis>.
      # All stdout gets sent to file pointed to by <emphasis>j</emphasis>.</programlisting>

      <para><anchor xml:id="ioredirectionref2" /></para>

      <programlisting>
   0&lt; FILENAME
    &lt; FILENAME
      # Accept input from a file.
      # Companion command to <quote>&gt;</quote>, and often used in combination with it.
      #
      # grep search-word &lt;filename


   [j]&lt;&gt;filename
      #  Open file "filename" for reading and writing,
      #+ and assign file descriptor "j" to it.
      #  If "filename" does not exist, create it.
      #  If file descriptor "j" is not specified, default to fd 0, stdin.
      #
      #  An application of this is writing at a specified place in a file. 
      echo 1234567890 &gt; File    # Write string to "File".
      exec 3&lt;&gt; File             # Open "File" and assign fd 3 to it.
      read -n 4 &lt;&amp;3             # Read only 4 characters.
      echo -n . &gt;&amp;3             # Write a decimal point there.
      exec 3&gt;&amp;-                 # Close fd 3.
      cat File                  # ==&gt; 1234.67890
      #  Random access, by golly.



   |
      # Pipe.
      # General purpose process and command chaining tool.
      # Similar to <quote>&gt;</quote>, but more general in effect.
      # Useful for chaining commands, scripts, files, and programs together.
      cat *.txt | sort | uniq &gt; result-file
      # Sorts the output of all the .txt files and deletes duplicate lines,
      # finally saves results to <quote>result-file</quote>.</programlisting>

      <para>Multiple instances of input and output redirection
        and/or pipes can be combined in a single command
        line.

       <programlisting>command &lt; input-file &gt; output-file
# Or the equivalent:
&lt; input-file command &gt; output-file   # Although this is non-standard.

command1 | command2 | command3 &gt; output-file</programlisting>
        See <xref linkend="derpm" /> and <xref linkend="fifo" />.</para>

       
       <para>Multiple output streams may be redirected to one file.

         <programlisting>ls -yz &gt;&gt; command.log 2&gt;&amp;1
#  Capture result of illegal options "yz" in file "command.log."
#  Because stderr is redirected to the file,
#+ any error messages will also be there.

#  Note, however, that the following does *not* give the same result.
ls -yz 2&gt;&amp;1 &gt;&gt; command.log
#  Outputs an error message, but does not write to file.
#  More precisely, the command output (in this case, null)
#+ writes to the file, but the error message goes only to stdout.

#  If redirecting both stdout and stderr,
#+ the order of the commands makes a difference.
</programlisting></para>


      <variablelist xml:id="closingfiledescriptors">
        <title><anchor xml:id="cfd" />Closing File Descriptors</title>

	<varlistentry>
	  <term><token>n&lt;&amp;-</token></term>
	  <listitem>
	    <para>Close input file descriptor
	    <replaceable>n</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>0&lt;&amp;-</token></term>
	  <term><token>&lt;&amp;-</token></term>
	  <listitem>
	    <para>Close <filename>stdin</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>n&gt;&amp;-</token></term>
	  <listitem>
	    <para>Close output file descriptor <replaceable>n</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>1&gt;&amp;-</token></term>
	  <term><token>&gt;&amp;-</token></term>
	  <listitem>
	    <para>Close <filename>stdout</filename>.</para>
	  </listitem>
	</varlistentry>

      </variablelist>


        <para><anchor xml:id="fdref2" /></para>
        <para>Child processes inherit open file descriptors. This is
          why pipes work. To prevent an fd from being inherited, close it.
	    <programlisting># Redirecting only stderr to a pipe.

exec 3&gt;&amp;1                              # Save current "value" of stdout.
ls -l 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | grep bad 3&gt;&amp;-    # Close fd 3 for 'grep' (but not 'ls').
#              ^^^^   ^^^^
exec 3&gt;&amp;-                              # Now close it for the remainder of the script.

# Thanks, S.C.</programlisting>
        </para>

	<para>For a more detailed introduction to I/O redirection see
	  <xref linkend="ioredirintro" />.</para>




      <section><title>Using <firstterm>exec</firstterm></title>


	<para><anchor xml:id="usingexecref" /></para>

        <para>An <command>exec &lt;filename</command> command redirects
	  <filename>stdin</filename> to a file. From that point on, all
	  <filename>stdin</filename> comes from that file, rather than
	  its normal source (usually keyboard input). This provides a
	  method of reading a file line by line and possibly parsing
	  each line of input using <link linkend="sedref">sed</link>
	  and/or <link linkend="awkref">awk</link>.</para>

      <example xml:id="redir1">
	<title>Redirecting <filename>stdin</filename> using
	  <firstterm>exec</firstterm></title>
	<programlisting>#!/bin/bash
# Redirecting stdin using 'exec'.


exec 6&lt;&amp;0          # Link file descriptor #6 with stdin.
                   # Saves stdin.

exec &lt; data-file   # stdin replaced by file "data-file"

read a1            # Reads first line of file "data-file".
read a2            # Reads second line of file "data-file."

echo
echo "Following lines read from file."
echo "-------------------------------"
echo $a1
echo $a2

echo; echo; echo

exec 0&lt;&amp;6 6&lt;&amp;-
#  Now restore stdin from fd #6, where it had been saved,
#+ and close fd #6 ( 6&lt;&amp;- ) to free it for other processes to use.
#
# &lt;&amp;6 6&lt;&amp;-    also works.

echo -n "Enter data  "
read b1  # Now "read" functions as expected, reading from normal stdin.
echo "Input read from stdin."
echo "----------------------"
echo "b1 = $b1"

echo

exit 0
</programlisting>
      </example>

        <para>Similarly, an <command>exec &gt;filename</command>
	  command redirects <filename>stdout</filename> to a designated
	  file.  This sends all command output that would normally go
	  to <filename>stdout</filename> to that file.</para>

      <important>
        <para>
	  <command>exec N &gt; filename</command> affects the entire
	  script or <firstterm>current shell</firstterm>. Redirection in
	  the <link linkend="processidref">PID</link> of the script or shell
	  from that point on has changed. However . . .
        </para>
        <para>
	  <command>N &gt; filename</command> affects only the newly-forked process,
	  not the entire script or shell.
        </para>
	<para>Thank you, Ahmed Darwish, for pointing this out.</para>
      </important>



      <example xml:id="reassignstdout">
	<title>Redirecting <filename>stdout</filename> using
	  <firstterm>exec</firstterm></title>
	<programlisting>#!/bin/bash
# reassign-stdout.sh

LOGFILE=logfile.txt

exec 6&gt;&amp;1           # Link file descriptor #6 with stdout.
                    # Saves stdout.

exec &gt; $LOGFILE     # stdout replaced with file "logfile.txt".

# ----------------------------------------------------------- #
# All output from commands in this block sent to file $LOGFILE.

echo -n "Logfile: "
date
echo "-------------------------------------"
echo

echo "Output of \"ls -al\" command"
echo
ls -al
echo; echo
echo "Output of \"df\" command"
echo
df

# ----------------------------------------------------------- #

exec 1&gt;&amp;6 6&gt;&amp;-      # Restore stdout and close file descriptor #6.

echo
echo "== stdout now restored to default == "
echo
ls -al
echo

exit 0
</programlisting>
      </example>

      <example xml:id="upperconv">
	<title>Redirecting both <filename>stdin</filename> and
	  <filename>stdout</filename> in the same script with
	  <firstterm>exec</firstterm></title>
	<programlisting>#!/bin/bash
# upperconv.sh
# Converts a specified input file to uppercase.

E_FILE_ACCESS=70
E_WRONG_ARGS=71

if [ ! -r "$1" ]     # Is specified input file readable?
then
  echo "Can't read from input file!"
  echo "Usage: $0 input-file output-file"
  exit $E_FILE_ACCESS
fi                   #  Will exit with same error
                     #+ even if input file ($1) not specified (why?).

if [ -z "$2" ]
then
  echo "Need to specify output file."
  echo "Usage: $0 input-file output-file"
  exit $E_WRONG_ARGS
fi


exec 4&lt;&amp;0
exec &lt; $1            # Will read from input file.

exec 7&gt;&amp;1
exec &gt; $2            # Will write to output file.
                     # Assumes output file writable (add check?).

# -----------------------------------------------
    cat - | tr a-z A-Z   # Uppercase conversion.
#   ^^^^^                # Reads from stdin.
#           ^^^^^^^^^^   # Writes to stdout.
# However, both stdin and stdout were redirected.
# Note that the 'cat' can be omitted.
# -----------------------------------------------

exec 1&gt;&amp;7 7&gt;&amp;-       # Restore stout.
exec 0&lt;&amp;4 4&lt;&amp;-       # Restore stdin.

# After restoration, the following line prints to stdout as expected.
echo "File \"$1\" written to \"$2\" as uppercase conversion."

exit 0
</programlisting>
      </example>

      <para>I/O redirection is a clever way of avoiding the dreaded <link linkend="parvis">inaccessible variables within a subshell</link>
      problem.</para>

      <example xml:id="avoidsubshell">
	<title>Avoiding a subshell</title>
	<programlisting>#!/bin/bash
# avoid-subshell.sh
# Suggested by Matthew Walker.

Lines=0

echo

cat myfile.txt | while read line;
                 do {
                   echo $line
                   (( Lines++ ));  #  Incremented values of this variable
                                   #+ inaccessible outside loop.
                                   #  Subshell problem.
                 }
                 done

echo "Number of lines read = $Lines"     # 0
                                         # Wrong!

echo "------------------------"


exec 3&lt;&gt; myfile.txt
while read line &lt;&amp;3
do {
  echo "$line"
  (( Lines++ ));                   #  Incremented values of this variable
                                   #+ accessible outside loop.
                                   #  No subshell, no problem.
}
done
exec 3&gt;&amp;-

echo "Number of lines read = $Lines"     # 8

echo

exit 0

# Lines below not seen by script.

$ cat myfile.txt

Line 1.
Line 2.
Line 3.
Line 4.
Line 5.
Line 6.
Line 7.
Line 8.
</programlisting>
      </example>

       

       </section><!-- Using exec For Redirection -->	



      <section xml:id="redircb"><title>Redirecting Code Blocks</title>

        <para><anchor xml:id="redirref" />Blocks of code, such as <link linkend="whileloopref">while</link>, <link linkend="untilloopref">until</link>, and <link linkend="forloopref1">for</link> loops, even <link linkend="ifthen">if/then</link> test blocks can also incorporate
	  redirection of <filename>stdin</filename>.  Even a function may
	  use this form of redirection (see <xref linkend="realname" />).
	  The <token>&lt;</token> operator at the end of the code block
	  accomplishes this.</para>

      <example xml:id="redir2">
	<title>Redirected <firstterm>while</firstterm> loop</title>
	<programlisting>#!/bin/bash
# redir2.sh

if [ -z "$1" ]
then
  Filename=names.data       # Default, if no filename specified.
else
  Filename=$1
fi  
#+ Filename=${1:-names.data}
#  can replace the above test (parameter substitution).

count=0

echo

while [ "$name" != Smith ]  # Why is variable $name in quotes?
do
  read name                 # Reads from $Filename, rather than stdin.
  echo $name
  let "count += 1"
done &lt;"$Filename"           # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

echo; echo "$count names read"; echo

exit 0

#  Note that in some older shell scripting languages,
#+ the redirected loop would run as a subshell.
#  Therefore, $count would return 0, the initialized value outside the loop.
#  Bash and ksh avoid starting a subshell *whenever possible*,
#+ so that this script, for example, runs correctly.
#  (Thanks to Heiner Steven for pointing this out.)

#  However . . .
#  Bash *can* sometimes start a subshell in a PIPED "while-read" loop,
#+ as distinct from a REDIRECTED "while" loop.

abc=hi
echo -e "1\n2\n3" | while read l
     do abc="$l"
        echo $abc
     done
echo $abc

#  Thanks, Bruno de Oliveira Schneider, for demonstrating this
#+ with the above snippet of code.
#  And, thanks, Brian Onn, for correcting an annotation error.
</programlisting>
      </example>

      <example xml:id="redir2a">
	<title>Alternate form of redirected <firstterm>while</firstterm> loop</title>
	<programlisting>#!/bin/bash

# This is an alternate form of the preceding script.

#  Suggested by Heiner Steven
#+ as a workaround in those situations when a redirect loop
#+ runs as a subshell, and therefore variables inside the loop
# +do not keep their values upon loop termination.


if [ -z "$1" ]
then
  Filename=names.data     # Default, if no filename specified.
else
  Filename=$1
fi  


exec 3&lt;&amp;0                 # Save stdin to file descriptor 3.
exec 0&lt;"$Filename"        # Redirect standard input.

count=0
echo


while [ "$name" != Smith ]
do
  read name               # Reads from redirected stdin ($Filename).
  echo $name
  let "count += 1"
done                      #  Loop reads from file $Filename
                          #+ because of line 20.

#  The original version of this script terminated the "while" loop with
#+      done &lt;"$Filename" 
#  Exercise:
#  Why is this unnecessary?


exec 0&lt;&amp;3                 # Restore old stdin.
exec 3&lt;&amp;-                 # Close temporary fd 3.

echo; echo "$count names read"; echo

exit 0
</programlisting>
      </example>

      <example xml:id="redir3">
	<title>Redirected <firstterm>until</firstterm> loop</title>
	<programlisting>#!/bin/bash
# Same as previous example, but with "until" loop.

if [ -z "$1" ]
then
  Filename=names.data         # Default, if no filename specified.
else
  Filename=$1
fi  

# while [ "$name" != Smith ]
until [ "$name" = Smith ]     # Change  !=  to =.
do
  read name                   # Reads from $Filename, rather than stdin.
  echo $name
done &lt;"$Filename"             # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

# Same results as with "while" loop in previous example.

exit 0
</programlisting>
      </example>

      <example xml:id="redir4">
	<title>Redirected <firstterm>for</firstterm> loop</title>
	<programlisting>#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data          # Default, if no filename specified.
else
  Filename=$1
fi  

line_count=`wc $Filename | awk '{ print $1 }'`
#           Number of lines in target file.
#
#  Very contrived and kludgy, nevertheless shows that
#+ it's possible to redirect stdin within a "for" loop...
#+ if you're clever enough.
#
# More concise is     line_count=$(wc -l &lt; "$Filename")


for name in `seq $line_count`  # Recall that "seq" prints sequence of numbers.
# while [ "$name" != Smith ]   --   more complicated than a "while" loop   --
do
  read name                    # Reads from $Filename, rather than stdin.
  echo $name
  if [ "$name" = Smith ]       # Need all this extra baggage here.
  then
    break
  fi  
done &lt;"$Filename"              # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

exit 0
</programlisting>
      </example>

      <para>We can modify the previous example to also redirect the output of
        the loop.</para>

      <example xml:id="redir4a">
	<title>Redirected <firstterm>for</firstterm> loop (both
	  <filename>stdin</filename> and <filename>stdout</filename>
	  redirected)</title>
	<programlisting>#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data          # Default, if no filename specified.
else
  Filename=$1
fi  

Savefile=$Filename.new         # Filename to save results in.
FinalName=Jonah                # Name to terminate "read" on.

line_count=`wc $Filename | awk '{ print $1 }'`  # Number of lines in target file.


for name in `seq $line_count`
do
  read name
  echo "$name"
  if [ "$name" = "$FinalName" ]
  then
    break
  fi  
done &lt; "$Filename" &gt; "$Savefile"     # Redirects stdin to file $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       and saves it to backup file.

exit 0
</programlisting>
      </example>

      <example xml:id="redir5">
	<title>Redirected <firstterm>if/then</firstterm> test</title>
	<programlisting>#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data   # Default, if no filename specified.
else
  Filename=$1
fi  

TRUE=1

if [ "$TRUE" ]          # if true    and   if :   also work.
then
 read name
 echo $name
fi &lt;"$Filename"
#  ^^^^^^^^^^^^

# Reads only first line of file.
# An "if/then" test has no way of iterating unless embedded in a loop.

exit 0
</programlisting>
      </example>

      <example xml:id="namesdata">
	<title>Data file <firstterm>names.data</firstterm> for above
	examples</title>
	<programlisting>Aristotle
Arrhenius
Belisarius
Capablanca
Dickens
Euler
Goethe
Hegel
Jonah
Laplace
Maroczy
Purcell
Schmidt
Schopenhauer
Semmelweiss
Smith
Steinmetz
Tukhashevsky
Turing
Venn
Warshawski
Znosko-Borowski

#  This is a data file for
#+ "redir2.sh", "redir3.sh", "redir4.sh", "redir4a.sh", "redir5.sh".
</programlisting>
      </example>

      <para>Redirecting the <filename>stdout</filename> of a code
	block has the effect of saving its output to a file. See <xref linkend="rpmcheck" />.</para>

      <para><link linkend="heredocref">Here documents</link>
        are a special case of redirected code blocks. That being the case,
	it should be possible to feed the output of a <firstterm>here
	document</firstterm> into the <filename>stdin</filename> for a
	<firstterm>while loop</firstterm>.</para>

            <para>
	    <programlisting># This example by Albert Siersema
# Used with permission (thanks!).

function doesOutput()
 # Could be an external command too, of course.
 # Here we show you can use a function as well.
{
  ls -al *.jpg | awk '{print $5,$9}'
}


nr=0          #  We want the while loop to be able to manipulate these and
totalSize=0   #+ to be able to see the changes after the 'while' finished.

while read fileSize fileName ; do
  echo "$fileName is $fileSize bytes"
  let nr++
  totalSize=$((totalSize+fileSize))   # Or: "let totalSize+=fileSize"
done&lt;&lt;EOF
$(doesOutput)
EOF

echo "$nr files totaling $totalSize bytes"</programlisting>
            </para>

      </section><!--  Redirecting Code Blocks -->



      <section xml:id="redirapps"><title>Applications</title>

      <para>Clever use of I/O redirection permits parsing and stitching
	together snippets of command output (see <xref linkend="readredir" />). This permits
	 generating report and log files.</para>

      <example xml:id="logevents">
	<title>Logging events</title>
	<programlisting>#!/bin/bash
# logevents.sh
# Author: Stephane Chazelas.
# Used in ABS Guide with permission.

# Event logging to a file.
# Must be run as root (for write access in /var/log).

ROOT_UID=0     # Only users with $UID 0 have root privileges.
E_NOTROOT=67   # Non-root exit error.


if [ "$UID" -ne "$ROOT_UID" ]
then
  echo "Must be root to run this script."
  exit $E_NOTROOT
fi  


FD_DEBUG1=3
FD_DEBUG2=4
FD_DEBUG3=5

# === Uncomment one of the two lines below to activate script. ===
# LOG_EVENTS=1
# LOG_VARS=1


log()  # Writes time and date to log file.
{
echo "$(date)  $*" &gt;&amp;7     # This *appends* the date to the file.
#     ^^^^^^^  command substitution
                           # See below.
}



case $LOG_LEVEL in
 1) exec 3&gt;&amp;2         4&gt; /dev/null 5&gt; /dev/null;;
 2) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt; /dev/null;;
 3) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt;&amp;2;;
 *) exec 3&gt; /dev/null 4&gt; /dev/null 5&gt; /dev/null;;
esac

FD_LOGVARS=6
if [[ $LOG_VARS ]]
then exec 6&gt;&gt; /var/log/vars.log
else exec 6&gt; /dev/null                     # Bury output.
fi

FD_LOGEVENTS=7
if [[ $LOG_EVENTS ]]
then
  # exec 7 &gt;(exec gawk '{print strftime(), $0}' &gt;&gt; /var/log/event.log)
  # Above line fails in versions of Bash more recent than 2.04. Why?
  exec 7&gt;&gt; /var/log/event.log              # Append to "event.log".
  log                                      # Write time and date.
else exec 7&gt; /dev/null                     # Bury output.
fi

echo "DEBUG3: beginning" &gt;&amp;${FD_DEBUG3}

ls -l &gt;&amp;5 2&gt;&amp;4                             # command1 &gt;&amp;5 2&gt;&amp;4

echo "Done"                                # command2 

echo "sending mail" &gt;&amp;${FD_LOGEVENTS}
# Writes "sending mail" to file descriptor #7.


exit 0
</programlisting>
      </example>


       </section><!-- Applications -->	


  </chapter> <!-- I/O Redirection -->




  <chapter xml:id="subshells">
    <title>Subshells</title>

      <para><anchor xml:id="subshellsref" /></para>

      <para>Running a shell script launches a new process, a
        <firstterm>subshell</firstterm>.</para>

      <sidebar>
        <para><userinput>Definition:</userinput>
          A <firstterm>subshell</firstterm> is a
          <link linkend="childref2">child process</link> launched by a
          shell (or <firstterm>shell script</firstterm>).</para>
      </sidebar>
      
      <para>A subshell is a separate instance of the command processor
        -- the <firstterm>shell</firstterm> that gives you the prompt at
        the console or in an <firstterm>xterm</firstterm> window. Just
        as your commands are interpreted at the command-line prompt,
        similarly does a script <link linkend="batchprocref">batch-process</link> a list of
        commands. Each shell script running is, in effect, a subprocess
        (<firstterm>child process</firstterm>) of the <link linkend="forkref">parent</link> shell.</para>


      <para>A shell script can itself launch subprocesses. These
	<firstterm>subshells</firstterm> let the script do
	parallel processing, in effect executing multiple subtasks
	simultaneously.</para>


      <para>
      <programlisting>#!/bin/bash
# subshell-test.sh

(
# Inside parentheses, and therefore a subshell . . .
while [ 1 ]   # Endless loop.
do
  echo "Subshell running . . ."
done
)

#  Script will run forever,
#+ or at least until terminated by a Ctl-C.

exit $?  # End of script (but will never get here).



Now, run the script:
sh subshell-test.sh

And, while the script is running, from a different xterm:
ps -ef | grep subshell-test.sh

UID       PID   PPID  C STIME TTY      TIME     CMD
500       2698  2502  0 14:26 pts/4    00:00:00 sh subshell-test.sh
500       2699  2698 21 14:26 pts/4    00:00:24 sh subshell-test.sh

          ^^^^

Analysis:
PID 2698, the script, launched PID 2699, the subshell.

Note: The "UID ..." line would be filtered out by the "grep" command,
but is shown here for illustrative purposes.</programlisting>
      </para>


      <para>In general, an <link linkend="externalref">external
	command</link> in a script <link linkend="forkref">forks
	off</link> a subprocess,
           <footnote><para>An external command invoked with an <link linkend="execref">exec</link> does <emphasis>not</emphasis>
             (usually) fork off a subprocess / subshell.</para></footnote>
        whereas a Bash <link linkend="builtinref">builtin</link>
        does not. For this reason, builtins execute more quickly
        and use fewer system resources than their external command
        equivalents.</para>


      <variablelist xml:id="subshellparens">
	<title><anchor xml:id="subshellparens1" />Command List within
	Parentheses</title>

	<varlistentry>
	  <term>( command1; command2; command3; ... )</term>
	<listitem>
	  <para>A command list embedded between
	  <replaceable>parentheses</replaceable> runs as a
	  subshell.</para>
	</listitem>
	</varlistentry>
      </variablelist>

      <para><anchor xml:id="parvis" />Variables in a subshell are
        <emphasis>not</emphasis> visible outside the block of code
        in the subshell. They are not accessible to the <link linkend="forkref">parent process</link>, to the shell
        that launched the subshell. These are, in effect,
        variables <link linkend="localref">local</link> to the
	<firstterm>child process</firstterm>.</para>

      <example xml:id="subshell">
	<title>Variable scope in a subshell</title>
	<programlisting>#!/bin/bash
# subshell.sh

echo

echo "We are outside the subshell."
echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
# Bash, version 3, adds the new         $BASH_SUBSHELL variable.
echo; echo

outer_variable=Outer
global_variable=
#  Define global variable for "storage" of
#+ value of subshell variable.

(
echo "We are inside the subshell."
echo "Subshell level INSIDE subshell = $BASH_SUBSHELL"
inner_variable=Inner

echo "From inside subshell, \"inner_variable\" = $inner_variable"
echo "From inside subshell, \"outer\" = $outer_variable"

global_variable="$inner_variable"   #  Will this allow "exporting"
                                    #+ a subshell variable?
)

echo; echo
echo "We are outside the subshell."
echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
echo

if [ -z "$inner_variable" ]
then
  echo "inner_variable undefined in main body of shell"
else
  echo "inner_variable defined in main body of shell"
fi

echo "From main body of shell, \"inner_variable\" = $inner_variable"
#  $inner_variable will show as blank (uninitialized)
#+ because variables defined in a subshell are "local variables".
#  Is there a remedy for this?
echo "global_variable = "$global_variable""  # Why doesn't this work?

echo

# =======================================================================

# Additionally ...

echo "-----------------"; echo

var=41                                                 # Global variable.

( let "var+=1"; echo "\$var INSIDE subshell = $var" )  # 42

echo "\$var OUTSIDE subshell = $var"                   # 41
#  Variable operations inside a subshell, even to a GLOBAL variable
#+ do not affect the value of the variable outside the subshell!


exit 0

#  Question:
#  --------
#  Once having exited a subshell,
#+ is there any way to reenter that very same subshell
#+ to modify or access the subshell variables?
</programlisting>
      </example>
      <para>See also <link linkend="bashpidref">$BASHPID</link> and
        <xref linkend="subpit" />.</para>

      <sidebar>
          <para><anchor xml:id="scoperef" /></para>
	  <para><userinput>Definition:</userinput> The
	    <firstterm>scope</firstterm> of a variable is the
	    context in which it has meaning, in which it has a
	    <firstterm>value</firstterm> that can be referenced. For
	    example, the scope of a <link linkend="localref1">local
	    variable</link> lies only within the function,
	    block of code, or subshell within which it is defined,
	    while the scope of a <firstterm>global</firstterm> variable
	    is the entire script in which it appears.</para>
      </sidebar>




	  <para><anchor xml:id="subshnlevref" /></para>
	  <note>
	    <para>While the <link linkend="bashsubshellref">$BASH_SUBSHELL</link>
	      internal variable indicates the nesting level of a
	      subshell, the <link linkend="shlvlref">$SHLVL</link>
	      variable <emphasis>shows no change</emphasis> within
	      a subshell.</para>

            <para>
<programlisting>echo " \$BASH_SUBSHELL outside subshell       = $BASH_SUBSHELL"           # 0
  ( echo " \$BASH_SUBSHELL inside subshell        = $BASH_SUBSHELL" )     # 1
  ( ( echo " \$BASH_SUBSHELL inside nested subshell = $BASH_SUBSHELL" ) ) # 2
# ^ ^                           *** nested ***                        ^ ^

echo

echo " \$SHLVL outside subshell = $SHLVL"       # 3
( echo " \$SHLVL inside subshell  = $SHLVL" )   # 3 (No change!)</programlisting>
            </para>
	  </note>



      <para>Directory changes made in a subshell do not carry over to the
        parent shell.</para>

      <example xml:id="allprofs">
	<title>List User Profiles</title>
	<programlisting>#!/bin/bash
# allprofs.sh: Print all user profiles.

# This script written by Heiner Steven, and modified by the document author.

FILE=.bashrc  #  File containing user profile,
              #+ was ".profile" in original script.

for home in `awk -F: '{print $6}' /etc/passwd`
do
  [ -d "$home" ] || continue    # If no home directory, go to next.
  [ -r "$home" ] || continue    # If not readable, go to next.
  (cd $home; [ -e $FILE ] &amp;&amp; less $FILE)
done

#  When script terminates, there is no need to 'cd' back to original directory,
#+ because 'cd $home' takes place in a subshell.

exit 0
</programlisting>
      </example>


      <para>A subshell may be used to set up a <quote>dedicated
	      environment</quote> for a command group.
	      <programlisting>COMMAND1
COMMAND2
COMMAND3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  COMMAND4
  COMMAND5
  exit 3 # Only exits the subshell!
)
# The parent shell has not been affected, and the environment is preserved.
COMMAND6
COMMAND7</programlisting>

    As seen here, the <link linkend="exitref">exit</link>
    command only terminates the subshell in which it is running,
    <emphasis>not</emphasis> the parent shell or script.</para>

      <para>One application of such a <quote>dedicated environment</quote>
        is testing whether a variable is defined.
              <programlisting>if (set -u; : $variable) 2&gt; /dev/null
then
  echo "Variable is set."
fi     #  Variable has been set in current script,
       #+ or is an internal Bash variable,
       #+ or is present in environment (has been exported).

# Could also be written [[ ${variable-x} != x || ${variable-y} != y ]]
# or                    [[ ${variable-x} != x$variable ]]
# or                    [[ ${variable+x} = x ]]
# or                    [[ ${variable-x} != x ]]</programlisting></para>

      <para>Another application is checking for a lock file:
	      <programlisting>if (set -C; : &gt; lock_file) 2&gt; /dev/null
then
  :   # lock_file didn't exist: no user running the script
else
  echo "Another user is already running that script."
exit 65
fi

#  Code snippet by Stphane Chazelas,
#+ with modifications by Paulo Marcel Coelho Aragao.</programlisting>
      </para>   

      <para>+</para>

      <para>Processes may execute in parallel within different
        subshells. This permits breaking a complex task into subcomponents
        processed concurrently.</para>

      <example xml:id="parallel-processes">
	<title>Running parallel processes in subshells</title>
	<programlisting>
	(cat list1 list2 list3 | sort | uniq &gt; list123) &amp;
	(cat list4 list5 list6 | sort | uniq &gt; list456) &amp;
	# Merges and sorts both sets of lists simultaneously.
	# Running in background ensures parallel execution.
	#
	# Same effect as
	#   cat list1 list2 list3 | sort | uniq &gt; list123 &amp;
	#   cat list4 list5 list6 | sort | uniq &gt; list456 &amp;
	
	wait   # Don't execute the next command until subshells finish.
	
	diff list123 list456</programlisting>
	</example>

	<para>Redirecting I/O to a subshell uses the <quote>|</quote> pipe
	  operator, as in <userinput>ls -al | (command)</userinput>.</para>


          <note>
	    <para>A code block between <link linkend="codeblockref">curly brackets</link> does
	      <emphasis>not</emphasis> launch a subshell.</para>
            <para>{ command1; command2; command3; . . . commandN; }</para>
	    <para><programlisting>var1=23
echo "$var1"   # 23

{ var1=76; }
echo "$var1"   # 76</programlisting></para>
          </note>



  </chapter> <!-- Subshells -->


    
  <chapter xml:id="restricted-sh">
    <title>Restricted Shells</title>

      <para><anchor xml:id="restrictedshref" /></para>

      <variablelist xml:id="disabledcommref0">
        <title><anchor xml:id="disabledcommref" />Disabled commands in restricted
	  shells</title>
	<varlistentry>
	  <term />
	  <listitem>
	  <formalpara><title> </title>
      <para>Running a script or portion of a script in
        <firstterm>restricted mode</firstterm> disables certain commands
        that would otherwise be available. This is a security measure
        intended to limit the privileges of the script user and to
        minimize possible damage from running the script.</para>
	  </formalpara>  
	  </listitem>
      </varlistentry>

      </variablelist>	

      <para>The following commands and actions are disabled:</para>
        
      <itemizedlist>
        <listitem>
	  <para>Using <replaceable>cd</replaceable> to change the working
	  directory.</para>
	</listitem>

	<listitem>
	  <para>Changing the values of the
	  <replaceable>$PATH</replaceable>,
	  <replaceable>$SHELL</replaceable>,
	  <replaceable>$BASH_ENV</replaceable>,
	  or <replaceable>$ENV</replaceable> <link linkend="envref">environmental variables</link>.</para>
	</listitem>
	
	<listitem>
	  <para>Reading or changing the <replaceable>$SHELLOPTS</replaceable>,
	  shell environmental options.</para>
	</listitem>
	
	<listitem>
	  <para>Output redirection.</para>
	</listitem>
	
	<listitem>
	  <para>Invoking commands containing one or more
	  <token>/</token>'s.</para>
	</listitem>
	
	
	<listitem>
	  <para>Invoking <link linkend="execref">exec</link> to substitute
	  a different process for the shell.</para>
	</listitem>
	
	<listitem>
	  <para>Various other commands that would enable monkeying
	  with or attempting to subvert the script for an unintended
	  purpose.</para>
	</listitem>
	
	
	<listitem>
	  <para>Getting out of restricted mode within the script.</para>
	</listitem>  

      </itemizedlist>


      <example xml:id="restricted">
	<title>Running a script in restricted mode</title>
	<programlisting>#!/bin/bash

#  Starting the script with "#!/bin/bash -r"
#+ runs entire script in restricted mode.

echo

echo "Changing directory."
cd /usr/local
echo "Now in `pwd`"
echo "Coming back home."
cd
echo "Now in `pwd`"
echo

# Everything up to here in normal, unrestricted mode.

set -r
# set --restricted    has same effect.
echo "==&gt; Now in restricted mode. &lt;=="

echo
echo

echo "Attempting directory change in restricted mode."
cd ..
echo "Still in `pwd`"

echo
echo

echo "\$SHELL = $SHELL"
echo "Attempting to change shell in restricted mode."
SHELL="/bin/ash"
echo
echo "\$SHELL= $SHELL"

echo
echo

echo "Attempting to redirect output in restricted mode."
ls -l /usr/bin &gt; bin.files
ls -l bin.files    # Try to list attempted file creation effort.

echo

exit 0
</programlisting>
      </example>

  </chapter> <!-- Restricted Shells -->




  <chapter xml:id="process-sub">
    <title>Process Substitution</title>

      <para><anchor xml:id="processsubref" /><link linkend="piperef">Piping</link> the <filename>stdout</filename>
	of a command into the <filename>stdin</filename> of another
	is a powerful technique.  But, what if you need to pipe the
	<filename>stdout</filename> of <emphasis>multiple</emphasis>
	commands? This is where <replaceable>process
	substitution</replaceable> comes in.</para>

      <para><firstterm>Process substitution</firstterm> feeds the
        output of a <link linkend="processref">process</link> (or
        processes) into the <filename>stdin</filename> of another
        process.</para>

      <variablelist xml:id="commandsparens">
        <title><anchor xml:id="commandsparens1" />Template</title>

	<varlistentry>
	  <term>Command list enclosed within parentheses</term>

	<listitem>
	  <para><command>&gt;(command_list)</command></para>
	  <para><command>&lt;(command_list)</command></para>
	  <para>Process substitution uses
	    <filename>/dev/fd/&lt;n&gt;</filename> files to send the
	    results of the process(es) within parentheses to another process.
	      <footnote><para>This has the same effect as a
		<link linkend="namedpiperef">named pipe</link> (temp
		file), and, in fact, named pipes were at one time used
		in process substitution.</para></footnote>
	  </para>

          <caution><para>There is <emphasis>no</emphasis> space between the
            the <quote>&lt;</quote> or <quote>&gt;</quote> and the parentheses.
            Space there would give an error message.</para></caution>

	</listitem>
	
	</varlistentry>
      </variablelist>


              <para>
	      <screen><prompt>bash$ </prompt><userinput>echo &gt;(true)</userinput>
<computeroutput>/dev/fd/63</computeroutput>

<prompt>bash$ </prompt><userinput>echo &lt;(true)</userinput>
<computeroutput>/dev/fd/63</computeroutput>

<prompt>bash$ </prompt><userinput>echo &gt;(true) &lt;(true)</userinput>
<computeroutput>/dev/fd/63 /dev/fd/62</computeroutput>



<prompt>bash$ </prompt><userinput>wc &lt;(cat /usr/share/dict/linux.words)</userinput>
<computeroutput> 483523  483523 4992010 /dev/fd/63</computeroutput>

<prompt>bash$ </prompt><userinput>grep script /usr/share/dict/linux.words | wc</userinput>
<computeroutput>    262     262    3601</computeroutput>

<prompt>bash$ </prompt><userinput>wc &lt;(grep script /usr/share/dict/linux.words)</userinput>
<computeroutput>    262     262    3601 /dev/fd/63</computeroutput>
	      </screen>
              </para>

	  <note><para>
	  Bash creates a pipe with two <link linkend="fdref">file
	  descriptors</link>, <filename>--fIn</filename> and
	  <filename>fOut--</filename>.	The <filename>stdin</filename>
	  of <link linkend="trueref">true</link> connects
	  to <filename>fOut</filename> (dup2(fOut, 0)),
	  then Bash passes a <filename>/dev/fd/fIn</filename>
	  argument to <command>echo</command>. On systems lacking
	  <filename>/dev/fd/&lt;n&gt;</filename> files, Bash may use
	  temporary files. (Thanks, S.C.)
          </para></note>


              <para>Process substitution can compare the output of two
	       different commands, or even the output of different options
	       to the same command.</para>

	 <screen><prompt>bash$ </prompt><userinput>comm &lt;(ls -l) &lt;(ls -al)</userinput>
<computeroutput>total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh</computeroutput></screen>

	      <para><anchor xml:id="pcc2dir" /></para>
	      <para>
	        Process substitution can compare the contents
		of two directories -- to see which filenames are in one,
		but not the other.</para>
	      <para>
		<programlisting>diff &lt;(ls $first_directory) &lt;(ls $second_directory)</programlisting>
              </para>

              <para>Some other usages and uses of process substitution:</para>
	      <para><anchor xml:id="psfdstdin" /></para>
      <para><programlisting>read -a list &lt; &lt;( od -Ad -w24 -t u2 /dev/urandom )
#  Read a list of random numbers from /dev/urandom,
#+ process with "od"
#+ and feed into stdin of "read" . . .

#  From "insertion-sort.bash" example script.
#  Courtesy of JuanJo Ciarlante.</programlisting></para>


<para><anchor xml:id="netcatexample" /></para>
<para><programlisting>PORT=6881   # bittorrent

# Scan the port to make sure nothing nefarious is going on.
netcat -l $PORT | tee&gt;(md5sum -&gt;mydata-orig.md5) |
gzip | tee&gt;(md5sum - | sed 's/-$/mydata.lz2/'&gt;mydata-gz.md5)&gt;mydata.gz

# Check the decompression:
  gzip -d&lt;mydata.gz | md5sum -c mydata-orig.md5)
# The MD5sum of the original checks stdin and detects compression issues.

#  Bill Davidsen contributed this example
#+ (with light edits by the ABS Guide author).</programlisting></para>



      <para><programlisting>cat &lt;(ls -l)
# Same as     ls -l | cat

sort -k 9 &lt;(ls -l /bin) &lt;(ls -l /usr/bin) &lt;(ls -l /usr/X11R6/bin)
# Lists all the files in the 3 main 'bin' directories, and sorts by filename.
# Note that three (count 'em) distinct commands are fed to 'sort'.

 
diff &lt;(command1) &lt;(command2)    # Gives difference in command output.

tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name
# Calls "tar cf /dev/fd/?? $directory_name", and "bzip2 -c &gt; file.tar.bz2".
#
# Because of the /dev/fd/&lt;n&gt; system feature,
# the pipe between both commands does not need to be named.
#
# This can be emulated.
#
bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;
tar cf pipe $directory_name
rm pipe
#        or
exec 3&gt;&amp;1
tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2 3&gt;&amp;-
exec 3&gt;&amp;-


# Thanks, Stphane Chazelas</programlisting></para>

     <para><anchor xml:id="goodread0" />Here is a method of circumventing the
       problem of an <link linkend="badread0"><firstterm>echo</firstterm>
       piped to a <firstterm>while-read loop</firstterm></link> running
       in a subshell.</para>

      <example xml:id="wrps">
        <title>Code block redirection without forking</title>
	<programlisting>#!/bin/bash
# wr-ps.bash: while-read loop with process substitution.

# This example contributed by Tomas Pospisek.
# (Heavily edited by the ABS Guide author.)

echo

echo "random input" | while read i
do
  global=3D": Not available outside the loop."
  # ... because it runs in a subshell.
done

echo "\$global (from outside the subprocess) = $global"
# $global (from outside the subprocess) =

echo; echo "--"; echo

while read i
do
  echo $i
  global=3D": Available outside the loop."
  # ... because it does NOT run in a subshell.
done &lt; &lt;( echo "random input" )
#    ^ ^

echo "\$global (using process substitution) = $global"
# Random input
# $global (using process substitution) = 3D: Available outside the loop.


echo; echo "##########"; echo



# And likewise . . .

declare -a inloop
index=0
cat $0 | while read line
do
  inloop[$index]="$line"
  ((index++))
  # It runs in a subshell, so ...
done
echo "OUTPUT = "
echo ${inloop[*]}           # ... nothing echoes.


echo; echo "--"; echo


declare -a outloop
index=0
while read line
do
  outloop[$index]="$line"
  ((index++))
  # It does NOT run in a subshell, so ...
done &lt; &lt;( cat $0 )
echo "OUTPUT = "
echo ${outloop[*]}          # ... the entire script echoes.

exit $?
</programlisting>
      </example>

      <para><anchor xml:id="psubpiping" />This is a similar example.</para>

      <example xml:id="psubp">
	      <title>Redirecting the output of <firstterm>process
	        substitution</firstterm> into a loop.</title>
	<programlisting>#!/bin/bash
# psub.bash

# As inspired by Diego Molina (thanks!).

declare -a array0
while read
do
  array0[${#array0[@]}]="$REPLY"
done &lt; &lt;( sed -e 's/bash/CRASH-BANG!/' $0 | grep bin | awk '{print $1}' )
#  Sets the default 'read' variable, $REPLY, by process substitution,
#+ then copies it into an array.

echo "${array0[@]}"

exit $?

# ====================================== #

bash psub.bash

#!/bin/CRASH-BANG! done #!/bin/CRASH-BANG!
</programlisting>
      </example>

      <para>A reader sent in the following interesting example of process
        substitution.</para>

      <para><programlisting># Script fragment taken from SuSE distribution:

# --------------------------------------------------------------#
while read  des what mask iface; do
# Some commands ...
done &lt; &lt;(route -n)  
#    ^ ^  First &lt; is redirection, second is process substitution.

# To test it, let's make it do something.
while read  des what mask iface; do
  echo $des $what $mask $iface
done &lt; &lt;(route -n)  

# Output:
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo
# --------------------------------------------------------------#

#  As Stphane Chazelas points out,
#+ an easier-to-understand equivalent is:
route -n |
  while read des what mask iface; do   # Variables set from output of pipe.
    echo $des $what $mask $iface
  done  #  This yields the same output as above.
        #  However, as Ulrich Gayer points out . . .
        #+ this simplified equivalent uses a subshell for the while loop,
        #+ and therefore the variables disappear when the pipe terminates.
	
# --------------------------------------------------------------#
	
#  However, Filip Moritz comments that there is a subtle difference
#+ between the above two examples, as the following shows.

(
route -n | while read x; do ((y++)); done
echo $y # $y is still unset

while read x; do ((y++)); done &lt; &lt;(route -n)
echo $y # $y has the number of lines of output of route -n
)

More generally spoken
(
: | x=x
# seems to start a subshell like
: | ( x=x )
# while
x=x &lt; &lt;(:)
# does not
)

# This is useful, when parsing csv and the like.
# That is, in effect, what the original SuSE code fragment does.</programlisting></para>

  </chapter> <!-- Process Substitution -->




  <chapter xml:id="functions">
    <title>Functions</title>

      <para><anchor xml:id="functionref" /></para>
      
      <para>Like <quote>real</quote> programming languages,
	Bash has functions, though in a somewhat limited implementation.
	A function is a subroutine, a <link linkend="codeblockref">code
	block</link> that implements a set of operations, a <quote>black
	box</quote> that performs a specified task.  Wherever there is
	repetitive code, when a task repeats with only slight variations in
	procedure, then consider using a function.</para>

      <para><cmdsynopsis sepchar=" ">
	  <command>function</command>
	  <arg choice="plain" rep="norepeat"><replaceable>function_name</replaceable></arg> 
	  <arg choice="plain" rep="norepeat">{</arg><sbr />
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr />
	  <arg choice="plain" rep="norepeat">}</arg><sbr />
	</cmdsynopsis>
	or 
	<cmdsynopsis sepchar=" ">
	  <arg choice="plain" rep="norepeat"><replaceable>function_name</replaceable></arg> 
	  <arg choice="plain" rep="norepeat">()</arg>
	  <arg choice="plain" rep="norepeat">{</arg><sbr />
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr />
	  <arg choice="plain" rep="norepeat">}</arg><sbr />
	</cmdsynopsis>
      </para>

      <para>This second form will cheer the hearts of C programmers
	      (and is more <link linkend="portabilityissues">portable</link>).</para>

      <para>As in C, the function's opening bracket may optionally appear
        on the second line.</para>

      <para><cmdsynopsis sepchar=" ">
	  <arg choice="plain" rep="norepeat"><replaceable>function_name</replaceable></arg> 
	  <arg choice="plain" rep="norepeat">()</arg><sbr />
	  <arg choice="plain" rep="norepeat">{</arg><sbr />
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr />
	  <arg choice="plain" rep="norepeat">}</arg><sbr />
	</cmdsynopsis>
      </para>

      <note>
        <para>A function may be <quote>compacted</quote> into a single
          line.</para>
	  
	<para><programlisting>fun () { echo "This is a function"; echo; }
#                                 ^     ^</programlisting></para>

        <para>In this case, however, a <firstterm>semicolon</firstterm>
          must follow the final command in the function.</para>

        <para><programlisting>fun () { echo "This is a function"; echo } # Error!
#                                       ^

fun2 () { echo "Even a single-command function? Yes!"; }
#                                                    ^</programlisting></para>
      </note>

      <para>Functions are called, <firstterm>triggered</firstterm>, simply by
	invoking their names. <emphasis>A function call is equivalent to
	a command.</emphasis></para>

      <example xml:id="ex59">
	<title>Simple functions</title>
	<programlisting>#!/bin/bash
# ex59.sh: Exercising functions (simple).

JUST_A_SECOND=1

funky ()
{ # This is about as simple as functions get.
  echo "This is a funky function."
  echo "Now exiting funky function."
} # Function declaration must precede call.


fun ()
{ # A somewhat more complex function.
  i=0
  REPEATS=30

  echo
  echo "And now the fun really begins."
  echo

  sleep $JUST_A_SECOND    # Hey, wait a second!
  while [ $i -lt $REPEATS ]
  do
    echo "----------FUNCTIONS----------&gt;"
    echo "&lt;------------ARE-------------"
    echo "&lt;------------FUN------------&gt;"
    echo
    let "i+=1"
  done
}

  # Now, call the functions.

funky
fun

exit $?
</programlisting>
      </example>

      <para><anchor xml:id="functdefmust" /></para>
      <para>The function definition must precede the first call to
	it. There is no method of <quote>declaring</quote> the function,
	as, for example, in C.
	  <programlisting>f1
# Will give an error message, since function "f1" not yet defined.

declare -f f1      # This doesn't help either.
f1                 # Still an error message.

# However...

	  
f1 ()
{
  echo "Calling function \"f2\" from within function \"f1\"."
  f2
}

f2 ()
{
  echo "Function \"f2\"."
}

f1  #  Function "f2" is not actually called until this point,
    #+ although it is referenced before its definition.
    #  This is permissible.
    
    # Thanks, S.C.</programlisting>
      </para>

      <note><para><anchor xml:id="emptyfunc" />Functions may not be empty!
        <programlisting>#!/bin/bash
# empty-function.sh

empty ()
{
}

exit 0  # Will not exit here!

# $ sh empty-function.sh
# empty-function.sh: line 6: syntax error near unexpected token `}'
# empty-function.sh: line 6: `}'

# $ echo $?
# 2


# Note that a function containing only comments is empty.

func ()
{
  # Comment 1.
  # Comment 2.
  # This is still an empty function.
  # Thank you, Mark Bova, for pointing this out.
}
# Results in same error message as above.


# However ...

not_quite_empty ()
{
  illegal_command
} #  A script containing this function will *not* bomb
  #+ as long as the function is not called.

not_empty ()
{
  :
} # Contains a : (null command), and this is okay.


# Thank you, Dominick Geyer and Thiemo Kellner.</programlisting>
</para></note>




      <para>It is even possible to nest a function within another function,
        although this is not very useful.
	  <programlisting>f1 ()
{

  f2 () # nested
  {
    echo "Function \"f2\", inside \"f1\"."
  }

}  

f2  #  Gives an error message.
    #  Even a preceding "declare -f f2" wouldn't help.

echo    

f1  #  Does nothing, since calling "f1" does not automatically call "f2".
f2  #  Now, it's all right to call "f2",
    #+ since its definition has been made visible by calling "f1".

    # Thanks, S.C.</programlisting>
      </para>
      
      <para>Function declarations can appear in unlikely places, even where a
        command would otherwise go.
          <programlisting>ls -l | foo() { echo "foo"; }  # Permissible, but useless.



if [ "$USER" = bozo ]
then
  bozo_greet ()   # Function definition embedded in an if/then construct.
  {
    echo "Hello, Bozo."
  }
fi  

bozo_greet        # Works only for Bozo, and other users get an error.



# Something like this might be useful in some contexts.
NO_EXIT=1   # Will enable function definition below.

[[ $NO_EXIT -eq 1 ]] &amp;&amp; exit() { true; }     # Function definition in an "and-list".
# If $NO_EXIT is 1, declares "exit ()".
# This disables the "exit" builtin by aliasing it to "true".

exit  # Invokes "exit ()" function, not "exit" builtin.



# Or, similarly:
filename=file1

[ -f "$filename" ] &amp;&amp;
foo () { rm -f "$filename"; echo "File "$filename" deleted."; } ||
foo () { echo "File "$filename" not found."; touch bar; }

foo

# Thanks, S.C. and Christopher Head</programlisting>
      </para>


      <para><anchor xml:id="fstrangeref" />Function names can take strange
      forms.
        <programlisting>  _(){ for i in {1..10}; do echo -n "$FUNCNAME"; done; echo; }
# ^^^         No space between function name and parentheses.
#             This doesn't always work. Why not?

# Now, let's invoke the function.
  _         # __________
#             ^^^^^^^^^^   10 underscores (10 x function name)!  
# A "naked" underscore is an acceptable function name.


# In fact, a colon is likewise an acceptable function name.

:(){ echo ":"; }; :

# Of what use is this?
# It's a devious way to obfuscate the code in a script.</programlisting>
      See also <xref linkend="gronsfeld" /></para>



      <note><para>What happens when different versions of the same function
        appear in a script?
	<programlisting>#  As Yan Chen points out,
#  when a function is defined multiple times,
#  the final version is what is invoked.
#  This is not, however, particularly useful.

func ()
{
  echo "First version of func ()."
}

func ()
{
  echo "Second version of func ()."
}

func   # Second version of func ().

exit $?

#  It is even possible to use functions to override
#+ or preempt system commands.
#  Of course, this is *not* advisable.</programlisting></para></note>

      <!-- End of intro section -->

      <section xml:id="complexfunct">
        <title>Complex Functions and Function Complexities</title>

      <para>Functions may process arguments passed to them and return
	an <link linkend="exitstatusref">exit status</link> to the script
	for further processing.</para>

      <programlisting>function_name $arg1 $arg2</programlisting>

      <para><anchor xml:id="passedargs" /></para>
      <para>The function refers to the passed arguments by position (as if they were
	<link linkend="posparamref">positional parameters</link>),
	that is, <varname>$1</varname>, <varname>$2</varname>, and
	so forth.</para>

      <example xml:id="ex60">
	<title>Function Taking Parameters</title>
	<programlisting>#!/bin/bash
# Functions and parameters

DEFAULT=default                             # Default param value.

func2 () {
   if [ -z "$1" ]                           # Is parameter #1 zero length?
   then
     echo "-Parameter #1 is zero length.-"  # Or no parameter passed.
   else
     echo "-Parameter #1 is \"$1\".-"
   fi

   variable=${1-$DEFAULT}                   #  What does
   echo "variable = $variable"              #+ parameter substitution show?
                                            #  ---------------------------
                                            #  It distinguishes between
                                            #+ no param and a null param.

   if [ "$2" ]
   then
     echo "-Parameter #2 is \"$2\".-"
   fi

   return 0
}

echo
   
echo "Nothing passed."   
func2                          # Called with no params
echo


echo "Zero-length parameter passed."
func2 ""                       # Called with zero-length param
echo

echo "Null parameter passed."
func2 "$uninitialized_param"   # Called with uninitialized param
echo

echo "One parameter passed."   
func2 first           # Called with one param
echo

echo "Two parameters passed."   
func2 first second    # Called with two params
echo

echo "\"\" \"second\" passed."
func2 "" second       # Called with zero-length first parameter
echo                  # and ASCII string as a second one.

exit 0
</programlisting>
      </example>

      <para><anchor xml:id="fshiftref" /></para>
      <important><para>The <link linkend="shiftref">shift</link>
        command works on arguments passed to functions (see <xref linkend="multiplication" />).</para></important>

      <para>But, what about command-line arguments passed to the script? 
        Does a function see them? Well, let's clear up the confusion.</para>

      <example xml:id="funccmdlinearg">
	<title>Functions and command-line args passed to the script</title>
	<programlisting>#!/bin/bash
# func-cmdlinearg.sh
#  Call this script with a command-line argument,
#+ something like $0 arg1.


func ()

{
echo "$1"   # Echoes first arg passed to the function.
}           # Does a command-line arg qualify?

echo "First call to function: no arg passed."
echo "See if command-line arg is seen."
func
# No! Command-line arg not seen.

echo "============================================================"
echo
echo "Second call to function: command-line arg passed explicitly."
func $1
# Now it's seen!

exit 0
</programlisting>
      </example>


      <para>In contrast to certain other programming languages,
	shell scripts normally pass only value parameters to
	functions. Variable names (which are actually
	<firstterm>pointers</firstterm>), if
	passed as parameters to functions, will be treated as string
	literals.  <emphasis>Functions interpret their arguments
	literally.</emphasis></para>

	<para><anchor xml:id="funcpointers" /></para>
	<para><link linkend="ivrref">Indirect variable
	    references</link> (see <xref linkend="ex78" />) provide a clumsy
	    sort of mechanism for passing variable pointers to
	    functions.</para>

	    <example xml:id="indfunc">
	      <title>Passing an indirect reference to a function</title>
	      <programlisting>#!/bin/bash
# ind-func.sh: Passing an indirect reference to a function.

echo_var ()
{
echo "$1"
}

message=Hello
Hello=Goodbye

echo_var "$message"        # Hello
# Now, let's pass an indirect reference to the function.
echo_var "${!message}"     # Goodbye

echo "-------------"

# What happens if we change the contents of "hello" variable?
Hello="Hello, again!"
echo_var "$message"        # Hello
echo_var "${!message}"     # Hello, again!

exit 0
</programlisting>
	    </example>

	<para>The next logical question is whether parameters can be
	  dereferenced <emphasis>after</emphasis> being passed to a
	  function.</para>

	    <example xml:id="dereferencecl">
	      <title>Dereferencing a parameter passed to a function</title>
	      <programlisting>#!/bin/bash
# dereference.sh
# Dereferencing parameter passed to a function.
# Script by Bruce W. Clare.

dereference ()
{
     y=\$"$1"   # Name of variable (not value!).
     echo $y    # $Junk

     x=`eval "expr \"$y\" "`
     echo $1=$x
     eval "$1=\"Some Different Text \""  # Assign new value.
}

Junk="Some Text"
echo $Junk "before"    # Some Text before

dereference Junk
echo $Junk "after"     # Some Different Text after

exit 0
</programlisting>
	    </example>

	    <example xml:id="refparams">
	      <title>Again, dereferencing a parameter passed to a function</title>
	      <programlisting>#!/bin/bash
# ref-params.sh: Dereferencing a parameter passed to a function.
#                (Complex Example)

ITERATIONS=3  # How many times to get input.
icount=1

my_read () {
  #  Called with my_read varname,
  #+ outputs the previous value between brackets as the default value,
  #+ then asks for a new value.

  local local_var

  echo -n "Enter a value "
  eval 'echo -n "[$'$1'] "'  #  Previous value.
# eval echo -n "[\$$1] "     #  Easier to understand,
                             #+ but loses trailing space in user prompt.
  read local_var
  [ -n "$local_var" ] &amp;&amp; eval $1=\$local_var

  # "And-list": if "local_var" then set "$1" to its value.
}

echo

while [ "$icount" -le "$ITERATIONS" ]
do
  my_read var
  echo "Entry #$icount = $var"
  let "icount += 1"
  echo
done  


# Thanks to Stephane Chazelas for providing this instructive example.

exit 0
</programlisting>
	    </example>


      <variablelist xml:id="exitreturn">
        <title><anchor xml:id="exitreturn1" />Exit and Return</title>

	<varlistentry>
	  <term><command moreinfo="none">exit status</command></term>
	  <listitem>
	    <para>Functions return a value, called an <firstterm>exit
	      status</firstterm>. This is analogous to the <link linkend="exitstatusref">exit status</link> returned by a
	      command. The exit status may be explicitly specified
	      by a <command>return</command> statement, otherwise it
	      is the exit status of the last command in the function
	      (<returnvalue>0</returnvalue> if successful, and a non-zero
	      error code if not). This <link linkend="exitstatusref">exit
	      status</link> may be used in the script by referencing it
	      as <link linkend="xstatvarref">$?</link>.  This mechanism
	      effectively permits script functions to have a <quote>return
	      value</quote> similar to C functions.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command moreinfo="none">return</command></term>
	  <listitem>
	  <indexterm>
	    <primary>return</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>return</secondary>
	  </indexterm>
            <para><anchor xml:id="returnref" /></para>
	    <para>Terminates a function. A <command>return</command> command
	       <footnote><para>The <command>return</command> command is a
		 Bash <link linkend="builtinref">builtin</link>.</para></footnote>
	      optionally takes an <firstterm>integer</firstterm>
	      argument, which is returned to the calling script as
	      the <quote>exit status</quote> of the function, and
	      this exit status is assigned to the variable <link linkend="xstatvarref">$?</link>.</para>

	    <example xml:id="max">
	      <title>Maximum of two numbers</title>
	      <programlisting>#!/bin/bash
# max.sh: Maximum of two integers.

E_PARAM_ERR=250    # If less than 2 params passed to function.
EQUAL=251          # Return value if both params equal.
#  Error values out of range of any
#+ params that might be fed to the function.

max2 ()             # Returns larger of two numbers.
{                   # Note: numbers compared must be less than 250.
if [ -z "$2" ]
then
  return $E_PARAM_ERR
fi

if [ "$1" -eq "$2" ]
then
  return $EQUAL
else
  if [ "$1" -gt "$2" ]
  then
    return $1
  else
    return $2
  fi
fi
}

max2 33 34
return_val=$?

if [ "$return_val" -eq $E_PARAM_ERR ]
then
  echo "Need to pass two parameters to the function."
elif [ "$return_val" -eq $EQUAL ]
  then
    echo "The two numbers are equal."
else
    echo "The larger of the two numbers is $return_val."
fi  

  
exit 0

#  Exercise (easy):
#  ---------------
#  Convert this to an interactive script,
#+ that is, have the script ask for input (two numbers).
</programlisting>
	    </example>

	    <tip>
	    <para>For a function to return a string or array, use a
	      dedicated variable.
	        <programlisting>count_lines_in_etc_passwd()
{
  [[ -r /etc/passwd ]] &amp;&amp; REPLY=$(echo $(wc -l &lt; /etc/passwd))
  #  If /etc/passwd is readable, set REPLY to line count.
  #  Returns both a parameter value and status information.
  #  The 'echo' seems unnecessary, but . . .
  #+ it removes excess whitespace from the output.
}

if count_lines_in_etc_passwd
then
  echo "There are $REPLY lines in /etc/passwd."
else
  echo "Cannot count lines in /etc/passwd."
fi  

# Thanks, S.C.</programlisting>
	    </para>
	    </tip>




	    <example xml:id="ex61">
	      <title>Converting numbers to Roman numerals</title>
	      <programlisting>#!/bin/bash

# Arabic number to Roman numeral conversion
# Range: 0 - 200
# It's crude, but it works.

# Extending the range and otherwise improving the script is left as an exercise.

# Usage: roman number-to-convert

LIMIT=200
E_ARG_ERR=65
E_OUT_OF_RANGE=66

if [ -z "$1" ]
then
  echo "Usage: `basename $0` number-to-convert"
  exit $E_ARG_ERR
fi  

num=$1
if [ "$num" -gt $LIMIT ]
then
  echo "Out of range!"
  exit $E_OUT_OF_RANGE
fi  

to_roman ()   # Must declare function before first call to it.
{
number=$1
factor=$2
rchar=$3
let "remainder = number - factor"
while [ "$remainder" -ge 0 ]
do
  echo -n $rchar
  let "number -= factor"
  let "remainder = number - factor"
done  

return $number
       # Exercises:
       # ---------
       # 1) Explain how this function works.
       #    Hint: division by successive subtraction.
       # 2) Extend to range of the function.
       #    Hint: use "echo" and command-substitution capture.
}
   

to_roman $num 100 C
num=$?
to_roman $num 90 LXXXX
num=$?
to_roman $num 50 L
num=$?
to_roman $num 40 XL
num=$?
to_roman $num 10 X
num=$?
to_roman $num 9 IX
num=$?
to_roman $num 5 V
num=$?
to_roman $num 4 IV
num=$?
to_roman $num 1 I
# Successive calls to conversion function!
# Is this really necessary??? Can it be simplified?

echo

exit
</programlisting>
	    </example>

	    <para>See also <xref linkend="isalpha" />.</para>

	    <important>

	    <para>The largest positive integer a function can return is
	      255. The <command>return</command> command is closely tied
	      to the concept of <link linkend="exitstatusref">exit
	      status</link>, which accounts for this particular
	      limitation.  Fortunately, there are various <link linkend="rvt">workarounds</link> for those situations
	      requiring a large integer return value from a
	      function.</para>


	    <example xml:id="returntest">
	      <title>Testing large return values in a function</title>
	      <programlisting>#!/bin/bash
# return-test.sh

# The largest positive value a function can return is 255.

return_test ()         # Returns whatever passed to it.
{
  return $1
}

return_test 27         # o.k.
echo $?                # Returns 27.
  
return_test 255        # Still o.k.
echo $?                # Returns 255.

return_test 257        # Error!
echo $?                # Returns 1 (return code for miscellaneous error).

# =========================================================
return_test -151896    # Do large negative numbers work?
echo $?                # Will this return -151896?
                       # No! It returns 168.
#  Version of Bash before 2.05b permitted
#+ large negative integer return values.
#  It happened to be a useful feature.
#  Newer versions of Bash unfortunately plug this loophole.
#  This may break older scripts.
#  Caution!
# =========================================================

exit 0
</programlisting>
	    </example>


	    <para>A workaround for obtaining large integer <quote>return
	      values</quote> is to simply assign the <quote>return
	      value</quote> to a global variable.

	        <programlisting>Return_Val=   # Global variable to hold oversize return value of function.

alt_return_test ()
{
  fvar=$1
  Return_Val=$fvar
  return   # Returns 0 (success).
}

alt_return_test 1
echo $?                              # 0
echo "return value = $Return_Val"    # 1

alt_return_test 256
echo "return value = $Return_Val"    # 256

alt_return_test 257
echo "return value = $Return_Val"    # 257

alt_return_test 25701
echo "return value = $Return_Val"    #25701</programlisting>
            </para>


	    <para><anchor xml:id="captureretval" /></para>
	    <para>A more elegant method is to have the function
              <command>echo</command> its <quote>return
              value to <filename>stdout</filename>,</quote> and
              then capture it by <link linkend="commandsubref">command
	      substitution</link>. See the <link linkend="rvt">discussion
	      of this</link> in <xref linkend="assortedtips" />.</para>

	    <example xml:id="max2">
	      <title>Comparing two large integers</title>
	      <programlisting>#!/bin/bash
# max2.sh: Maximum of two LARGE integers.

#  This is the previous "max.sh" example,
#+ modified to permit comparing large integers.

EQUAL=0             # Return value if both params equal.
E_PARAM_ERR=-99999  # Not enough params passed to function.
#           ^^^^^^    Out of range of any params that might be passed.

max2 ()             # "Returns" larger of two numbers.
{
if [ -z "$2" ]
then
  echo $E_PARAM_ERR
  return
fi

if [ "$1" -eq "$2" ]
then
  echo $EQUAL
  return
else
  if [ "$1" -gt "$2" ]
  then
    retval=$1
  else
    retval=$2
  fi
fi

echo $retval        # Echoes (to stdout), rather than returning value.
                    # Why?
}


return_val=$(max2 33001 33997)
#            ^^^^             Function name
#                 ^^^^^ ^^^^^ Params passed
#  This is actually a form of command substitution:
#+ treating a function as if it were a command,
#+ and assigning the stdout of the function to the variable "return_val."


# ========================= OUTPUT ========================
if [ "$return_val" -eq "$E_PARAM_ERR" ]
  then
  echo "Error in parameters passed to comparison function!"
elif [ "$return_val" -eq "$EQUAL" ]
  then
    echo "The two numbers are equal."
else
    echo "The larger of the two numbers is $return_val."
fi
# =========================================================
  
exit 0

#  Exercises:
#  ---------
#  1) Find a more elegant way of testing
#+    the parameters passed to the function.
#  2) Simplify the if/then structure at "OUTPUT."
#  3) Rewrite the script to take input from command-line parameters.
</programlisting>
	    </example>

            <para>Here is another example of capturing a function
	      <quote>return value.</quote> Understanding it requires some
	      knowledge of <link linkend="awkref">awk</link>.

	    <programlisting>month_length ()  # Takes month number as an argument.
{                # Returns number of days in month.
monthD="31 28 31 30 31 30 31 31 30 31 30 31"  # Declare as local?
echo "$monthD" | awk '{ print $'"${1}"' }'    # Tricky.
#                             ^^^^^^^^^
# Parameter passed to function  ($1 -- month number), then to awk.
# Awk sees this as "print $1 . . . print $12" (depending on month number)
# Template for passing a parameter to embedded awk script:
#                                 $'"${script_parameter}"'

#    Here's a slightly simpler awk construct:
#    echo $monthD | awk -v month=$1 '{print $(month)}'
#    Uses the -v awk option, which assigns a variable value
#+   prior to execution of the awk program block.
#    Thank you, Rich.

#  Needs error checking for correct parameter range (1-12)
#+ and for February in leap year.
}

# ----------------------------------------------
# Usage example:
month=4        # April, for example (4th month).
days_in=$(month_length $month)
echo $days_in  # 30
# ----------------------------------------------</programlisting></para>


	    <para>See also <xref linkend="daysbetween" />
	      and <xref linkend="stddev" />.</para>

	    <para><userinput>Exercise:</userinput> Using what we have
	      just learned, extend the previous <link linkend="ex61">Roman numerals example</link> to accept
	      arbitrarily large input.</para>

	    </important>

	  </listitem>
	</varlistentry>
      </variablelist>


      <variablelist xml:id="redstdinfunc">
        <title><anchor xml:id="redstdinfunc1" />Redirection</title>

	<varlistentry>
	  <term><replaceable>Redirecting the stdin
	    of a function</replaceable></term>
	  <listitem>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>stdin</secondary>
	  </indexterm>

	    <para>A function is essentially a <link linkend="codeblockref">code block</link>, which means its
	      <filename>stdin</filename> can be redirected (as in <xref linkend="ex8" />).</para>

	    <example xml:id="realname">
	      <title>Real name from username</title>
	      <programlisting>#!/bin/bash
# realname.sh
#
# From username, gets "real name" from /etc/passwd.


ARGCOUNT=1       # Expect one arg.
E_WRONGARGS=85

file=/etc/passwd
pattern=$1

if [ $# -ne "$ARGCOUNT" ]
then
  echo "Usage: `basename $0` USERNAME"
  exit $E_WRONGARGS
fi  

file_excerpt ()    #  Scan file for pattern,
{                  #+ then print relevant portion of line.
  while read line  # "while" does not necessarily need [ condition ]
  do
    echo "$line" | grep $1 | awk -F":" '{ print $5 }'
    # Have awk use ":" delimiter.
  done
} &lt;$file  # Redirect into function's stdin.

file_excerpt $pattern

# Yes, this entire script could be reduced to
#       grep PATTERN /etc/passwd | awk -F":" '{ print $5 }'
# or
#       awk -F: '/PATTERN/ {print $5}'
# or
#       awk -F: '($1 == "username") { print $5 }' # real name from username
# However, it might not be as instructive.

exit 0
</programlisting>
	    </example>

	   <para>There is an alternate, and perhaps less confusing
	     method of redirecting a function's
	     <filename>stdin</filename>.  This involves redirecting the
	     <filename>stdin</filename> to an embedded bracketed code
	     block within the function.

	       <programlisting># Instead of:
Function ()
{
 ...
 } &lt; file

# Try this:
Function ()
{
  {
    ...
   } &lt; file
}

# Similarly,

Function ()  # This works.
{
  {
   echo $*
  } | tr a b
}

Function ()  # This doesn't work.
{
  echo $*
} | tr a b   # A nested code block is mandatory here.


# Thanks, S.C.</programlisting>
           </para>

           <note><para>Emmanuel Rouat's <link linkend="sample-bashrc">sample <filename>bashrc</filename>
             file</link> contains some instructive examples of
             functions.</para></note>

	  </listitem>
	</varlistentry>

      </variablelist>

      </section> <!-- Complex Functions and Function Complexities -->



      <section xml:id="localvar">
        <title>Local Variables</title>

      <variablelist xml:id="localref">
        <title><anchor xml:id="localref1" />What makes a variable
        <firstterm>local</firstterm>?</title>

	<varlistentry>
	  <term>local variables</term>
	  <listitem>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>
	    <para>A variable declared as <firstterm>local</firstterm>
	      is one that is visible only within the <link linkend="codeblockref">block of code</link> in which it
	      appears. It has local <link linkend="scoperef">scope</link>.
	      In a function, a <firstterm>local variable</firstterm> has
	      meaning only within that function block.

	      <footnote>

              <para>However, as Thomas Braunberger points out, a local
                variable declared in a function <emphasis>is also visible
                to functions called by the parent
                function.</emphasis></para>

              <para><programlisting>#!/bin/bash

function1 ()
{
  local func1var=20

  echo "Within function1, \$func1var = $func1var."

  function2
}

function2 ()
{
  echo "Within function2, \$func1var = $func1var."
}

function1

exit 0


# Output of the script:

# Within function1, $func1var = 20.
# Within function2, $func1var = 20.</programlisting></para>

	      <para>This is documented in the Bash manual:</para>

	      <para><quote>Local can only be used within a function;
                it makes the variable name have a visible scope
                restricted to that function <emphasis>and its
			children</emphasis>.</quote> [emphasis added]
                <emphasis>The ABS Guide author considers this behavior
                to be a bug.</emphasis></para>

	      </footnote>
      </para>



	    <example xml:id="ex62">
	      <title>Local variable visibility</title>
	      <programlisting>#!/bin/bash
# ex62.sh: Global and local variables inside a function.

func ()
{
  local loc_var=23       # Declared as local variable.
  echo                   # Uses the 'local' builtin.
  echo "\"loc_var\" in function = $loc_var"
  global_var=999         # Not declared as local.
                         # Therefore, defaults to global. 
  echo "\"global_var\" in function = $global_var"
}  

func

# Now, to see if local variable "loc_var" exists outside the function.

echo
echo "\"loc_var\" outside function = $loc_var"
                                      # $loc_var outside function = 
                                      # No, $loc_var not visible globally.
echo "\"global_var\" outside function = $global_var"
                                      # $global_var outside function = 999
                                      # $global_var is visible globally.
echo				      

exit 0
#  In contrast to C, a Bash variable declared inside a function
#+ is local ONLY if declared as such.
</programlisting>
	    </example>

	    <caution>
	    <para>Before a function is called, <emphasis>all</emphasis>
	      variables declared within the function are invisible outside
	      the body of the function, not just those explicitly declared
	      as <firstterm>local</firstterm>.
	        <programlisting>#!/bin/bash

func ()
{
global_var=37    #  Visible only within the function block
                 #+ before the function has been called. 
}                #  END OF FUNCTION

echo "global_var = $global_var"  # global_var =
                                 #  Function "func" has not yet been called,
                                 #+ so $global_var is not visible here.

func
echo "global_var = $global_var"  # global_var = 37
                                 # Has been set by function call.</programlisting>
            </para>
	    </caution>

	    <note>
            <para><anchor xml:id="exitvalanomaly01" /></para>
            <para>As Evgeniy Ivanov points out, when declaring and
              setting a local variable in a single command, apparently the
              order of operations is to <emphasis>first set the variable,
              and only afterwards restrict it to local scope</emphasis>.
              This is reflected in the <link linkend="exitstatusref">return value</link>.</para>

	    <para><programlisting>#!/bin/bash

echo "==OUTSIDE Function (global)=="
t=$(exit 1)
echo $?      # 1
             # As expected.
echo

function0 ()
{

echo "==INSIDE Function=="
echo "Global"
t0=$(exit 1)
echo $?      # 1
             # As expected.

echo
echo "Local declared &amp; assigned in same command."
local t1=$(exit 1)
echo $?      # 0
             # Unexpected!
#  Apparently, the variable assignment takes place before
#+ the local declaration.
#+ The return value is for the latter.

echo
echo "Local declared, then assigned (separate commands)."
local t2
t2=$(exit 1)
echo $?      # 1
             # As expected.

}

function0</programlisting></para>
	    </note>

	  </listitem>
	</varlistentry>

      </variablelist>


      <section xml:id="locvarrecur">
        <title>Local variables and recursion.</title>

	      <para><anchor xml:id="recursionref0" /></para>

	      <sidebar>

	      <para><anchor xml:id="recursionref" /></para>
	      <para><firstterm>Recursion</firstterm> is an interesting
		and sometimes useful form of
		<firstterm>self-reference</firstterm>.	<link linkend="mayerref">Herbert Mayer</link> defines it
		as <quote>. . . expressing an algorithm by using a
		simpler version of that same algorithm . . .</quote></para>

             <para>Consider a definition defined in terms of itself,
		  <footnote><para>Otherwise known as
		  <firstterm>redundancy</firstterm>.</para></footnote>
		an expression implicit in its own expression,
		  <footnote><para>Otherwise known as
		  <firstterm>tautology</firstterm>.</para></footnote>
		<emphasis>a snake swallowing its own
		tail</emphasis>,
		  <footnote><para>Otherwise known as a
		  <firstterm>metaphor</firstterm>.</para></footnote>
		or . . . a function that calls itself.
		  <footnote><para>Otherwise known as a
		  <firstterm>recursive function</firstterm>.</para></footnote>
		</para>


	      <para><anchor xml:id="recursiondemo0" /></para>
	      <example xml:id="recursiondemo">
	      <title>Demonstration of a simple recursive function</title>
	      <programlisting>#!/bin/bash
# recursion-demo.sh
# Demonstration of recursion.

RECURSIONS=9   # How many times to recurse.
r_count=0      # Must be global. Why?

recurse ()
{
  var="$1"

  while [ "$var" -ge 0 ]
  do
    echo "Recursion count = "$r_count"  +-+  \$var = "$var""
    (( var-- )); (( r_count++ ))
    recurse "$var"  #  Function calls itself (recurses)
  done              #+ until what condition is met?
}

recurse $RECURSIONS

exit $?
</programlisting>
	    </example>

	      <para><anchor xml:id="recursiondemo02" /></para>
	      <example xml:id="recursiondemo2">
	      <title>Another simple demonstration</title>
	      <programlisting>#!/bin/bash
# recursion-def.sh
# A script that defines "recursion" in a rather graphic way.

RECURSIONS=10
r_count=0
sp=" "

define_recursion ()
{
  ((r_count++))
  sp="$sp"" "
  echo -n "$sp"
  echo "\"The act of recurring ... \""   # Per 1913 Webster's dictionary.

  while [ $r_count -le $RECURSIONS ]
  do
    define_recursion
  done
}

echo
echo "Recursion: "
define_recursion
echo

exit $?
</programlisting>
	    </example>

		</sidebar>

	    <para>Local variables are a useful tool for writing recursive
	      code, but this practice generally involves a great deal of
	      computational overhead and is definitely
	      <emphasis>not</emphasis> recommended in a shell script.

	         <footnote><para>Too many levels of recursion may crash a
		   script with a segfault.
		   <programlisting>#!/bin/bash

#  Warning: Running this script could possibly lock up your system!
#  If you're lucky, it will segfault before using up all available memory.

recursive_function ()		   
{
echo "$1"     # Makes the function do something, and hastens the segfault.
(( $1 &lt; $2 )) &amp;&amp; recursive_function $(( $1 + 1 )) $2;
#  As long as 1st parameter is less than 2nd,
#+ increment 1st and recurse.
}

recursive_function 1 50000  # Recurse 50,000 levels!
#  Most likely segfaults (depending on stack size, set by ulimit -m).

#  Recursion this deep might cause even a C program to segfault,
#+ by using up all the memory allotted to the stack.


echo "This will probably not print."
exit 0  # This script will not exit normally.

#  Thanks, Stphane Chazelas.</programlisting>
</para></footnote>
	      
	      </para>

	    <para><anchor xml:id="factorialref" /></para>
	    <example xml:id="ex63">
	      <title>Recursion, using a local variable</title>
	      <programlisting>#!/bin/bash

#               factorial
#               ---------


# Does bash permit recursion?
# Well, yes, but...
# It's so slow that you gotta have rocks in your head to try it.


MAX_ARG=5
E_WRONG_ARGS=85
E_RANGE_ERR=86


if [ -z "$1" ]
then
  echo "Usage: `basename $0` number"
  exit $E_WRONG_ARGS
fi

if [ "$1" -gt $MAX_ARG ]
then
  echo "Out of range ($MAX_ARG is maximum)."
  #  Let's get real now.
  #  If you want greater range than this,
  #+ rewrite it in a Real Programming Language.
  exit $E_RANGE_ERR
fi  

fact ()
{
  local number=$1
  #  Variable "number" must be declared as local,
  #+ otherwise this doesn't work.
  if [ "$number" -eq 0 ]
  then
    factorial=1    # Factorial of 0 = 1.
  else
    let "decrnum = number - 1"
    fact $decrnum  # Recursive function call (the function calls itself).
    let "factorial = $number * $?"
  fi

  return $factorial
}

fact $1
echo "Factorial of $1 is $?."

exit 0
</programlisting>
	    </example>

	    <para>Also see <xref linkend="primes" /> for an example of
	      recursion in a script. Be aware that recursion is
	      resource-intensive and executes slowly, and is therefore
	      generally not appropriate in a script.</para>

      </section>
      </section> <!-- Local Variables -->



      <section xml:id="recurnolocvar">
        <title>Recursion Without Local Variables</title>

            <para>A function may recursively call itself even without use of
	      local variables.</para>

            <para><anchor xml:id="fiboref" /></para>
	    <example xml:id="fibo">
	      <title><firstterm>The Fibonacci Sequence</firstterm></title>
	      <programlisting>#!/bin/bash
# fibo.sh : Fibonacci sequence (recursive)
# Author: M. Cooper
# License: GPL3

# ----------algorithm--------------
# Fibo(0) = 0
# Fibo(1) = 1
# else
#   Fibo(j) = Fibo(j-1) + Fibo(j-2)
# ---------------------------------

MAXTERM=15       # Number of terms (+1) to generate.
MINIDX=2         # If idx is less than 2, then Fibo(idx) = idx.

Fibonacci ()
{
  idx=$1   # Doesn't need to be local. Why not?
  if [ "$idx" -lt "$MINIDX" ]
  then
    echo "$idx"  # First two terms are 0 1 ... see above.
  else
    (( --idx ))  # j-1
    term1=$( Fibonacci $idx )   #  Fibo(j-1)

    (( --idx ))  # j-2
    term2=$( Fibonacci $idx )   #  Fibo(j-2)

    echo $(( term1 + term2 ))
  fi
  #  An ugly, ugly kludge.
  #  The more elegant implementation of recursive fibo in C
  #+ is a straightforward translation of the algorithm in lines 7 - 10.
}

for i in $(seq 0 $MAXTERM)
do  # Calculate $MAXTERM+1 terms.
  FIBO=$(Fibonacci $i)
  echo -n "$FIBO "
done
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610
# Takes a while, doesn't it? Recursion in a script is slow.

echo

exit 0
</programlisting>
	    </example>

            <para><anchor xml:id="hanoiref" /></para>
	    <example xml:id="hanoi">
	      <title><firstterm>The Towers of Hanoi</firstterm></title>
	      <programlisting>#! /bin/bash
#
# The Towers Of Hanoi
# Bash script
# Copyright (C) 2000 Amit Singh. All Rights Reserved.
# http://hanoi.kernelthread.com
#
# Tested under Bash version 2.05b.0(13)-release.
# Also works under Bash version 3.x.
#
#  Used in "Advanced Bash Scripting Guide"
#+ with permission of script author.
#  Slightly modified and commented by ABS author.

#=================================================================#
#  The Tower of Hanoi is a mathematical puzzle attributed to
#+ Edouard Lucas, a nineteenth-century French mathematician.
#
#  There are three vertical posts set in a base.
#  The first post has a set of annular rings stacked on it.
#  These rings are disks with a hole drilled out of the center,
#+ so they can slip over the posts and rest flat.
#  The rings have different diameters, and they stack in ascending
#+ order, according to size.
#  The smallest ring is on top, and the largest on the bottom.
#
#  The task is to transfer the stack of rings
#+ to one of the other posts.
#  You can move only one ring at a time to another post.
#  You are permitted to move rings back to the original post.
#  You may place a smaller ring atop a larger one,
#+ but *not* vice versa.
#  Again, it is forbidden to place a larger ring atop a smaller one.
#
#  For a small number of rings, only a few moves are required.
#+ For each additional ring,
#+ the required number of moves approximately doubles,
#+ and the "strategy" becomes increasingly complicated.
#
#  For more information, see http://hanoi.kernelthread.com
#+ or pp. 186-92 of _The Armchair Universe_ by A.K. Dewdney.
#
#
#         ...                   ...                    ...
#         | |                   | |                    | |
#        _|_|_                  | |                    | |
#       |_____|                 | |                    | |
#      |_______|                | |                    | |
#     |_________|               | |                    | |
#    |___________|              | |                    | |
#   |             |             | |                    | |
# .--------------------------------------------------------------.
# |**************************************************************|
#          #1                   #2                      #3
#
#=================================================================#


E_NOPARAM=66  # No parameter passed to script.
E_BADPARAM=67 # Illegal number of disks passed to script.
Moves=        # Global variable holding number of moves.
              # Modification to original script.

dohanoi() {   # Recursive function.
    case $1 in
    0)
        ;;
    *)
        dohanoi "$(($1-1))" $2 $4 $3
        echo move $2 "--&gt;" $3
        ((Moves++))          # Modification to original script.
        dohanoi "$(($1-1))" $4 $3 $2
        ;;
    esac
}

case $# in
    1) case $(($1&gt;0)) in     # Must have at least one disk.
       1)  # Nested case statement.
           dohanoi $1 1 3 2
           echo "Total moves = $Moves"   # 2^n - 1, where n = # of disks.
           exit 0;
           ;;
       *)
           echo "$0: illegal value for number of disks";
           exit $E_BADPARAM;
           ;;
       esac
    ;;
    *)
       echo "usage: $0 N"
       echo "       Where \"N\" is the number of disks."
       exit $E_NOPARAM;
       ;;
esac

# Exercises:
# ---------
# 1) Would commands beyond this point ever be executed?
#    Why not? (Easy)
# 2) Explain the workings of the workings of the "dohanoi" function.
#    (Difficult -- see the Dewdney reference, above.)
</programlisting>
	    </example>


      </section> <!-- Recursion Without Local Variables -->



  </chapter> <!-- Functions -->



  <chapter xml:id="aliases">
    <title>Aliases</title>

      <para><anchor xml:id="aliasref" /></para>

      <indexterm>
        <primary>alias</primary>
      </indexterm>

      <para>A Bash <firstterm>alias</firstterm> is essentially nothing
	more than a keyboard shortcut, an abbreviation, a means of
	avoiding typing a long command sequence. If, for example,
	we include <command>alias lm="ls -l | more"</command> in
	the <link linkend="sample-bashrc"><filename>~/.bashrc</filename>
        file</link>, then each <userinput>lm</userinput>
          <footnote><para> ... as the first word of a command string.
          Obviously, an alias is only meaningful at the
          <emphasis>beginning</emphasis> of a command.</para></footnote>
	typed at the command-line will automatically be replaced by a
	<command>ls -l | more</command>. This can save a great deal of
	typing at the command-line and avoid having to remember complex
	combinations of commands and options. Setting <command>alias
	rm="rm -i"</command> (interactive mode delete) may save a
	good deal of grief, since it can prevent inadvertently deleting
	important files.</para>

      <para>In a script, aliases have very limited usefulness. It would be
	nice if aliases could assume some of the functionality of
	the <command>C</command> preprocessor, such as macro expansion,
	but unfortunately Bash does not expand arguments within the
	alias body.
	  <footnote><para>However, aliases do seem to expand positional
	  parameters.</para></footnote>
	Moreover, a script fails to expand an alias itself
	within <quote>compound constructs,</quote> such as <link linkend="ifthen">if/then</link> statements, loops, and
	functions. An added limitation is that an alias will not expand
	recursively. Almost invariably, whatever we would like an alias
	to do could be accomplished much more effectively with a <link linkend="functionref">function</link>.</para>

    <example xml:id="al">
      <title>Aliases within a script</title>
      <programlisting>#!/bin/bash
# alias.sh

shopt -s expand_aliases
# Must set this option, else script will not expand aliases.


# First, some fun.
alias Jesse_James='echo "\"Alias Jesse James\" was a 1959 comedy starring Bob Hope."'
Jesse_James

echo; echo; echo;

alias ll="ls -l"
# May use either single (') or double (") quotes to define an alias.

echo "Trying aliased \"ll\":"
ll /usr/X11R6/bin/mk*   #* Alias works.

echo

directory=/usr/X11R6/bin/
prefix=mk*  # See if wild card causes problems.
echo "Variables \"directory\" + \"prefix\" = $directory$prefix"
echo

alias lll="ls -l $directory$prefix"

echo "Trying aliased \"lll\":"
lll         # Long listing of all files in /usr/X11R6/bin stating with mk.
# An alias can handle concatenated variables -- including wild card -- o.k.




TRUE=1

echo

if [ TRUE ]
then
  alias rr="ls -l"
  echo "Trying aliased \"rr\" within if/then statement:"
  rr /usr/X11R6/bin/mk*   #* Error message results!
  # Aliases not expanded within compound statements.
  echo "However, previously expanded alias still recognized:"
  ll /usr/X11R6/bin/mk*
fi  

echo

count=0
while [ $count -lt 3 ]
do
  alias rrr="ls -l"
  echo "Trying aliased \"rrr\" within \"while\" loop:"
  rrr /usr/X11R6/bin/mk*   #* Alias will not expand here either.
                           #  alias.sh: line 57: rrr: command not found
  let count+=1
done 

echo; echo

alias xyz='cat $0'   # Script lists itself.
                     # Note strong quotes.
xyz
#  This seems to work,
#+ although the Bash documentation suggests that it shouldn't.
#
#  However, as Steve Jacobson points out,
#+ the "$0" parameter expands immediately upon declaration of the alias.

exit 0
</programlisting>
    </example>

    <para><anchor xml:id="unaliasref" /></para>
    <para>The <command>unalias</command> command removes a previously
      set <firstterm>alias</firstterm>.</para>

    <example xml:id="unal">
      <title><firstterm>unalias</firstterm>: Setting and unsetting
      an alias</title>
      <programlisting>#!/bin/bash
# unalias.sh

shopt -s expand_aliases  # Enables alias expansion.

alias llm='ls -al | more'
llm

echo

unalias llm              # Unset alias.
llm
# Error message results, since 'llm' no longer recognized.

exit 0
</programlisting>
    </example>

	    <screen><prompt>bash$ </prompt><userinput>./unalias.sh</userinput>
<computeroutput>
total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: command not found
</computeroutput></screen>


  </chapter> <!-- Aliases -->




  <chapter xml:id="list-cons">
    <title>List Constructs</title>

    <para><anchor xml:id="listconsref" /></para>


      <indexterm>
	<primary>&amp;&amp;</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>&amp;&amp;</secondary>
      </indexterm>
      <indexterm>
	<primary>AND</primary>
	<secondary>list</secondary>
      </indexterm>
      <indexterm>
	<primary>||</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>||</secondary>
      </indexterm>
      <indexterm>
	<primary>OR</primary>
	<secondary>list</secondary>
      </indexterm>

      <para>The <firstterm>and list</firstterm> and <firstterm>or
	list</firstterm> constructs provide a means of processing a
	number of commands consecutively. These can effectively replace
	complex nested <link linkend="testconstructs1">if/then</link>
	or even <link linkend="caseesac1">case</link> statements.</para>


      <variablelist xml:id="lcons">
        <title><anchor xml:id="lcons1" />Chaining together commands</title>

	<varlistentry>
	  <term>and list</term>
	  <listitem>
	    <para><programlisting>command-1 &amp;&amp; command-2 &amp;&amp; command-3 &amp;&amp; ... command-n</programlisting>
	      Each command executes in turn, provided that
	      the previous command has given a return value of
	      <replaceable>true</replaceable> (zero). At the first
	      <replaceable>false</replaceable> (non-zero) return, the
	      command chain terminates (the first command returning
	      <replaceable>false</replaceable> is the last one to
	      execute).</para>

	    <para>An interesting use of a two-condition <firstterm>and
	      list</firstterm> from an early version of YongYe's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/Tetris_Game.sh">Tetris
	      game script</link>:</para>

	   <para>
           <programlisting>equation()

{  # core algorithm used for doubling and halving the coordinates
   [[ ${cdx} ]] &amp;&amp; ((y=cy+(ccy-cdy)${2}2))
   eval ${1}+=\"${x} ${y} \"
}</programlisting>
           </para>


	    <example xml:id="ex64">
	      <title>Using an <firstterm>and list</firstterm> to test
	      for command-line arguments</title>
	      <programlisting>#!/bin/bash
# and list

if [ ! -z "$1" ] &amp;&amp; echo "Argument #1 = $1" &amp;&amp; [ ! -z "$2" ] &amp;&amp; \
#                ^^                         ^^               ^^
echo "Argument #2 = $2"
then
  echo "At least 2 arguments passed to script."
  # All the chained commands return true.
else
  echo "Fewer than 2 arguments passed to script."
  # At least one of the chained commands returns false.
fi  
# Note that "if [ ! -z $1 ]" works, but its alleged equivalent,
#   "if [ -n $1 ]" does not.
#     However, quoting fixes this.
#  if "[ -n "$1" ]" works.
#           ^  ^    Careful!
# It is always best to QUOTE the variables being tested.


# This accomplishes the same thing, using "pure" if/then statements.
if [ ! -z "$1" ]
then
  echo "Argument #1 = $1"
fi
if [ ! -z "$2" ]
then
  echo "Argument #2 = $2"
  echo "At least 2 arguments passed to script."
else
  echo "Fewer than 2 arguments passed to script."
fi
# It's longer and more ponderous than using an "and list".


exit $?
</programlisting>
	    </example>

	    <example xml:id="andlist2">
	      <title>Another command-line arg test using an <firstterm>and
	      list</firstterm></title>
	      <programlisting>#!/bin/bash

ARGS=1        # Number of arguments expected.
E_BADARGS=85  # Exit value if incorrect number of args passed.

test $# -ne $ARGS &amp;&amp; \
#    ^^^^^^^^^^^^ condition #1
echo "Usage: `basename $0` $ARGS argument(s)" &amp;&amp; exit $E_BADARGS
#                                             ^^
#  If condition #1 tests true (wrong number of args passed to script),
#+ then the rest of the line executes, and script terminates.

# Line below executes only if the above test fails.
echo "Correct number of arguments passed to this script."

exit 0

# To check exit value, do a "echo $?" after script termination.
</programlisting>
	    </example>

            <para><anchor xml:id="anddefault" /></para>
            <para>
	      Of course, an <firstterm>and list</firstterm> can also
	      <firstterm>set</firstterm> variables to a default value.
	        <programlisting>arg1=$@ &amp;&amp; [ -z "$arg1" ] &amp;&amp; arg1=DEFAULT
		
              # Set $arg1 to command-line arguments, if any.
              # But . . . set to DEFAULT if not specified on command-line.</programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="orlistref" />or list</term>
	  <listitem>
	    <para><programlisting>command-1 || command-2 || command-3 || ... command-n</programlisting>
	      Each command executes in turn for as long as the previous
	      command returns <returnvalue>false</returnvalue>. At
	      the first <returnvalue>true</returnvalue> return, the
	      command chain terminates (the first command returning
	      <returnvalue>true</returnvalue> is the last one to
	      execute). This is obviously the inverse of the <quote>and
	      list</quote>.</para>



	    <example xml:id="ex65">
	      <title>Using <firstterm>or lists</firstterm> in combination
	      with an <firstterm>and list</firstterm></title>
	      <programlisting>#!/bin/bash

#  delete.sh, a not-so-cunning file deletion utility.
#  Usage: delete filename

E_BADARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS  # No arg? Bail out.
else  
  file=$1          # Set filename.
fi  


[ ! -f "$file" ] &amp;&amp; echo "File \"$file\" not found. \
Cowardly refusing to delete a nonexistent file."
# AND LIST, to give error message if file not present.
# Note echo message continuing on to a second line after an escape.

[ ! -f "$file" ] || (rm -f $file; echo "File \"$file\" deleted.")
# OR LIST, to delete file if present.

# Note logic inversion above.
# AND LIST executes on true, OR LIST on false.

exit $?
</programlisting>
	    </example>

	    <caution><para>If the first command in an <firstterm>or
	      list</firstterm> returns <returnvalue>true</returnvalue>,
	      it <replaceable>will</replaceable> execute.</para></caution>

	  </listitem>
	</varlistentry>

	</variablelist>


	    <para><programlisting># ==&gt; The following snippets from the /etc/rc.d/init.d/single
#+==&gt; script by Miquel van Smoorenburg
#+==&gt; illustrate use of "and" and "or" lists.
# ==&gt; "Arrowed" comments added by document author.

[ -x /usr/bin/clear ] &amp;&amp; /usr/bin/clear
  # ==&gt; If /usr/bin/clear exists, then invoke it.
  # ==&gt; Checking for the existence of a command before calling it
  #+==&gt; avoids error messages and other awkward consequences.

  # ==&gt; . . .

# If they want to run something in single user mode, might as well run it...
for i in /etc/rc1.d/S[0-9][0-9]* ; do
        # Check if the script is there.
        [ -x "$i" ] || continue
  # ==&gt; If corresponding file in $PWD *not* found,
  #+==&gt; then "continue" by jumping to the top of the loop.

        # Reject backup files and files generated by rpm.
        case "$1" in
                *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
                        continue;;
        esac
        [ "$i" = "/etc/rc1.d/S00single" ] &amp;&amp; continue
  # ==&gt; Set script name, but don't execute it yet.
        $i start
done

  # ==&gt; . . .</programlisting></para>


	<important><para>The <link linkend="exitstatusref">exit
	  status</link> of an <userinput>and list</userinput> or an
	  <userinput>or list</userinput> is the exit status of the last
	  command executed.</para></important>

	<para>Clever combinations of <firstterm>and</firstterm> and
	<firstterm>or</firstterm> lists are possible, but the logic may
	easily become convoluted and require close attention to <link linkend="opprecedence1">operator precedence rules</link>, and
	possibly extensive debugging.</para>

	<para><programlisting>false &amp;&amp; true || echo false         # false

# Same result as
( false &amp;&amp; true ) || echo false     # false
# But NOT
false &amp;&amp; ( true || echo false )     # (nothing echoed)

#  Note left-to-right grouping and evaluation of statements.

#  It's usually best to avoid such complexities.

#  Thanks, S.C.</programlisting>
	</para>

	<para>See <xref linkend="daysbetween" /> and <xref linkend="brokenlink" /> for illustrations of using <userinput>and
	/ or list</userinput> constructs to test variables.</para>


  </chapter> <!-- List Constructs -->




  <chapter xml:id="arrays">
    <title>Arrays</title>

      <para><anchor xml:id="arrayref" /></para>

      <para>Newer versions of Bash support one-dimensional arrays.
        <anchor xml:id="brackarray" />
	Array elements may be initialized with the
	<userinput>variable[xx]</userinput> notation. Alternatively,
	a script may introduce the entire array by an explicit
	<userinput>declare -a variable</userinput> statement. To
	dereference (retrieve the contents of) an array element, use
	<firstterm>curly bracket</firstterm> notation, that is,
	<userinput>${element[xx]}</userinput>.</para>

      <para><anchor xml:id="arraynotation" /></para>

      <example xml:id="ex66">
	<title>Simple array usage</title>
	<programlisting>#!/bin/bash


area[11]=23
area[13]=37
area[51]=UFOs

#  Array members need not be consecutive or contiguous.

#  Some members of the array can be left uninitialized.
#  Gaps in the array are okay.
#  In fact, arrays with sparse data ("sparse arrays")
#+ are useful in spreadsheet-processing software.


echo -n "area[11] = "
echo ${area[11]}    #  {curly brackets} needed.

echo -n "area[13] = "
echo ${area[13]}

echo "Contents of area[51] are ${area[51]}."

# Contents of uninitialized array variable print blank (null variable).
echo -n "area[43] = "
echo ${area[43]}
echo "(area[43] unassigned)"

echo

# Sum of two array variables assigned to third
area[5]=`expr ${area[11]} + ${area[13]}`
echo "area[5] = area[11] + area[13]"
echo -n "area[5] = "
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo "area[6] = area[11] + area[51]"
echo -n "area[6] = "
echo ${area[6]}
# This fails because adding an integer to a string is not permitted.

echo; echo; echo

# -----------------------------------------------------------------
# Another array, "area2".
# Another way of assigning array variables...
# array_name=( XXX YYY ZZZ ... )

area2=( zero one two three four )

echo -n "area2[0] = "
echo ${area2[0]}
# Aha, zero-based indexing (first element of array is [0], not [1]).

echo -n "area2[1] = "
echo ${area2[1]}    # [1] is second element of array.
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# Yet another array, "area3".
# Yet another way of assigning array variables...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=seventeen [24]=twenty-four)

echo -n "area3[17] = "
echo ${area3[17]}

echo -n "area3[24] = "
echo ${area3[24]}
# -----------------------------------------------

exit 0
</programlisting>
      </example>

      <para><anchor xml:id="arrayinit0" /></para>
      <para>As we have seen, a convenient way of initializing an entire array
        is the <varname>array=( element1 element2 ... elementN )</varname>
	notation.</para>

<para>
<programlisting>base64_charset=( {A..Z} {a..z} {0..9} + / = )
               #  Using extended brace expansion
               #+ to initialize the elements of the array.                
               #  Excerpted from vladz's "base64.sh" script
               #+ in the "Contributed Scripts" appendix.</programlisting>
</para>

      <para><anchor xml:id="arrayopsvars" /></para>

      <sidebar><para>Bash permits array operations on variables, even if
        the variables are not explicitly declared as arrays.</para>
	  <para><programlisting>string=abcABC123ABCabc
echo ${string[@]}               # abcABC123ABCabc
echo ${string[*]}               # abcABC123ABCabc 
echo ${string[0]}               # abcABC123ABCabc
echo ${string[1]}               # No output!
                                # Why?
echo ${#string[@]}              # 1
                                # One element in the array.
                                # The string itself.

# Thank you, Michael Zick, for pointing this out.</programlisting>
      Once again this demonstrates that <link linkend="bvuntyped">Bash
      variables are untyped</link>.
      </para></sidebar>


      <example xml:id="poem">
	<title>Formatting a poem</title>
	<programlisting>#!/bin/bash
# poem.sh: Pretty-prints one of the ABS Guide author's favorite poems.

# Lines of the poem (single stanza).
Line[1]="I do not know which to prefer,"
Line[2]="The beauty of inflections"
Line[3]="Or the beauty of innuendoes,"
Line[4]="The blackbird whistling"
Line[5]="Or just after."
# Note that quoting permits embedding whitespace.

# Attribution.
Attrib[1]=" Wallace Stevens"
Attrib[2]="\"Thirteen Ways of Looking at a Blackbird\""
# This poem is in the Public Domain (copyright expired).

echo

tput bold   # Bold print.

for index in 1 2 3 4 5    # Five lines.
do
  printf "     %s\n" "${Line[index]}"
done

for index in 1 2          # Two attribution lines.
do
  printf "          %s\n" "${Attrib[index]}"
done

tput sgr0   # Reset terminal.
            # See 'tput' docs.

echo

exit 0

# Exercise:
# --------
# Modify this script to pretty-print a poem from a text data file.
</programlisting>
      </example>

      <para><anchor xml:id="arraysyntax" /></para>
      <para>Array variables have a syntax all their own, and even
	standard Bash commands and operators have special options adapted
	for array use.</para>

      <example xml:id="arrayops">
	<title>Various array operations</title>
	<programlisting>#!/bin/bash
# array-ops.sh: More fun with arrays.


array=( zero one two three four five )
# Element 0   1   2    3     4    5

echo ${array[0]}       #  zero
echo ${array:0}        #  zero
                       #  Parameter expansion of first element,
                       #+ starting at position # 0 (1st character).
echo ${array:1}        #  ero
                       #  Parameter expansion of first element,
                       #+ starting at position # 1 (2nd character).

echo "--------------"

echo ${#array[0]}      #  4
                       #  Length of first element of array.
echo ${#array}         #  4
                       #  Length of first element of array.
                       #  (Alternate notation)

echo ${#array[1]}      #  3
                       #  Length of second element of array.
                       #  Arrays in Bash have zero-based indexing.

echo ${#array[*]}      #  6
                       #  Number of elements in array.
echo ${#array[@]}      #  6
                       #  Number of elements in array.

echo "--------------"

array2=( [0]="first element" [1]="second element" [3]="fourth element" )
#            ^     ^       ^     ^      ^       ^     ^      ^       ^
# Quoting permits embedding whitespace within individual array elements.

echo ${array2[0]}      # first element
echo ${array2[1]}      # second element
echo ${array2[2]}      #
                       # Skipped in initialization, and therefore null.
echo ${array2[3]}      # fourth element
echo ${#array2[0]}     # 13    (length of first element)
echo ${#array2[*]}     # 3     (number of elements in array)

exit
</programlisting>
      </example>

      <para><anchor xml:id="arraystringops" /></para>
      <para>Many of the standard <link linkend="stringmanip">string
       operations</link> work on arrays.</para>

      <example xml:id="arraystrops">
	<title>String operations on arrays</title>
	<programlisting>#!/bin/bash
# array-strops.sh: String operations on arrays.

# Script by Michael Zick.
# Used in ABS Guide with permission.
# Fixups: 05 May 08, 04 Aug 08.

#  In general, any string operation using the ${name ... } notation
#+ can be applied to all string elements in an array,
#+ with the ${name[@] ... } or ${name[*] ...} notation.


arrayZ=( one two three four five five )

echo

# Trailing Substring Extraction
echo ${arrayZ[@]:0}     # one two three four five five
#                ^        All elements.

echo ${arrayZ[@]:1}     # two three four five five
#                ^        All elements following element[0].

echo ${arrayZ[@]:1:2}   # two three
#                  ^      Only the two elements after element[0].

echo "---------"


# Substring Removal

# Removes shortest match from front of string(s).

echo ${arrayZ[@]#f*r}   # one two three five five
#               ^       # Applied to all elements of the array.
                        # Matches "four" and removes it.

# Longest match from front of string(s)
echo ${arrayZ[@]##t*e}  # one two four five five
#               ^^      # Applied to all elements of the array.
                        # Matches "three" and removes it.

# Shortest match from back of string(s)
echo ${arrayZ[@]%h*e}   # one two t four five five
#               ^       # Applied to all elements of the array.
                        # Matches "hree" and removes it.

# Longest match from back of string(s)
echo ${arrayZ[@]%%t*e}  # one two four five five
#               ^^      # Applied to all elements of the array.
                        # Matches "three" and removes it.

echo "----------------------"


# Substring Replacement

# Replace first occurrence of substring with replacement.
echo ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe
#               ^           # Applied to all elements of the array.

# Replace all occurrences of substring.
echo ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe
                            # Applied to all elements of the array.

# Delete all occurrences of substring.
# Not specifing a replacement defaults to 'delete' ...
echo ${arrayZ[@]//fi/}      # one two three four ve ve
#               ^^          # Applied to all elements of the array.

# Replace front-end occurrences of substring.
echo ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve
#                ^          # Applied to all elements of the array.

# Replace back-end occurrences of substring.
echo ${arrayZ[@]/%ve/ZZ}    # one two three four fiZZ fiZZ
#                ^          # Applied to all elements of the array.

echo ${arrayZ[@]/%o/XX}     # one twXX three four five five
#                ^          # Why?

echo "-----------------------------"


replacement() {
    echo -n "!!!"
}

echo ${arrayZ[@]/%e/$(replacement)}
#                ^  ^^^^^^^^^^^^^^
# on!!! two thre!!! four fiv!!! fiv!!!
# The stdout of replacement() is the replacement string.
# Q.E.D: The replacement action is, in effect, an 'assignment.'

echo "------------------------------------"

#  Accessing the "for-each":
echo ${arrayZ[@]//*/$(replacement optional_arguments)}
#                ^^ ^^^^^^^^^^^^^
# !!! !!! !!! !!! !!! !!!

#  Now, if Bash would only pass the matched string
#+ to the function being called . . .

echo

exit 0

#  Before reaching for a Big Hammer -- Perl, Python, or all the rest --
#  recall:
#    $( ... ) is command substitution.
#    A function runs as a sub-process.
#    A function writes its output (if echo-ed) to stdout.
#    Assignment, in conjunction with "echo" and command substitution,
#+   can read a function's stdout.
#    The name[@] notation specifies (the equivalent of) a "for-each"
#+   operation.
#  Bash is more powerful than you think!
</programlisting>
      </example>


      <para><link linkend="commandsubref">Command substitution</link> can
        construct the individual elements of an array.</para>
      
      <example xml:id="scriptarray">
	<title>Loading the contents of a script into an array</title>
	<programlisting>#!/bin/bash
# script-array.sh: Loads this script into an array.
# Inspired by an e-mail from Chris Martin (thanks!).

script_contents=( $(cat "$0") )  #  Stores contents of this script ($0)
                                 #+ in an array.

for element in $(seq 0 $((${#script_contents[@]} - 1)))
  do                #  ${#script_contents[@]}
                    #+ gives number of elements in the array.
                    #
                    #  Question:
                    #  Why is  seq 0  necessary?
                    #  Try changing it to seq 1.
  echo -n "${script_contents[$element]}"
                    # List each field of this script on a single line.
# echo -n "${script_contents[element]}" also works because of ${ ... }.
  echo -n " -- "    # Use " -- " as a field separator.
done

echo

exit 0

# Exercise:
# --------
#  Modify this script so it lists itself
#+ in its original format,
#+ complete with whitespace, line breaks, etc.
</programlisting>
      </example>

      <para>In an array context, some Bash <link linkend="builtinref">builtins</link> have a slightly
	altered meaning. <anchor xml:id="arrayunset" />For example, <link linkend="unsetref">unset</link> deletes array elements, or even
	an entire array.</para>

      <para><anchor xml:id="arrayspecialprops" /></para>
      <example xml:id="ex67">
	<title>Some special properties of arrays</title>
	<programlisting>#!/bin/bash

declare -a colors
#  All subsequent commands in this script will treat
#+ the variable "colors" as an array.

echo "Enter your favorite colors (separated from each other by a space)."

read -a colors    # Enter at least 3 colors to demonstrate features below.
#  Special option to 'read' command,
#+ allowing assignment of elements in an array.

echo

element_count=${#colors[@]}
# Special syntax to extract number of elements in array.
#     element_count=${#colors[*]} works also.
#
#  The "@" variable allows word splitting within quotes
#+ (extracts variables separated by whitespace).
#
#  This corresponds to the behavior of "$@" and "$*"
#+ in positional parameters. 

index=0

while [ "$index" -lt "$element_count" ]
do    # List all the elements in the array.
  echo ${colors[$index]}
  #    ${colors[index]} also works because it's within ${ ... } brackets.
  let "index = $index + 1"
  # Or:
  #    ((index++))
done
# Each array element listed on a separate line.
# If this is not desired, use  echo -n "${colors[$index]} "
#
# Doing it with a "for" loop instead:
#   for i in "${colors[@]}"
#   do
#     echo "$i"
#   done
# (Thanks, S.C.)

echo

# Again, list all the elements in the array, but using a more elegant method.
  echo ${colors[@]}          # echo ${colors[*]} also works.

echo

# The "unset" command deletes elements of an array, or entire array.
unset colors[1]              # Remove 2nd element of array.
                             # Same effect as   colors[1]=
echo  ${colors[@]}           # List array again, missing 2nd element.

unset colors                 # Delete entire array.
                             #  unset colors[*] and
                             #+ unset colors[@] also work.
echo; echo -n "Colors gone."			   
echo ${colors[@]}            # List array again, now empty.

exit 0
</programlisting>
      </example>

      <para><anchor xml:id="arraynumelements" /></para>
      <para>As seen in the previous example, either
	<command>${array_name[@]}</command> or
	<command>${array_name[*]}</command> refers to
	<emphasis>all</emphasis> the elements of the array.
	Similarly, to get a count of the number of elements in an
	array, use either <command>${#array_name[@]}</command>
	or <command>${#array_name[*]}</command>.
	<command>${#array_name}</command> is the length (number of
	characters) of <command>${array_name[0]}</command>, the first
	element of the array.</para>

      <para><anchor xml:id="emptyarray0" /></para>
      <example xml:id="emptyarray">
	<title>Of empty arrays and empty elements</title>
	<programlisting>#!/bin/bash
# empty-array.sh

#  Thanks to Stephane Chazelas for the original example,
#+ and to Michael Zick and Omair Eshkenazi, for extending it.
#  And to Nathan Coulter for clarifications and corrections.


# An empty array is not the same as an array with empty elements.

  array0=( first second third )
  array1=( '' )   # "array1" consists of one empty element.
  array2=( )      # No elements . . . "array2" is empty.
  array3=(   )    # What about this array?


echo
ListArray()
{
echo
echo "Elements in array0:  ${array0[@]}"
echo "Elements in array1:  ${array1[@]}"
echo "Elements in array2:  ${array2[@]}"
echo "Elements in array3:  ${array3[@]}"
echo
echo "Length of first element in array0 = ${#array0}"
echo "Length of first element in array1 = ${#array1}"
echo "Length of first element in array2 = ${#array2}"
echo "Length of first element in array3 = ${#array3}"
echo
echo "Number of elements in array0 = ${#array0[*]}"  # 3
echo "Number of elements in array1 = ${#array1[*]}"  # 1  (Surprise!)
echo "Number of elements in array2 = ${#array2[*]}"  # 0
echo "Number of elements in array3 = ${#array3[*]}"  # 0
}

# ===================================================================

ListArray

# Try extending those arrays.

# Adding an element to an array.
array0=( "${array0[@]}" "new1" )
array1=( "${array1[@]}" "new1" )
array2=( "${array2[@]}" "new1" )
array3=( "${array3[@]}" "new1" )

ListArray

# or
array0[${#array0[*]}]="new2"
array1[${#array1[*]}]="new2"
array2[${#array2[*]}]="new2"
array3[${#array3[*]}]="new2"

ListArray

# When extended as above, arrays are 'stacks' ...
# Above is the 'push' ...
# The stack 'height' is:
height=${#array2[@]}
echo
echo "Stack height for array2 = $height"

# The 'pop' is:
unset array2[${#array2[@]}-1]   #  Arrays are zero-based,
height=${#array2[@]}            #+ which means first element has index 0.
echo
echo "POP"
echo "New stack height for array2 = $height"

ListArray

# List only 2nd and 3rd elements of array0.
from=1		    # Zero-based numbering.
to=2
array3=( ${array0[@]:1:2} )
echo
echo "Elements in array3:  ${array3[@]}"

# Works like a string (array of characters).
# Try some other "string" forms.

# Replacement:
array4=( ${array0[@]/second/2nd} )
echo
echo "Elements in array4:  ${array4[@]}"

# Replace all matching wildcarded string.
array5=( ${array0[@]//new?/old} )
echo
echo "Elements in array5:  ${array5[@]}"

# Just when you are getting the feel for this . . .
array6=( ${array0[@]#*new} )
echo # This one might surprise you.
echo "Elements in array6:  ${array6[@]}"

array7=( ${array0[@]#new1} )
echo # After array6 this should not be a surprise.
echo "Elements in array7:  ${array7[@]}"

# Which looks a lot like . . .
array8=( ${array0[@]/new1/} )
echo
echo "Elements in array8:  ${array8[@]}"

#  So what can one say about this?

#  The string operations are performed on
#+ each of the elements in var[@] in succession.
#  Therefore : Bash supports string vector operations.
#  If the result is a zero length string,
#+ that element disappears in the resulting assignment.
#  However, if the expansion is in quotes, the null elements remain.

#  Michael Zick:    Question, are those strings hard or soft quotes?
#  Nathan Coulter:  There is no such thing as "soft quotes."
#!    What's really happening is that
#!+   the pattern matching happens after
#!+   all the other expansions of [word]
#!+   in cases like ${parameter#word}.


zap='new*'
array9=( ${array0[@]/$zap/} )
echo
echo "Number of elements in array9:  ${#array9[@]}"
array9=( "${array0[@]/$zap/}" )
echo "Elements in array9:  ${array9[@]}"
# This time the null elements remain.
echo "Number of elements in array9:  ${#array9[@]}"


# Just when you thought you were still in Kansas . . .
array10=( ${array0[@]#$zap} )
echo
echo "Elements in array10:  ${array10[@]}"
# But, the asterisk in zap won't be interpreted if quoted.
array10=( ${array0[@]#"$zap"} )
echo
echo "Elements in array10:  ${array10[@]}"
# Well, maybe we _are_ still in Kansas . . .
# (Revisions to above code block by Nathan Coulter.)


#  Compare array7 with array10.
#  Compare array8 with array9.

#  Reiterating: No such thing as soft quotes!
#  Nathan Coulter explains:
#  Pattern matching of 'word' in ${parameter#word} is done after
#+ parameter expansion and *before* quote removal.
#  In the normal case, pattern matching is done *after* quote removal.
 
exit
</programlisting>
      </example>

      <para>The relationship of <command>${array_name[@]}</command>
	and <command>${array_name[*]}</command> is analogous to that
	between <link linkend="appref">$@ and $*</link>. This powerful
	array notation has a number of uses.</para>

      <para><anchor xml:id="copyarray0" /></para>
      <para>
      <programlisting># Copying an array.
array2=( "${array1[@]}" )
# or
array2="${array1[@]}"
#
#  However, this fails with "sparse" arrays,
#+ arrays with holes (missing elements) in them,
#+ as Jochen DeSmet points out.
# ------------------------------------------
  array1[0]=0
# array1[1] not assigned
  array1[2]=2
  array2=( "${array1[@]}" )       # Copy it?

echo ${array2[0]}      # 0
echo ${array2[2]}      # (null), should be 2
# ------------------------------------------



# Adding an element to an array.
array=( "${array[@]}" "new element" )
# or
array[${#array[*]}]="new element"

# Thanks, S.C.</programlisting>
      </para>


      <para><anchor xml:id="arrayinitcs" /></para>
      <tip>
      <para>The <command>array=( element1 element2 ... elementN )</command>
	initialization operation, with the help of <link linkend="commandsubref">command substitution</link>, makes it
	possible to load the contents of a text file into an array.</para>

      <para>  	
      <programlisting>#!/bin/bash

filename=sample_file

#            cat sample_file
#
#            1 a b c
#            2 d e fg


declare -a array1

array1=( `cat "$filename"`)                #  Loads contents
#         List file to stdout              #+ of $filename into array1.
#
#  array1=( `cat "$filename" | tr '\n' ' '`)
#                            change linefeeds in file to spaces. 
#  Not necessary because Bash does word splitting,
#+ changing linefeeds to spaces.

echo ${array1[@]}            # List the array.
#                              1 a b c 2 d e fg
#
#  Each whitespace-separated "word" in the file
#+ has been assigned to an element of the array.

element_count=${#array1[*]}
echo $element_count          # 8</programlisting>
      </para>  	
      </tip>
      
      <para>Clever scripting makes it possible to add array operations.</para>

      <para><anchor xml:id="arrayassign0" /></para>
      <example xml:id="arrayassign">
        <title>Initializing arrays</title>
	<programlisting>#! /bin/bash
# array-assign.bash

#  Array operations are Bash-specific,
#+ hence the ".bash" in the script name.

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# Clarification and additional comments by William Park.

#  Based on an example provided by Stephane Chazelas
#+ which appeared in an earlier version of the
#+ Advanced Bash Scripting Guide.

# Output format of the 'times' command:
# User CPU &lt;space&gt; System CPU
# User CPU of dead children &lt;space&gt; System CPU of dead children

#  Bash has two versions of assigning all elements of an array
#+ to a new array variable.
#  Both drop 'null reference' elements
#+ in Bash versions 2.04 and later.
#  An additional array assignment that maintains the relationship of
#+ [subscript]=value for arrays may be added to newer versions.

#  Constructs a large array using an internal command,
#+ but anything creating an array of several thousand elements
#+ will do just fine.

declare -a bigOne=( /dev/* )  # All the files in /dev . . .
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of'
echo "Number of elements in array is ${#bigOne[@]}"

# set -vx



echo
echo '- - testing: =( ${array[@]} ) - -'
times
declare -a bigTwo=( ${bigOne[@]} )
# Note parens:    ^              ^
times


echo
echo '- - testing: =${array[@]} - -'
times
declare -a bigThree=${bigOne[@]}
# No parentheses this time.
times

#  Comparing the numbers shows that the second form, pointed out
#+ by Stephane Chazelas, is faster.
#
#  As William Park explains:
#+ The bigTwo array assigned element by element (because of parentheses),
#+ whereas bigThree assigned as a single string.
#  So, in essence, you have:
#                   bigTwo=( [0]="..." [1]="..." [2]="..." ... )
#                   bigThree=( [0]="... ... ..." )
#
#  Verify this by:  echo ${bigTwo[0]}
#                   echo ${bigThree[0]}


#  I will continue to use the first form in my example descriptions
#+ because I think it is a better illustration of what is happening.

#  The reusable portions of my examples will actual contain
#+ the second form where appropriate because of the speedup.

# MSZ: Sorry about that earlier oversight folks.


#  Note:
#  ----
#  The "declare -a" statements in lines 32 and 44
#+ are not strictly necessary, since it is implicit
#+ in the  Array=( ... )  assignment form.
#  However, eliminating these declarations slows down
#+ the execution of the following sections of the script.
#  Try it, and see.

exit 0
</programlisting>
      </example>

      <note><para>Adding a superfluous <command>declare -a</command>
	statement to an array declaration may speed up execution of
	subsequent operations on the array.</para></note>

      <para><anchor xml:id="arrayappend0" /></para>
      <example xml:id="copyarray">
        <title>Copying and concatenating arrays</title>
	<programlisting>#! /bin/bash
# CopyArray.sh
#
# This script written by Michael Zick.
# Used here with permission.

#  How-To "Pass by Name &amp; Return by Name"
#+ or "Building your own assignment statement".


CpArray_Mac() {

# Assignment Command Statement Builder

    echo -n 'eval '
    echo -n "$2"                    # Destination name
    echo -n '=( ${'
    echo -n "$1"                    # Source name
    echo -n '[@]} )'

# That could all be a single command.
# Matter of style only.
}

declare -f CopyArray                # Function "Pointer"
CopyArray=CpArray_Mac               # Statement Builder

Hype()
{

# Hype the array named $1.
# (Splice it together with array containing "Really Rocks".)
# Return in array named $2.

    local -a TMP
    local -a hype=( Really Rocks )

    $($CopyArray $1 TMP)
    TMP=( ${TMP[@]} ${hype[@]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo "Array Before = ${before[@]}"

Hype before after

echo "Array After = ${after[@]}"

# Too much hype?

echo "What ${after[@]:3:2}?"

declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )
#                    ---- substring extraction ----

echo "Array Modest = ${modest[@]}"

# What happened to 'before' ?

echo "Array Before = ${before[@]}"

exit 0
</programlisting>
      </example>

      <example xml:id="arrayappend">
        <title>More on concatenating arrays</title>
	<programlisting>#! /bin/bash
# array-append.bash

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# Slightly modified in formatting by M.C.


# Array operations are Bash-specific.
# Legacy UNIX /bin/sh lacks equivalents.


#  Pipe the output of this script to 'more'
#+ so it doesn't scroll off the terminal.
#  Or, redirect output to a file.


declare -a array1=( zero1 one1 two1 )
# Subscript packed.
declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )
# Subscript sparse -- [1] is not defined.

echo
echo '- Confirm that the array is really subscript sparse. -'
echo "Number of elements: 4"        # Hard-coded for illustration.
for (( i = 0 ; i &lt; 4 ; i++ ))
do
    echo "Element [$i]: ${array2[$i]}"
done
# See also the more general code example in basics-reviewed.bash.


declare -a dest

# Combine (append) two arrays into a third array.
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'
echo '- Undefined elements not present, subscripts not maintained. -'
# # The undefined elements do not exist; they are not being dropped.

dest=( ${array1[@]} ${array2[@]} )
# dest=${array1[@]}${array2[@]}     # Strange results, possibly a bug.

# Now, list the result.
echo
echo '- - Testing Array Append - -'
cnt=${#dest[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo "Element [$i]: ${dest[$i]}"
done

# Assign an array to a single array element (twice).
dest[0]=${array1[@]}
dest[1]=${array2[@]}

# List the result.
echo
echo '- - Testing modified array - -'
cnt=${#dest[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo "Element [$i]: ${dest[$i]}"
done

# Examine the modified second element.
echo
echo '- - Reassign and list second element - -'

declare -a subArray=${dest[1]}
cnt=${#subArray[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo "Element [$i]: ${subArray[$i]}"
done

#  The assignment of an entire array to a single element
#+ of another array using the '=${ ... }' array assignment
#+ has converted the array being assigned into a string,
#+ with the elements separated by a space (the first character of IFS).

# If the original elements didn't contain whitespace . . .
# If the original array isn't subscript sparse . . .
# Then we could get the original array structure back again.

# Restore from the modified second element.
echo
echo '- - Listing restored element - -'

declare -a subArray=( ${dest[1]} )
cnt=${#subArray[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i &lt; cnt ; i++ ))
do
    echo "Element [$i]: ${subArray[$i]}"
done
echo '- - Do not depend on this behavior. - -'
echo '- - This behavior is subject to change - -'
echo '- - in versions of Bash newer than version 2.05b - -'

# MSZ: Sorry about any earlier confusion folks.

exit 0
</programlisting>
      </example>


      <para>--</para>

      <para>Arrays permit deploying old familiar algorithms as shell scripts.
        Whether this is necessarily a good idea is left for the reader to
	decide.</para>

      <para><anchor xml:id="bubblesort" /></para>

      <example xml:id="bubble">
	<title>The Bubble Sort</title>
	<programlisting>#!/bin/bash
# bubble.sh: Bubble sort, of sorts.

# Recall the algorithm for a bubble sort. In this particular version...

#  With each successive pass through the array to be sorted,
#+ compare two adjacent elements, and swap them if out of order.
#  At the end of the first pass, the "heaviest" element has sunk to bottom.
#  At the end of the second pass, the next "heaviest" one has sunk next to bottom.
#  And so forth.
#  This means that each successive pass needs to traverse less of the array.
#  You will therefore notice a speeding up in the printing of the later passes.


exchange()
{
  # Swaps two members of the array.
  local temp=${Countries[$1]} #  Temporary storage
                              #+ for element getting swapped out.
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp
  
  return
}  

declare -a Countries  #  Declare array,
                      #+ optional here since it's initialized below.

#  Is it permissable to split an array variable over multiple lines
#+ using an escape (\)?
#  Yes.

Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
Israel Peru Canada Oman Denmark Wales France Kenya \
Xanadu Qatar Liechtenstein Hungary)

# "Xanadu" is the mythical place where, according to Coleridge,
#+ Kubla Khan did a pleasure dome decree.


clear                      # Clear the screen to start with. 

echo "0: ${Countries[*]}"  # List entire array at pass 0.

number_of_elements=${#Countries[@]}
let "comparisons = $number_of_elements - 1"

count=1 # Pass number.

while [ "$comparisons" -gt 0 ]          # Beginning of outer loop
do

  index=0  # Reset index to start of array after each pass.

  while [ "$index" -lt "$comparisons" ] # Beginning of inner loop
  do
    if [ ${Countries[$index]} \&gt; ${Countries[`expr $index + 1`]} ]
    #  If out of order...
    #  Recalling that \&gt; is ASCII comparison operator
    #+ within single brackets.

    #  if [[ ${Countries[$index]} &gt; ${Countries[`expr $index + 1`]} ]]
    #+ also works.
    then
      exchange $index `expr $index + 1`  # Swap.
    fi  
    let "index += 1"  # Or,   index+=1   on Bash, ver. 3.1 or newer.
  done # End of inner loop

# ----------------------------------------------------------------------
# Paulo Marcel Coelho Aragao suggests for-loops as a simpler altenative.
#
# for (( last = $number_of_elements - 1 ; last &gt; 0 ; last-- ))
##                     Fix by C.Y. Hunt          ^   (Thanks!)
# do
#     for (( i = 0 ; i &lt; last ; i++ ))
#     do
#         [[ "${Countries[$i]}" &gt; "${Countries[$((i+1))]}" ]] \
#             &amp;&amp; exchange $i $((i+1))
#     done
# done
# ----------------------------------------------------------------------
  

let "comparisons -= 1" #  Since "heaviest" element bubbles to bottom,
                       #+ we need do one less comparison each pass.

echo
echo "$count: ${Countries[@]}"  # Print resultant array at end of each pass.
echo
let "count += 1"                # Increment pass count.

done                            # End of outer loop
                                # All done.

exit 0
</programlisting>
      </example>
      
      <para>--</para>

      <para><anchor xml:id="arraynest" /></para>
      <para>Is it possible to nest arrays within arrays?</para>
      <para><programlisting>#!/bin/bash
# "Nested" array.

#  Michael Zick provided this example,
#+ with corrections and clarifications by William Park.

AnArray=( $(ls --inode --ignore-backups --almost-all \
	--directory --full-time --color=none --time=status \
	--sort=time -l ${PWD} ) )  # Commands and options.

# Spaces are significant . . . and don't quote anything in the above.

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
#  This array has six elements:
#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
#
#  Arrays in Bash are (circularly) linked lists
#+ of type string (char *).
#  So, this isn't actually a nested array,
#+ but it's functionally similar.

echo "Current directory and date of last status change:"
echo "${SubArray[@]}"

exit 0</programlisting></para>

      <para>--</para>

      <para>Embedded arrays in combination with <link linkend="varrefnew">indirect references</link> create some fascinating
	possibilities</para>

      <para><anchor xml:id="arrayindir" /></para>
      <example xml:id="embarr">
	<title>Embedded arrays and indirect references</title>
	<programlisting>#!/bin/bash
# embedded-arrays.sh
# Embedded arrays and indirect references.

# This script by Dennis Leeuw.
# Used with permission.
# Modified by document author.


ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE="test"
        STRING="VAR1=value1 VAR2=value2 VAR3=value3"
        ARRAY21=${ARRAY1[*]}
)       # Embed ARRAY1 within this second array.

function print () {
        OLD_IFS="$IFS"
        IFS=$'\n'       #  To print each array element
                        #+ on a separate line.
        TEST1="ARRAY2[*]"
        local ${!TEST1} # See what happens if you delete this line.
        #  Indirect reference.
	#  This makes the components of $TEST1
	#+ accessible to this function.


        #  Let's see what we've got so far.
        echo
        echo "\$TEST1 = $TEST1"       #  Just the name of the variable.
        echo; echo
        echo "{\$TEST1} = ${!TEST1}"  #  Contents of the variable.
                                      #  That's what an indirect
                                      #+ reference does.
        echo
        echo "-------------------------------------------"; echo
        echo


        # Print variable
        echo "Variable VARIABLE: $VARIABLE"
	
        # Print a string element
        IFS="$OLD_IFS"
        TEST2="STRING[*]"
        local ${!TEST2}      # Indirect reference (as above).
        echo "String element VAR2: $VAR2 from STRING"

        # Print an array element
        TEST2="ARRAY21[*]"
        local ${!TEST2}      # Indirect reference (as above).
        echo "Array element VAR1_1: $VAR1_1 from ARRAY21"
}

print
echo

exit 0

#   As the author of the script notes,
#+ "you can easily expand it to create named-hashes in bash."
#   (Difficult) exercise for the reader: implement this.
</programlisting>
      </example>
      
      <para>--</para>

      <para><anchor xml:id="primes0" /></para>
      <para>Arrays enable implementing a shell script version of the
	<firstterm>Sieve of Eratosthenes</firstterm>. Of course, a
	resource-intensive application of this nature should really be
	written in a compiled language, such as C. It runs excruciatingly
	slowly as a script.</para>

      <example xml:id="ex68">
	<title>The Sieve of Eratosthenes</title>
	<programlisting>#!/bin/bash
# sieve.sh (ex68.sh)

# Sieve of Eratosthenes
# Ancient algorithm for finding prime numbers.

#  This runs a couple of orders of magnitude slower
#+ than the equivalent program written in C.

LOWER_LIMIT=1       # Starting with 1.
UPPER_LIMIT=1000    # Up to 1000.
# (You may set this higher . . . if you have time on your hands.)

PRIME=1
NON_PRIME=0

let SPLIT=UPPER_LIMIT/2
# Optimization:
# Need to test numbers only halfway to upper limit. Why?


declare -a Primes
# Primes[] is an array.


initialize ()
{
# Initialize the array.

i=$LOWER_LIMIT
until [ "$i" -gt "$UPPER_LIMIT" ]
do
  Primes[i]=$PRIME
  let "i += 1"
done
#  Assume all array members guilty (prime)
#+ until proven innocent.
}

print_primes ()
{
# Print out the members of the Primes[] array tagged as prime.

i=$LOWER_LIMIT

until [ "$i" -gt "$UPPER_LIMIT" ]
do

  if [ "${Primes[i]}" -eq "$PRIME" ]
  then
    printf "%8d" $i
    # 8 spaces per number gives nice, even columns.
  fi
  
  let "i += 1"
  
done

}

sift () # Sift out the non-primes.
{

let i=$LOWER_LIMIT+1
# Let's start with 2.

until [ "$i" -gt "$UPPER_LIMIT" ]
do

if [ "${Primes[i]}" -eq "$PRIME" ]
# Don't bother sieving numbers already sieved (tagged as non-prime).
then

  t=$i

  while [ "$t" -le "$UPPER_LIMIT" ]
  do
    let "t += $i "
    Primes[t]=$NON_PRIME
    # Tag as non-prime all multiples.
  done

fi  

  let "i += 1"
done  


}


# ==============================================
# main ()
# Invoke the functions sequentially.
initialize
sift
print_primes
# This is what they call structured programming.
# ==============================================

echo

exit 0



# -------------------------------------------------------- #
# Code below line will not execute, because of 'exit.'

#  This improved version of the Sieve, by Stephane Chazelas,
#+ executes somewhat faster.

# Must invoke with command-line argument (limit of primes).

UPPER_LIMIT=$1                  # From command-line.
let SPLIT=UPPER_LIMIT/2         # Halfway to max number.

Primes=( '' $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) &gt; SPLIT ))  # Need check only halfway.
do
  if [[ -n ${Primes[i]} ]]
  then
    t=$i
    until (( ( t += i ) &gt; UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi  
done  
echo ${Primes[*]}

exit $?
</programlisting>
      </example>

      <example xml:id="ex68a">
	<title>The Sieve of Eratosthenes, Optimized</title>
	<programlisting>#!/bin/bash
# Optimized Sieve of Eratosthenes
# Script by Jared Martin, with very minor changes by ABS Guide author.
# Used in ABS Guide with permission (thanks!).

# Based on script in Advanced Bash Scripting Guide.
# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).

# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (reference)
# Check results against http://primes.utm.edu/lists/small/1000.txt

# Necessary but not sufficient would be, e.g.,
#     (($(sieve 7919 | wc -w) == 1000)) &amp;&amp; echo "7919 is the 1000th prime"

UPPER_LIMIT=${1:?"Need an upper limit of primes to search."}

Primes=( '' $(seq ${UPPER_LIMIT}) )

typeset -i i t
Primes[i=1]='' # 1 is not a prime.
until (( ( i += 1 ) &gt; (${UPPER_LIMIT}/i) ))  # Need check only ith-way.
  do                                         # Why?
    if ((${Primes[t=i*(i-1), i]}))
    # Obscure, but instructive, use of arithmetic expansion in subscript.
    then
      until (( ( t += i ) &gt; ${UPPER_LIMIT} ))
        do Primes[t]=; done
    fi
  done

# echo ${Primes[*]}
echo   # Change to original script for pretty-printing (80-col. display).
printf "%8d" ${Primes[*]}
echo; echo

exit $?
</programlisting>
      </example>

      <para>Compare these array-based prime number generators with
        alternatives that do not use arrays, <xref linkend="primes" />,
        and <xref linkend="primes2" />.</para>

      <para>--</para>

      <para>Arrays lend themselves, to some extent, to emulating data
        structures for which Bash has no native support.</para>

	    <para><anchor xml:id="stackex0" /></para>
	    <example xml:id="stackex">
	      <title>Emulating a push-down stack</title>
	      <programlisting>#!/bin/bash
# stack.sh: push-down stack simulation

#  Similar to the CPU stack, a push-down stack stores data items
#+ sequentially, but releases them in reverse order, last-in first-out.


BP=100            #  Base Pointer of stack array.
                  #  Begin at element 100.

SP=$BP            #  Stack Pointer.
                  #  Initialize it to "base" (bottom) of stack.

Data=             #  Contents of stack location.  
                  #  Must use global variable,
                  #+ because of limitation on function return range.


                  # 100     Base pointer       &lt;-- Base Pointer
                  #  99     First data item
                  #  98     Second data item
                  # ...     More data
                  #         Last data item     &lt;-- Stack pointer


declare -a stack


push()            # Push item on stack.
{
if [ -z "$1" ]    # Nothing to push?
then
  return
fi

let "SP -= 1"     # Bump stack pointer.
stack[$SP]=$1

return
}

pop()                    # Pop item off stack.
{
Data=                    # Empty out data item.

if [ "$SP" -eq "$BP" ]   # Stack empty?
then
  return
fi                       #  This also keeps SP from getting past 100,
                         #+ i.e., prevents a runaway stack.

Data=${stack[$SP]}
let "SP += 1"            # Bump stack pointer.
return
}

status_report()          # Find out what's happening.
{
echo "-------------------------------------"
echo "REPORT"
echo "Stack Pointer = $SP"
echo "Just popped \""$Data"\" off the stack."
echo "-------------------------------------"
echo
}


# =======================================================
# Now, for some fun.

echo

# See if you can pop anything off empty stack.
pop
status_report

echo

push garbage
pop
status_report     # Garbage in, garbage out.      

value1=23;        push $value1
value2=skidoo;    push $value2
value3=LAST;      push $value3

pop               # LAST
status_report
pop               # skidoo
status_report
pop               # 23
status_report     # Last-in, first-out!

#  Notice how the stack pointer decrements with each push,
#+ and increments with each pop.

echo

exit 0

# =======================================================


# Exercises:
# ---------

# 1)  Modify the "push()" function to permit pushing
#   + multiple element on the stack with a single function call.

# 2)  Modify the "pop()" function to permit popping
#   + multiple element from the stack with a single function call.

# 3)  Add error checking to the critical functions.
#     That is, return an error code, depending on
#   + successful or unsuccessful completion of the operation,
#   + and take appropriate action.

# 4)  Using this script as a starting point,
#   + write a stack-based 4-function calculator.
</programlisting>
	    </example>

      <para>--</para>

      <para>Fancy manipulation of array <quote>subscripts</quote> may require
        intermediate variables. For projects involving this, again consider
	using a more powerful programming language, such as Perl or C.</para>

      <example xml:id="qfunction">
	<title>Complex array application:
             <emphasis>Exploring a weird mathematical series</emphasis></title>
	<programlisting>#!/bin/bash

# Douglas Hofstadter's notorious "Q-series":

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), for n&gt;2

#  This is a "chaotic" integer series with strange
#+ and unpredictable behavior.
#  The first 20 terms of the series are:
#  1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12 

#  See Hofstadter's book, _Goedel, Escher, Bach: An Eternal Golden Braid_,
#+ p. 137, ff.


LIMIT=100     # Number of terms to calculate.
LINEWIDTH=20  # Number of terms printed per line.

Q[1]=1        # First two terms of series are 1.
Q[2]=1

echo
echo "Q-series [$LIMIT terms]:"
echo -n "${Q[1]} "             # Output first two terms.
echo -n "${Q[2]} "

for ((n=3; n &lt;= $LIMIT; n++))  # C-like loop expression.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n&gt;2
#    Need to break the expression into intermediate terms,
#+   since Bash doesn't handle complex array arithmetic very well.

  let "n1 = $n - 1"        # n-1
  let "n2 = $n - 2"        # n-2
  
  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]
  
  T0=${Q[t0]}              # Q[n - Q[n-1]]
  T1=${Q[t1]}              # Q[n - Q[n-2]]

Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
echo -n "${Q[n]} "

if [ `expr $n % $LINEWIDTH` -eq 0 ]    # Format output.
then   #      ^ modulo
  echo # Break lines into neat chunks.
fi

done

echo

exit 0

#  This is an iterative implementation of the Q-series.
#  The more intuitive recursive implementation is left as an exercise.
#  Warning: calculating this series recursively takes a VERY long time
#+ via a script. C/C++ would be orders of magnitude faster.
</programlisting>
      </example>

      <para>--</para>

      <para><anchor xml:id="arraymultidim" /></para>
      <para>Bash supports only one-dimensional arrays, though a little
        trickery permits simulating multi-dimensional ones.</para>

      <example xml:id="twodim">
	<title>Simulating a two-dimensional array, then tilting it</title>
	<programlisting>#!/bin/bash
# twodim.sh: Simulating a two-dimensional array.

# A one-dimensional array consists of a single row.
# A two-dimensional array stores rows sequentially.

Rows=5
Columns=5
# 5 X 5 Array.

declare -a alpha     # char alpha [Rows] [Columns];
                     # Unnecessary declaration. Why?

load_alpha ()
{
local rc=0
local index

for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
do     # Use different symbols if you like.
  local row=`expr $rc / $Columns`
  local column=`expr $rc % $Rows`
  let "index = $row * $Rows + $column"
  alpha[$index]=$i
# alpha[$row][$column]
  let "rc += 1"
done  

#  Simpler would be
#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
#+ but this somehow lacks the "flavor" of a two-dimensional array.
}

print_alpha ()
{
local row=0
local index

echo

while [ "$row" -lt "$Rows" ]   #  Print out in "row major" order:
do                             #+ columns vary,
                               #+ while row (outer loop) remains the same.
  local column=0

  echo -n "       "            #  Lines up "square" array with rotated one.
  
  while [ "$column" -lt "$Columns" ]
  do
    let "index = $row * $Rows + $column"
    echo -n "${alpha[index]} "  # alpha[$row][$column]
    let "column += 1"
  done

  let "row += 1"
  echo

done  

# The simpler equivalent is
#     echo ${alpha[*]} | xargs -n $Columns

echo
}

filter ()     # Filter out negative array indices.
{

echo -n "  "  # Provides the tilt.
              # Explain how.

if [[ "$1" -ge 0 &amp;&amp;  "$1" -lt "$Rows" &amp;&amp; "$2" -ge 0 &amp;&amp; "$2" -lt "$Columns" ]]
then
    let "index = $1 * $Rows + $2"
    # Now, print it rotated.
    echo -n " ${alpha[index]}"
    #           alpha[$row][$column]
fi    

}
  



rotate ()  #  Rotate the array 45 degrees --
{          #+ "balance" it on its lower lefthand corner.
local row
local column

for (( row = Rows; row &gt; -Rows; row-- ))
  do       # Step through the array backwards. Why?

  for (( column = 0; column &lt; Columns; column++ ))
  do

    if [ "$row" -ge 0 ]
    then
      let "t1 = $column - $row"
      let "t2 = $column"
    else
      let "t1 = $column"
      let "t2 = $column + $row"
    fi  

    filter $t1 $t2   # Filter out negative array indices.
                     # What happens if you don't do this?
  done

  echo; echo

done 

#  Array rotation inspired by examples (pp. 143-146) in
#+ "Advanced C Programming on the IBM PC," by Herbert Mayer
#+ (see bibliography).
#  This just goes to show that much of what can be done in C
#+ can also be done in shell scripting.

}


#--------------- Now, let the show begin. ------------#
load_alpha     # Load the array.
print_alpha    # Print it out.  
rotate         # Rotate it 45 degrees counterclockwise.
#-----------------------------------------------------#

exit 0

# This is a rather contrived, not to mention inelegant simulation.

# Exercises:
# ---------
# 1)  Rewrite the array loading and printing functions
#     in a more intuitive and less kludgy fashion.
#
# 2)  Figure out how the array rotation functions work.
#     Hint: think about the implications of backwards-indexing an array.
#
# 3)  Rewrite this script to handle a non-square array,
#     such as a 6 X 4 one.
#     Try to minimize "distortion" when the array is rotated.
</programlisting>
      </example>

      <para>A two-dimensional array is essentially equivalent to a
	one-dimensional one, but with additional addressing modes
	for referencing and manipulating the individual elements by
	<firstterm>row</firstterm> and <firstterm>column</firstterm>
	position.</para>

      <para>For an even more elaborate example of simulating a
        two-dimensional array, see <xref linkend="lifeslow" />.</para>

     <para>--</para>

     <para>For more interesting scripts using arrays, see:
       <itemizedlist>
	 <listitem><para><xref linkend="agram2" /></para></listitem>
	 <listitem><para><xref linkend="primes2" /></para></listitem>
	 <listitem><para><xref linkend="hashex2" /></para></listitem>
         <listitem><para><xref linkend="homework" /></para></listitem>
         <listitem><para><xref linkend="qky" /></para></listitem>
         <listitem><para><xref linkend="nim" /></para></listitem>
       </itemizedlist>
     </para>

  </chapter> <!-- Arrays -->


  <chapter xml:id="ivr">
        <title>Indirect References</title>

	<para><anchor xml:id="ivrref" /></para>

      <para>We have seen that <link linkend="varsubn">referencing
        a variable</link>, <varname>$var</varname>, fetches its
        <firstterm>value</firstterm>. <anchor xml:id="evalindref" />But,
        what about the <emphasis>value of a value</emphasis>? What
        about <varname>$$var</varname>?</para>
	
      <para>The actual notation is
	<replaceable>\$$var</replaceable>, usually preceded by
	an <link linkend="evalref">eval</link> (and sometimes an
	<link linkend="echoref">echo</link>). This is called an
	<firstterm>indirect reference</firstterm>.</para>


      <example xml:id="indref">
	<title>Indirect Variable References</title>
	<programlisting>#!/bin/bash
# ind-ref.sh: Indirect variable referencing.
# Accessing the contents of the contents of a variable.

# First, let's fool around a little.

var=23

echo "\$var   = $var"           # $var   = 23
# So far, everything as expected. But ...

echo "\$\$var  = $$var"         # $$var  = 4570var
#  Not useful ...
#  \$\$ expanded to PID of the script
#  -- refer to the entry on the $$ variable --
#+ and "var" is echoed as plain text.
#  (Thank you, Jakob Bohm, for pointing this out.)

echo "\\\$\$var = \$$var"       # \$$var = $23
#  As expected. The first $ is escaped and pasted on to
#+ the value of var ($var = 23 ).
#  Meaningful, but still not useful. 

# Now, let's start over and do it the right way.

# ============================================== #


a=letter_of_alphabet   # Variable "a" holds the name of another variable.
letter_of_alphabet=z

echo

# Direct reference.
echo "a = $a"          # a = letter_of_alphabet

# Indirect reference.
  eval a=\$$a
# ^^^        Forcing an eval(uation), and ...
#        ^   Escaping the first $ ...
# ------------------------------------------------------------------------
# The 'eval' forces an update of $a, sets it to the updated value of \$$a.
# So, we see why 'eval' so often shows up in indirect reference notation.
# ------------------------------------------------------------------------
  echo "Now a = $a"    # Now a = z

echo


# Now, let's try changing the second-order reference.

t=table_cell_3
table_cell_3=24
echo "\"table_cell_3\" = $table_cell_3"            # "table_cell_3" = 24
echo -n "dereferenced \"t\" = "; eval echo \$$t    # dereferenced "t" = 24
# In this simple case, the following also works (why?).
#         eval t=\$$t; echo "\"t\" = $t"

echo

t=table_cell_3
NEW_VAL=387
table_cell_3=$NEW_VAL
echo "Changing value of \"table_cell_3\" to $NEW_VAL."
echo "\"table_cell_3\" now $table_cell_3"
echo -n "dereferenced \"t\" now "; eval echo \$$t
# "eval" takes the two arguments "echo" and "\$$t" (set equal to $table_cell_3)


echo

# (Thanks, Stephane Chazelas, for clearing up the above behavior.)


#   A more straightforward method is the ${!t} notation, discussed in the
#+ "Bash, version 2" section.
#   See also ex78.sh.

exit 0
</programlisting>
      </example>

      <para><anchor xml:id="irrref" /></para>
		      
      <sidebar><para>Indirect referencing in Bash
        is a multi-step process. First, take the name of a variable:
	<varname>varname</varname>. Then, reference it:
	<varname>$varname</varname>. Then, reference the reference:
	<varname>$$varname</varname>. Then, <firstterm>escape</firstterm>
	the first <token>$</token>: <varname>\$$varname</varname>.
	Finally, force a reevaluation of the expression and assign it:
	<command>eval newvar=\$$varname</command>.</para></sidebar>


        <para>Of what practical use is indirect referencing of
	  variables? It gives Bash a little of the functionality
	  of <link linkend="pointerref">pointers</link>
	  in <firstterm>C</firstterm>, for instance, in <link linkend="resistor">table lookup</link>.  And, it also has some
	  other very interesting applications. . . .</para>

        <para>Nils Radtke shows how to build <quote>dynamic</quote>
	  variable names and evaluate their contents. This can be useful
	  when <link linkend="sourceref">sourcing</link> configuration
	  files.</para>

	<para><programlisting>#!/bin/bash


# ---------------------------------------------
# This could be "sourced" from a separate file.
isdnMyProviderRemoteNet=172.16.0.100
isdnYourProviderRemoteNet=10.0.0.10
isdnOnlineService="MyProvider"
# ---------------------------------------------
      

remoteNet=$(eval "echo \$$(echo isdn${isdnOnlineService}RemoteNet)")
remoteNet=$(eval "echo \$$(echo isdnMyProviderRemoteNet)")
remoteNet=$(eval "echo \$isdnMyProviderRemoteNet")
remoteNet=$(eval "echo $isdnMyProviderRemoteNet")

echo "$remoteNet"    # 172.16.0.100

# ================================================================

#  And, it gets even better.

#  Consider the following snippet given a variable named getSparc,
#+ but no such variable getIa64:

chkMirrorArchs () { 
  arch="$1";
  if [ "$(eval "echo \${$(echo get$(echo -ne $arch |
       sed 's/^\(.\).*/\1/g' | tr 'a-z' 'A-Z'; echo $arch |
       sed 's/^.\(.*\)/\1/g')):-false}")" = true ]
  then
     return 0;
  else
     return 1;
  fi;
}

getSparc="true"
unset getIa64
chkMirrorArchs sparc
echo $?        # 0
               # True

chkMirrorArchs Ia64
echo $?        # 1
               # False

# Notes:
# -----
# Even the to-be-substituted variable name part is built explicitly.
# The parameters to the chkMirrorArchs calls are all lower case.
# The variable name is composed of two parts: "get" and "Sparc" . . .</programlisting>
        </para>



      <example xml:id="coltotaler2">
	<title>Passing an indirect reference to <firstterm>awk</firstterm></title>
	<programlisting>#!/bin/bash

#  Another version of the "column totaler" script
#+ that adds up a specified column (of numbers) in the target file.
#  This one uses indirect references.

ARGS=2
E_WRONGARGS=85

if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1         # Name of file to operate on.
column_number=$2    # Which column to total up.

#===== Same as original script, up to this point =====#


# A multi-line awk script is invoked by
#   awk "
#   ...
#   ...
#   ...
#   "


# Begin awk script.
# -------------------------------------------------
awk "

{ total += \$${column_number} # Indirect reference
}
END {
     print total
     }

     " "$filename"
# Note that awk doesn't need an eval preceding \$$.
# -------------------------------------------------
# End awk script.

#  Indirect variable reference avoids the hassles
#+ of referencing a shell variable within the embedded awk script.
#  Thanks, Stephane Chazelas.


exit $?
</programlisting>
      </example>

      <caution><para>This method of indirect referencing is a bit tricky.
	If the second order variable changes its value, then the first
	order variable must be properly dereferenced (as in the above
	example). <anchor xml:id="ivr2" />Fortunately, the
	<replaceable>${!variable}</replaceable> notation introduced
	with <link linkend="bash2ref">version 2</link> of Bash
	(see <xref linkend="ex78" /> and <xref linkend="hashex2" />) makes
	indirect referencing more intuitive.</para></caution>

     
     <sidebar>
       <para>Bash does not support pointer arithmetic, and this severely
	 limits the usefulness of indirect referencing. In fact, indirect
	 referencing in a scripting language is, at best, something of
	 an afterthought.</para>
     </sidebar>

      </chapter> <!-- Indirect References to Variables -->




  <chapter xml:id="devproc">
    <title><filename class="directory">/dev</filename> and <filename class="directory">/proc</filename></title>

      <para><anchor xml:id="devprocref" /></para>

      <para>A Linux or UNIX filesystem typically has the
      <filename class="directory">/dev</filename> and
	<filename class="directory">/proc</filename> special-purpose
	directories.</para>



      <section xml:id="devref1">
	<title><filename class="directory">/dev</filename></title>

      <para><anchor xml:id="devfileref" />The <filename class="directory">/dev</filename> directory contains entries for
	the <firstterm>physical devices</firstterm> that may or may not
	be present in the hardware.

	   <footnote>
	   <para>The entries in <filename class="directory">/dev</filename>
	     provide mount points for physical and virtual devices. These
	     entries use very little drive space.</para>
	 <para>Some devices, such as <filename>/dev/null</filename>,
	   <filename>/dev/zero</filename>,
	   and <filename>/dev/urandom</filename> are virtual. They
	   are not actual physical devices and exist only in
	   software.</para>
	   </footnote>
	
	Appropriately enough, these are called <firstterm>device
	files</firstterm>.
	As an example, the hard drive partitions containing
	the mounted filesystem(s) have entries in <filename class="directory">/dev</filename>, as <link linkend="dfref">df</link> shows.</para>

	 <para><screen><prompt>bash$ </prompt><userinput>df</userinput>
<computeroutput>Filesystem           1k-blocks      Used Available Use%
 Mounted on
 /dev/hda6               495876    222748    247527  48% /
 /dev/hda1                50755      3887     44248   9% /boot
 /dev/hda8               367013     13262    334803   4% /home
 /dev/hda5              1714416   1123624    503704  70% /usr</computeroutput>
	      </screen>
        </para>	     

      <para><anchor xml:id="loopbackref" />Among other things, the <filename class="directory">/dev</filename> directory
	contains <firstterm>loopback</firstterm> devices, such as
	<filename>/dev/loop0</filename>. A loopback device is a gimmick
	that allows an ordinary file to be accessed as if it were a
	block device.

	  <footnote><para><anchor xml:id="blockdevref" />A <firstterm>block
	    device</firstterm> reads and/or writes data in chunks,
	    or <firstterm>blocks</firstterm>, in contrast to a <anchor xml:id="chardevref" /><firstterm>character device</firstterm>,
	    which acesses data in <firstterm>character</firstterm>
	    units. Examples of block devices are hard drives, CDROM
	    drives, and flash drives. Examples of character devices are
	    keyboards, modems, sound cards.</para></footnote>

	This permits mounting an entire filesystem within a
	single large file. See <xref linkend="createfs" /> and <xref linkend="isomountref" />.</para>

       <para>A few of the pseudo-devices in <filename class="directory">/dev</filename>
	 have other specialized uses, such as <link linkend="zerosref"><filename>/dev/null</filename></link>, <link linkend="zerosref1"><filename>/dev/zero</filename></link>, <link linkend="urandomref"><filename>/dev/urandom</filename></link>,
	 <filename>/dev/sda1</filename> (hard drive partition),
	 <filename>/dev/udp</filename> (<firstterm>User
	 Datagram Packet</firstterm> port), and <link linkend="devtcp"><filename>/dev/tcp</filename></link>.</para>

       <para>For instance:</para>

       <para>To manually <link linkend="mountref">mount</link>
         a USB flash drive, append the following line to
         <link linkend="fstabref"><filename>/etc/fstab</filename></link>.

	      <footnote>
	      <para>Of course, the mount point
	        <filename>/mnt/flashdrive</filename> must exist. If not,
		then, as <firstterm>root</firstterm>, <command>mkdir
		/mnt/flashdrive</command>.</para>
	     <para>To actually mount the drive, use the following command:
	       <command>mount /mnt/flashdrive</command></para>
	     <para>Newer Linux distros automount flash drives in the
	       <filename class="directory">/media</filename>
	       directory without user intervention.</para>
	      </footnote>

	   <programlisting>/dev/sda1    /mnt/flashdrive    auto    noauto,user,noatime    0 0</programlisting>

         (See also <xref linkend="usbinst" />.)</para>

       <para>Checking whether a disk is in the CD-burner
         (soft-linked to <filename>/dev/hdc</filename>):

	 <programlisting>head -1 /dev/hdc


#  head: cannot open '/dev/hdc' for reading: No medium found
#  (No disc in the drive.)

#  head: error reading '/dev/hdc': Input/output error
#  (There is a disk in the drive, but it can't be read;
#+  possibly it's an unrecorded CDR blank.)   

#  Stream of characters and assorted gibberish
#  (There is a pre-recorded disk in the drive,
#+ and this is raw output -- a stream of ASCII and binary data.)
#  Here we see the wisdom of using 'head' to limit the output
#+ to manageable proportions, rather than 'cat' or something similar.


#  Now, it's just a matter of checking/parsing the output and taking
#+ appropriate action.</programlisting></para>


       <para><anchor xml:id="socketref" /></para>

       <para>When executing a command on a
         <filename>/dev/tcp/$host/$port</filename> pseudo-device file, Bash
	 opens a TCP connection to the associated
	 <firstterm>socket</firstterm>.</para>


	    <sidebar><para>A <firstterm>socket</firstterm> is a
	      communications node associated with a specific I/O
	      port. (This is analogous to a <firstterm>hardware
	      socket</firstterm>, or <firstterm>receptacle</firstterm>,
	      for a connecting cable.) It permits data transfer between
	      hardware devices on the same machine, between machines
	      on the same network, between machines across different
	      networks, and, of course, between machines at different
	      locations on the Internet.</para></sidebar>


       <para><anchor xml:id="npref" />The following examples assume an active Internet
         connection.</para>

       <para>Getting the time from <filename>nist.gov</filename>:</para>
	      <screen><prompt>bash$ </prompt><userinput>cat &lt;/dev/tcp/time.nist.gov/13</userinput>
<computeroutput>53082 04-03-18 04:26:54 68 0 0 502.3 UTC(NIST) *</computeroutput>
	      </screen>

       <para>[Mark contributed this example.]</para>

       <para>Generalizing the above into a script:</para>
       <para><programlisting>#!/bin/bash
# This script must run with root permissions.

URL="time.nist.gov/13"

Time=$(cat &lt;/dev/tcp/"$URL")
UTC=$(echo "$Time" | awk '{print$3}')   # Third field is UTC (GMT) time.
# Exercise: modify this for different time zones.

echo "UTC Time = "$UTC""</programlisting></para>

       <para><anchor xml:id="nw001" />Downloading a URL:</para>
	      <screen><prompt>bash$ </prompt><userinput>exec 5&lt;&gt;/dev/tcp/www.net.cn/80</userinput>
<prompt>bash$ </prompt><userinput>echo -e "GET / HTTP/1.0\n" &gt;&amp;5</userinput>
<prompt>bash$ </prompt><userinput>cat &lt;&amp;5</userinput>
	      </screen>

       <para>[Thanks, Mark and Mihai Maties.]</para>




	    <example xml:id="devtcp">
	      <title>Using <filename>/dev/tcp</filename> for
	      troubleshooting</title>
	      <programlisting>#!/bin/bash
# dev-tcp.sh: /dev/tcp redirection to check Internet connection.

# Script by Troy Engel.
# Used with permission.
 
TCP_HOST=news-15.net       # A known spam-friendly ISP.
TCP_PORT=80                # Port 80 is http.
  
# Try to connect. (Somewhat similar to a 'ping' . . .) 
echo "HEAD / HTTP/1.0" &gt;/dev/tcp/${TCP_HOST}/${TCP_PORT}
MYEXIT=$?

: &lt;&lt;EXPLANATION
If bash was compiled with --enable-net-redirections, it has the capability of
using a special character device for both TCP and UDP redirections. These
redirections are used identically as STDIN/STDOUT/STDERR. The device entries
are 30,36 for /dev/tcp:

  mknod /dev/tcp c 30 36

&gt;From the bash reference:
/dev/tcp/host/port
    If host is a valid hostname or Internet address, and port is an integer
port number or service name, Bash attempts to open a TCP connection to the
corresponding socket.
EXPLANATION

   
if [ "X$MYEXIT" = "X0" ]; then
  echo "Connection successful. Exit code: $MYEXIT"
else
  echo "Connection unsuccessful. Exit code: $MYEXIT"
fi

exit $MYEXIT
</programlisting>
	    </example>

	    <example xml:id="musicscr">
	      <title>Playing music</title>
	      <programlisting>#!/bin/bash
# music.sh

# Music without external files

# Author: Antonio Macchi
# Used in ABS Guide with permission.


#  /dev/dsp default = 8000 frames per second, 8 bits per frame (1 byte),
#+ 1 channel (mono)

duration=2000       # If 8000 bytes = 1 second, then 2000 = 1/4 second.
volume=$'\xc0'      # Max volume = \xff (or \x00).
mute=$'\x80'        # No volume = \x80 (the middle).

function mknote ()  # $1=Note Hz in bytes (e.g. A = 440Hz ::
{                   #+ 8000 fps / 440 = 16 :: A = 16 bytes per second)
  for t in `seq 0 $duration`
  do
    test $(( $t % $1 )) = 0 &amp;&amp; echo -n $volume || echo -n $mute
  done
}

e=`mknote 49`
g=`mknote 41`
a=`mknote 36`
b=`mknote 32`
c=`mknote 30`
cis=`mknote 29`
d=`mknote 27`
e2=`mknote 24`
n=`mknote 32767`
# European notation.

echo -n "$g$e2$d$c$d$c$a$g$n$g$e$n$g$e2$d$c$c$b$c$cis$n$cis$d \
$n$g$e2$d$c$d$c$a$g$n$g$e$n$g$a$d$c$b$a$b$c" &gt; /dev/dsp
# dsp = Digital Signal Processor

exit      # A "bonny" example of an elegant shell script!
</programlisting>
	    </example>


      </section> <!-- /dev -->



      <section xml:id="procref1">
        <title><filename class="directory">/proc</filename></title>


      <para><anchor xml:id="procref2" /></para>
      <para>The <filename class="directory">/proc</filename> directory
	is actually a pseudo-filesystem.  The files in <filename class="directory">/proc</filename> mirror currently running
	system and kernel <link linkend="processref">processes</link>
	and contain information and statistics about them.</para>

       <para>
         <screen><prompt>bash$ </prompt><userinput>cat /proc/devices</userinput>
<computeroutput>Character devices:
   1 mem
   2 pty
   3 ttyp
   4 ttyS
   5 cua
   7 vcs
  10 misc
  14 sound
  29 fb
  36 netlink
 128 ptm
 136 pts
 162 raw
 254 pcmcia

 Block devices:
   1 ramdisk
   2 fd
   3 ide0
   9 md</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/interrupts</userinput>
<computeroutput>           CPU0       
   0:      84505          XT-PIC  timer
   1:       3375          XT-PIC  keyboard
   2:          0          XT-PIC  cascade
   5:          1          XT-PIC  soundblaster
   8:          1          XT-PIC  rtc
  12:       4231          XT-PIC  PS/2 Mouse
  14:     109373          XT-PIC  ide0
 NMI:          0 
 ERR:          0</computeroutput>


<prompt>bash$ </prompt><userinput>cat /proc/partitions</userinput>
<computeroutput>major minor  #blocks  name     rio rmerge rsect ruse wio wmerge wsect wuse running use aveq

    3     0    3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030
    3     1      52416 hda1 27 395 844 960 4 2 14 180 0 800 1140
    3     2          1 hda2 0 0 0 0 0 0 0 0 0 0 0
    3     4     165280 hda4 10 0 20 210 0 0 0 0 0 210 210
    ...</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/loadavg</userinput>
<computeroutput>0.13 0.42 0.27 2/44 1119</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/apm</userinput>
<computeroutput>1.16 1.2 0x03 0x01 0xff 0x80 -1% -1 ?</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/acpi/battery/BAT0/info</userinput>
<computeroutput>present:                 yes
 design capacity:         43200 mWh
 last full capacity:      36640 mWh
 battery technology:      rechargeable
 design voltage:          10800 mV
 design capacity warning: 1832 mWh
 design capacity low:     200 mWh
 capacity granularity 1:  1 mWh
 capacity granularity 2:  1 mWh
 model number:            IBM-02K6897
 serial number:            1133
 battery type:            LION
 OEM info:                Panasonic</computeroutput>
 
 
 
<prompt>bash$ </prompt><userinput>fgrep Mem /proc/meminfo</userinput>
<computeroutput>MemTotal:       515216 kB
 MemFree:        266248 kB</computeroutput>
         </screen>
      </para>

       <para>Shell scripts may extract data from certain of the files in
         <filename class="directory">/proc</filename>.

	   <footnote><para>Certain system commands, such as
	     <link linkend="procinforef">procinfo</link>,
	     <link linkend="freeref">free</link>,
	     <link linkend="vmstatref">vmstat</link>,
	     <link linkend="lsdevref">lsdev</link>,
	     and <link linkend="uptimeref">uptime</link>
	     do this as well.</para></footnote></para>

	  <para><programlisting>FS=iso                       # ISO filesystem support in kernel?

grep $FS /proc/filesystems   # iso9660</programlisting></para>


       <para><programlisting>kernel_version=$( awk '{ print $3 }' /proc/version )</programlisting></para>

       <para><programlisting>CPU=$( awk '/model name/ {print $5}' &lt; /proc/cpuinfo )

if [ "$CPU" = "Pentium(R)" ]
then
  run_some_commands
  ...
else
  run_other_commands
  ...
fi



cpu_speed=$( fgrep "cpu MHz" /proc/cpuinfo | awk '{print $4}' )
#  Current operating speed (in MHz) of the cpu on your machine.
#  On a laptop this may vary, depending on use of battery
#+ or AC power.</programlisting></para>


       <para><programlisting>#!/bin/bash
# get-commandline.sh
# Get the command-line parameters of a process.

OPTION=cmdline

# Identify PID.
pid=$( echo $(pidof "$1") | awk '{ print $1 }' )
# Get only first            ^^^^^^^^^^^^^^^^^^ of multiple instances.

echo
echo "Process ID of (first instance of) "$1" = $pid"
echo -n "Command-line arguments: "
cat /proc/"$pid"/"$OPTION" | xargs -0 echo
#   Formats output:        ^^^^^^^^^^^^^^^
#   (Thanks, Han Holl, for the fixup!)

echo; echo


# For example:
# sh get-commandline.sh xterm</programlisting></para>

       <para>+</para>

       <para><programlisting>devfile="/proc/bus/usb/devices"
text="Spd"
USB1="Spd=12"
USB2="Spd=480"


bus_speed=$(fgrep -m 1 "$text" $devfile | awk '{print $9}')
#                 ^^^^ Stop after first match.

if [ "$bus_speed" = "$USB1" ]
then
  echo "USB 1.1 port found."
  # Do something appropriate for USB 1.1.
fi</programlisting></para>


	<note>
	<para>It is even possible to control certain peripherals with commands
	  sent to the <filename class="directory">/proc</filename> directory.

          <screen>
	  <prompt>root# </prompt><command>echo on &gt; /proc/acpi/ibm/light</command>
          </screen>

	  This turns on the <emphasis>Thinklight</emphasis> in certain models
	  of IBM/Lenovo Thinkpads. (May not work on all Linux distros.)</para>

        <para>Of course, caution is advised when writing to <filename class="directory">/proc</filename>.</para>

	</note>


	<para><anchor xml:id="procrunning" /></para>
	<para>The <filename class="directory">/proc</filename> directory
	   contains subdirectories with unusual numerical
	   names.  Every one of these names maps to the <link linkend="ppidref">process ID</link> of a currently running
	   process.  Within each of these subdirectories, there are
	   a number of files that hold useful information about the
	   corresponding process.  The <filename>stat</filename> and
	   <filename>status</filename> files keep running statistics
	   on the process, the <filename>cmdline</filename> file holds
	   the command-line arguments the process was invoked with, and
	   the <filename>exe</filename> file is a symbolic link to the
	   complete path name of the invoking process. There are a few
	   more such files, but these seem to be the most interesting
	   from a scripting standpoint.</para>

	    <example xml:id="pidid">
	      <title>Finding the process associated with a PID</title>
	      <programlisting>#!/bin/bash
# pid-identifier.sh:
# Gives complete path name to process associated with pid.

ARGNO=1  # Number of arguments the script expects.
E_WRONGARGS=65
E_BADPID=66
E_NOSUCHPROCESS=67
E_NOPERMISSION=68
PROCFILE=exe

if [ $# -ne $ARGNO ]
then
  echo "Usage: `basename $0` PID-number" &gt;&amp;2  # Error message &gt;stderr.
  exit $E_WRONGARGS
fi  

pidno=$( ps ax | grep $1 | awk '{ print $1 }' | grep $1 )
# Checks for pid in "ps" listing, field #1.
# Then makes sure it is the actual process, not the process invoked by this script.
# The last "grep $1" filters out this possibility.
#
#    pidno=$( ps ax | awk '{ print $1 }' | grep $1 )
#    also works, as Teemu Huovila, points out.

if [ -z "$pidno" ]  #  If, after all the filtering, the result is a zero-length string,
then                #+ no running process corresponds to the pid given.
  echo "No such process running."
  exit $E_NOSUCHPROCESS
fi  

# Alternatively:
#   if ! ps $1 &gt; /dev/null 2&gt;&amp;1
#   then                # no running process corresponds to the pid given.
#     echo "No such process running."
#     exit $E_NOSUCHPROCESS
#    fi

# To simplify the entire process, use "pidof".


if [ ! -r "/proc/$1/$PROCFILE" ]  # Check for read permission.
then
  echo "Process $1 running, but..."
  echo "Can't get read permission on /proc/$1/$PROCFILE."
  exit $E_NOPERMISSION  # Ordinary user can't access some files in /proc.
fi  

# The last two tests may be replaced by:
#    if ! kill -0 $1 &gt; /dev/null 2&gt;&amp;1 # '0' is not a signal, but
                                      # this will test whether it is possible
                                      # to send a signal to the process.
#    then echo "PID doesn't exist or you're not its owner" &gt;&amp;2
#    exit $E_BADPID
#    fi



exe_file=$( ls -l /proc/$1 | grep "exe" | awk '{ print $11 }' )
# Or       exe_file=$( ls -l /proc/$1/exe | awk '{print $11}' )
#
#  /proc/pid-number/exe is a symbolic link
#+ to the complete path name of the invoking process.

if [ -e "$exe_file" ]  #  If /proc/pid-number/exe exists,
then                   #+ then the corresponding process exists.
  echo "Process #$1 invoked by $exe_file."
else
  echo "No such process running."
fi  


#  This elaborate script can *almost* be replaced by
#       ps ax | grep $1 | awk '{ print $5 }'
#  However, this will not work...
#+ because the fifth field of 'ps' is argv[0] of the process,
#+ not the executable file path.
#
# However, either of the following would work.
#       find /proc/$1/exe -printf '%l\n'
#       lsof -aFn -p $1 -d txt | sed -ne 's/^n//p'

# Additional commentary by Stephane Chazelas.

exit 0
</programlisting>
	    </example>

	    <example xml:id="constat">
	      <title>On-line connect status</title>
	      <programlisting>#!/bin/bash
# connect-stat.sh
#  Note that this script may need modification
#+ to work with a wireless connection.

PROCNAME=pppd        # ppp daemon
PROCFILENAME=status  # Where to look.
NOTCONNECTED=85
INTERVAL=2           # Update every 2 seconds.

pidno=$( ps ax | grep -v "ps ax" | grep -v grep | grep $PROCNAME |
awk '{ print $1 }' )

# Finding the process number of 'pppd', the 'ppp daemon'.
# Have to filter out the process lines generated by the search itself.
#
#  However, as Oleg Philon points out,
#+ this could have been considerably simplified by using "pidof".
#  pidno=$( pidof $PROCNAME )
#
#  Moral of the story:
#+ When a command sequence gets too complex, look for a shortcut.


if [ -z "$pidno" ]   # If no pid, then process is not running.
then
  echo "Not connected."
# exit $NOTCONNECTED
else
  echo "Connected."; echo
fi

while [ true ]       # Endless loop, script can be improved here.
do

  if [ ! -e "/proc/$pidno/$PROCFILENAME" ]
  # While process running, then "status" file exists.
  then
    echo "Disconnected."
#   exit $NOTCONNECTED
  fi

netstat -s | grep "packets received"  # Get some connect statistics.
netstat -s | grep "packets delivered"


  sleep $INTERVAL
  echo; echo

done

exit 0

# As it stands, this script must be terminated with a Control-C.

#    Exercises:
#    ---------
#    Improve the script so it exits on a "q" keystroke.
#    Make the script more user-friendly in other ways.
#    Fix the script to work with wireless/DSL connections.
</programlisting>
	    </example>


       <para><anchor xml:id="procwarning" /></para>
       <warning><para>In general, it is dangerous to
	 <emphasis>write</emphasis> to the files in <filename class="directory">/proc</filename>, as this can corrupt the
	 filesystem or crash the machine.</para></warning>

      </section> <!-- /proc -->

  </chapter> <!-- /dev and /proc -->

  <chapter xml:id="networkprogramming">
    <title>Network Programming</title>

    <epigraph>
	    <para>The Net's a cross between an elephant and a white
	      elephant sale: it never forgets, and it's always crap.</para>
            <para>--Nemo</para>
    </epigraph>

    <para>A Linux system has quite a number of tools for accessing,
      manipulating, and troubleshooting network connections. We can
      incorporate some of these tools into scripts -- scripts that
      expand our knowledge of networking, useful scripts that can
      facilitate the administration of a network.</para>

    <para><anchor xml:id="cgiscript" />Here is a simple CGI
      script that demonstrates connecting to a remote server.</para>

           <example xml:id="testcgi">
             <title>Print the server environment</title>
               <programlisting>#!/bin/bash
# test-cgi.sh
# by Michael Zick
# Used with permission

# May have to change the location for your site.
# (At the ISP's servers, Bash may not be in the usual place.)
# Other places: /usr/bin or /usr/local/bin
# Might even try it without any path in sha-bang.

# Disable filename globbing.
set -f

# Header tells browser what to expect.
echo Content-type: text/plain
echo

echo CGI/1.0 test script report:
echo

echo environment settings:
set
echo

echo whereis bash?
whereis bash
echo


echo who are we?
echo ${BASH_VERSINFO[*]}
echo

echo argc is $#. argv is "$*".
echo

# CGI/1.0 expected environment variables.

echo SERVER_SOFTWARE = $SERVER_SOFTWARE
echo SERVER_NAME = $SERVER_NAME
echo GATEWAY_INTERFACE = $GATEWAY_INTERFACE
echo SERVER_PROTOCOL = $SERVER_PROTOCOL
echo SERVER_PORT = $SERVER_PORT
echo REQUEST_METHOD = $REQUEST_METHOD
echo HTTP_ACCEPT = "$HTTP_ACCEPT"
echo PATH_INFO = "$PATH_INFO"
echo PATH_TRANSLATED = "$PATH_TRANSLATED"
echo SCRIPT_NAME = "$SCRIPT_NAME"
echo QUERY_STRING = "$QUERY_STRING"
echo REMOTE_HOST = $REMOTE_HOST
echo REMOTE_ADDR = $REMOTE_ADDR
echo REMOTE_USER = $REMOTE_USER
echo AUTH_TYPE = $AUTH_TYPE
echo CONTENT_TYPE = $CONTENT_TYPE
echo CONTENT_LENGTH = $CONTENT_LENGTH

exit 0

# Here document to give short instructions.
:&lt;&lt;-'_test_CGI_'

1) Drop this in your http://domain.name/cgi-bin directory.
2) Then, open http://domain.name/cgi-bin/test-cgi.sh.

_test_CGI_
</programlisting>
           </example>

    <para>For security purposes, it may be helpful to identify the IP
      addresses a computer is accessing.</para>

    <para><anchor xml:id="iptables02" /></para>

	    <example xml:id="ipaddresses">
              <title>IP addresses</title>
	      <programlisting>#!/bin/bash
# ip-addresses.sh
# List the IP addresses your computer is connected to.

#  Inspired by Greg Bledsoe's ddos.sh script,
#  Linux Journal, 09 March 2011.
#    URL:
#  http://www.linuxjournal.com/content/back-dead-simple-bash-complex-ddos
#  Greg licensed his script under the GPL2,
#+ and as a derivative, this script is likewise GPL2.

connection_type=TCP      # Also try UDP.
field=2           # Which field of the output we're interested in.
no_match=LISTEN   # Filter out records containing this. Why?
lsof_args=-ni     # -i lists Internet-associated files.
                  # -n preserves numerical IP addresses.
		  # What happens without the -n option? Try it.
router="[0-9][0-9][0-9][0-9][0-9]-&gt;"
#       Delete the router info.

lsof "$lsof_args" | grep $connection_type | grep -v "$no_match" |
      awk '{print $9}' | cut -d : -f $field | sort | uniq |
      sed s/"^$router"//

#  Bledsoe's script assigns the output of a filtered IP list,
#  (similar to lines 19-22, above) to a variable.
#  He checks for multiple connections to a single IP address,
#  then uses:
#
#    iptables -I INPUT -s $ip -p tcp -j REJECT --reject-with tcp-reset
#
#  ... within a 60-second delay loop to bounce packets from DDOS attacks.


#  Exercise:
#  --------
#  Use the 'iptables' command to extend this script
#+ to reject connection attempts from well-known spammer IP domains.
</programlisting>
	    </example>

     <para>More examples of network programming:
       <orderedlist>
         <listitem><para><link linkend="npref">Getting the time from
           <firstterm>nist.gov</firstterm></link></para></listitem>
	 <listitem><para><link linkend="nw001">Downloading a
           URL</link></para></listitem>
	 <listitem><para><link linkend="ipscript0">A GRE
	   tunnel</link></para></listitem>
	 <listitem><para><link linkend="ping0">Checking
	   if an Internet server is up</link></para></listitem>
         <listitem><para><xref linkend="isspammer" /></para></listitem>
         <listitem><para><xref linkend="isspammer2" /></para></listitem>
         <listitem><para><xref linkend="whx" /></para></listitem>
         <listitem><para><xref linkend="devtcp" /></para></listitem>
       </orderedlist>
     </para>  

     <para>See also the <link linkend="networksys1">networking commands</link>
       in the <link linkend="system">System and
       Administrative Commands</link> chapter and the <link linkend="communications">communications commands</link> in
       the <link linkend="external">External Filters, Programs and
       Commands</link> chapter.</para>


  </chapter> <!-- Network Programing -->
    

  <chapter xml:id="zeros">
    <title>Of Zeros and Nulls</title>

    <epigraph>
      <para>Faultily faultless, icily regular, splendidly null</para>
      <para>Dead perfection; no more.</para>
      <para>--Alfred Lord Tennyson</para>
    </epigraph>

      <para><anchor xml:id="zerosref" /></para>

      <variablelist xml:id="zeronull">
        <title><anchor xml:id="zeronull1" /><filename>/dev/zero</filename>
          ... <filename>/dev/null</filename></title>
	<varlistentry>
	  <term><anchor id="devnullref" />Uses of
	    <filename moreinfo="none">/dev/null</filename></term>
	  <listitem>
	    <para>Think of <filename>/dev/null</filename> as a <firstterm>black
		hole</firstterm>. It is essentially the equivalent of
		a write-only file. Everything written to it disappears.
		Attempts to read or output from it result in nothing. All
		the same, <filename>/dev/null</filename> can be quite
		useful from both the command-line and in scripts.</para>

	    <para>Suppressing <filename>stdout</filename>.
	      <programlisting>cat $filename &gt;/dev/null
# Contents of the file will not list to stdout.</programlisting>
            </para>

	    <para>Suppressing <filename>stderr</filename>
	      (from <xref linkend="ex57" />).
	      <programlisting>rm $badname 2&gt;/dev/null
#           So error messages [stderr] deep-sixed.</programlisting>
	    </para>

	    <para>Suppressing output from <emphasis>both</emphasis>
	      <filename>stdout</filename> and <filename>stderr</filename>.
	      <programlisting>cat $filename 2&gt;/dev/null &gt;/dev/null
# If "$filename" does not exist, there will be no error message output.
# If "$filename" does exist, the contents of the file will not list to stdout.
# Therefore, no output at all will result from the above line of code.
#
#  This can be useful in situations where the return code from a command
#+ needs to be tested, but no output is desired.
#
# cat $filename &amp;&gt;/dev/null
#     also works, as Baris Cicek points out.</programlisting>
	    </para>

	    <para>Deleting contents of a file, but preserving the file itself, with
	      all attendant permissions (from <xref linkend="ex1" /> and <xref linkend="ex2" />):
	      <programlisting>cat /dev/null &gt; /var/log/messages
#  : &gt; /var/log/messages   has same effect, but does not spawn a new process.

cat /dev/null &gt; /var/log/wtmp</programlisting>
	      </para>

	    <para>Automatically emptying the contents of a logfile
	      (especially good for dealing with those nasty
	      <quote>cookies</quote> sent by commercial Web sites):</para>

	    <example xml:id="cookies">  
	      <title>Hiding the cookie jar</title>
	      <programlisting># Obsolete Netscape browser.
# Same principle applies to newer browsers.

if [ -f ~/.netscape/cookies ]  # Remove, if exists.
then
  rm -f ~/.netscape/cookies
fi

ln -s /dev/null ~/.netscape/cookies
# All cookies now get sent to a black hole, rather than saved to disk.</programlisting>
            </example> 

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="zerosref1" />Uses of <filename moreinfo="none">/dev/zero</filename></term>
	  <listitem>
	    <para>Like <filename>/dev/null</filename>,
	      <filename>/dev/zero</filename> is a pseudo-device file, but
	      it actually produces a stream of nulls
	      (<emphasis>binary</emphasis> zeros, not the <link linkend="asciidef">ASCII</link> kind). Output written
	      to <filename>/dev/zero</filename> disappears, and it is
	      fairly difficult to actually read the nulls emitted there,
	      though it can be done with <link linkend="odref">od</link>
	      or a hex editor. <anchor xml:id="swapfileref" />The chief use of
	      <filename>/dev/zero</filename> is creating an initialized
	      dummy file of predetermined length intended as a temporary
	      swap file.</para>

	    <example xml:id="ex73">
	      <title>Setting up a swapfile using <filename>/dev/zero</filename></title>
	      <programlisting>#!/bin/bash
# Creating a swap file.

#  A swap file provides a temporary storage cache
#+ which helps speed up certain filesystem operations.

ROOT_UID=0         # Root has $UID 0.
E_WRONG_USER=85    # Not root?

FILE=/swap
BLOCKSIZE=1024
MINBLOCKS=40
SUCCESS=0


# This script must be run as root.
if [ "$UID" -ne "$ROOT_UID" ]
then
  echo; echo "You must be root to run this script."; echo
  exit $E_WRONG_USER
fi  
  

blocks=${1:-$MINBLOCKS}          #  Set to default of 40 blocks,
                                 #+ if nothing specified on command-line.
# This is the equivalent of the command block below.
# --------------------------------------------------
# if [ -n "$1" ]
# then
#   blocks=$1
# else
#   blocks=$MINBLOCKS
# fi
# --------------------------------------------------


if [ "$blocks" -lt $MINBLOCKS ]
then
  blocks=$MINBLOCKS              # Must be at least 40 blocks long.
fi  


######################################################################
echo "Creating swap file of size $blocks blocks (KB)."
dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks  # Zero out file.
mkswap $FILE $blocks             # Designate it a swap file.
swapon $FILE                     # Activate swap file.
retcode=$?                       # Everything worked?
#  Note that if one or more of these commands fails,
#+ then it could cause nasty problems.
######################################################################

#  Exercise:
#  Rewrite the above block of code so that if it does not execute
#+ successfully, then:
#    1) an error message is echoed to stderr,
#    2) all temporary files are cleaned up, and
#    3) the script exits in an orderly fashion with an
#+      appropriate error code.

echo "Swap file created and activated."

exit $retcode
</programlisting>
	    </example>

	    <para>Another application of <filename>/dev/zero</filename>
	      is to <quote>zero out</quote> a file of a designated
	      size for a special purpose, such as mounting a filesystem
	      on a <link linkend="loopbackref">loopback device</link>
	      (see <xref linkend="createfs" />) or <quote>securely</quote>
	      deleting a file (see <xref linkend="blotout" />).</para>

	    <example xml:id="ramdisk">
	      <title>Creating a ramdisk</title>
	      <programlisting>#!/bin/bash
# ramdisk.sh

#  A "ramdisk" is a segment of system RAM memory
#+ which acts as if it were a filesystem.
#  Its advantage is very fast access (read/write time).
#  Disadvantages: volatility, loss of data on reboot or powerdown,
#+                less RAM available to system.
#
#  Of what use is a ramdisk?
#  Keeping a large dataset, such as a table or dictionary on ramdisk,
#+ speeds up data lookup, since memory access is much faster than disk access.


E_NON_ROOT_USER=70             # Must run as root.
ROOTUSER_NAME=root

MOUNTPT=/mnt/ramdisk           # Create with mkdir /mnt/ramdisk.
SIZE=2000                      # 2K blocks (change as appropriate)
BLOCKSIZE=1024                 # 1K (1024 byte) block size
DEVICE=/dev/ram0               # First ram device

username=`id -nu`
if [ "$username" != "$ROOTUSER_NAME" ]
then
  echo "Must be root to run \"`basename $0`\"."
  exit $E_NON_ROOT_USER
fi

if [ ! -d "$MOUNTPT" ]         #  Test whether mount point already there,
then                           #+ so no error if this script is run
  mkdir $MOUNTPT               #+ multiple times.
fi

##############################################################################
dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE  # Zero out RAM device.
                                                      # Why is this necessary?
mke2fs $DEVICE                 # Create an ext2 filesystem on it.
mount $DEVICE $MOUNTPT         # Mount it.
chmod 777 $MOUNTPT             # Enables ordinary user to access ramdisk.
                               # However, must be root to unmount it.
##############################################################################
# Need to test whether above commands succeed. Could cause problems otherwise.
# Exercise: modify this script to make it safer.

echo "\"$MOUNTPT\" now available for use."
# The ramdisk is now accessible for storing files, even by an ordinary user.

#  Caution, the ramdisk is volatile, and its contents will disappear
#+ on reboot or power loss.
#  Copy anything you want saved to a regular directory.

# After reboot, run this script to again set up ramdisk.
# Remounting /mnt/ramdisk without the other steps will not work.

#  Suitably modified, this script can by invoked in /etc/rc.d/rc.local,
#+ to set up ramdisk automatically at bootup.
#  That may be appropriate on, for example, a database server.

exit 0
</programlisting>
	    </example>

	    <para>In addition to all the above,
	      <filename>/dev/zero</filename> is needed by ELF
	      (<firstterm>Executable and Linking Format</firstterm>)
	      UNIX/Linux binaries.</para>

	  </listitem>
	</varlistentry>

      </variablelist>

  </chapter> <!-- Zeros and Nulls -->



  <chapter xml:id="debugging">
    <title>Debugging</title>

    <epigraph>
      <para>Debugging is twice as hard as writing the code in the first
        place. Therefore, if you write the code as cleverly as possible,
        you are, by definition, not smart enough to debug it.</para>
      <para>--Brian Kernighan</para>
    </epigraph>

      <para>The Bash shell contains no built-in debugger, and only bare-bones
	debugging-specific commands and constructs. Syntax errors or
	outright typos in the script generate cryptic error messages that
	are often of no help in debugging a non-functional script.</para>

      <example xml:id="ex74">
	<title>A buggy script</title>
	<programlisting>#!/bin/bash
# ex74.sh

# This is a buggy script.
# Where, oh where is the error?

a=37

if [$a -gt 27 ]
then
  echo $a
fi  

exit $?   # 0! Why?
</programlisting>
      </example>

      <para>Output from script:
	<screen><computeroutput>./ex74.sh: [37: command not found</computeroutput></screen>
        What's wrong with the above script? Hint: after the
        <firstterm>if</firstterm>.</para>

      <example xml:id="missingkeyword">
	<title>Missing <link linkend="keywordref">keyword</link></title>
	<programlisting>#!/bin/bash
# missing-keyword.sh
# What error message will this script generate? And why?

for a in 1 2 3
do
  echo "$a"
# done     # Required keyword 'done' commented out in line 8.

exit 0     # Will not exit here!

# === #

# From command line, after script terminates:
  echo $?    # 2
</programlisting>
      </example>

      <para>Output from script:
	<screen>
<computeroutput>missing-keyword.sh: line 10: syntax error: unexpected end of file</computeroutput>
	</screen>
	Note that the error message does <emphasis>not</emphasis> necessarily
	reference the line in which the error occurs, but the line where the
	Bash interpreter finally becomes aware of the error.
	</para>

      <para>Error messages may disregard comment lines in a script when
        reporting the line number of a syntax error.</para>

      <para>What if the script executes, but does not work as expected? This is the
	all too familiar logic error.</para>

      <example xml:id="ex75">
	<title><firstterm>test24</firstterm>: another buggy script</title>
	<programlisting>#!/bin/bash

#  This script is supposed to delete all filenames in current directory
#+ containing embedded spaces.
#  It doesn't work.
#  Why not?


badname=`ls | grep ' '`

# Try this:
# echo "$badname"

rm "$badname"

exit 0
</programlisting>
      </example>

      <para>Try to find out what's wrong with <xref linkend="ex75" />
	by uncommenting the <userinput>echo "$badname"</userinput> line. Echo
	statements are useful for seeing whether what you expect is
	actually what you get.</para>

      <para>In this particular case, <userinput>rm "$badname"</userinput>
	will not give the desired results because
	<varname>$badname</varname> should not be quoted. Placing it
	in quotes ensures that <command>rm</command> has only one
	argument (it will match only one filename). A partial fix
	is to remove to quotes from <varname>$badname</varname> and
	to reset <varname>$IFS</varname> to contain only a newline,
	<userinput>IFS=$'\n'</userinput>. However, there are simpler
	ways of going about it.
	<programlisting># Correct methods of deleting filenames containing spaces.
rm *\ *
rm *" "*
rm *' '*
# Thank you. S.C.</programlisting>
	
	</para>

      <para>Summarizing the symptoms of a buggy script,
	<orderedlist>
	  <listitem>
	    <para>It bombs with a <quote><errorname>syntax error</errorname></quote> message, or</para>
	  </listitem>
	  <listitem>
	    <para>It runs, but does not work as expected 
	      (<errorname>logic error</errorname>).</para> 
	  </listitem>
	  <listitem>
	    <para>It runs, works as expected, but has nasty side effects
	      (<errorname>logic bomb</errorname>).</para> 
	  </listitem>
	</orderedlist>
      </para>
	
      <para><anchor xml:id="debugtools" /></para>
      <para>Tools for debugging non-working scripts include
	<orderedlist>
	  <listitem>

	    <para>Inserting <link linkend="echoref">echo</link>
	      statements at critical points in the script to trace the
	      variables, and otherwise give a snapshot of what is going
	      on.</para>

            <tip>
	    <para>Even better is an <command>echo</command> that echoes
	      only when <firstterm>debug</firstterm> is on.</para>

	    <para><programlisting>### debecho (debug-echo), by Stefano Falsetto ###
### Will echo passed parameters only if DEBUG is set to a value. ###
debecho () {
  if [ ! -z "$DEBUG" ]; then
     echo "$1" &gt;&amp;2
     #         ^^^ to stderr
  fi
}

DEBUG=on
Whatever=whatnot
debecho $Whatever   # whatnot

DEBUG=
Whatever=notwhat
debecho $Whatever   # (Will not echo.)</programlisting></para>

	    </tip>

	  </listitem>
	  <listitem>
	    <para>Using the <link linkend="teeref">tee</link> filter
	      to check processes or data flows at critical points.</para>
	  </listitem>
	  <listitem>
	    <para>Setting option flags <option>-n -v -x</option></para>

	    <para><userinput>sh -n scriptname</userinput> checks for
	      syntax errors without actually running the script. This is
	      the equivalent of inserting <userinput>set -n</userinput> or
	      <userinput>set -o noexec</userinput> into the script. Note
	      that certain types of syntax errors can slip past this
	      check.</para>

	    <para><userinput>sh -v scriptname</userinput> echoes each
	      command before executing it. This is the equivalent of
	      inserting <userinput>set -v</userinput> or <userinput>set
	      -o verbose</userinput> in the script.</para>
	    
	    <para>The <option>-n</option> and <option>-v</option>
	      flags work well together. <userinput>sh -nv
	      scriptname</userinput> gives a verbose syntax check.</para>

	    <para><userinput>sh -x scriptname</userinput> echoes the result each
	      command, but in an abbreviated manner. This is the equivalent of
	      inserting <userinput>set -x</userinput> or 
	      <userinput>set -o xtrace</userinput> in the script.</para>

	    <para><anchor xml:id="undvarerr" /></para>
	    <para>Inserting <userinput>set -u</userinput> or 
		<userinput>set -o nounset</userinput> in the script runs it, but
		gives an <errorname>unbound variable</errorname> error message
		and aborts the script.
		<programlisting>set -u   # Or   set -o nounset

# Setting a variable to null will not trigger the error/abort.
# unset_var=

echo $unset_var   # Unset (and undeclared) variable.

echo "Should not echo!"

# sh t2.sh
# t2.sh: line 6: unset_var: unbound variable</programlisting></para>
	  </listitem>

	  <listitem>
	    
	    <para>Using an <quote>assert</quote> function to test a
	      variable or condition at critical points in a script. (This is
	      an idea borrowed from C.)</para>

	    <example xml:id="assert">
	      <title>Testing a condition with an
	      <firstterm>assert</firstterm></title>
	      <programlisting>#!/bin/bash
# assert.sh

#######################################################################
assert ()                 #  If condition false,
{                         #+ exit from script
                          #+ with appropriate error message.
  E_PARAM_ERR=98
  E_ASSERT_FAILED=99


  if [ -z "$2" ]          #  Not enough parameters passed
  then                    #+ to assert() function.
    return $E_PARAM_ERR   #  No damage done.
  fi

  lineno=$2

  if [ ! $1 ] 
  then
    echo "Assertion failed:  \"$1\""
    echo "File \"$0\", line $lineno"    # Give name of file and line number.
    exit $E_ASSERT_FAILED
  # else
  #   return
  #   and continue executing the script.
  fi  
} # Insert a similar assert() function into a script you need to debug.    
#######################################################################


a=5
b=4
condition="$a -lt $b"     #  Error message and exit from script.
                          #  Try setting "condition" to something else
                          #+ and see what happens.

assert "$condition" $LINENO
# The remainder of the script executes only if the "assert" does not fail.


# Some commands.
# Some more commands . . .
echo "This statement echoes only if the \"assert\" does not fail."
# . . .
# More commands . . .

exit $?
</programlisting>
	    </example>	    

	  </listitem>

	  <listitem>

	    <para>Using the <link linkend="linenoref">$LINENO</link>
	      variable and the <link linkend="callerref">caller</link>
	      builtin.</para>

	  </listitem>


	  <listitem>

	    <para><anchor xml:id="debugtrap" />Trapping at exit.</para>

	<para>The <link linkend="exitref">exit</link> command in a script
	      triggers a signal <returnvalue>0</returnvalue>, terminating
	      the process, that is, the script itself.

	      <footnote><para>By convention, <replaceable>signal
		0</replaceable> is assigned to <link linkend="exitcommandref">exit</link>.  </para></footnote>

	      It is often useful to trap the
	      <firstterm>exit</firstterm>, forcing a <quote>printout</quote>
	      of variables, for example. The <firstterm>trap</firstterm>
	      must be the first command in the script.</para>

	  </listitem>
	</orderedlist>
      </para>

	<variablelist xml:id="trapref">
	  <title><anchor xml:id="trapref1" />Trapping signals</title>

	  <varlistentry>
	    <term><command moreinfo="none">trap</command></term>
	    <listitem>
	      <para>Specifies an action on receipt of a
	        signal; also useful for debugging.</para>

	      <para><anchor xml:id="signald" /></para>
	      <sidebar>
		<para>A <firstterm>signal</firstterm> is a message
		sent to a process, either by the kernel or another
		process, telling it to take some specified action
		(usually to terminate).  For example, hitting a
		<link linkend="ctlcref">Control-C</link>
		sends a user interrupt, an INT signal, to a running
		program.</para></sidebar>

		<para><emphasis>A simple instance:</emphasis>
		  <programlisting>trap '' 2
# Ignore interrupt 2 (Control-C), with no action specified. 

trap 'echo "Control-C disabled."' 2
# Message when Control-C pressed.</programlisting>
	      </para>

	    </listitem>
	  </varlistentry>
	</variablelist>

      <example xml:id="ex76">
	<title>Trapping at exit</title>
	<programlisting>#!/bin/bash
# Hunting variables with a trap.

trap 'echo Variable Listing --- a = $a  b = $b' EXIT
#  EXIT is the name of the signal generated upon exit from a script.
#
#  The command specified by the "trap" doesn't execute until
#+ the appropriate signal is sent.

echo "This prints before the \"trap\" --"
echo "even though the script sees the \"trap\" first."
echo

a=39

b=36

exit 0
#  Note that commenting out the 'exit' command makes no difference,
#+ since the script exits in any case after running out of commands.
</programlisting>
      </example>
	
      <example xml:id="online">
	<title>Cleaning up after <keycap>Control-C</keycap></title>
	<programlisting>#!/bin/bash
# logon.sh: A quick 'n dirty script to check whether you are on-line yet.

umask 177  # Make sure temp files are not world readable.


TRUE=1
LOGFILE=/var/log/messages
#  Note that $LOGFILE must be readable
#+ (as root, chmod 644 /var/log/messages).
TEMPFILE=temp.$$
#  Create a "unique" temp file name, using process id of the script.
#     Using 'mktemp' is an alternative.
#     For example:
#     TEMPFILE=`mktemp temp.XXXXXX`
KEYWORD=address
#  At logon, the line "remote IP address xxx.xxx.xxx.xxx"
#                      appended to /var/log/messages.
ONLINE=22
USER_INTERRUPT=13
CHECK_LINES=100
#  How many lines in log file to check.

trap 'rm -f $TEMPFILE; exit $USER_INTERRUPT' TERM INT
#  Cleans up the temp file if script interrupted by control-c.

echo

while [ $TRUE ]  #Endless loop.
do
  tail -n $CHECK_LINES $LOGFILE&gt; $TEMPFILE
  #  Saves last 100 lines of system log file as temp file.
  #  Necessary, since newer kernels generate many log messages at log on.
  search=`grep $KEYWORD $TEMPFILE`
  #  Checks for presence of the "IP address" phrase,
  #+ indicating a successful logon.

  if [ ! -z "$search" ] #  Quotes necessary because of possible spaces.
  then
     echo "On-line"
     rm -f $TEMPFILE    #  Clean up temp file.
     exit $ONLINE
  else
     echo -n "."        #  The -n option to echo suppresses newline,
                        #+ so you get continuous rows of dots.
  fi

  sleep 1  
done  


#  Note: if you change the KEYWORD variable to "Exit",
#+ this script can be used while on-line
#+ to check for an unexpected logoff.

# Exercise: Change the script, per the above note,
#           and prettify it.

exit 0


# Nick Drage suggests an alternate method:

while true
  do ifconfig ppp0 | grep UP 1&gt; /dev/null &amp;&amp; echo "connected" &amp;&amp; exit 0
  echo -n "."   # Prints dots (.....) until connected.
  sleep 2
done

# Problem: Hitting Control-C to terminate this process may be insufficient.
#+         (Dots may keep on echoing.)
# Exercise: Fix this.



# Stephane Chazelas has yet another alternative:

CHECK_INTERVAL=1

while ! tail -n 1 "$LOGFILE" | grep -q "$KEYWORD"
do echo -n .
   sleep $CHECK_INTERVAL
done
echo "On-line"

# Exercise: Discuss the relative strengths and weaknesses
#           of each of these various approaches.
</programlisting>
      </example>

     <example xml:id="progressbar2">
	<title>A Simple Implementation of a Progress Bar</title>
     <programlisting>#! /bin/bash
# progress-bar2.sh
# Author: Graham Ewart (with reformatting by ABS Guide author).
# Used in ABS Guide with permission (thanks!).

# Invoke this script with bash. It doesn't work with sh.

interval=1
long_interval=10

{
     trap "exit" SIGUSR1
     sleep $interval; sleep $interval
     while true
     do
       echo -n '.'     # Use dots.
       sleep $interval
     done; } &amp;         # Start a progress bar as a background process.

pid=$!
trap "echo !; kill -USR1 $pid; wait $pid"  EXIT        # To handle ^C.

echo -n 'Long-running process '
sleep $long_interval
echo ' Finished!'

kill -USR1 $pid
wait $pid              # Stop the progress bar.
trap EXIT

exit $?
</programlisting>
     </example>

      <note>
      <para>The <option>DEBUG</option> argument to
	<command>trap</command> causes a specified action to execute
	after every command in a script. This permits tracing variables,
	for example.

      <example xml:id="vartrace">
	<title>Tracing a variable</title>
	<programlisting>#!/bin/bash

trap 'echo "VARIABLE-TRACE&gt; \$variable = \"$variable\""' DEBUG
# Echoes the value of $variable after every command.

variable=29; line=$LINENO

echo "  Just initialized \$variable to $variable in line number $line."

let "variable *= 3"; line=$LINENO
echo "  Just multiplied \$variable by 3 in line number $line."

exit 0

#  The "trap 'command1 . . . command2 . . .' DEBUG" construct is
#+ more appropriate in the context of a complex script,
#+ where inserting multiple "echo $variable" statements might be
#+ awkward and time-consuming.

# Thanks, Stephane Chazelas for the pointer.


Output of script:

VARIABLE-TRACE&gt; $variable = ""
VARIABLE-TRACE&gt; $variable = "29"
  Just initialized $variable to 29.
VARIABLE-TRACE&gt; $variable = "29"
VARIABLE-TRACE&gt; $variable = "87"
  Just multiplied $variable by 3.
VARIABLE-TRACE&gt; $variable = "87"
</programlisting>
      </example>

      </para>
      </note>


      <para>Of course, the <command>trap</command> command has other uses
        aside from debugging, such as disabling certain keystrokes within a
	script (see <xref linkend="stopwatch" />).</para>

      <example xml:id="multipleproc">
	<title>Running multiple processes (on an SMP box)</title>
	<programlisting>#!/bin/bash
# parent.sh
# Running multiple processes on an SMP box.
# Author: Tedman Eng

#  This is the first of two scripts,
#+ both of which must be present in the current working directory.




LIMIT=$1         # Total number of process to start
NUMPROC=4        # Number of concurrent threads (forks?)
PROCID=1         # Starting Process ID
echo "My PID is $$"

function start_thread() {
        if [ $PROCID -le $LIMIT ] ; then
                ./child.sh $PROCID&amp;
                let "PROCID++"
        else
           echo "Limit reached."
           wait
           exit
        fi
}

while [ "$NUMPROC" -gt 0 ]; do
        start_thread;
        let "NUMPROC--"
done


while true
do

trap "start_thread" SIGRTMIN

done

exit 0



# ======== Second script follows ========


#!/bin/bash
# child.sh
# Running multiple processes on an SMP box.
# This script is called by parent.sh.
# Author: Tedman Eng

temp=$RANDOM
index=$1
shift
let "temp %= 5"
let "temp += 4"
echo "Starting $index  Time:$temp" "$@"
sleep ${temp}
echo "Ending $index"
kill -s SIGRTMIN $PPID

exit 0


# ======================= SCRIPT AUTHOR'S NOTES ======================= #
#  It's not completely bug free.
#  I ran it with limit = 500 and after the first few hundred iterations,
#+ one of the concurrent threads disappeared!
#  Not sure if this is collisions from trap signals or something else.
#  Once the trap is received, there's a brief moment while executing the
#+ trap handler but before the next trap is set.  During this time, it may
#+ be possible to miss a trap signal, thus miss spawning a child process.

#  No doubt someone may spot the bug and will be writing 
#+ . . . in the future.



# ===================================================================== #



# ----------------------------------------------------------------------#



#################################################################
# The following is the original script written by Vernia Damiano.
# Unfortunately, it doesn't work properly.
#################################################################

#!/bin/bash

#  Must call script with at least one integer parameter
#+ (number of concurrent processes).
#  All other parameters are passed through to the processes started.


INDICE=8        # Total number of process to start
TEMPO=5         # Maximum sleep time per process
E_BADARGS=65    # No arg(s) passed to script.

if [ $# -eq 0 ] # Check for at least one argument passed to script.
then
  echo "Usage: `basename $0` number_of_processes [passed params]"
  exit $E_BADARGS
fi

NUMPROC=$1              # Number of concurrent process
shift
PARAMETRI=( "$@" )      # Parameters of each process

function avvia() {
         local temp
         local index
         temp=$RANDOM
         index=$1
         shift
         let "temp %= $TEMPO"
         let "temp += 1"
         echo "Starting $index Time:$temp" "$@"
         sleep ${temp}
         echo "Ending $index"
         kill -s SIGRTMIN $$
}

function parti() {
         if [ $INDICE -gt 0 ] ; then
              avvia $INDICE "${PARAMETRI[@]}" &amp;
                let "INDICE--"
         else
                trap : SIGRTMIN
         fi
}

trap parti SIGRTMIN

while [ "$NUMPROC" -gt 0 ]; do
         parti;
         let "NUMPROC--"
done

wait
trap - SIGRTMIN

exit $?

: &lt;&lt;SCRIPT_AUTHOR_COMMENTS
I had the need to run a program, with specified options, on a number of
different files, using a SMP machine. So I thought [I'd] keep running
a specified number of processes and start a new one each time . . . one
of these terminates.

The "wait" instruction does not help, since it waits for a given process
or *all* process started in background. So I wrote [this] bash script
that can do the job, using the "trap" instruction.
  --Vernia Damiano
SCRIPT_AUTHOR_COMMENTS
</programlisting>
      </example>


      <note><para><userinput>trap '' SIGNAL</userinput> (two adjacent
	apostrophes) disables SIGNAL for the remainder of the
	script. <userinput>trap SIGNAL</userinput> restores
	the functioning of SIGNAL once more. This is useful to
	protect a critical portion of a script from an undesirable
	interrupt.</para></note>

	<para><programlisting>
	trap '' 2  # Signal 2 is Control-C, now disabled.
	command
	command
	command
	trap 2     # Reenables Control-C
	</programlisting></para>

      <sidebar>
        <para><link linkend="bash3ref">Version 3</link> of Bash adds the
	  following <link linkend="internalvariables1">internal
	  variables</link> for use by the debugger.

       <orderedlist>

         <listitem>
	   <para><varname>$BASH_ARGC</varname></para>
	   <para>Number of command-line arguments passed to script,
	     similar to <link linkend="clacountref"><varname>$#</varname></link>.</para>
	 </listitem>

         <listitem>
	   <para><varname>$BASH_ARGV</varname></para>
	   <para>Final command-line parameter passed to script, equivalent
	     <link linkend="lastargref"><varname>${!#}</varname></link>.</para>
	 </listitem>

         <listitem>
	   <para><varname>$BASH_COMMAND</varname></para>
	   <para>Command currently executing.</para>
	 </listitem>

         <listitem>
	   <para><varname>$BASH_EXECUTION_STRING</varname></para>
	   <para>The <firstterm>option string</firstterm> following the
	     <option>-c</option> <link linkend="clopts">option</link>
	     to Bash.</para>
	 </listitem>

         <listitem>
	   <para><varname>$BASH_LINENO</varname></para>
	   <para>In a <link linkend="functionref">function</link>,
	     indicates the line number of the function call.</para>
	</listitem>

         <listitem>
	   <para><varname>$BASH_REMATCH</varname></para>
	   <para>Array variable associated with <command>=~</command>
	   <link linkend="regexmatchref">conditional regex
	   matching</link>.</para>
	 </listitem>

         <listitem>
           <para><anchor xml:id="bashsourceref" /></para>
	   <para><varname>$BASH_SOURCE</varname></para>
	   <para>This is the name of the script, usually the same as
	     <link linkend="arg0">$0</link>.</para>
	 </listitem>

	 <listitem>
	   <para>
	 <link linkend="bashsubshellref"><varname>$BASH_SUBSHELL</varname></link></para>
	 </listitem>

       </orderedlist></para>
      </sidebar>

  </chapter> <!-- Debugging -->



  <chapter xml:id="options">
    <title>Options</title>

      <para><anchor xml:id="optionsref" /></para>

      <para>Options are settings that change shell and/or script
        behavior.</para> 
	
      <para>The <link linkend="setref">set</link> command
	enables options within a script. At the point in the script
	where you want the options to take effect, use <command>set
	-o option-name</command> or, in short form, <command>set
	-option-abbrev</command>. These two forms are equivalent.</para>

      <para><programlisting>
      #!/bin/bash

      set -o verbose
      # Echoes all commands before executing.
      </programlisting></para>

      <para><programlisting>
      #!/bin/bash

      set -v
      # Exact same effect as above.
      </programlisting></para>

      <note><para>To <firstterm>disable</firstterm> an option within a script,
	use <command>set +o option-name</command> or <command>set
	+option-abbrev</command>.</para></note>

      <para><programlisting>
      #!/bin/bash

      set -o verbose
      # Command echoing on.
      command
      ...
      command

      set +o verbose
      # Command echoing off.
      command
      # Not echoed.


      set -v
      # Command echoing on.
      command
      ...
      command

      set +v
      # Command echoing off.
      command

      exit 0
      </programlisting></para>


      <para>An alternate method of enabling options in a script is
	to specify them immediately following the
	<replaceable>#!</replaceable> script header.</para>

      <para><programlisting>
      #!/bin/bash -x
      #
      # Body of script follows.
      </programlisting></para>


      <para><anchor xml:id="invocationoptionsref" /></para>
      <para>It is also possible to enable script options from the command
	line. Some options that will not work with
	<command>set</command> are available this way. Among these
	are <replaceable>-i</replaceable>, force script to run
	interactive.</para>

      <para><userinput>bash -v script-name</userinput></para>
      
      <para><userinput>bash -o verbose script-name</userinput></para>


      <para>The following is a listing of some useful options. They may be
	specified in either abbreviated form (preceded by a single dash)
	or by complete name (preceded by a <emphasis>double</emphasis>
	dash or by <option>-o</option>).</para>

      <para><anchor xml:id="optionstable" /></para>

      <table>
	<title>Bash options</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Abbreviation</entry>
	      <entry>Name</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>-B</option></entry>
	      <entry>brace expansion</entry>
	      <entry><emphasis>Enable</emphasis>
                 <link linkend="braceexpref">brace
                 expansion</link> (default setting =
		 <emphasis>on</emphasis>)</entry>
	    </row>
	    <row>
	      <entry><option>+B</option></entry>
	      <entry>brace expansion</entry>
	      <entry><emphasis>Disable</emphasis>
                 brace expansion</entry>
	    </row>
	    <row>
	      <entry><anchor xml:id="noclobberref" /><option>-C</option></entry>
	      <entry>noclobber</entry>
	      <entry>Prevent overwriting of files by redirection (may be
		overridden by <token>&gt;|</token>)</entry> 
	    </row>
	    <row>
	      <entry><option>-D</option></entry>
	      <entry>(none)</entry>
	      <entry>List double-quoted strings prefixed by <token>$</token>,
	      but do not execute commands in script</entry>
	    </row>
	    <row>
	      <entry><option>-a</option></entry>
	      <entry>allexport</entry>
	      <entry>Export all defined variables</entry>
	    </row>
	    <row>
	      <entry><option>-b</option></entry>
	      <entry>notify</entry>
	      <entry>Notify when jobs running in background terminate (not of
	        much use in a script)</entry>
	    </row>
	    <row>
	      <entry><option>-c ...</option></entry>
	      <entry>(none)</entry>
	      <entry>Read commands from <command>...</command></entry>
	    </row>
	    <row>
	      <entry><option>checkjobs</option></entry>
	      <entry />
	      <entry>Informs user of any open <link linkend="jobsref">jobs</link> upon shell exit.
              Introduced in <link linkend="bash4ref">version 4</link>
	      of Bash, and still <quote>experimental.</quote>
              <emphasis>Usage:</emphasis> shopt -s checkjobs
	      (<emphasis>Caution:</emphasis> may hang!)</entry>
	    </row>
	    <row>
	      <entry><option>-e</option></entry>
	      <entry>errexit</entry>
	      <entry>Abort script at first error, when a command
		exits with non-zero status (except in <link linkend="untilloopref">until</link> or <link linkend="whileloopref">while loops</link>, <link linkend="testconstructs1">if-tests</link>, <link linkend="lcons1">list constructs</link>)</entry>
	    </row>
	    <row>
	      <entry><option>-f</option></entry>
	      <entry>noglob</entry>
	      <entry>Filename expansion (globbing) disabled</entry>
	    </row>
	    <row>
	      <entry><option>globstar</option></entry>
	      <entry><link linkend="globstarref"><firstterm>globbing</firstterm>
	        star-match</link></entry>
	      <entry>Enables the <token>**</token> <link linkend="globbingref">globbing</link> operator
               (<link linkend="bash4ref">version 4+</link> of Bash).
               <emphasis>Usage:</emphasis> shopt -s globstar</entry>
	    </row>
	    <row>
	      <entry><option>-i</option></entry>
	      <entry>interactive</entry>
	      <entry>Script runs in <firstterm>interactive</firstterm> mode</entry>
	    </row>
	    <row>
	      <entry><option>-n</option></entry>
	      <entry>noexec</entry>
	      <entry>Read commands in script, but do not execute them (syntax check)</entry>
	    </row>
	    <row>
	      <entry><option>-o Option-Name</option></entry>
	      <entry>(none)</entry>
	      <entry>Invoke the <firstterm>Option-Name</firstterm>
	        option</entry>
	    </row>
	    <row>
	      <entry><option>-o posix</option></entry>
	      <entry>POSIX</entry>
	      <entry>Change the behavior of Bash, or invoked script, to
		conform to <link linkend="posix2ref">POSIX</link>
		standard.</entry>
	    </row>
	    <row>
	      <entry><option>-o pipefail</option></entry>
	      <entry>pipe failure</entry>
	      <entry>Causes a pipeline to return the <link linkend="exitstatusref">exit status</link> of
	      the last command in the pipe that returned a non-zero
	      return value.</entry>
	    </row>
	    <row>
	      <entry><option>-p</option></entry>
	      <entry>privileged</entry>
	      <entry>Script runs as <quote>suid</quote> (caution!)</entry>
	    </row>
	    <row>
	      <entry><option>-r</option></entry>
	      <entry>restricted</entry>
	      <entry>Script runs in <firstterm>restricted</firstterm>
	      mode (see <xref linkend="restricted-sh" />).</entry>
	    </row>
	    <row>
	      <entry><option>-s</option></entry>
	      <entry>stdin</entry>
	      <entry>Read commands from <filename>stdin</filename></entry>
	    </row>
	    <row>
	      <entry><option>-t</option></entry>
	      <entry>(none)</entry>
	      <entry>Exit after first command</entry>
	    </row>
	    <row>
	      <entry><option>-u</option></entry>
	      <entry>nounset</entry>
	      <entry>Attempt to use undefined variable
		outputs error message, and forces an exit</entry>
	    </row>
	    <row>
	      <entry><option>-v</option></entry>
	      <entry>verbose</entry>
	      <entry>Print each command to <filename>stdout</filename> before executing it</entry>
	    </row>
	    <row>
	      <entry><option>-x</option></entry>
	      <entry>xtrace</entry>
	      <entry>Similar to <option>-v</option>, but expands commands</entry>
	    </row>
	    <row>
	      <entry><option>-</option></entry>
	      <entry>(none)</entry>
	      <entry>End of options flag. All other arguments
		are <link linkend="posparamref">positional
		parameters</link>.</entry>
	    </row>
	    <row>
	      <entry><option>--</option></entry>
	      <entry>(none)</entry>
	      <entry>Unset positional parameters.
		If arguments given (<parameter>-- arg1 arg2</parameter>),
		positional parameters set to arguments.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
  </chapter> <!-- Options -->


  
  <chapter xml:id="gotchas">
    <title>Gotchas</title>

    <epigraph>
      <para>Turandot: <foreignphrase>Gli enigmi sono tre, la morte
        una!</foreignphrase></para>
      <para>Caleph: <foreignphrase>No, no! Gli enigmi sono tre, una la
        vita!</foreignphrase></para>
      <para>--Puccini</para>
    </epigraph>

      <para><anchor xml:id="bash3gotcha" /></para>

      <para>Here are some (non-recommended!) scripting practices that
        will bring excitement into an otherwise dull life.</para>


      <itemizedlist>

	<listitem>
      <para><anchor xml:id="inappvn" /></para>

      <para>Assigning reserved words or characters to variable names.</para>

	<para>
	<programlisting>case=value0       # Causes problems.
23skidoo=value1   # Also problems.
# Variable names starting with a digit are reserved by the shell.
# Try _23skidoo=value1. Starting variables with an underscore is okay.

# However . . .   using just an underscore will not work.
_=25
echo $_           # $_ is a special variable set to last arg of last command.
# But . . .       _ is a valid function name!

xyz((!*=value2    # Causes severe problems.
# As of version 3 of Bash, periods are not allowed within variable names.</programlisting>
	</para>
	</listitem>

	<listitem>
      <para>Using a hyphen or other reserved characters in a variable name (or
        function name).</para>
	<para>
	<programlisting>var-1=23
# Use 'var_1' instead.

function-whatever ()   # Error
# Use 'function_whatever ()' instead.

 
# As of version 3 of Bash, periods are not allowed within function names.
function.whatever ()   # Error
# Use 'functionWhatever ()' instead.</programlisting>
      </para>
	</listitem>

	<listitem>
      <para>Using the same name for a variable and a function. This can make a
        script difficult to understand.</para>
      <para>
        <programlisting>do_something ()
{
  echo "This function does something with \"$1\"."
}

do_something=do_something

do_something do_something

# All this is legal, but highly confusing.</programlisting>
	</para>
	</listitem>



	<listitem>
      <para><anchor xml:id="wsbad" />Using <link linkend="whitespaceref">whitespace</link> inappropriately.
	In contrast to other programming languages, Bash can be quite
	finicky about whitespace.</para>

	<para>
	<programlisting>var1 = 23   # 'var1=23' is correct.
# On line above, Bash attempts to execute command "var1"
# with the arguments "=" and "23".
	
let c = $a - $b   # Instead:   let c=$a-$b   or   let "c = $a - $b"

if [ $a -le 5]    # if [ $a -le 5 ]   is correct.
#           ^^      if [ "$a" -le 5 ]   is even better.
                  # [[ $a -le 5 ]] also works.</programlisting>
	</para>
	</listitem>


	<listitem>
      <para><anchor xml:id="omitsemicolon" /></para>
      <para>Not terminating with a <link linkend="semicolonref">semicolon</link> the final command
        in a <link linkend="codeblockref">code block within curly
        brackets</link>.</para>
      <para>
        <programlisting>{ ls -l; df; echo "Done." }
# bash: syntax error: unexpected end of file

{ ls -l; df; echo "Done."; }
#                        ^     ### Final command needs semicolon.</programlisting>
      </para>
	</listitem>


	<listitem>
      <para><anchor xml:id="uninitvar" /></para>
      <para>
        Assuming uninitialized variables (variables before a value is
	assigned to them) are <quote>zeroed out</quote>. An
	uninitialized variable has a value of <firstterm>null</firstterm>,
	<emphasis>not</emphasis> zero.</para>

	<para><anchor xml:id="bash4.2-uninitialized" /></para>
      <para>
	   <programlisting>#!/bin/bash

echo "uninitialized_var = $uninitialized_var"
# uninitialized_var =

# However . . .
# if $BASH_VERSION  4.2; then

if [[ ! -v uninitialized_var ]]
then
  uninitialized_var=0   # Initialize it to zero!
fi


</programlisting>

      </para>
	</listitem>


	<listitem>
	<para><anchor xml:id="eqdif" /></para>
	<para>Mixing up <firstterm>=</firstterm> and
	  <firstterm>-eq</firstterm> in a test. Remember,
	  <firstterm>=</firstterm> is for comparing literal variables
	  and <firstterm>-eq</firstterm> for integers.</para>

      <para>
	<programlisting>if [ "$a" = 273 ]      # Is $a an integer or string?
if [ "$a" -eq 273 ]    # If $a is an integer.

# Sometimes you can interchange -eq and = without adverse consequences.
# However . . .


a=273.0   # Not an integer.
	   
if [ "$a" = 273 ]
then
  echo "Comparison works."
else  
  echo "Comparison does not work."
fi    # Comparison does not work.

# Same with   a=" 273"  and a="0273".


# Likewise, problems trying to use "-eq" with non-integer values.
	   
if [ "$a" -eq 273.0 ]
then
  echo "a = $a"
fi  # Aborts with an error message.  
# test.sh: [: 273.0: integer expression expected</programlisting>
        </para>
	</listitem>
	  

	<listitem>
      <para><anchor xml:id="numstrcompne" /></para>
      <para>Misusing <link linkend="scomparison1">string comparison</link>
        operators.</para>

	    <example xml:id="badop">
	      <title>Numerical and string comparison are not equivalent</title>
	      <programlisting>#!/bin/bash
# bad-op.sh: Trying to use a string comparison on integers.

echo
number=1

#  The following while-loop has two errors:
#+ one blatant, and the other subtle.

while [ "$number" &lt; 5 ]    # Wrong! Should be:  while [ "$number" -lt 5 ]
do
  echo -n "$number "
  let "number += 1"
done  
#  Attempt to run this bombs with the error message:
#+ bad-op.sh: line 10: 5: No such file or directory
#  Within single brackets, "&lt;" must be escaped,
#+ and even then, it's still wrong for comparing integers.

echo "---------------------"

while [ "$number" \&lt; 5 ]    #  1 2 3 4
do                          #
  echo -n "$number "        #  It *seems* to work, but . . .
  let "number += 1"         #+ it actually does an ASCII comparison,
done                        #+ rather than a numerical one.

echo; echo "---------------------"

# This can cause problems. For example:

lesser=5
greater=105

if [ "$greater" \&lt; "$lesser" ]
then
  echo "$greater is less than $lesser"
fi                          # 105 is less than 5
#  In fact, "105" actually is less than "5"
#+ in a string comparison (ASCII sort order).

echo

exit 0
</programlisting>
	    </example>
	</listitem>

	<listitem>
      <para><anchor xml:id="letbad" /></para>
	      <para>Attempting to use <link linkend="letref">let</link>
                to set string variables.</para>
              <para><programlisting>let "a = hello, you"
echo "$a"   # 0</programlisting></para>
	</listitem>

      
	<listitem>
      <para><anchor xml:id="failquote" /></para>
      <para>Sometimes variables within <quote>test</quote> brackets
	([ ]) need to be quoted (double quotes).  Failure to do so may
	cause unexpected behavior. See <xref linkend="strtest" />, <xref linkend="redir2" />, and <xref linkend="arglist" />.</para>
	</listitem>

	<listitem>
      <para><anchor xml:id="failnotquote" /></para>
      <para>Quoting a variable containing whitespace <link linkend="wsquo">prevents splitting</link>. Sometimes
	this produces <link linkend="varsplitting">unintended
	consequences</link>.</para>
	</listitem>


	<listitem>
      <para><anchor xml:id="execperm" /></para>
      <para>Commands issued from a script may fail to execute because
	the script owner lacks execute permission for them. If a user
	cannot invoke a command from the command-line, then putting it
	into a script will likewise fail. Try changing the attributes of
	the command in question, perhaps even setting the suid bit
	(as <firstterm>root</firstterm>, of course).</para>
	</listitem>



	<listitem>
      <para><anchor xml:id="dashnredr" /></para>
      <para>Attempting to use <command>-</command> as a redirection
        operator (which it is not) will usually result in an unpleasant
	surprise.</para>
        <para>
	<programlisting>command1 2&gt; - | command2
# Trying to redirect error output of command1 into a pipe . . .
# . . . will not work.	

command1 2&gt;&amp; - | command2  # Also futile.

Thanks, S.C.</programlisting></para>
	</listitem>




	<listitem>
      <para><anchor xml:id="lateverf" /></para>
      <para>Using Bash <link linkend="bash2ref">version 2+</link>
	functionality may cause a bailout with error messages. Older
	Linux machines may have version 1.XX of Bash as the default
	installation.</para>
        <para>
	<programlisting>#!/bin/bash

minimum_version=2
# Since Chet Ramey is constantly adding features to Bash,
# you may set $minimum_version to 2.XX, 3.XX, or whatever is appropriate.
E_BAD_VERSION=80

if [ "$BASH_VERSION" \&lt; "$minimum_version" ]
then
  echo "This script works only with Bash, version $minimum or greater."
  echo "Upgrade strongly recommended."
  exit $E_BAD_VERSION
fi

...</programlisting></para>
	</listitem>

	

	<listitem>
      <para>Using Bash-specific functionality in a <link linkend="bashdef">Bourne shell</link> script
	(<userinput>#!/bin/sh</userinput>) on a non-Linux machine
	<link linkend="binsh">may cause unexpected behavior</link>.
	A Linux system usually aliases <command>sh</command> to
	<command>bash</command>, but this does not necessarily hold true
	for a generic UNIX machine.</para> </listitem>

	<listitem>
      <para><anchor xml:id="undocf" /></para>
      <para>Using undocumented features in Bash turns out to be a
	dangerous practice. In previous releases of this
	book there were several scripts that depended on the
	<quote>feature</quote> that, although the maximum value
	of an <link linkend="exitstatusref">exit</link> or <link linkend="returnref">return</link> value was 255, that limit
	did not apply to <emphasis>negative</emphasis> integers.
	Unfortunately, in version 2.05b and later, that loophole
	disappeared.  See <xref linkend="returntest" />.</para>
	</listitem>


	<listitem>
      <para><anchor xml:id="gotchaexitvalanamalies" /></para>
      <para>In certain contexts, a misleading <link linkend="exitstatusref">exit status</link>
        may be returned. This may occur when <link linkend="exitvalanomaly01">setting a local variable within a
        function</link> or when <link linkend="exitvalanomaly02">assigning
        an arithmetic value to a variable</link>.</para>
	</listitem>

	<listitem>
          <para><anchor xml:id="arxs1" />The <link linkend="arxs">exit
            status of an arithmetic expression</link> is
            <emphasis>not</emphasis> equivalent to an <firstterm>error
            code</firstterm>.</para>
    <para><programlisting>var=1 &amp;&amp; ((--var)) &amp;&amp; echo $var
#        ^^^^^^^^^ Here the and-list terminates with exit status 1.
#                     $var doesn't echo!
echo $?   # 1</programlisting></para>
	</listitem>

	<listitem>
      <para><anchor xml:id="dosnewlines" /></para>
      <para>
        A script with DOS-type newlines (<replaceable>\r\n</replaceable>)
	will fail to execute, since <userinput>#!/bin/bash\r\n</userinput>
	is <emphasis>not</emphasis> recognized, <emphasis>not</emphasis>
	the same as the expected <userinput>#!/bin/bash\n</userinput>. The
	fix is to convert the script to UNIX-style newlines.</para>
      <para>
	  <programlisting>#!/bin/bash

echo "Here"

unix2dos $0    # Script changes itself to DOS format.
chmod 755 $0   # Change back to execute permission.
               # The 'unix2dos' command removes execute permission.

./$0           # Script tries to run itself again.
               # But it won't work as a DOS file.

echo "There"

exit 0</programlisting>
      </para>

	</listitem>



	<listitem>
      <para><anchor xml:id="binsh" /></para>
      <para>A shell script headed by <userinput>#!/bin/sh</userinput>
	will not run in full Bash-compatibility mode. Some Bash-specific
	functions might be disabled. Scripts that need complete
	access to all the Bash-specific extensions should start with
	<userinput>#!/bin/bash</userinput>.</para>
	</listitem>

	<listitem>
      <para><link linkend="indentedls">Putting whitespace in front of
	the terminating limit string</link> of a <link linkend="heredocref">here document</link> will cause unexpected
	behavior in a script.</para>
	</listitem>

	<listitem>
      <para><anchor xml:id="rvtcaution2" />Putting more than one
	<firstterm>echo</firstterm> statement in a function <link linkend="rvt">whose output is captured</link>.
	<programlisting>add2 ()
{
  echo "Whatever ... "   # Delete this line!
  let "retval = $1 + $2"
    echo $retval
    }

    num1=12
    num2=43
    echo "Sum of $num1 and $num2 = $(add2 $num1 $num2)"

#   Sum of 12 and 43 = Whatever ... 
#   55

#        The "echoes" concatenate.</programlisting>
	This <link linkend="rvtcaution">will not work</link>.</para>
	</listitem>


	<listitem>
      <para><anchor xml:id="parchildprobref" /></para>
      
      <para>A script may not <command>export</command> variables back
	to its <link linkend="forkref">parent process</link>, the shell,
	or to the environment. Just as we learned in biology, a child
	process can inherit from a parent, but not vice versa.</para>
      <para>
	  <programlisting>WHATEVER=/home/bozo
export WHATEVER
exit 0</programlisting>
          <screen><prompt>bash$ </prompt><command>echo $WHATEVER</command>
<computeroutput>

</computeroutput>
<prompt>bash$ </prompt></screen>
      </para>
      <para>
        Sure enough, back at the command prompt, $WHATEVER remains unset.
       </para>
	
	</listitem>


      
	<listitem>
      <para><anchor xml:id="varsubsh" /></para>
      <para>Setting and manipulating variables in a <link linkend="subshellsref">subshell</link>, then attempting
        to use those same variables outside the scope of the subshell will
	result an unpleasant surprise.</para>

      <example xml:id="subpit">
	<title>Subshell Pitfalls</title>
	<programlisting>#!/bin/bash
# Pitfalls of variables in a subshell.

outer_variable=outer
echo
echo "outer_variable = $outer_variable"
echo

(
# Begin subshell

echo "outer_variable inside subshell = $outer_variable"
inner_variable=inner  # Set
echo "inner_variable inside subshell = $inner_variable"
outer_variable=inner  # Will value change globally?
echo "outer_variable inside subshell = $outer_variable"

# Will 'exporting' make a difference?
#    export inner_variable
#    export outer_variable
# Try it and see.

# End subshell
)

echo
echo "inner_variable outside subshell = $inner_variable"  # Unset.
echo "outer_variable outside subshell = $outer_variable"  # Unchanged.
echo

exit 0

# What happens if you uncomment lines 19 and 20?
# Does it make a difference?
</programlisting>
      </example>
	</listitem>


	<listitem>
      <para><anchor xml:id="badread0" /></para>
      <para><link linkend="piperef">Piping</link>
	<command>echo</command> output to a <link linkend="readref">read</link> may produce unexpected
	results.  In this scenario, the <command>read</command>
	acts as if it were running in a subshell. Instead, use
	the <link linkend="setref">set</link> command (as in <xref linkend="setpos" />).</para>

      <example xml:id="badread">
	<title>Piping the output of <firstterm>echo</firstterm> to a
	<firstterm>read</firstterm></title>
	<programlisting>#!/bin/bash
#  badread.sh:
#  Attempting to use 'echo and 'read'
#+ to assign variables non-interactively.

#   shopt -s lastpipe

a=aaa
b=bbb
c=ccc

echo "one two three" | read a b c
# Try to reassign a, b, and c.

echo
echo "a = $a"  # a = aaa
echo "b = $b"  # b = bbb
echo "c = $c"  # c = ccc
# Reassignment failed.

### However . . .
##  Uncommenting line 6:
#   shopt -s lastpipe
##+ fixes the problem!
### This is a new feature in Bash, version 4.2.

# ------------------------------

# Try the following alternative.

var=`echo "one two three"`
set -- $var
a=$1; b=$2; c=$3

echo "-------"
echo "a = $a"  # a = one
echo "b = $b"  # b = two
echo "c = $c"  # c = three 
# Reassignment succeeded.

# ------------------------------

#  Note also that an echo to a 'read' works within a subshell.
#  However, the value of the variable changes *only* within the subshell.

a=aaa          # Starting all over again.
b=bbb
c=ccc

echo; echo
echo "one two three" | ( read a b c;
echo "Inside subshell: "; echo "a = $a"; echo "b = $b"; echo "c = $c" )
# a = one
# b = two
# c = three
echo "-----------------"
echo "Outside subshell: "
echo "a = $a"  # a = aaa
echo "b = $b"  # b = bbb
echo "c = $c"  # c = ccc
echo

exit 0
</programlisting>
      </example>

      <para><anchor xml:id="pipeloop" /></para>
      <para>In fact, as Anthony Richardson points out, piping to
        <emphasis>any</emphasis> loop can cause a similar problem.</para>

      <para>	
<programlisting># Loop piping troubles.
#  This example by Anthony Richardson,
#+ with addendum by Wilbert Berendsen.


foundone=false
find $HOME -type f -atime +30 -size 100k |
while true
do
   read f
   echo "$f is over 100KB and has not been accessed in over 30 days"
   echo "Consider moving the file to archives."
   foundone=true
   # ------------------------------------
     echo "Subshell level = $BASH_SUBSHELL"
   # Subshell level = 1
   # Yes, we're inside a subshell.
   # ------------------------------------
done
   
#  foundone will always be false here since it is
#+ set to true inside a subshell
if [ $foundone = false ]
then
   echo "No files need archiving."
fi

# =====================Now, here is the correct way:=================

foundone=false
for f in $(find $HOME -type f -atime +30 -size 100k)  # No pipe here.
do
   echo "$f is over 100KB and has not been accessed in over 30 days"
   echo "Consider moving the file to archives."
   foundone=true
done
   
if [ $foundone = false ]
then
   echo "No files need archiving."
fi

# ==================And here is another alternative==================

#  Places the part of the script that reads the variables
#+ within a code block, so they share the same subshell.
#  Thank you, W.B.

find $HOME -type f -atime +30 -size 100k | {
     foundone=false
     while read f
     do
       echo "$f is over 100KB and has not been accessed in over 30 days"
       echo "Consider moving the file to archives."
       foundone=true
     done

     if ! $foundone
     then
       echo "No files need archiving."
     fi
}</programlisting>
      </para>

      <para><anchor xml:id="ptailgrep" /></para>
      <para>
        A lookalike problem occurs when trying to write the
	<filename>stdout</filename> of a <command>tail -f</command>
	piped to <link linkend="grepref">grep</link>.
	  <programlisting>tail -f /var/log/messages | grep "$ERROR_MSG" &gt;&gt; error.log
#  The "error.log" file will not have anything written to it.
#  As Samuli Kaipiainen points out, this results from grep
#+ buffering its output.
#  The fix is to add the "--line-buffered" parameter to grep.</programlisting>
      </para>
	</listitem>



	<listitem>
      <para><anchor xml:id="suidscr" /></para>
      <para>Using <quote>suid</quote> commands within scripts is risky,
	as it may compromise system security.
	  <footnote><para>Setting the <link linkend="suidref">suid</link>
	  permission on the script itself has no effect in Linux
	  and most other UNIX flavors.</para></footnote>
      </para>
	</listitem>


	<listitem>
      <para><anchor xml:id="cgiref" /></para>
      <para>Using shell scripts for CGI programming may be problematic. Shell
        script variables are not <quote>typesafe,</quote> and this can cause
	undesirable behavior as far as CGI is concerned. Moreover, it is
	difficult to <quote>cracker-proof</quote> shell scripts.</para>
	</listitem>


	<listitem>
      <para>Bash does not handle the <link linkend="doubleslashref">double slash
        (<token>//</token>) string</link> correctly.</para>
	</listitem>


	<listitem>
      <para><anchor xml:id="gnuref" /></para>
      <para>Bash scripts written for Linux or BSD systems may need
	fixups to run on a commercial UNIX machine. Such
	scripts often employ the GNU set of commands and filters,
	which have greater functionality than their generic UNIX
	counterparts. This is particularly true of such text processing
	utilites as <link linkend="trref">tr</link>.</para>
	</listitem>

	<listitem>
      <para><anchor xml:id="updatebreaks" /></para>
      <para>Sadly, updates to Bash itself have broken older scripts
        that <link linkend="paragraphspace">used to work perfectly
        fine</link>. Let us recall <link linkend="undocf">how
        risky it is to use undocumented Bash features</link>.</para>
         </listitem>

      </itemizedlist>

    <epigraph>
      <para>Danger is near thee --</para>
      <para>Beware, beware, beware, beware.</para>
      <para>Many brave hearts are asleep in the deep.</para>
      <para>So beware --</para>
      <para>Beware.</para>
      <para>--A.J. Lamb and H.W. Petrie</para>
    </epigraph>

  </chapter> <!-- Gotchas -->



  <chapter xml:id="scrstyle">
    <title>Scripting With Style</title>

      <para>Get into the habit of writing shell scripts in a structured and
	systematic manner. Even on-the-fly and <quote>written on the
	back of an envelope</quote> scripts will benefit if you take a
	few minutes to plan and organize your thoughts before sitting
	down and coding.</para>

      <para>Herewith are a few stylistic guidelines. This is not
	(necessarily) intended as an <emphasis>Official Shell Scripting
	Stylesheet</emphasis>.</para>



      <section xml:id="unofficialst">
        <title>Unofficial Shell Scripting Stylesheet</title>

      <itemizedlist>

        <listitem>

	  <para>Comment your code. This makes it easier for others to
	    understand (and appreciate), and easier for you to maintain.
	    <programlisting>PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
#  It made perfect sense when you wrote it last year,
#+ but now it's a complete mystery.
#  (From Antek Sawicki's "pw.sh" script.)</programlisting>
	  </para>

	  <para>Add descriptive headers to your scripts and functions.
	    <programlisting>#!/bin/bash

#************************************************#
#                   xyz.sh                       #
#           written by Bozo Bozeman              #
#                July 05, 2001                   #
#                                                #
#           Clean up project files.              #
#************************************************#

E_BADDIR=85                       # No such directory.
projectdir=/home/bozo/projects    # Directory to clean up.

# --------------------------------------------------------- #
# cleanup_pfiles ()                                         #
# Removes all files in designated directory.                #
# Parameter: $target_directory                              #
# Returns: 0 on success, $E_BADDIR if something went wrong. #
# --------------------------------------------------------- #
cleanup_pfiles ()
{
  if [ ! -d "$1" ]  # Test if target directory exists.
  then
    echo "$1 is not a directory."
    return $E_BADDIR
  fi

  rm -f "$1"/*
  return 0   # Success.
}  

cleanup_pfiles $projectdir

exit $?</programlisting></para>

        </listitem>


        <listitem>
	  <para>Avoid using <quote>magic numbers,</quote>

	     <footnote><para>In this context, <quote>magic
	       numbers</quote> have an entirely different meaning than
	       the <link linkend="magnumref">magic numbers</link> used
	       to designate file types.</para></footnote>

	    that is, <quote>hard-wired</quote> literal constants. Use
	    meaningful variable names instead. This makes the script
	    easier to understand and permits making changes and updates
	    without breaking the application.

	    <programlisting>if [ -f /var/log/messages ]
then
  ...
fi
#  A year later, you decide to change the script to check /var/log/syslog.
#  It is now necessary to manually change the script, instance by instance,
#+ and hope nothing breaks.

# A better way:
LOGFILE=/var/log/messages  # Only line that needs to be changed.
if [ -f "$LOGFILE" ]
then
  ...
fi</programlisting>
          </para>
        </listitem>


        <listitem>

	  <para>Choose descriptive names for variables and functions.
	    <programlisting>fl=`ls -al $dirname`                 # Cryptic.
file_listing=`ls -al $dirname`       # Better.


MAXVAL=10   # All caps used for a script constant.
while [ "$index" -le "$MAXVAL" ]
...


E_NOTFOUND=95                        #  Uppercase for an errorcode,
                                     #+ and name prefixed with E_.
if [ ! -e "$filename" ]
then
  echo "File $filename not found."
  exit $E_NOTFOUND
fi  


MAIL_DIRECTORY=/var/spool/mail/bozo  #  Uppercase for an environmental
export MAIL_DIRECTORY                #+ variable.


GetAnswer ()                         #  Mixed case works well for a
{                                    #+ function name, especially
  prompt=$1                          #+ when it improves legibility.
  echo -n $prompt
  read answer
  return $answer
}  

GetAnswer "What is your favorite number? "
favorite_number=$?
echo $favorite_number


_uservariable=23                     # Permissible, but not recommended.
# It's better for user-defined variables not to start with an underscore.
# Leave that for system variables.</programlisting>
          </para>
        </listitem>


        <listitem>

	  <para>Use <link linkend="exitcommandref">exit codes</link>
	    in a systematic and meaningful way.

	    <programlisting>E_WRONG_ARGS=95
...
...
exit $E_WRONG_ARGS</programlisting>
            See also <xref linkend="exitcodes" />.</para>


          <para><emphasis>Ender</emphasis> suggests using the <link linkend="sysexitsref">exit codes
	    in <filename>/usr/include/sysexits.h</filename></link> in shell
	    scripts, though these are primarily intended for C and C++
	    programming.</para>

        </listitem>



        <listitem>


	   <para>Use standardized parameter flags for script invocation.
	     <emphasis>Ender</emphasis> proposes the following set
	     of flags.</para>

           <para>
             <programlisting>-a      All: Return all information (including hidden file info).
-b      Brief: Short version, usually for other scripts.
-c      Copy, concatenate, etc.
-d      Daily: Use information from the whole day, and not merely
        information for a specific instance/user.
-e      Extended/Elaborate: (often does not include hidden file info).
-h      Help: Verbose usage w/descs, aux info, discussion, help.
        See also -V.
-l      Log output of script.
-m      Manual: Launch man-page for base command.
-n      Numbers: Numerical data only.
-r      Recursive: All files in a directory (and/or all sub-dirs).
-s      Setup &amp; File Maintenance: Config files for this script.
-u      Usage: List of invocation flags for the script.
-v      Verbose: Human readable output, more or less formatted.
-V      Version / License / Copy(right|left) / Contribs (email too).</programlisting>
           </para>

           <para>See also <xref linkend="standard-options" />.</para>

        </listitem>


        <listitem>
	  <para>Break complex scripts into simpler modules. Use functions
	    where appropriate. See <xref linkend="cards" />.</para>
        </listitem>

        <listitem>
	  <para>Don't use a complex construct where a simpler one will do.

	    <programlisting>COMMAND
if [ $? -eq 0 ]
...
# Redundant and non-intuitive.

if COMMAND
...
# More concise (if perhaps not quite as legible).</programlisting>
          </para>
        </listitem>

	    
      </itemizedlist>


    <epigraph>
      <para>... reading the UNIX source code to the Bourne shell (/bin/sh). I
        was shocked at how much simple algorithms could be made cryptic, and
	therefore useless, by a poor choice of code style. I asked myself,
	<quote>Could someone be proud of this code?</quote></para>
      <para>--Landon Noll</para>
    </epigraph>

    </section> <!-- Unofficial Shell Scripting Stylesheet -->  



  </chapter> <!-- Scripting With Style -->



  <chapter xml:id="miscellany">
    <title>Miscellany</title>

    <epigraph>
      <para>Nobody really knows what the Bourne shell's grammar is. Even
        examination of the source code is little help.</para>
      <para>--Tom Duff</para>
    </epigraph>


      <section xml:id="intandnonint">
        <title>Interactive and non-interactive shells and scripts</title>
         
	 <para>An <firstterm>interactive</firstterm> shell reads
	   commands from user input on a <filename>tty</filename>. Among
	   other things, such a shell reads startup files on activation,
	   displays a prompt, and enables job control by default. The
	   user can <firstterm>interact</firstterm> with the shell.</para>

	 <para>A shell running a script is always a non-interactive
	   shell. All the same, the script can still access its
	   <filename>tty</filename>. It is even possible to emulate an
	   interactive shell in a script.

	   <programlisting>#!/bin/bash
MY_PROMPT='$ '
while :
do
  echo -n "$MY_PROMPT"
  read line
  eval "$line"
  done

exit 0

# This example script, and much of the above explanation supplied by
# Stphane Chazelas (thanks again).</programlisting></para>

	 <para>Let us consider an <firstterm>interactive</firstterm>
	   script to be one that requires input from the user, usually
	   with <link linkend="readref">read</link> statements (see <xref linkend="ex36" />). <quote>Real life</quote> is actually a
	   bit messier than that. For now, assume an interactive script
	   is bound to a tty, a script that a user has invoked from the
	   console or an <firstterm>xterm</firstterm>.</para>

	 <para>Init and startup scripts are necessarily non-interactive,
	   since they must run without human intervention. Many
	   administrative and system maintenance scripts are likewise
	   non-interactive.  Unvarying repetitive tasks cry out for
	   automation by non-interactive scripts.</para>

	 <para>Non-interactive scripts can run in the background, but
	   interactive ones hang, waiting for input that never comes.
	   Handle that difficulty by having an <command>expect</command>
	   script or embedded <link linkend="heredocref">here
	   document</link> feed input to an interactive script running
	   as a background job.  In the simplest case, redirect a
	   file to supply input to a <command>read</command> statement
	   (<command>read variable &lt;file</command>).  These particular
	   workarounds make possible general purpose scripts that run
	   in either interactive or non-interactive modes.</para>

	 <para>If a script needs to test whether it is running in an
	   interactive shell, it is simply a matter of finding
	   whether the <firstterm>prompt</firstterm> variable, <link linkend="ps1ref">$PS1</link> is set. (If the user is being
	   prompted for input, then the script needs to display a
	   prompt.)</para>

	   <para><programlisting>if [ -z $PS1 ] # no prompt?
### if [ -v PS1 ]   # On Bash 4.2+ ...
then
  # non-interactive
  ...
else
  # interactive
  ...
fi</programlisting></para>

	   <para><anchor xml:id="iitest" />Alternatively, the script can test
	   for the presence of option <quote>i</quote> in the <link linkend="flpref">$-</link> flag.</para>

           <para><programlisting>case $- in
*i*)    # interactive shell
;;
*)      # non-interactive shell
;;
# (Courtesy of "UNIX F.A.Q.," 1993)</programlisting></para>

	   <para><anchor xml:id="ii2test" />However, John Lange describes
             an alternative method, using the <link linkend="termtest"><token>-t</token>
	     <firstterm>test</firstterm> operator</link>.</para>

           <para><programlisting># Test for a terminal!

fd=0   # stdin

#  As we recall, the -t test option checks whether the stdin, [ -t 0 ],
#+ or stdout, [ -t 1 ], in a given script is running in a terminal.
if [ -t "$fd" ]
then
  echo interactive
else
  echo non-interactive
fi


#  But, as John points out:
#    if [ -t 0 ] works ... when you're logged in locally
#    but fails when you invoke the command remotely via ssh.
#    So for a true test you also have to test for a socket.

if [[ -t "$fd" || -p /dev/stdin ]]
then
  echo interactive
else
  echo non-interactive
fi</programlisting></para>

	 <note><para>Scripts may be forced to run in interactive
	   mode with the <token>-i</token> option or with a
	   <userinput>#!/bin/bash -i</userinput> header. Be aware that
	   this can cause erratic script behavior or show error messages
	   even when no error is present.</para></note>


      </section> <!-- Interactive and non-interactive scripts -->



    <section xml:id="wrapper">
      <title>Shell Wrappers</title>

      <para><anchor xml:id="shwrapper" /></para>

      <para>A <firstterm>wrapper</firstterm> is a shell script that embeds
	a system command or utility, that accepts and passes a set of
	parameters to that command.

      <footnote><para>Quite a number of Linux utilities are, in fact,
	shell wrappers. Some examples are
	<filename>/usr/bin/pdf2ps</filename>,
	<filename>/usr/bin/batch</filename>, and
	<filename>/usr/bin/xmkmf</filename>.</para></footnote>
	
	Wrapping a script around a complex command-line
	simplifies invoking it.  This is expecially useful
	with <link linkend="sedref">sed</link> and <link linkend="awkref">awk</link>.</para>

      <para>A
	<command>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm> <indexterm>
	    <primary>script</primary> <secondary>sed</secondary>
	  </indexterm> sed</command> or
	<command>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm> <indexterm>
	    <primary>script</primary> <secondary>awk</secondary>
	  </indexterm>
	    awk</command> script would normally be invoked
	    from the command-line by a <userinput>sed -e
	    <replaceable>'commands'</replaceable></userinput>
	    or <userinput>awk
	    <replaceable>'commands'</replaceable></userinput>.	Embedding
	    such a script in a Bash script permits calling it more simply,
	    and makes it <firstterm>reusable</firstterm>. This also
	    enables combining the functionality of <firstterm>sed</firstterm>
	    and <firstterm>awk</firstterm>, for example <link linkend="piperef">piping</link> the output of a set of
	    <firstterm>sed</firstterm> commands to
	    <firstterm>awk</firstterm>. As a saved executable file,
	    you can then repeatedly invoke it in its original form or
	    modified, without the inconvenience of retyping it on the
	    command-line.</para>

      <example xml:id="ex3">
	<title><firstterm>shell wrapper</firstterm></title>
	<programlisting>#!/bin/bash

# This simple script removes blank lines from a file.
# No argument checking.
#
# You might wish to add something like:
#
# E_NOARGS=85
# if [ -z "$1" ]
# then
#  echo "Usage: `basename $0` target-file"
#  exit $E_NOARGS
# fi



sed -e /^$/d "$1"
# Same as
#    sed -e '/^$/d' filename
# invoked from the command-line.

#  The '-e' means an "editing" command follows (optional here).
#  '^' indicates the beginning of line, '$' the end.
#  This matches lines with nothing between the beginning and the end --
#+ blank lines.
#  The 'd' is the delete command.

#  Quoting the command-line arg permits
#+ whitespace and special characters in the filename.

#  Note that this script doesn't actually change the target file.
#  If you need to do that, redirect its output.

exit
</programlisting>
      </example>
      
      <example xml:id="ex4">
	<title> A slightly more complex <firstterm>shell
	wrapper</firstterm></title>
	<programlisting>#!/bin/bash

#  subst.sh: a script that substitutes one pattern for
#+ another in a file,
#+ i.e., "sh subst.sh Smith Jones letter.txt".
#                     Jones replaces Smith.

ARGS=3         # Script requires 3 arguments.
E_BADARGS=85   # Wrong number of arguments passed to script.

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` old-pattern new-pattern filename"
  exit $E_BADARGS
fi

old_pattern=$1
new_pattern=$2

if [ -f "$3" ]
then
    file_name=$3
else
    echo "File \"$3\" does not exist."
    exit $E_BADARGS
fi


# -----------------------------------------------
#  Here is where the heavy work gets done.
sed -e "s/$old_pattern/$new_pattern/g" $file_name
# -----------------------------------------------

#  's' is, of course, the substitute command in sed,
#+ and /pattern/ invokes address matching.
#  The 'g,' or global flag causes substitution for EVERY
#+ occurence of $old_pattern on each line, not just the first.
#  Read the 'sed' docs for an in-depth explanation.

exit $?  # Redirect the output of this script to write to a file.
</programlisting>
      </example>

      <example xml:id="loggingwrapper">
	<title> A generic <firstterm>shell wrapper</firstterm> that
	writes to a logfile</title>
	<programlisting>#!/bin/bash
#  logging-wrapper.sh
#  Generic shell wrapper that performs an operation
#+ and logs it.

DEFAULT_LOGFILE=logfile.txt

# Set the following two variables.
OPERATION=
#         Can be a complex chain of commands,
#+        for example an awk script or a pipe . . .

LOGFILE=
if [ -z "$LOGFILE" ]
then     # If not set, default to ...
  LOGFILE="$DEFAULT_LOGFILE"
fi

#         Command-line arguments, if any, for the operation.
OPTIONS="$@"


# Log it.
echo "`date` + `whoami` + $OPERATION "$@"" &gt;&gt; $LOGFILE
# Now, do it.
exec $OPERATION "$@"

# It's necessary to do the logging before the operation.
# Why?
</programlisting>
      </example>

      <example xml:id="prasc">
	<title> A <firstterm>shell wrapper</firstterm> around an awk
	script</title>
	<programlisting>#!/bin/bash
# pr-ascii.sh: Prints a table of ASCII characters.

START=33   # Range of printable ASCII characters (decimal).
END=127    # Will not work for unprintable characters (&gt; 127).

echo " Decimal   Hex     Character"   # Header.
echo " -------   ---     ---------"

for ((i=START; i&lt;=END; i++))
do
  echo $i | awk '{printf("  %3d       %2x         %c\n", $1, $1, $1)}'
# The Bash printf builtin will not work in this context:
#     printf "%c" "$i"
done

exit 0


#  Decimal   Hex     Character
#  -------   ---     ---------
#    33       21         !
#    34       22         "
#    35       23         #
#    36       24         $
#
#    . . .
#
#   122       7a         z
#   123       7b         {
#   124       7c         |
#   125       7d         }


#  Redirect the output of this script to a file
#+ or pipe it to "more":  sh pr-asc.sh | more
</programlisting>
      </example>

      <example xml:id="coltotaler">
	<title> A <firstterm>shell wrapper</firstterm> around another
	awk script</title>
	<programlisting>#!/bin/bash

# Adds up a specified column (of numbers) in the target file.
# Floating-point (decimal) numbers okay, because awk can handle them.

ARGS=2
E_WRONGARGS=85

if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#  Passing shell variables to the awk part of the script is a bit tricky.
#  One method is to strong-quote the Bash-script variable
#+ within the awk script.
#     $'$BASH_SCRIPT_VAR'
#      ^                ^
#  This is done in the embedded awk script below.
#  See the awk documentation for more details.

# A multi-line awk script is here invoked by
#   awk '
#   ...
#   ...
#   ...
#   '


# Begin awk script.
# -----------------------------
awk '

{ total += $'"${column_number}"'
}
END {
     print total
}     

' "$filename"
# -----------------------------
# End awk script.


#   It may not be safe to pass shell variables to an embedded awk script,
#+  so Stephane Chazelas proposes the following alternative:
#   ---------------------------------------
#   awk -v column_number="$column_number" '
#   { total += $column_number
#   }
#   END {
#       print total
#   }' "$filename"
#   ---------------------------------------


exit 0
</programlisting>
      </example>


      <para><anchor xml:id="perlref" />For those scripts needing a single
	do-it-all tool, a Swiss army knife, there is
	<firstterm>Perl</firstterm>. Perl combines the
	capabilities of <link linkend="sedref">sed</link> and <link linkend="awkref">awk</link>, and throws in a large subset of
	<command>C</command>, to boot. It is modular and contains support
	for everything ranging from object-oriented programming up to and
	including the kitchen sink. Short Perl scripts lend themselves to
	embedding within shell scripts, and there may be some substance
	to the claim that Perl can totally replace shell scripting
	(though the author of the <emphasis>ABS Guide</emphasis> remains
	skeptical).</para>

      <para><anchor xml:id="perlemb" /></para>
      <example xml:id="ex56">
	<title>Perl embedded in a <firstterm>Bash</firstterm> script</title>
	<programlisting>#!/bin/bash

# Shell commands may precede the Perl script.
echo "This precedes the embedded Perl script within \"$0\"."
echo "==============================================================="

perl -e 'print "This line prints from an embedded Perl script.\n";'
# Like sed, Perl also uses the "-e" option.

echo "==============================================================="
echo "However, the script may also contain shell and system commands."

exit 0
</programlisting>
      </example>
     
      <para>It is even possible to combine a Bash script and Perl script
        within the same file. Depending on how the script is invoked, either
	the Bash part or the Perl part will execute.</para>

      <para><anchor xml:id="bashandperl0" /></para>
      <example xml:id="bashandperl">
	<title>Bash and Perl scripts combined</title>
	<programlisting>#!/bin/bash
# bashandperl.sh

echo "Greetings from the Bash part of the script, $0."
# More Bash commands may follow here.

exit
# End of Bash part of the script.

# =======================================================

#!/usr/bin/perl
# This part of the script must be invoked with
#    perl -x bashandperl.sh

print "Greetings from the Perl part of the script, $0.\n";
#      Perl doesn't seem to like "echo" ...
# More Perl commands may follow here.

# End of Perl part of the script.
</programlisting>
      </example>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>bash bashandperl.sh</userinput>
<computeroutput>Greetings from the Bash part of the script.</computeroutput>


<prompt>bash$ </prompt><userinput>perl -x bashandperl.sh</userinput>
<computeroutput>Greetings from the Perl part of the script.</computeroutput>
	      </screen>
	      </para>

      <para>It is, of course, possible to embed even more exotic scripting
        languages within shell wrappers.  <firstterm>Python</firstterm>,
        for example ...</para>

      <para><anchor xml:id="pythonemb" /></para>
      <example xml:id="ex56py">
	<title>Python embedded in a <firstterm>Bash</firstterm> script</title>
	<programlisting>#!/bin/bash
# ex56py.sh

# Shell commands may precede the Python script.
echo "This precedes the embedded Python script within \"$0.\""
echo "==============================================================="

python -c 'print "This line prints from an embedded Python script.\n";'
# Unlike sed and perl, Python uses the "-c" option.
python -c 'k = raw_input( "Hit a key to exit to outer script. " )'

echo "==============================================================="
echo "However, the script may also contain shell and system commands."

exit 0
</programlisting>
      </example>

      <para>Wrapping a script around <firstterm>mplayer</firstterm>
        and the Google's translation server, you can create something
        that talks back to you.</para>

      <para><anchor xml:id="speech00" /></para>
      <example xml:id="speech0">
      <title>A script that speaks</title>
	<programlisting>#!/bin/bash
#   Courtesy of:
#   http://elinux.org/RPi_Text_to_Speech_(Speech_Synthesis)

#  You must be on-line for this script to work,
#+ so you can access the Google translation server.
#  Of course, mplayer must be present on your computer.

speak()
  {
  local IFS=+
  # Invoke mplayer, then connect to Google translation server.
  /usr/bin/mplayer -ao alsa -really-quiet -noconsolecontrols \
 "http://translate.google.com/translate_tts?tl=en&amp;q="$*""
  # Google translates, but can also speak.
  }

LINES=4

spk=$(tail -$LINES $0) # Tail end of same script!
speak "$spk"
exit
# Browns. Nice talking to you.
</programlisting>
      </example>

      <para>One interesting example of a complex shell wrapper is Martin
         Matusiak's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/undvd/"><firstterm>undvd</firstterm>
         script</link>, which provides an easy-to-use
         command-line interface to the complex <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html">mencoder</link>
         utility. Another example is Itzchak Rehberg's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://projects.izzysoft.de/trac/ext3undel">Ext3Undel</link>,
         a set of scripts to recover deleted file on an
         <firstterm>ext3</firstterm> filesystem.</para>


    </section> <!-- Shell wrappers -->



      <section xml:id="testsandcomparisons">
        <title>Tests and Comparisons: Alternatives</title>

	<para>For tests, the <link linkend="dblbrackets">[[    ]]</link>
	  construct may be more appropriate than <userinput>[
	  ]</userinput>. Likewise, <link linkend="icomparison1">arithmetic
	  comparisons</link> might benefit from the <link linkend="dblparens">((    ))</link> construct.

	  <programlisting>a=8

# All of the comparisons below are equivalent.
test "$a" -lt 16 &amp;&amp; echo "yes, $a &lt; 16"         # "and list"
/bin/test "$a" -lt 16 &amp;&amp; echo "yes, $a &lt; 16" 
[ "$a" -lt 16 ] &amp;&amp; echo "yes, $a &lt; 16" 
[[ $a -lt 16 ]] &amp;&amp; echo "yes, $a &lt; 16"          # Quoting variables within
(( a &lt; 16 )) &amp;&amp; echo "yes, $a &lt; 16"             # [[ ]] and (( )) not necessary.

city="New York"
# Again, all of the comparisons below are equivalent.
test "$city" \&lt; Paris &amp;&amp; echo "Yes, Paris is greater than $city"
                                  # Greater ASCII order.
/bin/test "$city" \&lt; Paris &amp;&amp; echo "Yes, Paris is greater than $city" 
[ "$city" \&lt; Paris ] &amp;&amp; echo "Yes, Paris is greater than $city" 
[[ $city &lt; Paris ]] &amp;&amp; echo "Yes, Paris is greater than $city"
                                  # Need not quote $city.

# Thank you, S.C.</programlisting></para>

      </section> <!-- Tests and Comparisons: Alternatives -->



      <section xml:id="recursionsct">
        <title>Recursion: a script calling itself</title>


	<para><anchor xml:id="scriptrecursion" /></para>
	<para>Can a script <link linkend="recursionref">recursively</link>
	  call itself? Indeed.</para>

	    <example xml:id="recurse">
	      <title>A (useless) script that recursively calls itself</title>
	      <programlisting>#!/bin/bash
# recurse.sh

#  Can a script recursively call itself?
#  Yes, but is this of any practical use?
#  (See the following.)

RANGE=10
MAXVAL=9

i=$RANDOM
let "i %= $RANGE"  # Generate a random number between 0 and $RANGE - 1.

if [ "$i" -lt "$MAXVAL" ]
then
  echo "i = $i"
  ./$0             #  Script recursively spawns a new instance of itself.
fi                 #  Each child script does the same, until
                   #+ a generated $i equals $MAXVAL.

#  Using a "while" loop instead of an "if/then" test causes problems.
#  Explain why.

exit 0

# Note:
# ----
# This script must have execute permission for it to work properly.
# This is the case even if it is invoked by an "sh" command.
# Explain why.
</programlisting>
	    </example>

	    <example xml:id="pbook">
	      <title>A (useful) script that recursively calls itself</title>
	      <programlisting>#!/bin/bash
# pb.sh: phone book

# Written by Rick Boivie, and used with permission.
# Modifications by ABS Guide author.

MINARGS=1     #  Script needs at least one argument.
DATAFILE=./phonebook
              #  A data file in current working directory
              #+ named "phonebook" must exist.
PROGNAME=$0
E_NOARGS=70   #  No arguments error.

if [ $# -lt $MINARGS ]; then
      echo "Usage: "$PROGNAME" data-to-look-up"
      exit $E_NOARGS
fi      


if [ $# -eq $MINARGS ]; then
      grep $1 "$DATAFILE"
      # 'grep' prints an error message if $DATAFILE not present.
else
      ( shift; "$PROGNAME" $* ) | grep $1
      # Script recursively calls itself.
fi

exit 0        #  Script exits here.
              #  Therefore, it's o.k. to put
              #+ non-hashmarked comments and data after this point.

# ------------------------------------------------------------------------
Sample "phonebook" datafile:

John Doe        1555 Main St., Baltimore, MD 21228          (410) 222-3333
Mary Moe        9899 Jones Blvd., Warren, NH 03787          (603) 898-3232
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
Zoe Zenobia     4481 N. Baker St., San Francisco, SF 94338  (415) 501-1631
# ------------------------------------------------------------------------

$bash pb.sh Roe
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

$bash pb.sh Roe Sam
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

#  When more than one argument is passed to this script,
#+ it prints *only* the line(s) containing all the arguments.
</programlisting>
	    </example>

	    <example xml:id="usrmnt">
	      <title>Another (useful) script that recursively calls itself</title>
	      <programlisting>#!/bin/bash
# usrmnt.sh, written by Anthony Richardson
# Used in ABS Guide with permission.

# usage:       usrmnt.sh
# description: mount device, invoking user must be listed in the
#              MNTUSERS group in the /etc/sudoers file.

# ----------------------------------------------------------
#  This is a usermount script that reruns itself using sudo.
#  A user with the proper permissions only has to type

#   usermount /dev/fd0 /mnt/floppy

# instead of

#   sudo usermount /dev/fd0 /mnt/floppy

#  I use this same technique for all of my
#+ sudo scripts, because I find it convenient.
# ----------------------------------------------------------

#  If SUDO_COMMAND variable is not set we are not being run through
#+ sudo, so rerun ourselves. Pass the user's real and group id . . .

if [ -z "$SUDO_COMMAND" ]
then
   mntusr=$(id -u) grpusr=$(id -g) sudo $0 $*
   exit 0
fi

# We will only get here if we are being run by sudo.
/bin/mount $* -o uid=$mntusr,gid=$grpusr

exit 0

# Additional notes (from the author of this script): 
# -------------------------------------------------

# 1) Linux allows the "users" option in the /etc/fstab
#    file so that any user can mount removable media.
#    But, on a server, I like to allow only a few
#    individuals access to removable media.
#    I find using sudo gives me more control.

# 2) I also find sudo to be more convenient than
#    accomplishing this task through groups.

# 3) This method gives anyone with proper permissions
#    root access to the mount command, so be careful
#    about who you allow access.
#    You can get finer control over which access can be mounted
#    by using this same technique in separate mntfloppy, mntcdrom,
#    and mntsamba scripts.
</programlisting>
	    </example>

	<caution><para>Too many levels of recursion can exhaust the
	  script's stack space, causing a segfault.</para></caution>

      </section> <!-- Recursion -->



      <section xml:id="colorizing">
        <title><quote>Colorizing</quote> Scripts</title>

	<para><anchor xml:id="colorizingref" /></para>

	<para>The ANSI
	   <footnote><para><acronym>ANSI</acronym> is, of course, the
	     acronym for the American National Standards
	     Institute. This august body establishes and maintains
	     various technical and industrial standards.</para></footnote>
	   escape sequences set screen attributes, such as bold
	   text, and color of foreground and background. <link linkend="dosbatch1">DOS batch files</link> commonly used
	   ANSI escape codes for <emphasis>color</emphasis> output,
	   and so can Bash scripts.</para>

	    <example xml:id="ex30a">
	      <title>A <quote>colorized</quote> address database</title>
	      <programlisting>#!/bin/bash
# ex30a.sh: "Colorized" version of ex30.sh.
#            Crude address database


clear                                   # Clear the screen.

echo -n "          "
echo -e '\E[37;44m'"\033[1mContact List\033[0m"
                                        # White on blue background
echo; echo
echo -e "\033[1mChoose one of the following persons:\033[0m"
                                        # Bold
tput sgr0                               # Reset attributes.
echo "(Enter only the first letter of name.)"
echo
echo -en '\E[47;34m'"\033[1mE\033[0m"   # Blue
tput sgr0                               # Reset colors to "normal."
echo "vans, Roland"                     # "[E]vans, Roland"
echo -en '\E[47;35m'"\033[1mJ\033[0m"   # Magenta
tput sgr0
echo "ambalaya, Mildred"
echo -en '\E[47;32m'"\033[1mS\033[0m"   # Green
tput sgr0
echo "mith, Julie"
echo -en '\E[47;31m'"\033[1mZ\033[0m"   # Red
tput sgr0
echo "ane, Morris"
echo

read person

case "$person" in
# Note variable is quoted.

  "E" | "e" )
  # Accept upper or lowercase input.
  echo
  echo "Roland Evans"
  echo "4321 Flash Dr."
  echo "Hardscrabble, CO 80753"
  echo "(303) 734-9874"
  echo "(303) 734-9892 fax"
  echo "revans@zzy.net"
  echo "Business partner &amp; old friend"
  ;;

  "J" | "j" )
  echo
  echo "Mildred Jambalaya"
  echo "249 E. 7th St., Apt. 19"
  echo "New York, NY 10009"
  echo "(212) 533-2814"
  echo "(212) 533-9972 fax"
  echo "milliej@loisaida.com"
  echo "Girlfriend"
  echo "Birthday: Feb. 11"
  ;;

# Add info for Smith &amp; Zane later.

          * )
   # Default option.	  
   # Empty input (hitting RETURN) fits here, too.
   echo
   echo "Not yet in database."
  ;;

esac

tput sgr0                               # Reset colors to "normal."

echo

exit 0
</programlisting>
	    </example>

	    <example xml:id="draw-box">
	      <title>Drawing a box</title>
	      <programlisting>#!/bin/bash
# Draw-box.sh: Drawing a box using ASCII characters.

# Script by Stefano Palmeri, with minor editing by document author.
# Minor edits suggested by Jim Angstadt.
# Used in the ABS Guide with permission.


######################################################################
###  draw_box function doc  ###

#  The "draw_box" function lets the user
#+ draw a box in a terminal.       
#
#  Usage: draw_box ROW COLUMN HEIGHT WIDTH [COLOR] 
#  ROW and COLUMN represent the position        
#+ of the upper left angle of the box you're going to draw.
#  ROW and COLUMN must be greater than 0
#+ and less than current terminal dimension.
#  HEIGHT is the number of rows of the box, and must be &gt; 0. 
#  HEIGHT + ROW must be &lt;= than current terminal height. 
#  WIDTH is the number of columns of the box and must be &gt; 0.
#  WIDTH + COLUMN must be &lt;= than current terminal width.
#
# E.g.: If your terminal dimension is 20x80,
#  draw_box 2 3 10 45 is good
#  draw_box 2 3 19 45 has bad HEIGHT value (19+2 &gt; 20)
#  draw_box 2 3 18 78 has bad WIDTH value (78+3 &gt; 80)
#
#  COLOR is the color of the box frame.
#  This is the 5th argument and is optional.
#  0=black 1=red 2=green 3=tan 4=blue 5=purple 6=cyan 7=white.
#  If you pass the function bad arguments,
#+ it will just exit with code 65,
#+ and no messages will be printed on stderr.
#
#  Clear the terminal before you start to draw a box.
#  The clear command is not contained within the function.
#  This allows the user to draw multiple boxes, even overlapping ones.

###  end of draw_box function doc  ### 
######################################################################

draw_box(){

#=============#
HORZ="-"
VERT="|"
CORNER_CHAR="+"

MINARGS=4
E_BADARGS=65
#=============#


if [ $# -lt "$MINARGS" ]; then          # If args are less than 4, exit.
    exit $E_BADARGS
fi

# Looking for non digit chars in arguments.
# Probably it could be done better (exercise for the reader?).
if echo $@ | tr -d [:blank:] | tr -d [:digit:] | grep . &amp;&gt; /dev/null; then
   exit $E_BADARGS
fi

BOX_HEIGHT=`expr $3 - 1`   #  -1 correction needed because angle char "+"
BOX_WIDTH=`expr $4 - 1`    #+ is a part of both box height and width.
T_ROWS=`tput lines`        #  Define current terminal dimension 
T_COLS=`tput cols`         #+ in rows and columns.
         
if [ $1 -lt 1 ] || [ $1 -gt $T_ROWS ]; then    #  Start checking if arguments
   exit $E_BADARGS                             #+ are correct.
fi
if [ $2 -lt 1 ] || [ $2 -gt $T_COLS ]; then
   exit $E_BADARGS
fi
if [ `expr $1 + $BOX_HEIGHT + 1` -gt $T_ROWS ]; then
   exit $E_BADARGS
fi
if [ `expr $2 + $BOX_WIDTH + 1` -gt $T_COLS ]; then
   exit $E_BADARGS
fi
if [ $3 -lt 1 ] || [ $4 -lt 1 ]; then
   exit $E_BADARGS
fi                                 # End checking arguments.

plot_char(){                       # Function within a function.
   echo -e "\E[${1};${2}H"$3
}

echo -ne "\E[3${5}m"               # Set box frame color, if defined.

# start drawing the box

count=1                                         #  Draw vertical lines using
for (( r=$1; count&lt;=$BOX_HEIGHT; r++)); do      #+ plot_char function.
  plot_char $r $2 $VERT
  let count=count+1
done 

count=1
c=`expr $2 + $BOX_WIDTH`
for (( r=$1; count&lt;=$BOX_HEIGHT; r++)); do
  plot_char $r $c $VERT
  let count=count+1
done 

count=1                                        #  Draw horizontal lines using
for (( c=$2; count&lt;=$BOX_WIDTH; c++)); do      #+ plot_char function.
  plot_char $1 $c $HORZ
  let count=count+1
done 

count=1
r=`expr $1 + $BOX_HEIGHT`
for (( c=$2; count&lt;=$BOX_WIDTH; c++)); do
  plot_char $r $c $HORZ
  let count=count+1
done 

plot_char $1 $2 $CORNER_CHAR                   # Draw box angles.
plot_char $1 `expr $2 + $BOX_WIDTH` $CORNER_CHAR
plot_char `expr $1 + $BOX_HEIGHT` $2 $CORNER_CHAR
plot_char `expr $1 + $BOX_HEIGHT` `expr $2 + $BOX_WIDTH` $CORNER_CHAR

echo -ne "\E[0m"             #  Restore old colors.

P_ROWS=`expr $T_ROWS - 1`    #  Put the prompt at bottom of the terminal.

echo -e "\E[${P_ROWS};1H"
}      


# Now, let's try drawing a box.
clear                       # Clear the terminal.
R=2      # Row
C=3      # Column
H=10     # Height
W=45     # Width 
col=1    # Color (red)
draw_box $R $C $H $W $col   # Draw the box.

exit 0

# Exercise:
# --------
# Add the option of printing text within the drawn box.
</programlisting>
	    </example>


	<para>The simplest, and perhaps most useful ANSI escape sequence is
	  bold text, <command>\033[1m ... \033[0m</command>. The
	  <token>\033</token> represents an <link linkend="escp">escape</link>, the <quote>[1</quote> turns on the
	  bold attribute, while the <quote>[0</quote> switches it off. The
	  <quote>m</quote> terminates each term of the escape sequence.
	      <screen>
<prompt>bash$ </prompt><userinput>echo -e "\033[1mThis is bold text.\033[0m"</userinput>
	      </screen>
	</para>

	<para>A similar escape sequence switches on the underline
	  attribute (on an <firstterm>rxvt</firstterm> and an
	  <firstterm>aterm</firstterm>).
	      <screen>
<prompt>bash$ </prompt><userinput>echo -e "\033[4mThis is underlined text.\033[0m"</userinput>
	      </screen>
	</para>

	<note><para>With an <command>echo</command>, the
	  <option>-e</option> option enables the escape
	  sequences.</para></note>

	<para>Other escape sequences change the text and/or background
	  color.</para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo -e '\E[34;47mThis prints in blue.'; tput sgr0</userinput>


<prompt>bash$ </prompt><userinput>echo -e '\E[33;44m'"yellow text on blue background"; tput sgr0</userinput>


<prompt>bash$ </prompt><userinput>echo -e '\E[1;33;44m'"BOLD yellow text on blue background"; tput sgr0</userinput>
	      </screen>
	      </para>

	<note><para>It's usually advisable to set the
	  <firstterm>bold</firstterm> attribute for light-colored foreground
	  text.</para></note>

	      <para>The <command>tput sgr0</command> restores the
		terminal settings to normal. Omitting this lets all
	        subsequent output from that particular terminal remain
	        blue.</para>

              <note><para>Since <command>tput sgr0</command> fails to restore
	        terminal settings under certain circumstances,
		<command>echo -ne \E[0m</command> may be a better choice.</para></note>

	<para><anchor xml:id="coloriztempl" /></para>
	<sidebar>
	<para>Use the following template for writing colored text on a colored
	background.</para>

        <para>
	  <userinput>echo -e '\E[COLOR1;COLOR2mSome text goes here.'</userinput>
        </para>

	<para>The <quote>\E[</quote> begins the escape sequence.
	  The semicolon-separated numbers <quote>COLOR1</quote> and
	  <quote>COLOR2</quote> specify a foreground and a background
	  color, according to the table below. (The order of the
	  numbers does not matter, since the foreground and background
	  numbers fall in non-overlapping ranges.) The <quote>m</quote>
	  terminates the escape sequence, and the text begins immediately
	  after that.</para>

	<para>Note also that <link linkend="snglquo">single quotes</link>
	  enclose the remainder of the command sequence following the
	  <command>echo -e</command>.</para>
	</sidebar>


	<para>The numbers in the following table work for an
	  <firstterm>rxvt</firstterm> terminal. Results may vary for other
	  terminal emulators.</para>

      <para><anchor xml:id="coloriztable" /></para>
      <table>
	<title>Numbers representing colors in Escape Sequences</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Color</entry>
	      <entry>Foreground</entry>
	      <entry>Background</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>black</option></entry>
	      <entry>30</entry>
	      <entry>40</entry>
	    </row>
	    <row>
	      <entry><option>red</option></entry>
	      <entry>31</entry>
	      <entry>41</entry>
	    </row>
	    <row>
	      <entry><option>green</option></entry>
	      <entry>32</entry>
	      <entry>42</entry>
	    </row>
	    <row>
	      <entry><option>yellow</option></entry>
	      <entry>33</entry>
	      <entry>43</entry>
	    </row>
	    <row>
	      <entry><option>blue</option></entry>
	      <entry>34</entry>
	      <entry>44</entry>
	    </row>
	    <row>
	      <entry><option>magenta</option></entry>
	      <entry>35</entry>
	      <entry>45</entry>
	    </row>
	    <row>
	      <entry><option>cyan</option></entry>
	      <entry>36</entry>
	      <entry>46</entry>
	    </row>
	    <row>
	      <entry><option>white</option></entry>
	      <entry>37</entry>
	      <entry>47</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

	    <example xml:id="colorecho">
	      <title>Echoing colored text</title>
	      <programlisting>#!/bin/bash
# color-echo.sh: Echoing text messages in color.

# Modify this script for your own purposes.
# It's easier than hand-coding color.

black='\E[30;47m'
red='\E[31;47m'
green='\E[32;47m'
yellow='\E[33;47m'
blue='\E[34;47m'
magenta='\E[35;47m'
cyan='\E[36;47m'
white='\E[37;47m'


alias Reset="tput sgr0"      #  Reset text attributes to normal
                             #+ without clearing screen.


cecho ()                     # Color-echo.
                             # Argument $1 = message
                             # Argument $2 = color
{
local default_msg="No message passed."
                             # Doesn't really need to be a local variable.

message=${1:-$default_msg}   # Defaults to default message.
color=${2:-$black}           # Defaults to black, if not specified.

  echo -e "$color"
  echo "$message"
  Reset                      # Reset to normal.

  return
}  


# Now, let's try it out.
# ----------------------------------------------------
cecho "Feeling blue..." $blue
cecho "Magenta looks more like purple." $magenta
cecho "Green with envy." $green
cecho "Seeing red?" $red
cecho "Cyan, more familiarly known as aqua." $cyan
cecho "No color passed (defaults to black)."
       # Missing $color argument.
cecho "\"Empty\" color passed (defaults to black)." ""
       # Empty $color argument.
cecho
       # Missing $message and $color arguments.
cecho "" ""
       # Empty $message and $color arguments.
# ----------------------------------------------------

echo

exit 0

# Exercises:
# ---------
# 1) Add the "bold" attribute to the 'cecho ()' function.
# 2) Add options for colored backgrounds.
</programlisting>
	    </example>

	<para><anchor xml:id="horseraceref" /></para>
	    <example xml:id="horserace">
	      <title>A <quote>horserace</quote> game</title>
	      <programlisting>#!/bin/bash
# horserace.sh: Very simple horserace simulation.
# Author: Stefano Palmeri
# Used with permission.

################################################################
#  Goals of the script:
#  playing with escape sequences and terminal colors.
#
#  Exercise:
#  Edit the script to make it run less randomly,
#+ set up a fake betting shop . . .     
#  Um . . . um . . . it's starting to remind me of a movie . . .
#
#  The script gives each horse a random handicap.
#  The odds are calculated upon horse handicap
#+ and are expressed in European(?) style.
#  E.g., odds=3.75 means that if you bet $1 and win,
#+ you receive $3.75.
# 
#  The script has been tested with a GNU/Linux OS,
#+ using xterm and rxvt, and konsole.
#  On a machine with an AMD 900 MHz processor,
#+ the average race time is 75 seconds.    
#  On faster computers the race time would be lower.
#  So, if you want more suspense, reset the USLEEP_ARG variable.
#
#  Script by Stefano Palmeri.
################################################################

E_RUNERR=65

# Check if md5sum and bc are installed. 
if ! which bc &amp;&gt; /dev/null; then
   echo bc is not installed.  
   echo "Can\'t run . . . "
   exit $E_RUNERR
fi
if ! which md5sum &amp;&gt; /dev/null; then
   echo md5sum is not installed.  
   echo "Can\'t run . . . "
   exit $E_RUNERR
fi

#  Set the following variable to slow down script execution.
#  It will be passed as the argument for usleep (man usleep)  
#+ and is expressed in microseconds (500000 = half a second).
USLEEP_ARG=0  

#  Clean up the temp directory, restore terminal cursor and 
#+ terminal colors -- if script interrupted by Ctl-C.
trap 'echo -en "\E[?25h"; echo -en "\E[0m"; stty echo;\
tput cup 20 0; rm -fr  $HORSE_RACE_TMP_DIR'  TERM EXIT
#  See the chapter on debugging for an explanation of 'trap.'

# Set a unique (paranoid) name for the temp directory the script needs.
HORSE_RACE_TMP_DIR=$HOME/.horserace-`date +%s`-`head -c10 /dev/urandom \
| md5sum | head -c30`

# Create the temp directory and move right in.
mkdir $HORSE_RACE_TMP_DIR
cd $HORSE_RACE_TMP_DIR


#  This function moves the cursor to line $1 column $2 and then prints $3.
#  E.g.: "move_and_echo 5 10 linux" is equivalent to
#+ "tput cup 4 9; echo linux", but with one command instead of two.
#  Note: "tput cup" defines 0 0 the upper left angle of the terminal,
#+ echo defines 1 1 the upper left angle of the terminal.
move_and_echo() {
          echo -ne "\E[${1};${2}H""$3" 
}

# Function to generate a pseudo-random number between 1 and 9. 
random_1_9 ()
{
    head -c10 /dev/urandom | md5sum | tr -d [a-z] | tr -d 0 | cut -c1 
}

#  Two functions that simulate "movement," when drawing the horses. 
draw_horse_one() {
               echo -n " "//$MOVE_HORSE//
}
draw_horse_two(){
              echo -n " "\\\\$MOVE_HORSE\\\\ 
}   


# Define current terminal dimension.
N_COLS=`tput cols`
N_LINES=`tput lines`

# Need at least a 20-LINES X 80-COLUMNS terminal. Check it.
if [ $N_COLS -lt 80 ] || [ $N_LINES -lt 20 ]; then
   echo "`basename $0` needs a 80-cols X 20-lines terminal."
   echo "Your terminal is ${N_COLS}-cols X ${N_LINES}-lines."
   exit $E_RUNERR
fi


# Start drawing the race field.

# Need a string of 80 chars. See below.
BLANK80=`seq -s "" 100 | head -c80`

clear

# Set foreground and background colors to white.
echo -ne '\E[37;47m'

# Move the cursor on the upper left angle of the terminal.
tput cup 0 0 

# Draw six white lines.
for n in `seq 5`; do
      echo $BLANK80   # Use the 80 chars string to colorize the terminal.
done

# Sets foreground color to black. 
echo -ne '\E[30m'

move_and_echo 3 1 "START  1"            
move_and_echo 3 75 FINISH
move_and_echo 1 5 "|"
move_and_echo 1 80 "|"
move_and_echo 2 5 "|"
move_and_echo 2 80 "|"
move_and_echo 4 5 "|  2"
move_and_echo 4 80 "|"
move_and_echo 5 5 "V  3"
move_and_echo 5 80 "V"

# Set foreground color to red. 
echo -ne '\E[31m'

# Some ASCII art.
move_and_echo 1 8 "..@@@..@@@@@...@@@@@.@...@..@@@@..."
move_and_echo 2 8 ".@...@...@.......@...@...@.@......."
move_and_echo 3 8 ".@@@@@...@.......@...@@@@@.@@@@...."
move_and_echo 4 8 ".@...@...@.......@...@...@.@......."
move_and_echo 5 8 ".@...@...@.......@...@...@..@@@@..."
move_and_echo 1 43 "@@@@...@@@...@@@@..@@@@..@@@@."
move_and_echo 2 43 "@...@.@...@.@.....@.....@....."
move_and_echo 3 43 "@@@@..@@@@@.@.....@@@@...@@@.."
move_and_echo 4 43 "@..@..@...@.@.....@.........@."
move_and_echo 5 43 "@...@.@...@..@@@@..@@@@.@@@@.."


# Set foreground and background colors to green.
echo -ne '\E[32;42m'

# Draw  eleven green lines.
tput cup 5 0
for n in `seq 11`; do
      echo $BLANK80
done

# Set foreground color to black. 
echo -ne '\E[30m'
tput cup 5 0

# Draw the fences. 
echo "++++++++++++++++++++++++++++++++++++++\
++++++++++++++++++++++++++++++++++++++++++"

tput cup 15 0
echo "++++++++++++++++++++++++++++++++++++++\
++++++++++++++++++++++++++++++++++++++++++"

# Set foreground and background colors to white.
echo -ne '\E[37;47m'

# Draw three white lines.
for n in `seq 3`; do
      echo $BLANK80
done

# Set foreground color to black.
echo -ne '\E[30m'

# Create 9 files to stores handicaps.
for n in `seq 10 7 68`; do
      touch $n
done  

# Set the first type of "horse" the script will draw.
HORSE_TYPE=2

#  Create position-file and odds-file for every "horse".
#+ In these files, store the current position of the horse,
#+ the type and the odds.
for HN in `seq 9`; do
      touch horse_${HN}_position
      touch odds_${HN}
      echo \-1 &gt; horse_${HN}_position
      echo $HORSE_TYPE &gt;&gt;  horse_${HN}_position
      # Define a random handicap for horse.
       HANDICAP=`random_1_9`
      # Check if the random_1_9 function returned a good value.
      while ! echo $HANDICAP | grep [1-9] &amp;&gt; /dev/null; do
                HANDICAP=`random_1_9`
      done
      # Define last handicap position for horse. 
      LHP=`expr $HANDICAP \* 7 + 3`
      for FILE in `seq 10 7 $LHP`; do
            echo $HN &gt;&gt; $FILE
      done   
     
      # Calculate odds.
      case $HANDICAP in 
              1) ODDS=`echo $HANDICAP \* 0.25 + 1.25 | bc`
                                 echo $ODDS &gt; odds_${HN}
              ;;
              2 | 3) ODDS=`echo $HANDICAP \* 0.40 + 1.25 | bc`
                                       echo $ODDS &gt; odds_${HN}
              ;;
              4 | 5 | 6) ODDS=`echo $HANDICAP \* 0.55 + 1.25 | bc`
                                             echo $ODDS &gt; odds_${HN}
              ;; 
              7 | 8) ODDS=`echo $HANDICAP \* 0.75 + 1.25 | bc`
                                       echo $ODDS &gt; odds_${HN}
              ;; 
              9) ODDS=`echo $HANDICAP \* 0.90 + 1.25 | bc`
                                  echo $ODDS &gt; odds_${HN}
      esac


done


# Print odds.
print_odds() {
tput cup 6 0
echo -ne '\E[30;42m'
for HN in `seq 9`; do
      echo "#$HN odds-&gt;" `cat odds_${HN}`
done
}

# Draw the horses at starting line.
draw_horses() {
tput cup 6 0
echo -ne '\E[30;42m'
for HN in `seq 9`; do
      echo /\\$HN/\\"                               "
done
}

print_odds

echo -ne '\E[47m'
# Wait for a enter key press to start the race.
# The escape sequence '\E[?25l' disables the cursor.
tput cup 17 0
echo -e '\E[?25l'Press [enter] key to start the race...
read -s

#  Disable normal echoing in the terminal.
#  This avoids key presses that might "contaminate" the screen
#+ during the race.  
stty -echo

# --------------------------------------------------------
# Start the race.

draw_horses
echo -ne '\E[37;47m'
move_and_echo 18 1 $BLANK80
echo -ne '\E[30m'
move_and_echo 18 1 Starting...
sleep 1

# Set the column of the finish line.
WINNING_POS=74

# Define the time the race started.
START_TIME=`date +%s`

# COL variable needed by following "while" construct.
COL=0    

while [ $COL -lt $WINNING_POS ]; do
                   
          MOVE_HORSE=0     
          
          # Check if the random_1_9 function has returned a good value.
          while ! echo $MOVE_HORSE | grep [1-9] &amp;&gt; /dev/null; do
                MOVE_HORSE=`random_1_9`
          done
          
          # Define old type and position of the "randomized horse".
          HORSE_TYPE=`cat  horse_${MOVE_HORSE}_position | tail -n 1`
          COL=$(expr `cat  horse_${MOVE_HORSE}_position | head -n 1`)
          
          ADD_POS=1
          # Check if the current position is an handicap position. 
          if seq 10 7 68 | grep -w $COL &amp;&gt; /dev/null; then
                if grep -w $MOVE_HORSE $COL &amp;&gt; /dev/null; then
                      ADD_POS=0
                      grep -v -w  $MOVE_HORSE $COL &gt; ${COL}_new
                      rm -f $COL
                      mv -f ${COL}_new $COL
                      else ADD_POS=1
                fi 
          else ADD_POS=1
          fi
          COL=`expr $COL + $ADD_POS`
          echo $COL &gt;  horse_${MOVE_HORSE}_position  # Store new position.
                            
         # Choose the type of horse to draw.         
          case $HORSE_TYPE in 
                1) HORSE_TYPE=2; DRAW_HORSE=draw_horse_two
                ;;
                2) HORSE_TYPE=1; DRAW_HORSE=draw_horse_one 
          esac       
          echo $HORSE_TYPE &gt;&gt;  horse_${MOVE_HORSE}_position
          # Store current type.
         
          # Set foreground color to black and background to green.
          echo -ne '\E[30;42m'
          
          # Move the cursor to new horse position.
          tput cup `expr $MOVE_HORSE + 5` \
	  `cat  horse_${MOVE_HORSE}_position | head -n 1` 
          
          # Draw the horse.
          $DRAW_HORSE
           usleep $USLEEP_ARG
          
           # When all horses have gone beyond field line 15, reprint odds.
           touch fieldline15
           if [ $COL = 15 ]; then
             echo $MOVE_HORSE &gt;&gt; fieldline15  
           fi
           if [ `wc -l fieldline15 | cut -f1 -d " "` = 9 ]; then
               print_odds
               : &gt; fieldline15
           fi           
          
          # Define the leading horse.
          HIGHEST_POS=`cat *position | sort -n | tail -1`          
          
          # Set background color to white.
          echo -ne '\E[47m'
          tput cup 17 0
          echo -n Current leader: `grep -w $HIGHEST_POS *position | cut -c7`\
	  "                              "

done  

# Define the time the race finished.
FINISH_TIME=`date +%s`

# Set background color to green and enable blinking text.
echo -ne '\E[30;42m'
echo -en '\E[5m'

# Make the winning horse blink.
tput cup `expr $MOVE_HORSE + 5` \
`cat  horse_${MOVE_HORSE}_position | head -n 1`
$DRAW_HORSE

# Disable blinking text.
echo -en '\E[25m'

# Set foreground and background color to white.
echo -ne '\E[37;47m'
move_and_echo 18 1 $BLANK80

# Set foreground color to black.
echo -ne '\E[30m'

# Make winner blink.
tput cup 17 0
echo -e "\E[5mWINNER: $MOVE_HORSE\E[25m""  Odds: `cat odds_${MOVE_HORSE}`"\
"  Race time: `expr $FINISH_TIME - $START_TIME` secs"

# Restore cursor and old colors.
echo -en "\E[?25h"
echo -en "\E[0m"

# Restore echoing.
stty echo

# Remove race temp directory.
rm -rf $HORSE_RACE_TMP_DIR

tput cup 19 0

exit 0
</programlisting>
	    </example>

	<para>See also <xref linkend="hashexample" />, <xref linkend="homework" />, <xref linkend="showallc" />, and <xref linkend="petals" />.</para>

	<caution><para>There is, however, a major problem with all
	  this. <emphasis>ANSI escape sequences are emphatically
          <link linkend="portabilityissues">non-portable</link>.</emphasis>
          What works fine on some terminal emulators (or the
          console) may work differently, or not at all, on others.
          A <quote>colorized</quote> script that looks stunning on the
          script author's machine may produce unreadable output on
          someone else's. This somewhat compromises the usefulness of
          colorizing scripts, and possibly relegates this technique
          to the status of a gimmick. Colorized scripts are probably
          inappropriate in a commercial setting, i.e., your supervisor
          might disapprove.</para></caution>

        <para>Alister's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://code.google.com/p/ansi-color/">
          ansi-color</link> utility (based on <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/color-1.1.tar.gz">Moshe
          Jacobson's color utility</link> considerably simplifies using
          ANSI escape sequences. It substitutes a clean and logical
          syntax for the clumsy constructs just discussed.</para>

        <para>Henry/teikedvl has likewise created a utility (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://scriptechocolor.sourceforge.net/">http://scriptechocolor.sourceforge.net/</link>) to simplify creation of colorized scripts.</para>


      </section> <!-- "Colorizing" scripts -->



      <section xml:id="optimizations">
        <title>Optimizations</title>

	<para>Most shell scripts are quick 'n dirty solutions to non-complex
	  problems. As such, optimizing them for speed is not much of an
	  issue.  Consider the case, though, where a script carries out
	  an important task, does it well, but runs too slowly. Rewriting
	  it in a compiled language may not be a palatable option. The
	  simplest fix would be to rewrite the parts of the script
	  that slow it down. Is it possible to apply principles of code
	  optimization even to a lowly shell script?</para>

	<para>Check the loops in the script. Time consumed by repetitive
	  operations adds up quickly. If at all possible, remove
	  time-consuming operations from within loops.</para>

	<para>Use <link linkend="builtinref">builtin</link> commands in
	  preference to system commands. Builtins execute faster and
	  usually do not launch a subshell when invoked.</para>
	
	<para><anchor xml:id="catabuse" /></para>
	<para>Avoid unnecessary commands, particularly in a <link linkend="piperef">pipe</link>.
	    <programlisting>cat "$file" | grep "$word"

grep "$word" "$file"

#  The above command-lines have an identical effect,
#+ but the second runs faster since it launches one fewer subprocess.</programlisting>
	  The <link linkend="catref">cat</link> command seems especially
	  prone to overuse in scripts.</para>

  <para><anchor xml:id="lcall" /></para>
        <sidebar><para>Disabling certain Bash options can speed up scripts.</para>
                 <para>As Erik Brandsberg points out:</para>
                 <para>If you don't need <link linkend="unicoderef">Unicode</link> support, you can
                 get potentially a 2x or more improvement in speed by
		 simply setting the <userinput>LC_ALL</userinput> variable.

<programlisting>   export LC_ALL=C

   [specifies the locale as ANSI C,
   thereby disabling Unicode support]

[In an example script ...]

Without [Unicode support]:
erik@erik-desktop:~/capture$ time ./cap-ngrep.sh
live2.pcap &gt; out.txt

  real        0m20.483s
  user        1m34.470s
  sys         0m12.869s

With [Unicode support]:
erik@erik-desktop:~/capture$ time ./cap-ngrep.sh
live2.pcap &gt; out.txt

  real        0m50.232s
  user        3m51.118s
  sys         0m11.221s

A large part of the overhead that is optimized is, I believe,
regex match using [[ string =~ REGEX ]],
but it may help with other portions of the code as well.
I hadn't [seen it] mentioned that this optimization helped
with Bash, but I had seen it helped with "grep,"
so why not try?</programlisting></para></sidebar>

  <para><anchor xml:id="optimes" /></para>
	  <note><para>Certain operators, notably <link linkend="exprref">expr</link>, are very inefficient
          and might be replaced by <link linkend="dblparens">double
          parentheses</link> arithmetic expansion.
          See <xref linkend="testexectime" />.</para>
	  

<para><programlisting>Math tests

math via $(( ))
real          0m0.294s
user          0m0.288s
sys           0m0.008s

math via expr:
real          1m17.879s   # Much slower!
user          0m3.600s
sys           0m8.765s

math via let:
real          0m0.364s
user          0m0.372s
sys           0m0.000s</programlisting></para>


          <para><link linkend="ifthen">Condition testing</link>
            constructs in scripts deserve close scrutiny. Substitute
	    <link linkend="caseesac1">case</link> for <link linkend="ifthen">if-then</link> constructs and combine tests
	    when possible, to minimize script execution time. Again,
	    refer to <xref linkend="testexectime" />.</para>
 

          <para><programlisting>Test using "case" construct:
real          0m0.329s
user          0m0.320s
sys           0m0.000s


Test with if [], no quotes:
real          0m0.438s
user          0m0.432s
sys           0m0.008s


Test with if [], quotes:
real          0m0.476s
user          0m0.452s
sys           0m0.024s


Test with if [], using -eq:
real          0m0.457s
user          0m0.456s
sys           0m0.000s</programlisting></para></note>


  <para><anchor xml:id="assocarrtst" /></para>
	  <note><para>Erik Brandsberg recommends using <link linkend="assocarr">associative arrays</link> in preference to
	  conventional numeric-indexed arrays in most cases. When
	  overwriting values in a numeric array, there is a significant
	  performance penalty vs. associative arrays. Running a test
	  script confirms this. See <xref linkend="assocarrtest" />.</para>


  <para><programlisting>Assignment tests

Assigning a simple variable
real          0m0.418s
user          0m0.416s
sys           0m0.004s

Assigning a numeric index array entry
real          0m0.582s
user          0m0.564s
sys           0m0.016s

Overwriting a numeric index array entry
real          0m21.931s
user          0m21.913s
sys           0m0.016s

Linear reading of numeric index array
real          0m0.422s
user          0m0.416s
sys           0m0.004s

Assigning an associative array entry
real          0m1.800s
user          0m1.796s
sys           0m0.004s

Overwriting an associative array entry
real          0m1.798s
user          0m1.784s
sys           0m0.012s

Linear reading an associative array entry
real          0m0.420s
user          0m0.420s
sys           0m0.000s

Assigning a random number to a simple variable
real          0m0.402s
user          0m0.388s
sys           0m0.016s

Assigning a sparse numeric index array entry randomly into 64k cells
real          0m12.678s
user          0m12.649s
sys           0m0.028s

Reading sparse numeric index array entry
real          0m0.087s
user          0m0.084s
sys           0m0.000s

Assigning a sparse associative array entry randomly into 64k cells
real          0m0.698s
user          0m0.696s
sys           0m0.004s

Reading sparse associative index array entry
real          0m0.083s
user          0m0.084s
sys           0m0.000s</programlisting></para>
</note>


	<para>Use the <link linkend="timref">time</link> and <link linkend="timesref">times</link> tools to profile
	  computation-intensive commands. Consider rewriting time-critical
	  code sections in C, or even in assembler.</para>

	 <para>Try to minimize file I/O. Bash is not particularly
	   efficient at handling files, so consider using
	   more appropriate tools for this within the script,
	   such as <link linkend="awkref">awk</link> or <link linkend="perlref">Perl</link>.</para>

	 <para>Write your scripts in a modular and coherent form,
	   <footnote><para>This usually means liberal use of
	   <link linkend="functionref">functions</link>.</para></footnote>
	   so they can be reorganized and tightened up as necessary. Some
	   of the optimization techniques applicable to high-level
	   languages may work for scripts, but others, such as
	   <firstterm>loop unrolling</firstterm>, are mostly
	   irrelevant. Above all, use common sense.</para>

	 <para>For an excellent demonstration of how optimization can
	   dramatically reduce the  execution time of a script, see <xref linkend="monthlypmt" />.</para>

      </section> <!-- Optimizations -->



      <section xml:id="assortedtips">
        <title>Assorted Tips</title>


      <section>
      <title>Ideas for more powerful scripts</title>

       <itemizedlist>

	<listitem>

	   <para><anchor xml:id="pseudocoderef" /></para>
	   <para>You have a problem that you want to solve by writing a Bash
	     script. Unfortunately, you don't know quite where to start.
	     One method is to plunge right in and code those parts
	     of the script that come easily, and write the hard parts as
	     <firstterm>pseudo-code</firstterm>.</para>

           <para><programlisting>#!/bin/bash

ARGCOUNT=1                     # Need name as argument.
E_WRONGARGS=65

if [ number-of-arguments is-not-equal-to "$ARGCOUNT" ]
#    ^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^
#  Can't figure out how to code this . . .
#+ . . . so write it in pseudo-code.

then
  echo "Usage: name-of-script name"
  #            ^^^^^^^^^^^^^^     More pseudo-code.
  exit $E_WRONGARGS
fi 

. . .

exit 0


# Later on, substitute working code for the pseudo-code.

# Line 6 becomes:
if [ $# -ne "$ARGCOUNT" ]

# Line 12 becomes:
  echo "Usage: `basename $0` name"</programlisting></para>

	   <para>For an example of using pseudo-code, see the <link linkend="newtonsqrt">Square Root</link> exercise.</para>

	</listitem>


	<listitem>

	  <para><anchor xml:id="trackingscr" /></para>
	  <para>To keep a record of which user scripts have run
	    during a particular session or over a number of sessions,
	    add the following lines to each script you want to keep track
	    of. This will keep a continuing file record of the script
	    names and invocation times. </para>

	  <para>
	  <programlisting># Append (&gt;&gt;) following to end of each script tracked.

whoami&gt;&gt; $SAVE_FILE    # User invoking the script.
echo $0&gt;&gt; $SAVE_FILE   # Script name.
date&gt;&gt; $SAVE_FILE      # Date and time.
echo&gt;&gt; $SAVE_FILE      # Blank line as separator.

#  Of course, SAVE_FILE defined and exported as environmental variable in ~/.bashrc
#+ (something like ~/.scripts-run)</programlisting>
          </para>
	</listitem>

	<listitem>
	  <para><anchor xml:id="prependref" /></para>
	  <para>The <token>&gt;&gt;</token> operator
	    <firstterm>appends</firstterm> lines to a file.
	    What if you wish to <firstterm>prepend</firstterm> a
	    line to an existing file, that is, to paste it in at the
	    beginning?</para>

	  <para>
	  <programlisting>file=data.txt
title="***This is the title line of data text file***"

echo $title | cat - $file &gt;$file.new
# "cat -" concatenates stdout to $file.
#  End result is
#+ to write a new file with $title appended at *beginning*.</programlisting>
	  </para>

	  <para>This is a simplified variant of the <xref linkend="prependex" /> script given earlier.	And, of course,
	    <link linkend="sedref">sed</link> can also do this.</para>


	</listitem>

	<listitem>
	  <para><anchor xml:id="scriptasemb" /></para>
	  <para>A shell script may act as an embedded command inside
	    another shell script, a <firstterm>Tcl</firstterm> or
	    <firstterm>wish</firstterm> script, or even a <link linkend="makefileref">Makefile</link>. It can be invoked
	    as an external shell command in a C program using the
	    <replaceable>system()</replaceable> call, i.e.,
	   <replaceable>system("script_name");</replaceable>.</para>
	</listitem>

	<listitem>
	  <para><anchor xml:id="setvaremb" /></para>
          <para>Setting a variable to the contents of an embedded
	    <firstterm>sed</firstterm> or <firstterm>awk</firstterm>
	    script increases the readability of the surrounding <link linkend="shwrapper">shell wrapper</link>. See <xref linkend="mailformat" /> and <xref linkend="coltotaler3" />.</para>
	</listitem>

	<listitem>
          <para><anchor xml:id="libroutines" /></para>
	  <para>Put together files containing your favorite and most useful
	    definitions and functions.	As necessary,
	    <quote>include</quote> one or more of these
	    <quote>library files</quote> in scripts with either the
	    <link linkend="dotref">dot</link> (<command>.</command>)
	    or <link linkend="sourceref">source</link> command.</para>

	  <para>  
            <programlisting># SCRIPT LIBRARY
# ------ -------

# Note:
# No "#!" here.
# No "live code" either.


# Useful variable definitions

ROOT_UID=0             # Root has $UID 0.
E_NOTROOT=101          # Not root user error. 
MAXRETVAL=255          # Maximum (positive) return value of a function.
SUCCESS=0
FAILURE=-1



# Functions

Usage ()               # "Usage:" message.
{
  if [ -z "$1" ]       # No arg passed.
  then
    msg=filename
  else
    msg=$@
  fi

  echo "Usage: `basename $0` "$msg""
}  


Check_if_root ()       # Check if root running script.
{                      # From "ex39.sh" example.
  if [ "$UID" -ne "$ROOT_UID" ]
  then
    echo "Must be root to run this script."
    exit $E_NOTROOT
  fi
}  


CreateTempfileName ()  # Creates a "unique" temp filename.
{                      # From "ex51.sh" example.
  prefix=temp
  suffix=`eval date +%s`
  Tempfilename=$prefix.$suffix
}


isalpha2 ()            # Tests whether *entire string* is alphabetic.
{                      # From "isalpha.sh" example.
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!a-zA-Z]*|"") return $FAILURE;;
  *) return $SUCCESS;;
  esac                 # Thanks, S.C.
}


abs ()                           # Absolute value.
{                                # Caution: Max return value = 255.
  E_ARGERR=-999999

  if [ -z "$1" ]                 # Need arg passed.
  then
    return $E_ARGERR             # Obvious error value returned.
  fi

  if [ "$1" -ge 0 ]              # If non-negative,
  then                           #
    absval=$1                    # stays as-is.
  else                           # Otherwise,
    let "absval = (( 0 - $1 ))"  # change sign.
  fi  

  return $absval
}


tolower ()             #  Converts string(s) passed as argument(s)
{                      #+ to lowercase.

  if [ -z "$1" ]       #  If no argument(s) passed,
  then                 #+ send error message
    echo "(null)"      #+ (C-style void-pointer error message)
    return             #+ and return from function.
  fi  

  echo "$@" | tr A-Z a-z
  # Translate all passed arguments ($@).

  return

# Use command substitution to set a variable to function output.
# For example:
#    oldvar="A seT of miXed-caSe LEtTerS"
#    newvar=`tolower "$oldvar"`
#    echo "$newvar"    # a set of mixed-case letters
#
# Exercise: Rewrite this function to change lowercase passed argument(s)
#           to uppercase ... toupper()  [easy].
}</programlisting>
          </para>

	</listitem>

	<listitem>
	  <para><anchor xml:id="commenth" /></para>
	  <para>Use special-purpose comment headers to increase clarity
	    and legibility in scripts.</para>
	  <para><programlisting>## Caution.
rm -rf *.zzy   ##  The "-rf" options to "rm" are very dangerous,
               ##+ especially with wild cards.

#+ Line continuation.
#  This is line 1
#+ of a multi-line comment,
#+ and this is the final line.

#* Note.

#o List item.

#&gt; Another point of view.
while [ "$var1" != "end" ]    #&gt; while test "$var1" != "end"</programlisting></para>
	
	</listitem>

	<listitem>
	  <para><anchor xml:id="progbar" /></para>
	  <para>Dotan Barak contributes template code for a
	  <firstterm>progress bar</firstterm> in a script.</para>

	    <example xml:id="progressbar">
	      <title>A Progress Bar</title>
	      <programlisting>#!/bin/bash
# progress-bar.sh

# Author: Dotan Barak (very minor revisions by ABS Guide author).
# Used in ABS Guide with permission (thanks!).


BAR_WIDTH=50
BAR_CHAR_START="["
BAR_CHAR_END="]"
BAR_CHAR_EMPTY="."
BAR_CHAR_FULL="="
BRACKET_CHARS=2
LIMIT=100

print_progress_bar()
{
        # Calculate how many characters will be full.
        let "full_limit = ((($1 - $BRACKET_CHARS) * $2) / $LIMIT)"

        # Calculate how many characters will be empty.
        let "empty_limit = ($1 - $BRACKET_CHARS) - ${full_limit}"

        # Prepare the bar.
        bar_line="${BAR_CHAR_START}"
        for ((j=0; j&lt;full_limit; j++)); do
                bar_line="${bar_line}${BAR_CHAR_FULL}"
        done

        for ((j=0; j&lt;empty_limit; j++)); do
                bar_line="${bar_line}${BAR_CHAR_EMPTY}"
        done

        bar_line="${bar_line}${BAR_CHAR_END}"

        printf "%3d%% %s" $2 ${bar_line}
}

# Here is a sample of code that uses it.
MAX_PERCENT=100
for ((i=0; i&lt;=MAX_PERCENT; i++)); do
        #
        usleep 10000
        # ... Or run some other commands ...
        #
        print_progress_bar ${BAR_WIDTH} ${i}
        echo -en "\r"
done

echo ""

exit
</programlisting>
	    </example>
	</listitem>
	
	<listitem>
	  <para><anchor xml:id="comoutbl" /></para>
	  <para>A particularly clever use of <link linkend="testconstructs1">if-test</link> constructs
	    is for comment blocks.</para>
	      
	  <para>    
	      <programlisting>#!/bin/bash

COMMENT_BLOCK=
#  Try setting the above variable to some value
#+ for an unpleasant surprise.

if [ $COMMENT_BLOCK ]; then

Comment block --
=================================
This is a comment line.
This is another comment line.
This is yet another comment line.
=================================

echo "This will not echo."

Comment blocks are error-free! Whee!

fi

echo "No more comments, please."

exit 0</programlisting>
	  </para>    

	  <para>Compare this with <link linkend="cblock1">using  
	    here documents to comment out code blocks</link>.</para>    

	</listitem>

	<listitem>
	  <para><anchor xml:id="intparam" /></para>
	  <para>Using the <link linkend="xstatvarref">$? exit status
	    variable</link>, a script may test if a parameter contains
	    only digits, so it can be treated as an integer.</para>

	  <para>  
	    <programlisting>#!/bin/bash

SUCCESS=0
E_BADINPUT=85

test "$1" -ne 0 -o "$1" -eq 0 2&gt;/dev/null
# An integer is either equal to 0 or not equal to 0.
# 2&gt;/dev/null suppresses error message.

if [ $? -ne "$SUCCESS" ]
then
  echo "Usage: `basename $0` integer-input"
  exit $E_BADINPUT
fi

let "sum = $1 + 25"             # Would give error if $1 not integer.
echo "Sum = $sum"

# Any variable, not just a command-line parameter, can be tested this way.

exit 0</programlisting>
          </para>
	</listitem>


        <listitem>

	  <para><anchor xml:id="rvt" />The 0 - 255 range for function return
	    values is a severe limitation. Global variables and
	    other workarounds are often problematic. An alternative
	    method for a function to communicate a value back to
	    the main body of the script is to have the function
	    write to <filename>stdout</filename> (usually with
	    <link linkend="echoref">echo</link>) the <quote>return
	    value,</quote> and assign this to a variable. This is
	    actually a variant of <link linkend="commandsubref">command
	    substitution.</link></para>

	    <example xml:id="multiplication">
	      <title>Return value trickery</title>
	      <programlisting>#!/bin/bash
# multiplication.sh

multiply ()                     # Multiplies params passed.
{                               # Will accept a variable number of args.

  local product=1

  until [ -z "$1" ]             # Until uses up arguments passed...
  do
    let "product *= $1"
    shift
  done

  echo $product                 #  Will not echo to stdout,
}                               #+ since this will be assigned to a variable.

mult1=15383; mult2=25211
val1=`multiply $mult1 $mult2`
# Assigns stdout (echo) of function to the variable val1.
echo "$mult1 X $mult2 = $val1"                   # 387820813

mult1=25; mult2=5; mult3=20
val2=`multiply $mult1 $mult2 $mult3`
echo "$mult1 X $mult2 X $mult3 = $val2"          # 2500

mult1=188; mult2=37; mult3=25; mult4=47
val3=`multiply $mult1 $mult2 $mult3 $mult4`
echo "$mult1 X $mult2 X $mult3 X $mult4 = $val3" # 8173300

exit 0
</programlisting>
	    </example>

	  <para>The same technique also works for alphanumeric
	    strings. This means that a function can <quote>return</quote>
	    a non-numeric value.</para>
	    
	  <para>
	  <programlisting>capitalize_ichar ()          #  Capitalizes initial character
{                            #+ of argument string(s) passed.

  string0="$@"               # Accepts multiple arguments.

  firstchar=${string0:0:1}   # First character.
  string1=${string0:1}       # Rest of string(s).

  FirstChar=`echo "$firstchar" | tr a-z A-Z`
                             # Capitalize first character.

  echo "$FirstChar$string1"  # Output to stdout.

}  

newstring=`capitalize_ichar "every sentence should start with a capital letter."`
echo "$newstring"          # Every sentence should start with a capital letter.</programlisting> 
	  </para>

	  <para>It is even possible for a function to <quote>return</quote>
	    multiple values with this method.</para>

	    <example xml:id="sumproduct">
	      <title>Even more return value trickery</title>
	      <programlisting>#!/bin/bash
# sum-product.sh
# A function may "return" more than one value.

sum_and_product ()   # Calculates both sum and product of passed args.
{
  echo $(( $1 + $2 )) $(( $1 * $2 ))
# Echoes to stdout each calculated value, separated by space.
}

echo
echo "Enter first number "
read first

echo
echo "Enter second number "
read second
echo

retval=`sum_and_product $first $second`      # Assigns output of function.
sum=`echo "$retval" | awk '{print $1}'`      # Assigns first field.
product=`echo "$retval" | awk '{print $2}'`  # Assigns second field.

echo "$first + $second = $sum"
echo "$first * $second = $product"
echo

exit 0
</programlisting>
	    </example>

          <caution><para><anchor xml:id="rvtcaution" />There can be only
	    <command>one</command> <firstterm>echo</firstterm> statement
	    in the function for this to work. If you alter the previous
	    example:</para>

	      <para><programlisting>sum_and_product ()
{
  echo "This is the sum_and_product function." # This messes things up!
  echo $(( $1 + $2 )) $(( $1 * $2 ))
}
...
retval=`sum_and_product $first $second`      # Assigns output of function.
# Now, this will not work correctly.</programlisting></para></caution>


	</listitem>

        <listitem>
	  <para><anchor xml:id="passarray" /></para>
	  <para>Next in our bag of tricks are techniques for passing
	    an <link linkend="arrayref">array</link> to a
	    <link linkend="functionref">function</link>, then
	    <quote>returning</quote> an array back to the main body of
	    the script.</para>

	  <para>Passing an array involves loading the space-separated
	    elements of the array into a variable with <link linkend="commandsubref">command substitution</link>. <anchor xml:id="retarray" />Getting an array back as the <quote>return
	    value</quote> from a function uses the previously mentioned
	    strategem of <link linkend="echoref">echoing</link> the
	    array in the function, then invoking command substitution
	    and the <command>( ... )</command> operator to assign it to
	    an array.</para>

	    <example xml:id="arrfunc">
	      <title>Passing and returning arrays</title>
	      <programlisting>#!/bin/bash
# array-function.sh: Passing an array to a function and ...
#                   "returning" an array from a function


Pass_Array ()
{
  local passed_array   # Local variable!
  passed_array=( `echo "$1"` )
  echo "${passed_array[@]}"
  #  List all the elements of the new array
  #+ declared and set within the function.
}


original_array=( element1 element2 element3 element4 element5 )

echo
echo "original_array = ${original_array[@]}"
#                      List all elements of original array.


# This is the trick that permits passing an array to a function.
# **********************************
argument=`echo ${original_array[@]}`
# **********************************
#  Pack a variable
#+ with all the space-separated elements of the original array.
#
# Attempting to just pass the array itself will not work.


# This is the trick that allows grabbing an array as a "return value".
# *****************************************
returned_array=( `Pass_Array "$argument"` )
# *****************************************
# Assign 'echoed' output of function to array variable.

echo "returned_array = ${returned_array[@]}"

echo "============================================================="

#  Now, try it again,
#+ attempting to access (list) the array from outside the function.
Pass_Array "$argument"

# The function itself lists the array, but ...
#+ accessing the array from outside the function is forbidden.
echo "Passed array (within function) = ${passed_array[@]}"
# NULL VALUE since the array is a variable local to the function.

echo

############################################

# And here is an even more explicit example:

ret_array ()
{
  for element in {11..20}
  do
    echo "$element "   #  Echo individual elements
  done                 #+ of what will be assembled into an array.
}

arr=( $(ret_array) )   #  Assemble into array.

echo "Capturing array \"arr\" from function ret_array () ..."
echo "Third element of array \"arr\" is ${arr[2]}."   # 13  (zero-indexed)
echo -n "Entire array is: "
echo ${arr[@]}                # 11 12 13 14 15 16 17 18 19 20

echo

exit 0

#  Nathan Coulter points out that passing arrays with elements containing
#+ whitespace breaks this example.
</programlisting>
	    </example>

	  <para>For a more elaborate example of passing arrays to
	    functions, see <xref linkend="lifeslow" />.</para>

        </listitem>

        <listitem>
	  <para><anchor xml:id="cstyle" /></para>
	  <para>Using the <link linkend="dblparens">double-parentheses
	    construct</link>, it is possible to use C-style syntax
	    for setting and incrementing/decrementing variables
	    and in <link linkend="forloopref1">for</link> and <link linkend="whileloopref">while</link> loops.	See <xref linkend="forloopc" /> and <xref linkend="whloopc" />.</para>
	</listitem>

	<listitem>
	  <para><anchor xml:id="setpum" /></para>
	  <para>Setting the <link linkend="pathref">path</link> and <link linkend="umaskref">umask</link> at the beginning of a script makes
	    it more <link linkend="portabilityissues">portable</link>
	    -- more likely to run on a <quote>foreign</quote> machine
	    whose user may have bollixed up the <varname>$PATH</varname>
	    and <command>umask</command>.
	      <programlisting>#!/bin/bash
PATH=/bin:/usr/bin:/usr/local/bin ; export PATH
umask 022   # Files that the script creates will have 755 permission.

# Thanks to Ian D. Allen, for this tip.</programlisting></para>
	</listitem>

        <listitem>
	  <para><anchor xml:id="filteroutp" /></para>
	  <para>A useful scripting technique is to
	    <emphasis>repeatedly</emphasis> feed the output of a filter
	    (by piping) back to the <emphasis>same filter</emphasis>, but
	    with a different set of arguments and/or options. Especially
	    suitable for this are <link linkend="trref">tr</link> and
	    <link linkend="grepref">grep</link>.</para>

	  <para>
	  <programlisting># From "wstrings.sh" example.

wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`</programlisting>
	  </para>

	    <example xml:id="agram">
	      <title>Fun with anagrams</title>
	      <programlisting>#!/bin/bash
# agram.sh: Playing games with anagrams.

# Find anagrams of...
LETTERSET=etaoinshrdlu
FILTER='.......'       # How many letters minimum?
#       1234567

anagram "$LETTERSET" | # Find all anagrams of the letterset...
grep "$FILTER" |       # With at least 7 letters,
grep '^is' |           # starting with 'is'
grep -v 's$' |         # no plurals
grep -v 'ed$'          # no past tense verbs
# Possible to add many combinations of conditions and filters.

#  Uses "anagram" utility
#+ that is part of the author's "yawl" word list package.
#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
#  http://bash.deta.in/yawl-0.3.2.tar.gz

exit 0                 # End of code.


bash$ sh agram.sh
islander
isolate
isolead
isotheral



#  Exercises:
#  ---------
#  Modify this script to take the LETTERSET as a command-line parameter.
#  Parameterize the filters in lines 11 - 13 (as with $FILTER),
#+ so that they can be specified by passing arguments to a function.

#  For a slightly different approach to anagramming,
#+ see the agram2.sh script.
</programlisting>
	    </example>

	  <para>See also <xref linkend="constat" />, <xref linkend="cryptoquote" />, and <xref linkend="soundex" />.</para>

	</listitem>

	<listitem>
	  <para><anchor xml:id="commblahd" /></para>
	  <para>Use <quote><link linkend="anonheredoc0">anonymous here
	    documents</link></quote> to comment out blocks of code,
	    to save having to individually comment out each line with
	    a <token>#</token>.  See <xref linkend="commentblock" />.</para>
	</listitem>

	<listitem>
	  <para><anchor xml:id="whatisref3" /></para>
	  <para>Running a script on a machine that relies on a command
	    that might not be installed is dangerous. Use <link linkend="whatisref">whatis</link> to avoid potential problems
	    with this.</para>

	  <para>
	    <programlisting>CMD=command1                 # First choice.
PlanB=command2               # Fallback option.

command_test=$(whatis "$CMD" | grep 'nothing appropriate')
#  If 'command1' not found on system , 'whatis' will return
#+ "command1: nothing appropriate."
#
#  A safer alternative is:
#     command_test=$(whereis "$CMD" | grep \/)
#  But then the sense of the following test would have to be reversed,
#+ since the $command_test variable holds content only if
#+ the $CMD exists on the system.
#     (Thanks, bojster.)


if [[ -z "$command_test" ]]  # Check whether command present.
then
  $CMD option1 option2       #  Run command1 with options.
else                         #  Otherwise,
  $PlanB                     #+ run command2. 
fi</programlisting>
          </para>
	</listitem>

	<listitem>

	  <para><anchor xml:id="ifgrepfix" /></para>
	  <para>An <link linkend="ifgrepref">if-grep test</link> may not
	    return expected results in an error case, when text is output to
	    <filename>stderr</filename>, rather that
	    <filename>stdout</filename>.
	      <programlisting>if ls -l nonexistent_filename | grep -q 'No such file or directory'
  then echo "File \"nonexistent_filename\" does not exist."
fi</programlisting></para>

          <para><link linkend="ioredirref">Redirecting</link>
	    <filename>stderr</filename> to <filename>stdout</filename> fixes
	    this.
	      <programlisting>if ls -l nonexistent_filename 2&gt;&amp;1 | grep -q 'No such file or directory'
#                             ^^^^
  then echo "File \"nonexistent_filename\" does not exist."
fi

# Thanks, Chris Martin, for pointing this out.</programlisting></para>

	</listitem>


	<listitem>

      <para><anchor xml:id="subshtmp" />
        If you absolutely must access a subshell variable outside the
	subshell, here's a way to do it.
	  <programlisting>TMPFILE=tmpfile                  # Create a temp file to store the variable.

(   # Inside the subshell ...
inner_variable=Inner
echo $inner_variable
echo $inner_variable &gt;&gt;$TMPFILE  # Append to temp file.
)

    # Outside the subshell ...

echo; echo "-----"; echo
echo $inner_variable             # Null, as expected.
echo "-----"; echo

# Now ...
read inner_variable &lt;$TMPFILE    # Read back shell variable.
rm -f "$TMPFILE"                 # Get rid of temp file.
echo "$inner_variable"           # It's an ugly kludge, but it works.</programlisting>
	</para>

	</listitem>


	<listitem>
	  <para><anchor xml:id="runpartsref2" /></para>
	  <para>The <link linkend="runpartsref">run-parts</link>
	    command is handy for running a set of command
	    scripts in a particular sequence, especially in
	    combination with <link linkend="cronref">cron</link> or
	    <link linkend="atref">at</link>.</para>
	</listitem>


	<listitem>
	  <para><anchor xml:id="rcsref" /></para>
	  <para>For doing multiple revisions on a complex script, use the
	    <firstterm>rcs</firstterm> Revision Control System package.</para>

	  <para> Among other benefits of this is automatically updated ID
	    header tags. The <command>co</command> command in
	    <firstterm>rcs</firstterm> does a parameter replacement of
	    certain reserved key words, for example, replacing
	    <parameter># $Id$</parameter> in a script with something like:
	      <programlisting># $Id$</programlisting></para>

	</listitem>


      </itemizedlist>

	</section>


	<section>
      <title>Widgets</title>

	  <para><anchor xml:id="widgetref" /></para>
	  <para>It would be nice to be able to invoke X-Windows widgets
	    from a shell script. There happen to exist several packages
	    that purport to do so, namely <firstterm>Xscript</firstterm>,
	    <firstterm>Xmenu</firstterm>, and <firstterm>widtools</firstterm>.
	    The first two of these no longer seem
	    to be maintained.  Fortunately, it is still
	    possible to obtain <firstterm>widtools</firstterm> <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.batse.msfc.nasa.gov/~mallozzi/home/software/xforms/src/widtools-2.0.tgz">here</link>.
	    </para>

	  <caution><para>The <firstterm>widtools</firstterm> (widget tools)
	    package requires the <firstterm>XForms</firstterm> library to
	    be installed. Additionally, the <link linkend="makefileref">Makefile</link> needs some judicious
	    editing before the package will build on a typical Linux
	    system. Finally, three of the six widgets offered do not work
	    (and, in fact, segfault).</para></caution>


          <para><anchor xml:id="dialogref" /></para>

	  <para>The <firstterm>dialog</firstterm> family of tools offers a method
	    of calling <quote>dialog</quote> widgets from a shell script. The
	    original <firstterm>dialog</firstterm> utility works in a text
	    console, but its successors, <firstterm>gdialog</firstterm>,
	    <firstterm>Xdialog</firstterm>, and <firstterm>kdialog</firstterm>
	    use X-Windows-based widget sets.</para>

    <example xml:id="dialog">
      <title>Widgets invoked from a shell script</title>
      <programlisting>#!/bin/bash
# dialog.sh: Using 'gdialog' widgets.

# Must have 'gdialog' installed on your system to run this script.
# Or, you can replace all instance of 'gdialog' below with 'kdialog' ...
# Version 1.1 (corrected 04/05/05)

# This script was inspired by the following article.
#     "Scripting for X Productivity," by Marco Fioretti,
#      LINUX JOURNAL, Issue 113, September 2003, pp. 86-9.
# Thank you, all you good people at LJ.


# Input error in dialog box.
E_INPUT=85
# Dimensions of display, input widgets.
HEIGHT=50
WIDTH=60

# Output file name (constructed out of script name).
OUTFILE=$0.output

# Display this script in a text widget.
gdialog --title "Displaying: $0" --textbox $0 $HEIGHT $WIDTH



# Now, we'll try saving input in a file.
echo -n "VARIABLE=" &gt; $OUTFILE
gdialog --title "User Input" --inputbox "Enter variable, please:" \
$HEIGHT $WIDTH 2&gt;&gt; $OUTFILE


if [ "$?" -eq 0 ]
# It's good practice to check exit status.
then
  echo "Executed \"dialog box\" without errors."
else
  echo "Error(s) in \"dialog box\" execution."
        # Or, clicked on "Cancel", instead of "OK" button.
  rm $OUTFILE
  exit $E_INPUT
fi



# Now, we'll retrieve and display the saved variable.
. $OUTFILE   # 'Source' the saved file.
echo "The variable input in the \"input box\" was: "$VARIABLE""


rm $OUTFILE  # Clean up by removing the temp file.
             # Some applications may need to retain this file.

exit $?

# Exercise: Rewrite this script using the 'zenity' widget set.
</programlisting>
    </example>

	  <para><anchor xml:id="xmessageref2" />
	    The <link linkend="xmessageref">xmessage</link> command is
	    a simple method of popping up a message/query window. For
	    example:
	      <programlisting>xmessage Fatal error in script! -button exit</programlisting>
	  </para>

	  <para><anchor xml:id="zenityref2" />
	    The latest entry in the widget sweepstakes is
	    <link linkend="zenityref">zenity</link>.
	    This utility pops up
	    <firstterm>GTK+</firstterm> dialog widgets-and-windows,
	    and it works very nicely within a script.
	      <programlisting>get_info ()
{
  zenity --entry       #  Pops up query window . . .
                       #+ and prints user entry to stdout.

                       #  Also try the --calendar and --scale options.
}

answer=$( get_info )   #  Capture stdout in $answer variable.

echo "User entered: "$answer""</programlisting>
	  </para>

	  <para>For other methods of scripting with widgets, try
	    <firstterm>Tk</firstterm> or <firstterm>wish</firstterm>
	    (<firstterm>Tcl</firstterm> derivatives),
	    <firstterm>PerlTk</firstterm> (<firstterm>Perl</firstterm>
	    with <firstterm>Tk</firstterm> extensions),
	    <firstterm>tksh</firstterm> (<firstterm>ksh</firstterm>
	    with <firstterm>Tk</firstterm> extensions),
	    <firstterm>XForms4Perl</firstterm>
	    (<firstterm>Perl</firstterm> with
	    <firstterm>XForms</firstterm> extensions),
	    <firstterm>Gtk-Perl</firstterm> (<firstterm>Perl</firstterm>
	    with <firstterm>Gtk</firstterm> extensions), or
	    <firstterm>PyQt</firstterm> (<firstterm>Python</firstterm>
	    with <firstterm>Qt</firstterm> extensions).</para>

	</section>



      </section> <!-- Assorted Tips -->



      <section xml:id="securityissues">
        <title>Security Issues</title>

      <section xml:id="infectedscripts">
        <title>Infected Shell Scripts</title>

	<para><anchor xml:id="infectedscripts1" /></para>
	<para>A brief warning about script security is indicated.
	  A shell script may contain a <firstterm>worm</firstterm>,
	  <firstterm>trojan</firstterm>, or even a
	  <firstterm>virus</firstterm>. For that reason, never run
	  as <firstterm>root</firstterm> a script (or permit it to
	  be inserted into the system startup scripts in <filename class="directory">/etc/rc.d</filename>) unless you have obtained
	  said script from a trusted source or you have carefully analyzed
	  it to make certain it does nothing harmful.</para>

	<para>Various researchers at Bell Labs and other sites, including M.
	  Douglas McIlroy, Tom Duff, and Fred Cohen have investigated the
	  implications of shell script viruses. They conclude that it is
	  all too easy for even a novice, a <quote>script kiddie,</quote>
	  to write one.
	    <footnote><para>See Marius van Oers' article, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.virusbtn.com/magazine/archives/200204/malshell.xml">Unix
	      Shell Scripting Malware</link>, and also the
	      <link linkend="denningref"><emphasis>Denning</emphasis>
	      reference</link> in the
	      <firstterm>bibliography</firstterm>.</para></footnote>
	  </para>

	<para>Here is yet another reason to learn scripting. Being able to
	  look at and understand scripts may protect your system from
	  being compromised by a rogue script.</para>

     </section> <!-- Infected Shell Scripts -->

      <section xml:id="hidingsource">
        <title>Hiding Shell Script Source</title>

	<para>For security purposes, it may be necessary to render a script
	  unreadable. If only there were a utility to create a stripped
	  binary executable from a script. Francisco Rosales' <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.datsi.fi.upm.es/~frosal/sources/">shc --
	  generic shell script compiler</link> does exactly that.</para>

	<para>Unfortunately, according to <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxjournal.com/article/8256">an article</link> in
	 the October, 2005 <emphasis>Linux Journal</emphasis>,
	 the binary can, in at least some cases, be decrypted to recover
	 the original script source. Still, this could be a useful
	 method of keeping scripts secure from all but the most skilled
	 hackers.</para>

     </section> <!-- Hiding Shell Script Source -->


      <section xml:id="securitytips">
        <title>Writing Secure Shell Scripts</title>

	<para><anchor xml:id="securitytips1" /></para>
	<para><emphasis>Dan Stromberg</emphasis> suggests the following
	  guidelines for writing (relatively) secure shell scripts.</para>

        <para>
         <itemizedlist>

	  <listitem>
	    <para>Don't put secret data in <link linkend="envref">environment variables</link>.</para>
	  </listitem>

	  <listitem>
	    <para>Don't pass secret data in an external
	      command's arguments (pass them in via a <link linkend="piperef">pipe</link> or <link linkend="ioredirref">redirection</link> instead).</para>
	  </listitem>

	  <listitem>
	    <para>Set your <link linkend="pathref">$PATH</link>
	      carefully. Don't just trust whatever path you
	      inherit from the caller if your script is running as
	      <firstterm>root</firstterm>. In fact, whenever you use
	      an environment variable inherited from the caller, think
	      about what could happen if the caller put something
	      misleading in the variable, e.g., if the caller set
	      <link linkend="homedirref">$HOME</link> to <filename class="directory">/etc</filename>.</para>
	  </listitem>

         </itemizedlist>
        </para>

     </section> <!-- Security Tips -->

      </section> <!-- Security -->



      <section xml:id="portabilityissues">
        <title>Portability Issues</title>

    <epigraph>
      <para>It is easier to port a shell than a shell script.</para>
      <para>--Larry Wall</para>
    </epigraph>

	<para>This book deals specifically with Bash scripting on
	  a GNU/Linux system. All the same, users of <command>sh</command>
	  and <command>ksh</command> will find much of value here.</para>

	<para><anchor xml:id="posix3ref" />As it happens, many of the various
	  shells and scripting languages seem to be converging toward the
	  <link linkend="posix2ref">POSIX</link> 1003.2 standard. Invoking
	  Bash with the <option>--posix</option> option or inserting
	  a <command>set -o posix</command> at the head of a script
	  causes Bash to conform very closely to this standard. Another
	  alternative is to use a <firstterm>#!/bin/sh</firstterm> <link linkend="shabangref">sha-bang header</link> in the script,
	  rather than <firstterm>#!/bin/bash</firstterm>.

	    <footnote><para>Or, better yet, <link linkend="envv2ref">#!/bin/env sh</link>.</para></footnote>

	  Note that <filename>/bin/sh</filename> is a <link linkend="linkref">link</link> to <filename>/bin/bash</filename>
	  in Linux and certain other flavors of UNIX, and a script invoked
	  this way disables extended Bash functionality.</para>

	<para>Most Bash scripts will run as-is under
	  <command>ksh</command>, and vice-versa, since Chet Ramey has
	  been busily porting <command>ksh</command> features to the
	  latest versions of Bash.</para>

	<para>On a commercial UNIX machine, scripts using GNU-specific
	  features of standard commands may not work. This has become less
	  of a problem in the last few years, as the GNU utilities have
	  pretty much displaced their proprietary
	  counterparts even on <quote>big-iron</quote> UNIX.
	  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://linux.oreillynet.com/pub/a/linux/2002/02/28/caldera.html">Caldera's
	  release of the source</link> to many of the original UNIX
	  utilities has accelerated the trend.</para>

	<para><anchor xml:id="bashcompat" /></para>
	<para>Bash has certain features that the traditional <link linkend="bashdef">Bourne shell</link> lacks. Among these are:

	<itemizedlist>

	<listitem>
	<para>Certain extended <link linkend="invocationoptionsref">invocation options</link></para>
	</listitem>

        <listitem>
	<para><link linkend="commandsubref">Command substitution</link> using
	  <command>$(    )</command> notation</para>
	</listitem>

        <listitem>
          <para><link linkend="braceexpref3">Brace expansion</link></para>
	</listitem>

        <listitem>
          <para>Certain <link linkend="arrayref">array</link> operations,
          and <link linkend="assocarr">associative arrays</link></para>
	</listitem>

	<listitem>
	<para>The <link linkend="dblbrackets">double brackets</link>
	  extended test construct</para>
	</listitem>

	<listitem>
	<para>The <link linkend="dblparensref">double-parentheses</link>
	  arithmetic-evaluation construct</para>
	</listitem>

	<listitem>
	<para>Certain <link linkend="stringmanip">string manipulation</link>
	  operations</para>
	</listitem>

	<listitem>
	<para><link linkend="processsubref">Process substitution</link></para>
	</listitem>

	<listitem>
	<para>A Regular Expression <link linkend="regexmatchref">matching
	  operator</link></para>
	</listitem>

	<listitem>
	<para>Bash-specific <link linkend="builtinref">builtins</link></para>
	</listitem>

	<listitem>
        <para><link linkend="coprocref">Coprocesses</link></para>
	</listitem>

	</itemizedlist>
	</para>

	<para>See the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="ftp://ftp.cwru.edu/pub/bash/FAQ">Bash
	   F.A.Q.</link> for a complete listing.</para>

       <section> <!-- A Test Suite -->
         <title>A Test Suite</title>

	 <para><anchor xml:id="testsuite0" />Let us illustrate some of the
	   incompatibilities between Bash and the classic
	   Bourne shell. Download and install the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://freshmeat.net/projects/bournesh"><quote>Heirloom
	   Bourne Shell</quote></link> and run the following
	   script, first using Bash, then the classic
	   <firstterm>sh</firstterm>.</para>

      <example xml:id="testsuite">
	<title>Test Suite</title>
	<programlisting>#!/bin/bash
# test-suite.sh
# A partial Bash compatibility test suite.
# Run this on your version of Bash, or some other shell.

default_option=FAIL         # Tests below will fail unless . . .

echo
echo -n "Testing "
sleep 1; echo -n ". "
sleep 1; echo -n ". "
sleep 1; echo ". "
echo

# Double brackets
String="Double brackets supported?"
echo -n "Double brackets test: "
if [[ "$String" = "Double brackets supported?" ]]
then
  echo "PASS"
else
  echo "FAIL"
fi


# Double brackets and regex matching
String="Regex matching supported?"
echo -n "Regex matching: "
if [[ "$String" =~ R.....matching* ]]
then
  echo "PASS"
else
  echo "FAIL"
fi


# Arrays
test_arr=$default_option     # FAIL
Array=( If supports arrays will print PASS )
test_arr=${Array[5]}
echo "Array test: $test_arr"


# Command Substitution
csub_test ()
{
  echo "PASS"
}

test_csub=$default_option    # FAIL
test_csub=$(csub_test)
echo "Command substitution test: $test_csub"

echo

#  Completing this script is an exercise for the reader.
#  Add to the above similar tests for double parentheses,
#+ brace expansion, process substitution, etc.

exit $?
</programlisting>
      </example>

       </section> <!-- End: A Test Suite -->

      </section> <!-- Portability Issues -->



      <section xml:id="winscript">
        <title>Shell Scripting Under Windows</title>

	<para>Even users running <emphasis>that other</emphasis> OS can
	  run UNIX-like shell scripts, and therefore benefit
	  from many of the lessons of this book. The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceware.cygnus.com/cygwin/">
	  Cygwin</link> package from Cygnus and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.mkssoftware.com/">MKS utilities</link> from
	  Mortice Kern Associates add shell scripting capabilities to
	  Windows.</para>

        <para>Another alternative is <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www2.research.att.com/~gsf/download/uwin/uwin.html">
	 UWIN</link>, written by David Korn of AT&amp;T, of <link linkend="kornshellref">Korn Shell</link> fame.</para>

	<para>In 2006, Microsoft released the <trademark class="registered">Windows Powershell</trademark>,
	  which contains limited Bash-like command-line scripting
	  capabilities.</para>

      </section> <!-- Shell Scripting Under Windows -->



  </chapter> <!-- Miscellany -->



  <chapter xml:id="bash2">
    <title>Bash, versions 2, 3, and 4</title>

    <section xml:id="bashver2">
      <title>Bash, version 2</title>

      <para><anchor xml:id="bash2ref" /></para>

      <para>
        The current version of <firstterm>Bash</firstterm>, the one
	you have running on your machine, is most likely version 2.xx.yy,
	3.xx.yy, or 4.xx.yy.
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>3.2.25(1)-release</computeroutput>
	      </screen>
      </para>

      <para>The  version 2 update of the classic Bash scripting language
	added array variables, string and parameter expansion, and
	a better method of indirect variable references, among other
	features.</para>

      <example xml:id="ex77">
	<title>String expansion</title>
	<programlisting>#!/bin/bash

# String expansion.
# Introduced with version 2 of Bash.

#  Strings of the form $'xxx'
#+ have the standard escaped characters interpreted. 

echo $'Ringing bell 3 times \a \a \a'
     # May only ring once with certain terminals.
     # Or ...
     # May not ring at all, depending on terminal settings.
echo $'Three form feeds \f \f \f'
echo $'10 newlines \n\n\n\n\n\n\n\n\n\n'
echo $'\102\141\163\150'
     #   B   a   s   h
     # Octal equivalent of characters.

exit
</programlisting>
      </example>

      <para><anchor xml:id="varrefnew" /></para>
      <example xml:id="ex78">
	<title>Indirect variable references - the new way</title>
	<programlisting>#!/bin/bash

# Indirect variable referencing.
# This has a few of the attributes of references in C++.


a=letter_of_alphabet
letter_of_alphabet=z

echo "a = $a"           # Direct reference.

echo "Now a = ${!a}"    # Indirect reference.
#  The ${!variable} notation is more intuitive than the old
#+ eval var1=\$$var2

echo

t=table_cell_3
table_cell_3=24
echo "t = ${!t}"                      # t = 24
table_cell_3=387
echo "Value of t changed to ${!t}"    # 387
# No 'eval' necessary.

#  This is useful for referencing members of an array or table,
#+ or for simulating a multi-dimensional array.
#  An indexing option (analogous to pointer arithmetic)
#+ would have been nice. Sigh.

exit 0

# See also, ind-ref.sh example.
</programlisting>
      </example>
	
      <example xml:id="resistor">
	<title>Simple database application, using indirect variable
	  referencing</title>
	<programlisting>#!/bin/bash
# resistor-inventory.sh
# Simple database / table-lookup application.

# ============================================================== #
# Data

B1723_value=470                                   # Ohms
B1723_powerdissip=.25                             # Watts
B1723_colorcode="yellow-violet-brown"             # Color bands
B1723_loc=173                                     # Where they are
B1723_inventory=78                                # How many

B1724_value=1000
B1724_powerdissip=.25
B1724_colorcode="brown-black-red"
B1724_loc=24N
B1724_inventory=243

B1725_value=10000
B1725_powerdissip=.125
B1725_colorcode="brown-black-orange"
B1725_loc=24N
B1725_inventory=89

# ============================================================== #


echo

PS3='Enter catalog number: '

echo

select catalog_number in "B1723" "B1724" "B1725"
do
  Inv=${catalog_number}_inventory
  Val=${catalog_number}_value
  Pdissip=${catalog_number}_powerdissip
  Loc=${catalog_number}_loc
  Ccode=${catalog_number}_colorcode

  echo
  echo "Catalog number $catalog_number:"
  # Now, retrieve value, using indirect referencing.
  echo "There are ${!Inv} of  [${!Val} ohm / ${!Pdissip} watt]\
  resistors in stock."  #        ^             ^
  # As of Bash 4.2, you can replace "ohm" with \u2126 (using echo -e).
  echo "These are located in bin # ${!Loc}."
  echo "Their color code is \"${!Ccode}\"."

  break
done

echo; echo

# Exercises:
# ---------
# 1) Rewrite this script to read its data from an external file.
# 2) Rewrite this script to use arrays,
#+   rather than indirect variable referencing.
#    Which method is more straightforward and intuitive?
#    Which method is easier to code?


# Notes:
# -----
#  Shell scripts are inappropriate for anything except the most simple
#+ database applications, and even then it involves workarounds and kludges.
#  Much better is to use a language with native support for data structures,
#+ such as C++ or Java (or even Perl).

exit 0
</programlisting>
      </example>

      <example xml:id="cards">
	<title>Using arrays and other miscellaneous trickery
	  to deal four random hands from a deck of cards</title>
	<programlisting>#!/bin/bash
# cards.sh

# Deals four random hands from a deck of cards.

UNPICKED=0
PICKED=1

DUPE_CARD=99

LOWER_LIMIT=0
UPPER_LIMIT=51
CARDS_IN_SUIT=13
CARDS=52

declare -a Deck
declare -a Suits
declare -a Cards
#  It would have been easier to implement and more intuitive
#+ with a single, 3-dimensional array.
#  Perhaps a future version of Bash will support multidimensional arrays.


initialize_Deck ()
{
i=$LOWER_LIMIT
until [ "$i" -gt $UPPER_LIMIT ]
do
  Deck[i]=$UNPICKED   # Set each card of "Deck" as unpicked.
  let "i += 1"
done
echo
}

initialize_Suits ()
{
Suits[0]=C #Clubs
Suits[1]=D #Diamonds
Suits[2]=H #Hearts
Suits[3]=S #Spades
}

initialize_Cards ()
{
Cards=(2 3 4 5 6 7 8 9 10 J Q K A)
# Alternate method of initializing an array.
}

pick_a_card ()
{
card_number=$RANDOM
let "card_number %= $CARDS" # Restrict range to 0 - 51, i.e., 52 cards.
if [ "${Deck[card_number]}" -eq $UNPICKED ]
then
  Deck[card_number]=$PICKED
  return $card_number
else  
  return $DUPE_CARD
fi
}

parse_card ()
{
number=$1
let "suit_number = number / CARDS_IN_SUIT"
suit=${Suits[suit_number]}
echo -n "$suit-"
let "card_no = number % CARDS_IN_SUIT"
Card=${Cards[card_no]}
printf %-4s $Card
# Print cards in neat columns.
}

seed_random ()  # Seed random number generator.
{               # What happens if you don't do this?
seed=`eval date +%s`
let "seed %= 32766"
RANDOM=$seed
} # Consider other methods of seeding the random number generator.

deal_cards ()
{
echo

cards_picked=0
while [ "$cards_picked" -le $UPPER_LIMIT ]
do
  pick_a_card
  t=$?

  if [ "$t" -ne $DUPE_CARD ]
  then
    parse_card $t

    u=$cards_picked+1
    # Change back to 1-based indexing, temporarily. Why?
    let "u %= $CARDS_IN_SUIT"
    if [ "$u" -eq 0 ]   # Nested if/then condition test.
    then
     echo
     echo
    fi                  # Each hand set apart with a blank line.

    let "cards_picked += 1"
  fi  
done  

echo

return 0
}


# Structured programming:
# Entire program logic modularized in functions.

#===============
seed_random
initialize_Deck
initialize_Suits
initialize_Cards
deal_cards
#===============

exit



# Exercise 1:
# Add comments to thoroughly document this script.

# Exercise 2:
# Add a routine (function) to print out each hand sorted in suits.
# You may add other bells and whistles if you like.

# Exercise 3:
# Simplify and streamline the logic of the script.
</programlisting>
      </example>

    </section> <!-- Bash, Version 2 -->



    <section xml:id="bashver3">
      <title>Bash, version 3</title>

      <para><anchor xml:id="bash3ref" /></para>

      <para>On July 27, 2004, Chet Ramey released version 3 of Bash.
        This update fixed quite a number of bugs and added new
        features.</para>

      <para>Some of the more important added features:

      <itemizedlist>
	<listitem>
	  <para><anchor xml:id="braceexpref3" /></para>
	  <para>A new, more generalized <command>{a..z}</command> <link linkend="braceexpref">brace expansion</link> operator.</para>

          <para><programlisting>#!/bin/bash

for i in {1..10}
#  Simpler and more straightforward than
#+ for i in $(seq 10)
do
  echo -n "$i "
done

echo

# 1 2 3 4 5 6 7 8 9 10



# Or just . . .

echo {a..z}    #  a b c d e f g h i j k l m n o p q r s t u v w x y z
echo {e..m}    #  e f g h i j k l m
echo {z..a}    #  z y x w v u t s r q p o n m l k j i h g f e d c b a
               #  Works backwards, too.
echo {25..30}  #  25 26 27 28 29 30
echo {3..-2}   #  3 2 1 0 -1 -2
echo {X..d}    #  X Y Z [  ] ^ _ ` a b c d
               #  Shows (some of) the ASCII characters between Z and a,
               #+ but don't rely on this type of behavior because . . .
echo {]..a}    #  {]..a}
               #  Why?


# You can tack on prefixes and suffixes.
echo "Number #"{1..4}, "..."
     # Number #1, Number #2, Number #3, Number #4, ...


# You can concatenate brace-expansion sets.
echo {1..3}{x..z}" +" "..."
     # 1x + 1y + 1z + 2x + 2y + 2z + 3x + 3y + 3z + ...
     # Generates an algebraic expression.
     # This could be used to find permutations.

# You can nest brace-expansion sets.
echo {{a..c},{1..3}}
     # a b c 1 2 3
     # The "comma operator" splices together strings.

# ########## ######### ############ ########### ######### ###############
# Unfortunately, brace expansion does not lend itself to parameterization.
var1=1
var2=5
echo {$var1..$var2}   # {1..5}


# Yet, as Emiliano G. points out, using "eval" overcomes this limitation.

start=0
end=10
for index in $(eval echo {$start..$end})
do
  echo -n "$index "   # 0 1 2 3 4 5 6 7 8 9 10 
done

echo</programlisting></para>

	</listitem>


	<listitem>
	  <para>The <command>${!array[@]}</command> operator, which
	    expands to all the indices of a given <link linkend="arrayref">array</link>.</para>

	   <para><programlisting>#!/bin/bash

Array=(element-zero element-one element-two element-three)

echo ${Array[0]}   # element-zero
                   # First element of array.

echo ${!Array[@]}  # 0 1 2 3
                   # All the indices of Array.

for i in ${!Array[@]}
do
  echo ${Array[i]} # element-zero
                   # element-one
                   # element-two
                   # element-three
                   #
                   # All the elements in Array.
done</programlisting></para>

	</listitem>


	<listitem>
	  <para><anchor xml:id="regexmatchref" /></para>
	  <para>The <command>=~</command> <link linkend="regexref">Regular
	    Expression</link> matching operator within a <link linkend="dblbrackets">double brackets</link> test expression.
	    (Perl has a similar operator.)</para>

	      <para><programlisting>#!/bin/bash

variable="This is a fine mess."

echo "$variable"

# Regex matching with =~ operator within [[ double brackets ]].
if [[ "$variable" =~ T.........fin*es* ]]
# NOTE: As of version 3.2 of Bash, expression to match no longer quoted.
then
  echo "match found"
      # match found
fi</programlisting></para>

              <para>Or, more usefully:</para>

	      <para><programlisting>#!/bin/bash

input=$1


if [[ "$input" =~ "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" ]]
#                 ^ NOTE: Quoting not necessary, as of version 3.2 of Bash.
# NNN-NN-NNNN (where each N is a digit).
then
  echo "Social Security number."
  # Process SSN.
else
  echo "Not a Social Security number!"
  # Or, ask for corrected input.
fi</programlisting></para>

              <para>For additional examples of using the
                <command>=~</command> operator, see <xref linkend="whx" />,
                <xref linkend="mailboxgrep" />, <xref linkend="findsplit" />, and <xref linkend="tohtml" />.</para>


	</listitem>

	<listitem>
	  <para><anchor xml:id="pipefailref" /></para>
	  <para>The new <option>set -o pipefail</option> option is
	    useful for debugging <link linkend="piperef">pipes</link>. If
	    this option is set, then the <link linkend="exitstatusref">exit status</link> of a pipe
	    is the exit status of the last command in the pipe to
	    <emphasis>fail</emphasis> (return a non-zero value), rather
	    than the actual final command in the pipe.</para>
	  <para>See <xref linkend="fc4upd" />.</para>
	</listitem>


      </itemizedlist>
      </para>

      <caution>
      <para>The update to version 3 of Bash breaks a few scripts
        that worked under earlier versions. <emphasis>Test critical legacy
	scripts to make sure they still work!</emphasis></para>
      <para>As it happens, a couple of the scripts in the
        <emphasis>Advanced Bash Scripting Guide</emphasis> had to be
        fixed up (see <xref linkend="tout" />, for instance).</para>
      </caution>


       <section> <!-- Bash, Version 3.1 -->
         <title>Bash, version 3.1</title>

	 <para>The version 3.1 update of Bash introduces a number of bugfixes
	   and a few minor changes.</para>

          <itemizedlist>

	    <listitem>
	      <para>The <token>+=</token> operator is now permitted in
	        in places where previously only the <token>=</token>
		assignment operator was recognized.</para>

              <para><anchor xml:id="pluseqstr" /></para>

	      <para><programlisting>a=1
echo $a        # 1

a+=5           # Won't work under versions of Bash earlier than 3.1.
echo $a        # 15

a+=Hello
echo $a        # 15Hello</programlisting>
	      </para>

	      <para>Here, <token>+=</token> functions as a <firstterm>string
		concatenation</firstterm> operator. Note that its behavior
		in this particular context is different than within a
		<link linkend="letref">let</link> construct.</para>

	      <para><programlisting>a=1
echo $a        # 1

let a+=5       # Integer arithmetic, rather than string concatenation.
echo $a        # 6

let a+=Hello   # Doesn't "add" anything to a.
echo $a        # 6</programlisting>
	      </para>

	      <para><anchor xml:id="pathappend" />Jeffrey Haemer points out
		that this concatenation operator can be quite
		useful. In this instance, we append a directory to the
		<varname>$PATH</varname>.</para>

	      <para>

      <screen>
<prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin/:/usr/games</computeroutput>


<prompt>bash$ </prompt><userinput>PATH+=:/opt/bin</userinput>

<prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin/:/usr/games:/opt/bin</computeroutput>
      </screen>

	      </para>

	    </listitem>

          </itemizedlist>


       </section> <!-- Bash, Version 3.1 -->



       <section> <!-- Bash, Version 3.2 -->
         <title>Bash, version 3.2</title>

	 <para>This is pretty much a bugfix update.</para>

          <itemizedlist>

	    <listitem>
	      <para>In <link linkend="psglob"><firstterm>global</firstterm>
	        parameter substitutions</link>, the pattern no longer anchors
		at the start of the string.</para>
	    </listitem>

	    <listitem>
	      <para>The <option>--wordexp</option> option disables
	        <link linkend="processsubref">process substitution</link>.</para>
	    </listitem>

	    <listitem>
              <para>The <command>=~</command> <link linkend="regexmatchref">Regular Expression
                match operator</link> no longer requires
                <link linkend="quotingref">quoting</link> of the
                <firstterm>pattern</firstterm> within <link linkend="dblbrackets">[[ ... ]]</link>.</para>
		
              <caution>
	        <para>In fact, quoting in this context is
		<emphasis>not</emphasis> advisable as it may
		cause <firstterm>regex</firstterm> evaluation to fail.
		Chet Ramey states in the <link linkend="bashfaq">Bash
		FAQ</link> that quoting explicitly disables regex evaluation.
		See also the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://bugs.launchpad.net/ubuntu-website/+bug/109931">
		Ubuntu Bug List</link> and <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://en.wikinerds.org/index.php/Bash_syntax_and_semantics">
		Wikinerds on Bash syntax</link>.</para>

                <para>Setting <emphasis>shopt -s compat31</emphasis>
                  in a script causes reversion to the original
                  behavior.</para>
              </caution>

	    </listitem>

          </itemizedlist>

       </section> <!-- Bash, Version 3.2 -->


    </section> <!-- Bash, Version 3 -->



    <section xml:id="bashver4">
      <title>Bash, version 4</title>

      <para><anchor xml:id="bash4ref" /></para>
      <para>Chet Ramey announced Version 4 of Bash on the 20th
        of February, 2009. This release has a number of significant
	new features, as well as some important bugfixes.</para>

      <para>Among the new goodies:</para>

      <itemizedlist>

	<listitem>
		<para><anchor xml:id="assocarr" />Associative arrays.
                  <footnote><para>To be more specific, Bash 4+ has
                  <emphasis>limited</emphasis> support for associative
		  arrays. It's a bare-bones implementation,
		  and it lacks the much of the functionality of such
		  arrays in other programming languages. Note, however,
		  that <link linkend="assocarrtst">associative arrays in
		  Bash seem to execute faster and more efficiently than
		  numerically-indexed arrays</link>.</para></footnote>
                </para>

    <sidebar>
      <para>An <firstterm>associative</firstterm> array can
        be thought of as a set of two linked arrays -- one holding
        the <firstterm>data</firstterm>, and the other the
        <firstterm>keys</firstterm> that index the individual elements
	of the <firstterm>data</firstterm> array.</para>
    </sidebar>

    <example xml:id="fetchaddress">
      <title>A simple address database</title>
      <programlisting>#!/bin/bash4
# fetch_address.sh

declare -A address
#       -A option declares associative array.

address[Charles]="414 W. 10th Ave., Baltimore, MD 21236"
address[John]="202 E. 3rd St., New York, NY 10009"
address[Wilma]="1854 Vermont Ave, Los Angeles, CA 90023"


echo "Charles's address is ${address[Charles]}."
# Charles's address is 414 W. 10th Ave., Baltimore, MD 21236.
echo "Wilma's address is ${address[Wilma]}."
# Wilma's address is 1854 Vermont Ave, Los Angeles, CA 90023.
echo "John's address is ${address[John]}."
# John's address is 202 E. 3rd St., New York, NY 10009.

echo

echo "${!address[*]}"   # The array indices ...
# Charles John Wilma
</programlisting>
    </example>

    <example xml:id="fetchaddress2">
      <title>A somewhat more elaborate address database</title>
      <programlisting>#!/bin/bash4
# fetch_address-2.sh
# A more elaborate version of fetch_address.sh.

SUCCESS=0
E_DB=99    # Error code for missing entry.

declare -A address
#       -A option declares associative array.


store_address ()
{
  address[$1]="$2"
  return $?
}


fetch_address ()
{
  if [[ -z "${address[$1]}" ]]
  then
    echo "$1's address is not in database."
    return $E_DB
  fi

  echo "$1's address is ${address[$1]}."
  return $?
}


store_address "Lucas Fayne" "414 W. 13th Ave., Baltimore, MD 21236"
store_address "Arvid Boyce" "202 E. 3rd St., New York, NY 10009"
store_address "Velma Winston" "1854 Vermont Ave, Los Angeles, CA 90023"
#  Exercise:
#  Rewrite the above store_address calls to read data from a file,
#+ then assign field 1 to name, field 2 to address in the array.
#  Each line in the file would have a format corresponding to the above.
#  Use a while-read loop to read from file, sed or awk to parse the fields.

fetch_address "Lucas Fayne"
# Lucas Fayne's address is 414 W. 13th Ave., Baltimore, MD 21236.
fetch_address "Velma Winston"
# Velma Winston's address is 1854 Vermont Ave, Los Angeles, CA 90023.
fetch_address "Arvid Boyce"
# Arvid Boyce's address is 202 E. 3rd St., New York, NY 10009.
fetch_address "Bozo Bozeman"
# Bozo Bozeman's address is not in database.

exit $?   # In this case, exit code = 99, since that is function return.
</programlisting>
    </example>

          <para>See <xref linkend="samorse" /> for an interesting
            usage of an <firstterm>associative array</firstterm>.</para>

	<caution><para>Elements of the <firstterm>index</firstterm> array
          may include embedded <link linkend="whitespaceref">space
          characters</link>, or even leading and/or trailing space
          characters. However, index array elements containing
	  <emphasis>only</emphasis> <firstterm>whitespace</firstterm>
	  are <emphasis>not</emphasis> permitted.</para>
  <para><programlisting>address[   ]="Blank"   # Error!</programlisting>
  </para></caution>

	</listitem>


	<listitem>
          <para><anchor xml:id="ncterm" />Enhancements to the
            <link linkend="caseesac1">case</link> construct:
            the <replaceable>;;&amp;</replaceable> and
            <replaceable>;&amp;</replaceable> terminators.</para>

    <example xml:id="case4">
      <title>Testing characters</title>
      <programlisting>#!/bin/bash4

test_char ()
{
  case "$1" in
    [[:print:]] )  echo "$1 is a printable character.";;&amp;       # |
    # The ;;&amp; terminator continues to the next pattern test.      |
    [[:alnum:]] )  echo "$1 is an alpha/numeric character.";;&amp;  # v
    [[:alpha:]] )  echo "$1 is an alphabetic character.";;&amp;     # v
    [[:lower:]] )  echo "$1 is a lowercase alphabetic character.";;&amp;
    [[:digit:]] )  echo "$1 is an numeric character.";&amp;         # |
    # The ;&amp; terminator executes the next statement ...         # |
    %%%@@@@@    )  echo "********************************";;    # v
#   ^^^^^^^^  ... even with a dummy pattern.
  esac
}

echo

test_char 3
# 3 is a printable character.
# 3 is an alpha/numeric character.
# 3 is an numeric character.
# ********************************
echo

test_char m
# m is a printable character.
# m is an alpha/numeric character.
# m is an alphabetic character.
# m is a lowercase alphabetic character.
echo

test_char /
# / is a printable character.

echo

# The ;;&amp; terminator can save complex if/then conditions.
# The ;&amp; is somewhat less useful.
</programlisting>
    </example>
	</listitem>

	<listitem>
          <para><anchor xml:id="coprocref" />The new <command>coproc</command>
            builtin enables two parallel <link linkend="processref">processes</link> to communicate and
            interact. As Chet Ramey states in the
            <link linkend="bashfaq">Bash FAQ</link>
  <footnote><para>Copyright 1995-2009 by Chester Ramey.</para></footnote>
      , ver. 4.01:
    </para>

    <blockquote>
      <literallayout>
    There is a new 'coproc' reserved word that specifies a coprocess:
    an asynchronous command run with two pipes connected to the creating
    shell. Coprocs can be named. The input and output file descriptors
    and the PID of the coprocess are available to the calling shell in
    variables with coproc-specific names.

    George Dimitriu explains,
    "... coproc ... is a feature used in Bash process substitution,
    which now is made publicly available."
    This means it can be explicitly invoked in a script, rather than
    just being a behind-the-scenes mechanism used by Bash.
      </literallayout>
    </blockquote>

    <para>Coprocesses use <firstterm>file descriptors</firstterm>.
      <link linkend="fdref2">File descriptors enable processes and
        pipes to communicate</link>.</para>

    <para><programlisting>#!/bin/bash4
# A coprocess communicates with a while-read loop.


coproc { cat mx_data.txt; sleep 2; }
#                         ^^^^^^^
# Try running this without "sleep 2" and see what happens.

while read -u ${COPROC[0]} line    #  ${COPROC[0]} is the
do                                 #+ file descriptor of the coprocess.
  echo "$line" | sed -e 's/line/NOT-ORIGINAL-TEXT/'
done

kill $COPROC_PID                   #  No longer need the coprocess,
                                   #+ so kill its PID.</programlisting></para>

    <para>But, be careful!</para>

    <para><programlisting>#!/bin/bash4

echo; echo
a=aaa
b=bbb
c=ccc

coproc echo "one two three"
while read -u ${COPROC[0]} a b c;  #  Note that this loop
do                                 #+ runs in a subshell.
  echo "Inside while-read loop: ";
  echo "a = $a"; echo "b = $b"; echo "c = $c"
  echo "coproc file descriptor: ${COPROC[0]}"
done 

# a = one
# b = two
# c = three
# So far, so good, but ...

echo "-----------------"
echo "Outside while-read loop: "
echo "a = $a"  # a =
echo "b = $b"  # b =
echo "c = $c"  # c =
echo "coproc file descriptor: ${COPROC[0]}"
echo
#  The coproc is still running, but ...
#+ it still doesn't enable the parent process
#+ to "inherit" variables from the child process, the while-read loop.

#  Compare this to the "badread.sh" script.</programlisting></para>

    <caution>
      <para>The coprocess is <firstterm>asynchronous</firstterm>,
        and this might cause a problem. It may terminate before another
        process has finished communicating with it.</para>

      <programlisting>#!/bin/bash4

coproc cpname { for i in {0..10}; do echo "index = $i"; done; }
#      ^^^^^^ This is a *named* coprocess.
read -u ${cpname[0]}
echo $REPLY         #  index = 0
echo ${COPROC[0]}   #+ No output ... the coprocess timed out
#  after the first loop iteration.



# However, George Dimitriu has a partial fix.

coproc cpname { for i in {0..10}; do echo "index = $i"; done; sleep 1;
echo hi &gt; myo; cat - &gt;&gt; myo; }
#       ^^^^^ This is a *named* coprocess.

echo "I am main"$'\04' &gt;&amp;${cpname[1]}
myfd=${cpname[0]}
echo myfd=$myfd

### while read -u $myfd
### do
###   echo $REPLY;
### done

echo $cpname_PID

#  Run this with and without the commented-out while-loop, and it is
#+ apparent that each process, the executing shell and the coprocess,
#+ waits for the other to finish writing in its own write-enabled pipe.</programlisting>
      </caution>

	</listitem>

	<listitem>

    <para><anchor xml:id="mapfileref" />The new <command>mapfile</command>
      builtin makes it possible to load an array with the contents
      of a text file without using a loop or <link linkend="arrayinitcs">command substitution</link>.</para>

    <para><programlisting>#!/bin/bash4

mapfile Arr1 &lt; $0
# Same result as     Arr1=( $(cat $0) )
echo "${Arr1[@]}"  # Copies this entire script out to stdout.

echo "--"; echo

# But, not the same as   read -a   !!!
read -a Arr2 &lt; $0
echo "${Arr2[@]}"  # Reads only first line of script into the array.

exit</programlisting></para>

	</listitem>

	<listitem>
      <para>The <link linkend="readref">read</link> builtin got
	a minor facelift. The <option>-t</option>
	<link linkend="readtimed">timeout</link> option now accepts
	(decimal) fractional values
	        <footnote><para>This only works with <link linkend="piperef">pipes</link> and certain other
                <firstterm>special</firstterm> files.</para></footnote>
	and the <option>-i</option> option
	permits preloading the edit buffer.
	        <footnote><para>But only in conjunction with
                <link linkend="readlineref">readline</link>, i.e.,
                from the command-line.</para></footnote>
        Unfortunately, these enhancements are still a work in progress
        and not (yet) usable in scripts.</para>
	</listitem>

	<listitem>
		<para><anchor xml:id="casemodparamsub" />
                   <link linkend="paramsubref">Parameter substitution</link>
        gets <firstterm>case-modification</firstterm> operators.</para>

<para><programlisting>#!/bin/bash4

var=veryMixedUpVariable
echo ${var}            # veryMixedUpVariable
echo ${var^}           # VeryMixedUpVariable
#         *              First char --&gt; uppercase.
echo ${var^^}          # VERYMIXEDUPVARIABLE
#         **             All chars  --&gt; uppercase.
echo ${var,}           # veryMixedUpVariable
#         *              First char --&gt; lowercase.
echo ${var,,}          # verymixedupvariable
#         **             All chars  --&gt; lowercase.</programlisting></para>
	</listitem>

	<listitem>
      <para><anchor xml:id="declarecasemod" /></para>
      <para>The <link linkend="declareref">declare</link> builtin now
        accepts the <option>-l</option> <firstterm>lowercase</firstterm>
        and <option>-c</option> <firstterm>capitalize</firstterm>
        options.</para>

<para><programlisting>#!/bin/bash4

declare -l var1            # Will change to lowercase
var1=MixedCaseVARIABLE
echo "$var1"               # mixedcasevariable
# Same effect as             echo $var1 | tr A-Z a-z

declare -c var2            # Changes only initial char to uppercase.
var2=originally_lowercase
echo "$var2"               # Originally_lowercase
# NOT the same effect as     echo $var2 | tr a-z A-Z</programlisting></para>
	</listitem>

	<listitem>
    <para><anchor xml:id="braceexpref4" />
      <link linkend="braceexpref">Brace expansion</link> has more options.</para>

     <para><firstterm>Increment/decrement</firstterm>, specified in the
        final term within braces.</para>
     <para><programlisting>#!/bin/bash4

echo {40..60..2}
# 40 42 44 46 48 50 52 54 56 58 60
# All the even numbers, between 40 and 60.

echo {60..40..2}
# 60 58 56 54 52 50 48 46 44 42 40
# All the even numbers, between 40 and 60, counting backwards.
# In effect, a decrement.
echo {60..40..-2}
# The same output. The minus sign is not necessary.

# But, what about letters and symbols?
echo {X..d}
# X Y Z [  ] ^ _ ` a b c d
# Does not echo the \ which escapes a space.</programlisting></para>

     <para><firstterm>Zero-padding</firstterm>, specified in the
	     first term within braces, prefixes each term in the output
	     with the <emphasis>same number</emphasis> of zeroes.</para>

      <screen>
<prompt>bash4$ </prompt><userinput>echo {010..15}</userinput>
<computeroutput>010 011 012 013 014 015</computeroutput>


<prompt>bash4$ </prompt><userinput>echo {000..10}</userinput>
<computeroutput>000 001 002 003 004 005 006 007 008 009 010</computeroutput>
      </screen>

	</listitem>

	<listitem>
        <para><anchor xml:id="substrextref4" /></para>
        <para><link linkend="substrextref4"><firstterm>Substring
          extraction</firstterm> on <firstterm>positional
	  parameters</firstterm></link> now starts with <link linkend="scrnameparam">$0</link> as the
	  <firstterm>zero-index</firstterm>. (This corrects an
	  inconsistency in the treatment of positional parameters.)</para>

          <para><programlisting>#!/bin/bash
# show-params.bash
# Requires version 4+ of Bash.

# Invoke this scripts with at least one positional parameter.

E_BADPARAMS=99

if [ -z "$1" ]
then
  echo "Usage $0 param1 ..."
  exit $E_BADPARAMS
fi

echo ${@:0}

# bash3 show-params.bash4 one two three
# one two three

# bash4 show-params.bash4 one two three
# show-params.bash4 one two three

# $0                $1  $2  $3</programlisting></para>
        
	</listitem>

	<listitem>
          <para><anchor xml:id="globstarref" />The new <token>**</token>
            <link linkend="globbingref">globbing</link> operator
	    matches filenames and directories
	    <link linkend="recursionref0">recursively</link>.</para>

          <para><programlisting>#!/bin/bash4
# filelist.bash4

shopt -s globstar  # Must enable globstar, otherwise ** doesn't work.
                   # The globstar shell option is new to version 4 of Bash.

echo "Using *"; echo
for filename in *
do
  echo "$filename"
done   # Lists only files in current directory ($PWD).

echo; echo "--------------"; echo

echo "Using **"
for filename in **
do
  echo "$filename"
done   # Lists complete file tree, recursively.

exit

Using *

allmyfiles
filelist.bash4

--------------

Using **

allmyfiles
allmyfiles/file.index.txt
allmyfiles/my_music
allmyfiles/my_music/me-singing-60s-folksongs.ogg
allmyfiles/my_music/me-singing-opera.ogg
allmyfiles/my_music/piano-lesson.1.ogg
allmyfiles/my_pictures
allmyfiles/my_pictures/at-beach-with-Jade.png
allmyfiles/my_pictures/picnic-with-Melissa.png
filelist.bash4</programlisting></para>

	</listitem>

	<listitem>
      <para>The new <link linkend="bashpidref">$BASHPID</link>
        internal variable.</para>
	</listitem>

	<listitem>
          <para><anchor xml:id="cnfh" /></para>
          <para>There is a new <link linkend="builtinref">builtin</link>
            error-handling function named
	    <command>command_not_found_handle</command>.</para>
          <para><programlisting>#!/bin/bash4

command_not_found_handle ()
{ # Accepts implicit parameters.
  echo "The following command is not valid: \""$1\"""
  echo "With the following argument(s): \""$2\"" \""$3\"""   # $4, $5 ...
} # $1, $2, etc. are not explicitly passed to the function.

bad_command arg1 arg2

# The following command is not valid: "bad_command"
# With the following argument(s): "arg1" "arg2"</programlisting></para>
	</listitem>

      </itemizedlist>

      <sidebar>
        <para><emphasis>Editorial comment</emphasis></para>
	<para>Associative arrays? Coprocesses? Whatever happened
          to the lean and mean Bash we have come to know and love?
          Could it be suffering from (horrors!) <quote>feature
          creep</quote>? Or perhaps even Korn shell envy?</para>
	<para><emphasis>Note to Chet Ramey:</emphasis> Please add only
          <emphasis>essential</emphasis> features in future Bash
	  releases -- perhaps <firstterm>for-each</firstterm>
	  loops and support for multi-dimensional arrays.
	    <footnote><para>And while you're at it, consider fixing
              the notorious <link linkend="pipereadref0">piped read</link>
	      problem.</para></footnote>
	  Most Bash users won't need, won't use, and likely won't greatly
	  appreciate complex <quote>features</quote> like built-in
	  debuggers, Perl interfaces, and bolt-on rocket boosters.</para>
      </sidebar>


     <section> <!-- Bash, Version 4.1 -->
         <title>Bash, version 4.1</title>

	 <para><anchor xml:id="bash41" />Version 4.1 of Bash, released in May,
	   2010, was primarily a bugfix update.</para>

      <itemizedlist>

      <listitem>
      <para>The <link linkend="printfref">printf</link> command
        now accepts a <option>-v</option> option for setting <link linkend="arrayref">array</link> indices.</para>
      </listitem>

      <listitem>
      <para>Within <link linkend="dblbrackets">double brackets</link>,
        the <command>&gt;</command> and <command>&lt;</command>
        string comparison operators now conform to the <link linkend="localeref">locale</link>. Since the locale setting may
        affect the sorting order of string expressions, this
	has side-effects on comparison tests within
        <emphasis>[[ ... ]]</emphasis> expressions.</para>
      </listitem>

      <listitem>
      <para>The <link linkend="readref">read</link> builtin
        now takes a <option>-N</option> option (<firstterm>read -N
        chars</firstterm>), which causes the <firstterm>read</firstterm>
        to terminate after <firstterm>chars</firstterm>
        characters.</para>

                  <example xml:id="readn">
                     <title>Reading N characters</title>
                     <programlisting>#!/bin/bash
# Requires Bash version -ge 4.1 ...

num_chars=61

read -N $num_chars var &lt; $0   # Read first 61 characters of script!
echo "$var"
exit

####### Output of Script #######

#!/bin/bash
# Requires Bash version -ge 4.1 ...

num_chars=61
</programlisting>
                  </example>
	  </listitem>

      <listitem>
      <para><link linkend="heredocref">Here documents</link>
	      embedded in <link linkend="commandsubref0">
              <userinput>$( ... )</userinput> command substitution</link>
	      constructs may terminate with a simple
	      <command>)</command>.</para>

                  <example xml:id="herecommsub">
                     <title>Using a <firstterm>here document</firstterm>
                       to set a variable</title>
                     <programlisting>#!/bin/bash
# here-commsub.sh
# Requires Bash version -ge 4.1 ...

multi_line_var=$( cat &lt;&lt;ENDxxx
------------------------------
This is line 1 of the variable
This is line 2 of the variable
This is line 3 of the variable
------------------------------
ENDxxx)

#  Rather than what Bash 4.0 requires:
#+ that the terminating limit string and
#+ the terminating close-parenthesis be on separate lines.

# ENDxxx
# )


echo "$multi_line_var"

#  Bash still emits a warning, though.
#  warning: here-document at line 10 delimited
#+ by end-of-file (wanted `ENDxxx')
</programlisting>
                  </example>
	  </listitem>

  </itemizedlist>

     </section> <!-- Bash, Version 4.1 -->


     <section> <!-- Bash, Version 4.2 -->
         <title>Bash, version 4.2</title>

	 <para><anchor xml:id="bash42" />Version 4.2 of Bash, released
	   in February, 2011, contains a number of new features and
	   enhancements, in addition to bugfixes.</para>

  <itemizedlist>

      <listitem>
	      <para>Bash now supports the
		<replaceable>\u</replaceable>
		and <replaceable>\U</replaceable>
		<firstterm>Unicode</firstterm> escape.</para>

                 <para><anchor xml:id="unicoderef" /></para>
	<sidebar><para>Unicode is a cross-platform standard for encoding
          into numerical values letters and graphic symbols.
          This permits representing and displaying characters
          in foreign alphabets and unusual fonts.</para></sidebar>
                 <para><anchor xml:id="unicoderef2" /></para>

<para><programlisting>echo -e '\u2630'   # Horizontal triple bar character.
# Equivalent to the more roundabout:
echo -e "\xE2\x98\xB0"
                   # Recognized by earlier Bash versions.

echo -e '\u220F'   # PI (Greek letter and mathematical symbol)
echo -e '\u0416'   # Capital "ZHE" (Cyrillic letter)
echo -e '\u2708'   # Airplane (Dingbat font) symbol
echo -e '\u2622'   # Radioactivity trefoil

echo -e "The amplifier circuit requires a 100 \u2126 pull-up resistor."


unicode_var='\u2640'
echo -e $unicode_var      # Female symbol
printf "$unicode_var \n"  # Female symbol, with newline


#  And for something a bit more elaborate . . .

#  We can store Unicode symbols in an associative array,
#+ then retrieve them by name.
#  Run this in a gnome-terminal or a terminal with a large, bold font
#+ for better legibility.

declare -A symbol  # Associative array.

symbol[script_E]='\u2130'
symbol[script_F]='\u2131'
symbol[script_J]='\u2110'
symbol[script_M]='\u2133'
symbol[Rx]='\u211E'
symbol[TEL]='\u2121'
symbol[FAX]='\u213B'
symbol[care_of]='\u2105'
symbol[account]='\u2100'
symbol[trademark]='\u2122'


echo -ne "${symbol[script_E]}   "
echo -ne "${symbol[script_F]}   "
echo -ne "${symbol[script_J]}   "
echo -ne "${symbol[script_M]}   "
echo -ne "${symbol[Rx]}   "
echo -ne "${symbol[TEL]}   "
echo -ne "${symbol[FAX]}   "
echo -ne "${symbol[care_of]}   "
echo -ne "${symbol[account]}   "
echo -ne "${symbol[trademark]}   "
echo</programlisting></para>

     <note>
	<para>The above example uses the
          <link linkend="strq"><command>$' ... '</command></link>
          <firstterm>string-expansion</firstterm> construct.</para>
     </note>

      </listitem>


      <listitem>
        <para><anchor xml:id="lastpiperef" /></para>
        <para>When the <replaceable>lastpipe</replaceable> shell option
          is set, the last command in a <link linkend="piperef">pipe</link> <emphasis>doesn't run in a
	  subshell</emphasis>.</para>

                  <example xml:id="lastpipeopt">
		    <title>Piping input to a <link linkend="readref">read</link></title>
                     <programlisting>#!/bin/bash
# lastpipe-option.sh

line=''                   # Null value.
echo "\$line = "$line""   # $line =

echo

shopt -s lastpipe         # Error on Bash version -lt 4.2.
echo "Exit status of attempting to set \"lastpipe\" option is $?"
#     1 if Bash version -lt 4.2, 0 otherwise.

echo

head -1 $0 | read line    # Pipe the first line of the script to read.
#            ^^^^^^^^^      Not in a subshell!!!

echo "\$line = "$line""
# Older Bash releases       $line =
# Bash version 4.2          $line = #!/bin/bash
</programlisting>
                  </example>

		  <para>This option offers possible <quote>fixups</quote>
		    for these example scripts:
		    <xref linkend="badread" /> and
                    <xref linkend="readpipe" />.</para>

      </listitem>




      <listitem>
         <para>Negative <link linkend="arrayref">array</link> indices
           permit counting backwards from the end of an array.</para>

                  <example xml:id="negarray">
                    <title>Negative array indices</title>
                     <programlisting>#!/bin/bash
# neg-array.sh
# Requires Bash, version -ge 4.2.

array=( zero one two three four five )   # Six-element array.
#         0    1   2    3    4    5
#        -6   -5  -4   -3   -2   -1

# Negative array indices now permitted.
echo ${array[-1]}   # five
echo ${array[-2]}   # four
# ...
echo ${array[-6]}   # zero
# Negative array indices count backward from the last element+1.

# But, you cannot index past the beginning of the array.
echo ${array[-7]}   # array: bad array subscript


# So, what is this new feature good for?

echo "The last element in the array is "${array[-1]}""
# Which is quite a bit more straightforward than:
echo "The last element in the array is "${array[${#array[*]}-1]}""
echo

# And ...

index=0
let "neg_element_count = 0 - ${#array[*]}"
# Number of elements, converted to a negative number.

while [ $index -gt $neg_element_count ]; do
  ((index--)); echo -n "${array[index]} "
done  # Lists the elements in the array, backwards.
      # We have just simulated the "tac" command on this array.

echo

# See also neg-offset.sh.
</programlisting>
                  </example>

	  </listitem>

      <listitem>
         <para><link linkend="substrextr01">Substring extraction</link>
           uses a negative <firstterm>length</firstterm> parameter to
           specify an offset from the <firstterm>end</firstterm> of the
           target string.</para>

                  <example xml:id="negoffset">
                    <title>Negative parameter in string-extraction
                      construct</title>
                     <programlisting>#!/bin/bash
# Bash, version -ge 4.2
# Negative length-index in substring extraction.
# Important: It changes the interpretation of this construct!

stringZ=abcABC123ABCabc

echo ${stringZ}                              # abcABC123ABCabc
#                   Position within string:    0123456789.....
echo ${stringZ:2:3}                          #   cAB
#  Count 2 chars forward from string beginning, and extract 3 chars.
#  ${string:position:length}

#  So far, nothing new, but now ...

                                             # abcABC123ABCabc
#                   Position within string:    0123....6543210
echo ${stringZ:3:-6}                         #    ABC123
#                ^
#  Index 3 chars forward from beginning and 6 chars backward from end,
#+ and extract everything in between.
#  ${string:offset-from-front:offset-from-end}
#  When the "length" parameter is negative, 
#+ it serves as an offset-from-end parameter.

#  See also neg-array.sh.
</programlisting>
                  </example>

	  </listitem>
  </itemizedlist>

     </section> <!-- Bash, Version 4.2 -->



     </section> <!-- Bash, Version 4 -->




  </chapter> <!-- Bash, versions 2, 3, and 4 -->

  </part>

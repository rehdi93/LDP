<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book [
<!ENTITY part1 SYSTEM "part1.xml">
<!ENTITY part2 SYSTEM "part2.xml">
<!ENTITY part3 SYSTEM "part3.xml">
<!ENTITY part4 SYSTEM "part4.xml">
<!ENTITY part5 SYSTEM "part5.xml">
<!ENTITY otherres SYSTEM "other-res.xml">
]>
<!-- Converted by db4-upgrade version 1.1 -->
<book xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="abs-guide">
  <info>
    <title>Advanced Bash-Scripting Guide</title>
    <subtitle>An in-depth exploration of the art of shell scripting</subtitle>

    <author><personname><firstname>Mendel</firstname><surname>Cooper</surname></personname><affiliation>
	<address><email>thegrendel.abs@gmail.com</email></address>
      </affiliation></author>

    <othercredit>
      <personname>Pedro Oliva Rodrigues</personname>
      <contrib>Docbook 5 upgrade and fixes.</contrib>
      <affiliation>
        <address><email>pedroolivarodrigues@outlook.com</email></address>
      </affiliation>
    </othercredit>

    <releaseinfo>11</releaseinfo>
    <pubdate>2020-09-03</pubdate>
    <biblioid class="isbn">978-1-4357-5219-1</biblioid>

    <revhistory xml:id="revhistory">

      <revision>
        <revnumber>6.5</revnumber>
        <date>2012-04-05</date>
        <authorinitials>mc</authorinitials>
	<revremark>'TUNGSTENBERRY' release</revremark>
      </revision>

      <revision>
        <revnumber>6.6</revnumber>
        <date>2012-11-27</date>
        <authorinitials>mc</authorinitials>
	<revremark>'YTTERBIUMBERRY' release</revremark>
      </revision>

      <revision>
        <revnumber>10</revnumber>
        <date>2014-03-10</date>
        <authorinitials>mc</authorinitials>
	<revremark>'PUBLICDOMAIN' release</revremark>
      </revision>

      <revision>
        <revnumber>11</revnumber>
        <date>2020-09-03</date>
        <authorinitials>por</authorinitials>
	      <revremark>Docbook 5 upgrade</revremark>
      </revision>

    </revhistory>


    <abstract>

      <para>This tutorial assumes no previous knowledge of
	scripting or programming, yet progresses rapidly toward an
	intermediate/advanced level of instruction <emphasis>. . . all
	the while sneaking in little nuggets of <trademark class="registered">UNIX</trademark> wisdom and lore</emphasis>. It
	serves as a textbook, a manual for self-study, and as a reference and
	source of knowledge on shell scripting techniques. The exercises
	and heavily-commented examples invite active reader participation,
	under the premise that <userinput>the only way to really learn
	scripting is to write scripts</userinput>.</para>

      <para>This book is suitable for classroom use as a
        general introduction to programming concepts.</para>

      <para>This document is herewith granted to the Public Domain.
      <userinput>No copyright!</userinput></para>

    </abstract>
  </info>

  <dedication>
    <para>For Anita, the source of all the magic</para>
  </dedication>

&part1;
   <!-- Part 1 (Introduction) -->

&part2;
   <!-- Part 2 (Basics) -->

&part3;
   <!-- Part 3 (Beyond the Basics) -->

&part4;
   <!-- Part 4 (Beyond the Basics) -->

&part5;
   <!-- Part 5 (Advanced Topics) -->

  <chapter xml:id="endnotes">
    <title>Endnotes</title>


    <section xml:id="authorsnote">
      <title>Author's Note</title>

    <epigraph>
      <para><foreignphrase>doce ut discas</foreignphrase></para>
      <para>(Teach, that you yourself may learn.)</para>
    </epigraph>


      <para>How did I come to write a scripting book? It's a strange
	tale. It seems that a few years back I needed to learn
	shell scripting -- and what better way to do that than to read a
	good book on the subject? I was looking to buy a tutorial and
	reference covering all aspects of the subject. I was looking for a
	book that would take difficult concepts, turn them inside out, and
	explain them in excruciating detail, with well-commented examples.
	    <footnote><para>This is the notorious <emphasis>flog
	    it to death</emphasis> technique that works so well
	    with slow learners, eccentrics, odd ducks, fools and
	    geniuses.</para></footnote>
	In fact, I was looking for <emphasis>this very book</emphasis>,
	or something very much like it. Unfortunately, <link linkend="kochanref">it didn't exist</link>, and if I wanted it,
	I'd have to write it. And so, here we are, folks.</para>

      <para>That reminds me of the apocryphal story about a mad
        professor. Crazy as a loon, the fellow was. At the sight of a
        book, any book -- at the library, at a bookstore, anywhere --
        he would become totally obsessed with the idea that he could have
        written it, should have written it -- and done a better job of it
        to boot. He would thereupon rush home and proceed to do just that,
        write a book with the very same title. When he died some years
        later, he allegedly had several thousand books to his credit,
        probably putting even Asimov to shame. The books might not have
        been any good, who knows, but does that really matter? Here's
        a fellow who lived his dream, even if he was obsessed by it,
        driven by it . . . and somehow I can't help admiring the old
        coot.</para>

    </section> <!-- Author's Note -->


    
    <section xml:id="aboutauthor">
      <title>About the Author</title>
      <subtitle>Who is this guy anyhow?</subtitle>

      <para><anchor xml:id="nocreds" />The author claims no credentials or
        special qualifications,

          <footnote><para>In fact, he has no credentials or special
          qualifications. He's a school dropout with no formal credentials
          or professional experience whatsoever. None. Zero. Nada. Aside
          from the <emphasis>ABS Guide</emphasis>, his major claim to
          fame is a First Place in the sack race at the Colfax Elementary
          School Field Day in June, 1958.</para></footnote>

	other than a compulsion to write.

          <footnote><para>Those who can, do. Those who can't . . . get an
	  MCSE.</para></footnote>

	  </para>

        <para>This book is somewhat of a departure from his other major work,
	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/hmw60.zip">
	HOW-2 Meet Women: The Shy Man's Guide to
	Relationships</link>. He has also written the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://tldp.org/HOWTO/Software-Building-HOWTO.html">Software-Building
	HOWTO</link>. Of late, he has been trying his
(heavy) hand at fiction: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/dave-dawson-over-berlin.epub">Dave Dawson
	Over Berlin (First Installment)</link>
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/dave-dawson-over-berlin.II.epub">Dave Dawson
	Over Berlin (Second Installment)</link> and
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/dave-dawson-over-berlin.III.epub">Dave Dawson
	Over Berlin (Third Installment)</link>

. He also has a few
<emphasis>Instructables</emphasis> (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/Arduino-Morse-Code-Shield/">here</link>,
	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/Haywired-Hackduino/">here</link>,
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/Arduino-DIY-SD-Card-Logging-Shield/">here</link>,
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/Binguino-An-Arduino-based-Bingo-Number-Generato/">here</link>,
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/The-Raspberry-Pi-Lapdock-Connection/">here</link>,

<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/The-Raspberry-Pi-Arduino-Connection/">here</link>, and
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.instructables.com/id/Switchable-Dual-Voltage-33v5v-Hacduino/">here</link>
	to his (dis)credit.</para>

      <para>A Linux user since 1995 (Slackware 2.2, kernel 1.2.1),
	the author has emitted a few
	software truffles, including the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ibiblio.org/pub/Linux/utils/file/cruft-0.2.tar.gz">cruft</link>
	one-time pad encryption utility, the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz">mcalc</link>
	mortgage calculator, the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ibiblio.org/pub/Linux/games/amusements/judge-1.0.tar.gz">judge</link>
	ScrabbleÂ® adjudicator, the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz">yawl</link>
	word gaming list package, and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/qky.README.html">Quacky</link>
	anagramming gaming package. He got off to a rather shaky start in the
	computer game -- programming FORTRAN IV on a CDC 3800 (on paper coding
	pads, with occasional forays on a keypunch machine and a Friden
	Flexowriter) -- and is not the least bit nostalgic for those
	days.</para>

       <para>Living in an out-of-the-way community with wife and orange
         tabby, he cherishes human frailty, especially his own.
	   <footnote><para>Sometimes it seems as if he has spent
	   his entire life flouting conventional wisdom and defying the
	   sonorous Voice of Authority: <quote><emphasis>Hey, you
	   can't do that!</emphasis></quote></para></footnote>
	 </para>

    </section> <!-- About the Author -->



    <section xml:id="wherehelp">
      <title>Where to Go For Help</title>

       <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:thegrendel.abs@gmail.com">The author</link>
         is no longer supporting or updating this document. He will not
	 answer questions about this book or about general scripting topics.
       </para>

       <sidebar>
	 <para>If you need assistance with a schoolwork assignment,
           read the pertinent sections of this and other reference works.
	   Do your best to solve the problem using your own wits and
	   resources. <emphasis>Please do not waste the author's time.</emphasis>
	   You will get neither help nor sympathy.
	     <footnote><para>Well, if you <emphasis>absolutely</emphasis>
	     insist, you can try modifying <xref linkend="homework" /> to suit
	     your purposes.</para></footnote>
       </para>
       <para>Likewise, kindly refrain from annoying the author
         with solicitations, offers of employment, or <quote>business
         opportunities.</quote> He is doing just fine, and requires
         neither help nor sympathy, thank you.</para>
       <para>Please note that the author will <emphasis>not</emphasis> answer
          scripting questions for Sun/Solaris/Oracle or Apple systems. The
          endarkened execs and the arachnoid corporate attorneys of
          those particular outfits have been using litigation in a
          predatory manner and/or as a weapon against the Open Source
          Community. Any Solaris or Apple users needing scripting help
          will therefore kindly direct their concerns to corporate
          customer service.</para>

       </sidebar>

    <epigraph>
      <para>... sophisticated in mechanism but possibly agile
	operating under noises being extremely suppressed ...</para>
<para>--<emphasis>CI-300 printer manual</emphasis></para>
    </epigraph>

    </section> <!-- Where to Go For Help -->



    <section xml:id="toolsused">
      <title>Tools Used to Produce This Book</title>


     <section xml:id="software-hardware">
       <title>Hardware</title>

       <para>A used IBM Thinkpad, model 760XL laptop (P166, 104 meg RAM)
	 running Red Hat 7.1/7.3. Sure, it's slow and has a funky
	 keyboard, but it beats the heck out of a No. 2 pencil and a
	 Big Chief tablet.</para>
	 
	 <para>
	   <emphasis>Update:</emphasis> upgraded to a
	   770Z Thinkpad (P2-366, 192 meg RAM) running FC3. Anyone
	   feel like donating a later-model laptop to a starving writer
	   &lt;g&gt;?
	 </para>

	 <para>
	   <emphasis>Update:</emphasis> upgraded to a T61 Thinkpad
	   running Mandriva 2011. No longer starving &lt;g&gt;,
	   but not too proud to accept donations.
	 </para>

     </section> <!-- Hardware -->


     <section xml:id="software-printware">
       <title>Software and Printware</title>

      <orderedlist xml:id="software-printware2" numeration="lowerroman">

        <listitem>
	<para>Bram Moolenaar's powerful SGML-aware <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.vim.org">vim</link> text editor.</para>
	</listitem>

	<listitem>
	<para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.netfolder.com/DSSSL/">OpenJade</link>,
	a DSSSL rendering engine for converting SGML documents into other
	formats.</para>
	</listitem>

	<listitem>
	<para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://nwalsh.com/docbook/dsssl/"> Norman
	Walsh's DSSSL stylesheets</link>.</para>
	</listitem>

	<listitem>
	<para><citetitle pubwork="book">DocBook, The Definitive
	  Guide</citetitle>, by Norman Walsh and Leonard Muellner
	  (O'Reilly, ISBN 1-56592-580-7). This is still the standard
	  reference for anyone attempting to write a document in Docbook
	  SGML format.</para>
	</listitem>

      </orderedlist>

     </section> <!-- Software and Printware -->

    </section> <!-- Tools Used -->



    <section xml:id="credits">
      <title>Credits</title>

      <para><emphasis>Community participation made this project
        possible.</emphasis> The author gratefully acknowledges that
	writing this book would have been unthinkable without
	help and feedback from all you people out there.</para>

      <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:feloy@free.fr">Philippe Martin</link>
	translated the first version (0.1) of this document into
	DocBook/SGML. While not on the job at a small French company as a
	software developer, he enjoys working on GNU/Linux documentation
	and software, reading literature, playing music, and, for his
	peace of mind, making merry with friends. You may run across him
	somewhere in France or in the Basque Country, or you can email him
	at <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:feloy@free.fr">feloy@free.fr</link>.</para>

      <para>Philippe Martin also pointed out that positional parameters
	past $9 are possible using {bracket} notation. (See <xref linkend="ex17" />).</para>

      <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:stephane_chazelas@yahoo.fr">StÃ©phane
	Chazelas</link> sent a long list of corrections, additions,
	and example scripts. More than a contributor, he had, in effect,
	for a while taken on the role of <emphasis>co-editor</emphasis>
	for this document. <foreignphrase>Merci
	beaucoup!</foreignphrase></para>

      <para>Paulo Marcel Coelho Aragao offered many corrections, both major
        and minor, and contributed quite a number of helpful
        suggestions.</para>

      <para>I would like to especially thank <emphasis>Patrick
        Callahan</emphasis>, <emphasis>Mike Novak</emphasis>, and
        <emphasis>Pal Domokos</emphasis> for catching bugs, pointing out
        ambiguities, and for suggesting clarifications and changes in the
	preliminary version (0.1) of this document. Their lively
	discussion of shell scripting and general documentation issues
	inspired me to try to make this document more readable.</para>

      <para>I'm grateful to Jim Van Zandt for pointing out errors and
        omissions in version 0.2 of this document. He also contributed
        an instructive <link linkend="zfifo">example script</link>.</para>

      <para>Many thanks to <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:mikaku@fiwix.org">Jordi Sanfeliu</link>
        for giving permission to use his fine tree script (<xref linkend="tree" />), and to Rick Boivie for revising it.</para>

      <para>Likewise, thanks to <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:charpov@cs.unh.edu">Michel Charpentier</link> for
	permission to use his <link linkend="dcref">dc</link> factoring script
	(<xref linkend="factr" />).</para>

      <para>Kudos to <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:friedman@prep.ai.mit.edu">Noah Friedman</link>
        for permission to use his string function script (<xref linkend="string" />).</para>

      <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:emmanuel.rouat@wanadoo.fr">Emmanuel
        Rouat</link> suggested corrections and additions on <link linkend="commandsubref">command substitution</link>,
        <link linkend="aliasref">aliases</link>, and <link linkend="pathmanagement">path management</link>. He also
        contributed a very nice sample <filename>.bashrc</filename> file
        (<xref linkend="sample-bashrc" />).</para>

      <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:heiner.steven@odn.de">Heiner Steven</link>
	kindly gave permission to use his base conversion script, <xref linkend="base" />. He also made a number of corrections and many
	helpful suggestions. Special thanks.</para>

      <para>Rick Boivie contributed the delightfully recursive
	<emphasis>pb.sh</emphasis> script (<xref linkend="pbook" />),
	revised the <emphasis>tree.sh</emphasis> script (<xref linkend="tree" />), and suggested performance improvements
	for the <emphasis>monthlypmt.sh</emphasis> script (<xref linkend="monthlypmt" />).</para>

      <para>Florian Wisser enlightened me on some of the fine points of
	testing strings (see <xref linkend="strtest" />), and on other
	matters.</para>

      <para>Oleg Philon sent suggestions concerning <link linkend="cutref">cut</link> and <link linkend="pidofref">pidof</link>.</para>

      <para>Michael Zick extended the <link linkend="emptyarray">empty
	array</link> example to demonstrate some surprising array
	properties. He also contributed the <emphasis>isspammer</emphasis>
	scripts (<xref linkend="isspammer" /> and <xref linkend="isspammer2" />).</para>

      <para>Marc-Jano Knopp sent corrections and clarifications on DOS
        batch files.</para>

      <para>Hyun Jin Cha found several typos in the document in the
        process of doing a Korean translation. Thanks for pointing
        these out.</para>

      <para>Andreas Abraham sent in a long list of typographical
	errors and other corrections. Special thanks!</para>


      <para>Others contributing scripts, making helpful suggestions, and
	pointing out errors were Gabor Kiss, Leopold Toetsch,
	Peter Tillier, Marcus Berglof, Tony Richardson, Nick Drage
	(script ideas!), Rich Bartell, Jess Thrysoee, Adam Lazur, Bram
	Moolenaar, Baris Cicek, Greg Keraunen, Keith Matthews, Sandro
	Magi, Albert Reiner, Dim Segebart, Rory Winston, Lee Bigelow,
	Wayne Pollock, <quote>jipe,</quote> <quote>bojster,</quote>
	<quote>nyal,</quote> <quote>Hobbit,</quote> <quote>Ender,</quote>
	<quote>Little Monster</quote> (Alexis), <quote>Mark,</quote>
	<quote>Patsie,</quote> <quote>vladz,</quote> Peggy Russell,
	Emilio Conti, Ian. D. Allen, Hans-Joerg Diers, Arun Giridhar,
	Dennis Leeuw, Dan Jacobson, Aurelio Marinho Jargas, Edward
	Scholtz, Jean Helou, Chris Martin, Lee Maschmeyer, Bruno Haible,
	Wilbert Berendsen, Sebastien Godard, BjÃ¶n Eriksson, John
	MacDonald, John Lange, Joshua Tschida, Troy Engel, Manfred
	Schwarb, Amit Singh, Bill Gradwohl, E. Choroba, David Lombard,
	Jason Parker, Steve Parker, Bruce W. Clare, William Park, Vernia
	Damiano, Mihai Maties, Mark Alexander, Jeremy Impson, Ken Fuchs,
	Jared Martin, Frank Wang, Sylvain Fourmanoit, Matthew Sage,
	Matthew Walker, Kenny Stauffer, Filip Moritz, Andrzej Stefanski,
	Daniel Albers, Jeffrey Haemer, Stefano Palmeri, Nils Radtke,
	Sigurd Solaas, Serghey Rodin, Jeroen Domburg, Alfredo Pironti,
	Phil Braham, Bruno de Oliveira Schneider, Stefano Falsetto,
	Chris Morgan, Walter Dnes, Linc Fessenden, Michael Iatrou, Pharis
	Monalo, Jesse Gough, Fabian Kreutz, Mark Norman, Harald Koenig,
	Dan Stromberg, Peter Knowles, Francisco Lobo, Mariusz Gniazdowski,
	Sebastian Arming, Chetankumar Phulpagare, Benno Schulenberg,
	Tedman Eng, Jochen DeSmet, Juan Nicolas Ruiz, Oliver Beckstein,
	Achmed Darwish, Dotan Barak, Richard Neill, Albert Siersema,
	Omair Eshkenazi, Geoff Lee, Graham Ewart, JuanJo Ciarlante,
	Cliff Bamford, Nathan Coulter, Ramses Rodriguez Martinez,
	Evgeniy Ivanov, Craig Barnes, George Dimitriu, Kevin LeBlanc,
	Antonio Macchi, Tomas Pospisek, David Wheeler, Erik Brandsberg,
	YongYe, Andreas KÃ¼hne, PÃ¡draig Brady, Joseph
	Steinhauser, and David Lawyer (himself an author of four
	HOWTOs).</para>

      <para>My gratitude to <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:chet@po.cwru.edu">Chet
	Ramey</link> and Brian Fox for writing <firstterm>Bash</firstterm>,
	and building into it elegant and powerful scripting
	capabilities rivaling those of <firstterm>ksh</firstterm>.</para>

      <para>Very special thanks to the hard-working volunteers at
	the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org">Linux Documentation
	Project</link>. The LDP hosts a repository of Linux knowledge
	and lore, and has, to a great extent, enabled the publication
	of this book.</para>

      <para>Thanks and appreciation to IBM, Red Hat, Google, the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.fsf.org">Free Software Foundation</link>, and
        all the good people fighting the good fight to keep Open Source
        software free and open.</para>

      <para>Belated thanks to my fourth grade teacher, Miss Spencer,
        for emotional support and for convincing me that maybe, just
        maybe I wasn't a total loss.</para>

      <para>Thanks most of all to my wife, Anita, for her encouragement,
        inspiration,  and emotional support.</para>	

    </section> <!-- Credits --> 

    <section xml:id="disclaimer">
      <title>Disclaimer</title>


      <para>(This is a variant of the standard <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org">LDP</link> disclaimer.)</para>

      <para>No liability for the contents of this document can be
        accepted. Use the concepts, examples and information at your
        own risk. There may be errors, omissions, and inaccuracies
	that could cause you to lose data, harm your system, or induce
	involuntary electrocution, so <emphasis>proceed with appropriate
	caution</emphasis>. The author takes no responsibility for any
	damages, incidental or otherwise.</para>

      <para>As it happens, it is highly unlikely that either you or
        your system will suffer ill effects, aside from uncontrollable
	hiccups. In fact, the <foreignphrase>raison
	d'etre</foreignphrase> of this book is to enable its readers
	to analyze shell scripts and determine whether they have <link linkend="gotchas">unanticipated consequences</link>.</para>

    </section> <!-- Disclaimer --> 

  </chapter> <!-- End Notes --> 



  <bibliography xml:id="biblio">
  <anchor xml:id="biblioref" />

    <epigraph>
      <para>Those who do not understand UNIX are condemned to reinvent it,
	poorly.</para>
      <para>--Henry Spencer</para>
             <para><anchor xml:id="denningref" /></para>
    </epigraph>
    

    <biblioentry>
      <authorgroup>
	<editor><personname><firstname>Peter</firstname><surname>Denning</surname></personname></editor>
      </authorgroup>
      <citetitle>Computers Under Attack: Intruders, Worms, and Viruses</citetitle>
      <publisher>
	<publishername>ACM Press</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <biblioid class="isbn">0-201-53067-8</biblioid>
      <abstract><para>This compendium contains a couple of articles on 
        shell script viruses.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Ken</firstname><surname>Burtch</surname></personname></author>
      </authorgroup>
      <citetitle><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.samspublishing.com/title/0672326426">Linux Shell Scripting with Bash</link></citetitle>
      <edition>1st edition</edition>
      <publisher>
	<publishername>Sams Publishing (Pearson)</publishername>
      </publisher>
      <copyright>
	<year>2004</year>
      </copyright>
      <biblioid class="isbn">0672326426</biblioid>
      <abstract><para>
	  Covers much of the same material as the <emphasis>ABS
	    Guide</emphasis>, though in a different style.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>


    <biblioentry>
      <anchor xml:id="dgsedref"/>
      <authorgroup>
	<author><personname><firstname>Daniel</firstname><surname>Goldman</surname></personname></author>
      </authorgroup>
       <citetitle><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.sed-book.com/">Definitive Guide
       to Sed</link></citetitle>
      <edition>1st edition</edition>
      <copyright>
	<year>2013</year>
      </copyright>
      <abstract><para>
         This ebook is an excellent introduction to
         <firstterm>sed</firstterm>. Rather than being a conversion from
         a printed volume, it was specifically designed and formatted
         for viewing on an ebook reader. Well-written, informative,
	 and useful as a reference as well as a tutorial. Highly
	 recommended.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>



    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Dale</firstname><surname>Dougherty</surname></personname></author>
	<author><personname><firstname>Arnold</firstname><surname>Robbins</surname></personname></author>
      </authorgroup>
      <citetitle>Sed and Awk</citetitle>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <biblioid class="isbn">1-156592-225-5</biblioid>
      <abstract><para>
	  Unfolding the full power of shell scripting requires at least a passing
	  familiarity with <link linkend="sedref"><firstterm>sed</firstterm>
	  and <firstterm>awk</firstterm></link>. This is the classic
	  tutorial. It includes an excellent introduction to
	  <firstterm>Regular Expressions</firstterm>. Recommended.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Jeffrey</firstname><surname>Friedl</surname></personname></author>
      </authorgroup>
      <citetitle>Mastering Regular Expressions</citetitle>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <biblioid class="isbn">0-596-00289-0</biblioid>
      <abstract><para>Still the best all-around reference on <link linkend="regexref">Regular Expressions</link>.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Aeleen</firstname><surname>Frisch</surname></personname></author>
      </authorgroup>
      <citetitle>Essential System Administration</citetitle>
      <edition>3rd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <biblioid class="isbn">0-596-00343-9</biblioid>
      <abstract><para>This excellent manual provides a decent introduction
          to shell scripting from a sys admin point of view. It includes
          comprehensive explanations of the startup and initialization
          scripts in a UNIX system.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <anchor xml:id="kochanref"/>
      <authorgroup>
	<author><personname><firstname>Stephen</firstname><surname>Kochan</surname></personname></author>
	<author><personname><firstname>Patrick</firstname><surname>Wood</surname></personname></author>
      </authorgroup>
      <citetitle>Unix Shell Programming</citetitle>
      <publisher>
	<publishername>Hayden</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <biblioid class="isbn">067248448X</biblioid>
      <abstract>
      <para>Still considered a standard reference, though somewhat dated, and
      a bit <quote>wooden</quote> stylistically speaking.
          <footnote><para>It was hard to resist the obvious pun. No slight
	  intended, since the book is a pretty decent introduction to
	  the basic concepts of shell scripting.</para></footnote>
	In fact, this book was the <firstterm>ABS Guide</firstterm> author's
	first exposure to UNIX shell scripting, lo these many years ago.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Neil</firstname><surname>Matthew</surname></personname></author>
	<author><personname><firstname>Richard</firstname><surname>Stones</surname></personname></author>
      </authorgroup>
      <citetitle>Beginning Linux Programming</citetitle>
      <publisher>
	<publishername>Wrox Press</publishername>
      </publisher>
      <copyright>
	<year>1996</year>
      </copyright>
      <biblioid class="isbn">1874416680</biblioid>
      <abstract><para>Surprisingly good in-depth coverage of various
        programming languages available for Linux, including a fairly
        strong chapter on shell scripting.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <anchor xml:id="mayerref"/>
      <authorgroup>
	<author><personname><firstname>Herbert</firstname><surname>Mayer</surname></personname></author>
      </authorgroup>
      <citetitle>Advanced C Programming on the IBM PC</citetitle>
      <publisher>
	<publishername>Windcrest Books</publishername>
      </publisher>
      <copyright>
	<year>1989</year>
      </copyright>
      <biblioid class="isbn">0830693637</biblioid>
      <abstract><para>Excellent coverage of algorithms and general
        programming practices. Highly recommended, but unfortunately
        out of print.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>Medinets</surname></personname></author>
      </authorgroup>
      <citetitle>Unix Shell Programming Tools</citetitle>
      <publisher>
	<publishername>McGraw-Hill</publishername>
      </publisher>
      <copyright>
	<year>1999</year>
      </copyright>
      <biblioid class="isbn">0070397333</biblioid>
      <abstract><para>Pretty good treatment of shell scripting, with
        examples, and a short intro to Tcl and Perl.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Cameron</firstname><surname>Newham</surname></personname></author>
	<author><personname><firstname>Bill</firstname><surname>Rosenblatt</surname></personname></author>
      </authorgroup>
      <citetitle>Learning the Bash Shell</citetitle>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <biblioid class="isbn">1-56592-347-2</biblioid>
      <abstract><para>This is a valiant effort at a decent shell primer,
          but sadly deficient in its coverage of writing scripts and
          lacking sufficient examples.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Anatole</firstname><surname>Olczak</surname></personname></author>
      </authorgroup>
      <citetitle>Bourne Shell Quick Reference Guide</citetitle>
      <publisher>
	<publishername>ASP, Inc.</publishername>
      </publisher>
      <copyright>
	<year>1991</year>
      </copyright>
      <biblioid class="isbn">093573922X</biblioid>
      <abstract><para>A very handy pocket reference, despite lacking
        coverage of Bash-specific features.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Jerry</firstname><surname>Peek</surname></personname></author>
	<author><personname><firstname>Tim</firstname><surname>O'Reilly</surname></personname></author>
	<author><personname><firstname>Mike</firstname><surname>Loukides</surname></personname></author>
      </authorgroup>
      <citetitle>Unix Power Tools</citetitle>
      <edition>3rd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <publisher>
	<publishername>Random House</publishername>
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <biblioid class="isbn">0-596-00330-7</biblioid>
      <abstract><para>Contains a couple of sections of very informative
       in-depth articles on shell programming, but falls short of being
       a self-teaching manual. It reproduces much of the <link linkend="regexref">Regular Expressions</link> tutorial from the
       Dougherty and Robbins book, above. The comprehensive coverage
       of UNIX commands makes this book worthy of a place on your
       bookshelf.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Clifford</firstname><surname>Pickover</surname></personname></author>
      </authorgroup>
      <citetitle>Computers, Pattern, Chaos, and Beauty</citetitle>
      <publisher>
	<publishername>St. Martin's Press</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <biblioid class="isbn">0-312-04123-3</biblioid>
      <abstract><para>A treasure trove of ideas and recipes for
        computer-based exploration of mathematical oddities.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>George</firstname><surname>Polya</surname></personname></author>
      </authorgroup>
      <citetitle>How To Solve It</citetitle>
      <publisher>
	<publishername>Princeton University Press</publishername>
      </publisher>
      <copyright>
	<year>1973</year>
      </copyright>
      <biblioid class="isbn">0-691-02356-5</biblioid>
      <abstract><para>The classic tutorial on problem-solving methods
        (algorithms), with special emphasis on how to teach them.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

     <biblioentry>
       <authorgroup>
 	<author><personname><firstname>Chet</firstname><surname>Ramey</surname></personname></author>
 	<author><personname><firstname>Brian</firstname><surname>Fox</surname></personname></author>
       </authorgroup>
       <citetitle><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.network-theory.co.uk/bash/manual/">The GNU Bash Reference Manual</link></citetitle>
       <publisher>
 	<publishername>Network Theory Ltd</publishername>
       </publisher>
       <copyright>
 	<year>2003</year>
       </copyright>
       <biblioid class="isbn">0-9541617-7-7</biblioid>
       <abstract><para>This manual is the definitive reference for
         GNU Bash. The authors of this manual, Chet Ramey and Brian Fox,
         are the original developers of GNU Bash. For each copy sold,
         the publisher donates $1 to the Free Software Foundation.</para>
	  <para>*</para>
       </abstract>
     </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Arnold</firstname><surname>Robbins</surname></personname></author>
      </authorgroup>
      <citetitle>Bash Reference Card</citetitle>
      <publisher>
	<publishername>SSC</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <biblioid class="isbn">1-58731-010-5</biblioid>
      <abstract>
          <para>Excellent Bash pocket reference (don't leave home without it,
	    especially if you're a sysadmin). A bargain at $4.95, but
	    unfortunately no longer available for free download.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Arnold</firstname><surname>Robbins</surname></personname></author>
      </authorgroup>
      <citetitle>Effective Awk Programming</citetitle>
      <publisher>
	<publishername>Free Software Foundation / O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2000</year>
      </copyright>
      <biblioid class="isbn">1-882114-26-4</biblioid>
      <abstract>
	  <para>The absolute best <link linkend="awkref">awk</link>
	    tutorial and reference. The free electronic version of this
	    book is part of the <firstterm>awk</firstterm> documentation,
	    and printed copies of the latest version are available from
	    O'Reilly and Associates.</para>
	  <para>This book served as an inspiration for the author
	    of the <firstterm>ABS Guide</firstterm>.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <anchor xml:id="kornshellref"/>
      <authorgroup>
	<author><personname><firstname>Bill</firstname><surname>Rosenblatt</surname></personname></author>
      </authorgroup>
      <citetitle>Learning the Korn Shell</citetitle>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1993</year>
      </copyright>
      <biblioid class="isbn">1-56592-054-6</biblioid>
      <abstract>
        <para>This well-written book contains
        some excellent pointers on shell scripting in general.</para>
        <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Paul</firstname><surname>Sheer</surname></personname></author>
      </authorgroup>
      <citetitle>LINUX: Rute User's Tutorial and Exposition</citetitle>
      <edition>1st edition</edition>
      <publisher>
	<publishername />
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <biblioid class="isbn">0-13-033351-4</biblioid>
      <abstract>
      <para>Very detailed and readable introduction to Linux system
        administration.</para>
      <para>The book is available in print, or
        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://burks.brighton.ac.uk/burks/linux/rute/rute.htm">on-line</link>.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Ellen</firstname><surname>Siever</surname></personname></author>
	<author><personname><surname>the staff of O'Reilly and Associates</surname></personname></author>
      </authorgroup>
      <citetitle>Linux in a Nutshell</citetitle>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1999</year>
      </copyright>
      <biblioid class="isbn">1-56592-585-8</biblioid>
      <abstract><para>The all-around best Linux command reference.
        It even has a Bash section.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><personname><firstname>Dave</firstname><surname>Taylor</surname></personname></author>
      </authorgroup>
      <citetitle>Wicked Cool Shell Scripts: 101 Scripts for Linux, Mac OS X, and Unix Systems</citetitle>
      <edition>1st edition</edition>
      <publisher>
	<publishername>No Starch Press</publishername>
      </publisher>
      <copyright>
	<year>2004</year>
      </copyright>
      <biblioid class="isbn">1-59327-012-7</biblioid>
      <abstract><para>Pretty much what the title promises . . .</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <citetitle>The UNIX CD Bookshelf</citetitle>
      <edition>3rd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2003</year>
      </copyright>
      <biblioid class="isbn">0-596-00392-7</biblioid>
      <abstract><para>An array of seven UNIX books on CD ROM, including
	<citetitle pubwork="book">UNIX Power Tools</citetitle>,
	<citetitle pubwork="book">Sed and Awk</citetitle>, and <citetitle pubwork="book">Learning the Korn Shell</citetitle>. A complete
	set of all the UNIX references and tutorials you would ever need
	at about $130. Buy this one, even if it means going into debt
	and not paying the rent.</para>
	<para>Update: Seems to have somehow fallen out of print.
	  Ah, well. You can still buy the dead-tree editions of these books.</para>
	<para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The O'Reilly books on Perl. (Actually,
	  <emphasis>any</emphasis> O'Reilly books.)</para>
      </abstract>
    </biblioentry>

    <!-- other resources -->
&otherres;

  </bibliography>



  <appendix xml:id="contributed-scripts">
      <title>Contributed Scripts</title>

    <para>These scripts, while not fitting into the text of this document, do
    illustrate some interesting shell programming techniques. Some are useful,
    too. Have fun analyzing and running them.</para>

    <example xml:id="mailformat">
      <title><firstterm>mailformat</firstterm>: Formatting an e-mail
      message</title>
      <programlisting>#!/bin/bash
# mail-format.sh (ver. 1.1): Format e-mail messages.

# Gets rid of carets, tabs, and also folds excessively long lines.

# =================================================================
#                 Standard Check for Script Argument(s)
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne $ARGS ]  # Correct number of arguments passed to script?
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ -f "$1" ]       # Check if file exists.
then
    file_name=$1
else
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
fi
# -----------------------------------------------------------------

MAXWIDTH=70          # Width to fold excessively long lines to.

# =================================
# A variable can hold a sed script.
# It's a useful technique.
sedscript='s/^&gt;//
s/^  *&gt;//
s/^  *//
s/		*//'
# =================================

#  Delete carets and tabs at beginning of lines,
#+ then fold lines to $MAXWIDTH characters.
sed "$sedscript" $1 | fold -s --width=$MAXWIDTH
                        #  -s option to "fold"
                        #+ breaks lines at whitespace, if possible.


#  This script was inspired by an article in a well-known trade journal
#+ extolling a 164K MS Windows utility with similar functionality.
#
#  An nice set of text processing utilities and an efficient
#+ scripting language provide an alternative to the bloated executables
#+ of a clunky operating system.

exit $?
</programlisting>
    </example>

    <example xml:id="rn">
      <title><firstterm>rn</firstterm>: A simple-minded file renaming
      utility</title>
      <para>This script is a modification of <xref linkend="lowercase" />.</para>
      <programlisting>#! /bin/bash
# rn.sh

# Very simpleminded filename "rename" utility (based on "lowercase.sh").
#
#  The "ren" utility, by Vladimir Lanin (lanin@csd2.nyu.edu),
#+ does a much better job of this.


ARGS=2
E_BADARGS=85
ONE=1                     # For getting singular/plural right (see below).

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` old-pattern new-pattern"
  # As in "rn gif jpg", which renames all gif files in working directory to jpg.
  exit $E_BADARGS
fi

number=0                  # Keeps track of how many files actually renamed.


for filename in *$1*      #Traverse all matching files in directory.
do
   if [ -f "$filename" ]  # If finds match...
   then
     fname=`basename $filename`            # Strip off path.
     n=`echo $fname | sed -e "s/$1/$2/"`   # Substitute new for old in filename.
     mv $fname $n                          # Rename.
     let "number += 1"
   fi
done   

if [ "$number" -eq "$ONE" ]                # For correct grammar.
then
 echo "$number file renamed."
else 
 echo "$number files renamed."
fi 

exit $?


# Exercises:
# ---------
# What types of files will this not work on?
# How can this be fixed?
</programlisting>
    </example>

    <example xml:id="blankrename">
      <title><firstterm>blank-rename</firstterm>: Renames filenames containing
        blanks</title>
      <para>This is an even simpler-minded version of previous script.</para>
      <programlisting>#! /bin/bash
# blank-rename.sh
#
# Substitutes underscores for blanks in all the filenames in a directory.

ONE=1                     # For getting singular/plural right (see below).
number=0                  # Keeps track of how many files actually renamed.
FOUND=0                   # Successful return value.

for filename in *         #Traverse all files in directory.
do
     echo "$filename" | grep -q " "         #  Check whether filename
     if [ $? -eq $FOUND ]                   #+ contains space(s).
     then
       fname=$filename                      # Yes, this filename needs work.
       n=`echo $fname | sed -e "s/ /_/g"`   # Substitute underscore for blank.
       mv "$fname" "$n"                     # Do the actual renaming.
       let "number += 1"
     fi
done   

if [ "$number" -eq "$ONE" ]                 # For correct grammar.
then
 echo "$number file renamed."
else 
 echo "$number files renamed."
fi 

exit 0
</programlisting>
    </example>

    <example xml:id="encryptedpw">
      <title><firstterm>encryptedpw</firstterm>: Uploading to an ftp site,
      using a locally encrypted password</title>
      <programlisting>#!/bin/bash

# Example "ex72.sh" modified to use encrypted password.

#  Note that this is still rather insecure,
#+ since the decrypted password is sent in the clear.
#  Use something like "ssh" if this is a concern.

E_BADARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi  

Username=bozo           # Change to suit.
pword=/home/bozo/secret/password_encrypted.file
# File containing encrypted password.

Filename=`basename $1`  # Strips pathname out of file name.

Server="XXX"
Directory="YYY"         # Change above to actual server name &amp; directory.


Password=`cruft &lt;$pword`          # Decrypt password.
#  Uses the author's own "cruft" file encryption package,
#+ based on the classic "onetime pad" algorithm,
#+ and obtainable from:
#+ Primary-site:   ftp://ibiblio.org/pub/Linux/utils/file
#+                 cruft-0.2.tar.gz [16k]


ftp -n $Server &lt;&lt;End-Of-Session
user $Username $Password
binary
bell
cd $Directory
put $Filename
bye
End-Of-Session
# -n option to "ftp" disables auto-logon.
# Note that "bell" rings 'bell' after each file transfer.

exit 0
</programlisting>
    </example>

    <example xml:id="copycd">
      <title><firstterm>copy-cd</firstterm>: Copying a data CD</title>
      <programlisting>#!/bin/bash
# copy-cd.sh: copying a data CD

CDROM=/dev/cdrom                           # CD ROM device
OF=/home/bozo/projects/cdimage.iso         # output file
#       /xxxx/xxxxxxxx/                      Change to suit your system.
BLOCKSIZE=2048
# SPEED=10                                 # If unspecified, uses max spd.
# DEVICE=/dev/cdrom                          older version.
DEVICE="1,0,0"

echo; echo "Insert source CD, but do *not* mount it."
echo "Press ENTER when ready. "
read ready                                 # Wait for input, $ready not used.

echo; echo "Copying the source CD to $OF."
echo "This may take a while. Please be patient."

dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Raw device copy.


echo; echo "Remove data CD."
echo "Insert blank CDR."
echo "Press ENTER when ready. "
read ready                                 # Wait for input, $ready not used.

echo "Copying $OF to CDR."

# cdrecord -v -isosize speed=$SPEED dev=$DEVICE $OF   # Old version.
wodim -v -isosize dev=$DEVICE $OF
# Uses Joerg Schilling's "cdrecord" package (see its docs).
# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html
# Newer Linux distros may use "wodim" rather than "cdrecord" ...


echo; echo "Done copying $OF to CDR on device $CDROM."

echo "Do you want to erase the image file (y/n)? "  # Probably a huge file.
read answer

case "$answer" in
[yY]) rm -f $OF
      echo "$OF erased."
      ;;
*)    echo "$OF not erased.";;
esac

echo

# Exercise:
# Change the above "case" statement to also accept "yes" and "Yes" as input.

exit 0
</programlisting>
    </example>

    <example xml:id="collatz">
      <title>Collatz series</title>
    <programlisting>#!/bin/bash
# collatz.sh

#  The notorious "hailstone" or Collatz series.
#  -------------------------------------------
#  1) Get the integer "seed" from the command-line.
#  2) NUMBER &lt;-- seed
#  3) Print NUMBER.
#  4)  If NUMBER is even, divide by 2, or
#  5)+ if odd, multiply by 3 and add 1.
#  6) NUMBER &lt;-- result 
#  7) Loop back to step 3 (for specified number of iterations).
#
#  The theory is that every such sequence,
#+ no matter how large the initial value,
#+ eventually settles down to repeating "4,2,1..." cycles,
#+ even after fluctuating through a wide range of values.
#
#  This is an instance of an "iterate,"
#+ an operation that feeds its output back into its input.
#  Sometimes the result is a "chaotic" series.


MAX_ITERATIONS=200
# For large seed numbers (&gt;32000), try increasing MAX_ITERATIONS.

h=${1:-$$}                      #  Seed.
                                #  Use $PID as seed,
                                #+ if not specified as command-line arg.

echo
echo "C($h) -*- $MAX_ITERATIONS Iterations"
echo

for ((i=1; i&lt;=MAX_ITERATIONS; i++))
do

# echo -n "$h	"
#            ^^^ 
#            tab
# printf does it better ...
COLWIDTH=%7d
printf $COLWIDTH $h

  let "remainder = h % 2"
  if [ "$remainder" -eq 0 ]   # Even?
  then
    let "h /= 2"              # Divide by 2.
  else
    let "h = h*3 + 1"         # Multiply by 3 and add 1.
  fi


COLUMNS=10                    # Output 10 values per line.
let "line_break = i % $COLUMNS"
if [ "$line_break" -eq 0 ]
then
  echo
fi  

done

echo

#  For more information on this strange mathematical function,
#+ see _Computers, Pattern, Chaos, and Beauty_, by Pickover, p. 185 ff.,
#+ as listed in the bibliography.

exit 0
</programlisting>
    </example>

    <para><anchor xml:id="daysbetween0" /></para>
    <example xml:id="daysbetween">
      <title><firstterm>days-between</firstterm>: Days between two
        dates</title>
      <programlisting>#!/bin/bash
# days-between.sh:    Number of days between two dates.
# Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY
#
# Note: Script modified to account for changes in Bash, v. 2.05b +,
#+      that closed the loophole permitting large negative
#+      integer return values.

ARGS=2                # Two command-line parameters expected.
E_PARAM_ERR=85        # Param error.

REFYR=1600            # Reference year.
CENTURY=100
DIY=365
ADJ_DIY=367           # Adjusted for leap year + fraction.
MIY=12
DIM=31
LEAPCYCLE=4

MAXRETVAL=255         #  Largest permissible
                      #+ positive return value from a function.

diff=                 # Declare global variable for date difference.
value=                # Declare global variable for absolute value.
day=                  # Declare globals for day, month, year.
month=
year=


Param_Error ()        # Command-line parameters wrong.
{
  echo "Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY"
  echo "       (date must be after 1/3/1600)"
  exit $E_PARAM_ERR
}  


Parse_Date ()                 # Parse date from command-line params.
{
  month=${1%%/**}
  dm=${1%/**}                 # Day and month.
  day=${dm#*/}
  let "year = `basename $1`"  # Not a filename, but works just the same.
}  


check_date ()                 # Checks for invalid date(s) passed.
{
  [ "$day" -gt "$DIM" ] || [ "$month" -gt "$MIY" ] ||
  [ "$year" -lt "$REFYR" ] &amp;&amp; Param_Error
  # Exit script on bad value(s).
  # Uses or-list / and-list.
  #
  # Exercise: Implement more rigorous date checking.
}


strip_leading_zero () #  Better to strip possible leading zero(s)
{                     #+ from day and/or month
  return ${1#0}       #+ since otherwise Bash will interpret them
}                     #+ as octal values (POSIX.2, sect 2.9.2.1).


day_index ()          # Gauss' Formula:
{                     # Days from March 1, 1600 to date passed as param.
                      #           ^^^^^^^^^^^^^
  day=$1
  month=$2
  year=$3

  let "month = $month - 2"
  if [ "$month" -le 0 ]
  then
    let "month += 12"
    let "year -= 1"
  fi  

  let "year -= $REFYR"
  let "indexyr = $year / $CENTURY"


  let "Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr \
              + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM"
  #  For an in-depth explanation of this algorithm, see
  #+   http://weblogs.asp.net/pgreborio/archive/2005/01/06/347968.aspx


  echo $Days

}  


calculate_difference ()            # Difference between two day indices.
{
  let "diff = $1 - $2"             # Global variable.
}  


abs ()                             #  Absolute value
{                                  #  Uses global "value" variable.
  if [ "$1" -lt 0 ]                #  If negative
  then                             #+ then
    let "value = 0 - $1"           #+ change sign,
  else                             #+ else
    let "value = $1"               #+ leave it alone.
  fi
}



if [ $# -ne "$ARGS" ]              # Require two command-line params.
then
  Param_Error
fi  

Parse_Date $1
check_date $day $month $year       #  See if valid date.

strip_leading_zero $day            #  Remove any leading zeroes
day=$?                             #+ on day and/or month.
strip_leading_zero $month
month=$?

let "date1 = `day_index $day $month $year`"


Parse_Date $2
check_date $day $month $year

strip_leading_zero $day
day=$?
strip_leading_zero $month
month=$?

date2=$(day_index $day $month $year) # Command substitution.


calculate_difference $date1 $date2

abs $diff                            # Make sure it's positive.
diff=$value

echo $diff

exit 0

#  Exercise:
#  --------
#  If given only one command-line parameter, have the script
#+ use today's date as the second.


#  Compare this script with
#+ the implementation of Gauss' Formula in a C program at
#+    http://buschencrew.hypermart.net/software/datedif
</programlisting>
    </example>

    <example xml:id="makedict">
      <title>Making a <firstterm>dictionary</firstterm></title>
    <programlisting>#!/bin/bash
# makedict.sh  [make dictionary]

# Modification of /usr/sbin/mkdict (/usr/sbin/cracklib-forman) script.
# Original script copyright 1993, by Alec Muffett.
#
#  This modified script included in this document in a manner
#+ consistent with the "LICENSE" document of the "Crack" package
#+ that the original script is a part of.

#  This script processes text files to produce a sorted list
#+ of words found in the files.
#  This may be useful for compiling dictionaries
#+ and for other lexicographic purposes.


E_BADARGS=85

if [ ! -r "$1" ]                    #  Need at least one
then                                #+ valid file argument.
  echo "Usage: $0 files-to-process"
  exit $E_BADARGS
fi  


# SORT="sort"                       #  No longer necessary to define
                                    #+ options to sort. Changed from
                                    #+ original script.

cat $* |                            #  Dump specified files to stdout.
        tr A-Z a-z |                #  Convert to lowercase.
        tr ' ' '\012' |             #  New: change spaces to newlines.
#       tr -cd '\012[a-z][0-9]' |   #  Get rid of everything
                                    #+ non-alphanumeric (in orig. script).
        tr -c '\012a-z'  '\012' |   #  Rather than deleting non-alpha
                                    #+ chars, change them to newlines.
        sort |                      #  $SORT options unnecessary now.
        uniq |                      #  Remove duplicates.
        grep -v '^#' |              #  Delete lines starting with #.
        grep -v '^$'                #  Delete blank lines.

exit $?
</programlisting>
    </example>

    <para><anchor xml:id="soundex0" /></para>
    <example xml:id="soundex">
      <title>Soundex conversion</title>
    <programlisting>#!/bin/bash
# soundex.sh: Calculate "soundex" code for names

# =======================================================
#        Soundex script
#              by
#         Mendel Cooper
#     thegrendel.abs@gmail.com
#     reldate: 23 January, 2002
#
#   Placed in the Public Domain.
#
# A slightly different version of this script appeared in
#+ Ed Schaefer's July, 2002 "Shell Corner" column
#+ in "Unix Review" on-line,
#+ http://www.unixreview.com/documents/uni1026336632258/
# =======================================================


ARGCOUNT=1                     # Need name as argument.
E_WRONGARGS=90

if [ $# -ne "$ARGCOUNT" ]
then
  echo "Usage: `basename $0` name"
  exit $E_WRONGARGS
fi  


assign_value ()                #  Assigns numerical value
{                              #+ to letters of name.

  val1=bfpv                    # 'b,f,p,v' = 1
  val2=cgjkqsxz                # 'c,g,j,k,q,s,x,z' = 2
  val3=dt                      #  etc.
  val4=l
  val5=mn
  val6=r

# Exceptionally clever use of 'tr' follows.
# Try to figure out what is going on here.

value=$( echo "$1" \
| tr -d wh \
| tr $val1 1 | tr $val2 2 | tr $val3 3 \
| tr $val4 4 | tr $val5 5 | tr $val6 6 \
| tr -s 123456 \
| tr -d aeiouy )

# Assign letter values.
# Remove duplicate numbers, except when separated by vowels.
# Ignore vowels, except as separators, so delete them last.
# Ignore 'w' and 'h', even as separators, so delete them first.
#
# The above command substitution lays more pipe than a plumber &lt;g&gt;.

}  


input_name="$1"
echo
echo "Name = $input_name"


# Change all characters of name input to lowercase.
# ------------------------------------------------
name=$( echo $input_name | tr A-Z a-z )
# ------------------------------------------------
# Just in case argument to script is mixed case.


# Prefix of soundex code: first letter of name.
# --------------------------------------------


char_pos=0                     # Initialize character position. 
prefix0=${name:$char_pos:1}
prefix=`echo $prefix0 | tr a-z A-Z`
                               # Uppercase 1st letter of soundex.

let "char_pos += 1"            # Bump character position to 2nd letter of name.
name1=${name:$char_pos}


# ++++++++++++++++++++++++++ Exception Patch ++++++++++++++++++++++++++++++
#  Now, we run both the input name and the name shifted one char
#+ to the right through the value-assigning function.
#  If we get the same value out, that means that the first two characters
#+ of the name have the same value assigned, and that one should cancel.
#  However, we also need to test whether the first letter of the name
#+ is a vowel or 'w' or 'h', because otherwise this would bollix things up.

char1=`echo $prefix | tr A-Z a-z`    # First letter of name, lowercased.

assign_value $name
s1=$value
assign_value $name1
s2=$value
assign_value $char1
s3=$value
s3=9$s3                              #  If first letter of name is a vowel
                                     #+ or 'w' or 'h',
                                     #+ then its "value" will be null (unset).
				     #+ Therefore, set it to 9, an otherwise
				     #+ unused value, which can be tested for.


if [[ "$s1" -ne "$s2" || "$s3" -eq 9 ]]
then
  suffix=$s2
else  
  suffix=${s2:$char_pos}
fi  
# ++++++++++++++++++++++ end Exception Patch ++++++++++++++++++++++++++++++


padding=000                    # Use at most 3 zeroes to pad.


soun=$prefix$suffix$padding    # Pad with zeroes.

MAXLEN=4                       # Truncate to maximum of 4 chars.
soundex=${soun:0:$MAXLEN}

echo "Soundex = $soundex"

echo

#  The soundex code is a method of indexing and classifying names
#+ by grouping together the ones that sound alike.
#  The soundex code for a given name is the first letter of the name,
#+ followed by a calculated three-number code.
#  Similar sounding names should have almost the same soundex codes.

#   Examples:
#   Smith and Smythe both have a "S-530" soundex.
#   Harrison = H-625
#   Hargison = H-622
#   Harriman = H-655

#  This works out fairly well in practice, but there are numerous anomalies.
#
#
#  The U.S. Census and certain other governmental agencies use soundex,
#  as do genealogical researchers.
#
#  For more information,
#+ see the "National Archives and Records Administration home page",
#+ http://www.nara.gov/genealogy/soundex/soundex.html



# Exercise:
# --------
# Simplify the "Exception Patch" section of this script.

exit 0
</programlisting>
    </example>

    <para><anchor xml:id="liferef" /></para>
    <example xml:id="lifeslow">
      <title><firstterm>Game of Life</firstterm></title>
    <programlisting>#!/bin/bash
# life.sh: "Life in the Slow Lane"
# Author: Mendel Cooper
# License: GPL3

# Version 0.2:   Patched by Daniel Albers
#+               to allow non-square grids as input.
# Version 0.2.1: Added 2-second delay between generations.

# ##################################################################### #
# This is the Bash script version of John Conway's "Game of Life".      #
# "Life" is a simple implementation of cellular automata.               #
# --------------------------------------------------------------------- #
# On a rectangular grid, let each "cell" be either "living" or "dead."  #
# Designate a living cell with a dot, and a dead one with a blank space.#
#      Begin with an arbitrarily drawn dot-and-blank grid,              #
#+     and let this be the starting generation: generation 0.           #
# Determine each successive generation by the following rules:          #
#   1) Each cell has 8 neighbors, the adjoining cells                   #
#+     left, right, top, bottom, and the 4 diagonals.                   #
#                                                                       #
#                       123                                             #
#                       4*5     The * is the cell under consideration.  #
#                       678                                             #
#                                                                       #
# 2) A living cell with either 2 or 3 living neighbors remains alive.   #
SURVIVE=2                                                               #
# 3) A dead cell with 3 living neighbors comes alive, a "birth."        #
BIRTH=3                                                                 #
# 4) All other cases result in a dead cell for the next generation.     #
# ##################################################################### #


startfile=gen0   # Read the starting generation from the file "gen0" ...
                 # Default, if no other file specified when invoking script.
                 #
if [ -n "$1" ]   # Specify another "generation 0" file.
then
    startfile="$1"
fi  

############################################
#  Abort script if "startfile" not specified
#+ and
#+ default file "gen0" not present.

E_NOSTARTFILE=86

if [ ! -e "$startfile" ]
then
  echo "Startfile \""$startfile"\" missing!"
  exit $E_NOSTARTFILE
fi
############################################


ALIVE1=.
DEAD1=_
                 # Represent living and dead cells in the start-up file.

#  -----------------------------------------------------#
#  This script uses a 10 x 10 grid (may be increased,
#+ but a large grid will slow down execution).
ROWS=10
COLS=10
#  Change above two variables to match desired grid size.
#  -----------------------------------------------------#

GENERATIONS=10          #  How many generations to cycle through.
                        #  Adjust this upwards
                        #+ if you have time on your hands.

NONE_ALIVE=85           #  Exit status on premature bailout,
                        #+ if no cells left alive.
DELAY=2                 #  Pause between generations.
TRUE=0
FALSE=1
ALIVE=0
DEAD=1

avar=                   # Global; holds current generation.
generation=0            # Initialize generation count.

# =================================================================

let "cells = $ROWS * $COLS"   # How many cells.

# Arrays containing "cells."
declare -a initial
declare -a current

display ()
{

alive=0                 # How many cells alive at any given time.
                        # Initially zero.

declare -a arr
arr=( `echo "$1"` )     # Convert passed arg to array.

element_count=${#arr[*]}

local i
local rowcheck

for ((i=0; i&lt;$element_count; i++))
do

  # Insert newline at end of each row.
  let "rowcheck = $i % COLS"
  if [ "$rowcheck" -eq 0 ]
  then
    echo                # Newline.
    echo -n "      "    # Indent.
  fi  

  cell=${arr[i]}

  if [ "$cell" = . ]
  then
    let "alive += 1"
  fi  

  echo -n "$cell" | sed -e 's/_/ /g'
  # Print out array, changing underscores to spaces.
done  

return

}

IsValid ()                            # Test if cell coordinate valid.
{

  if [ -z "$1"  -o -z "$2" ]          # Mandatory arguments missing?
  then
    return $FALSE
  fi

local row
local lower_limit=0                   # Disallow negative coordinate.
local upper_limit
local left
local right

let "upper_limit = $ROWS * $COLS - 1" # Total number of cells.


if [ "$1" -lt "$lower_limit" -o "$1" -gt "$upper_limit" ]
then
  return $FALSE                       # Out of array bounds.
fi  

row=$2
let "left = $row * $COLS"             # Left limit.
let "right = $left + $COLS - 1"       # Right limit.

if [ "$1" -lt "$left" -o "$1" -gt "$right" ]
then
  return $FALSE                       # Beyond row boundary.
fi  

return $TRUE                          # Valid coordinate.

}  


IsAlive ()              #  Test whether cell is alive.
                        #  Takes array, cell number, and
{                       #+ state of cell as arguments.
  GetCount "$1" $2      #  Get alive cell count in neighborhood.
  local nhbd=$?

  if [ "$nhbd" -eq "$BIRTH" ]  # Alive in any case.
  then
    return $ALIVE
  fi

  if [ "$3" = "." -a "$nhbd" -eq "$SURVIVE" ]
  then                  # Alive only if previously alive.
    return $ALIVE
  fi  

  return $DEAD          # Defaults to dead.

}  


GetCount ()             # Count live cells in passed cell's neighborhood.
                        # Two arguments needed:
			# $1) variable holding array
			# $2) cell number
{
  local cell_number=$2
  local array
  local top
  local center
  local bottom
  local r
  local row
  local i
  local t_top
  local t_cen
  local t_bot
  local count=0
  local ROW_NHBD=3

  array=( `echo "$1"` )

  let "top = $cell_number - $COLS - 1"    # Set up cell neighborhood.
  let "center = $cell_number - 1"
  let "bottom = $cell_number + $COLS - 1"
  let "r = $cell_number / $COLS"

  for ((i=0; i&lt;$ROW_NHBD; i++))           # Traverse from left to right. 
  do
    let "t_top = $top + $i"
    let "t_cen = $center + $i"
    let "t_bot = $bottom + $i"


    let "row = $r"                        # Count center row.
    IsValid $t_cen $row                   # Valid cell position?
    if [ $? -eq "$TRUE" ]
    then
      if [ ${array[$t_cen]} = "$ALIVE1" ] # Is it alive?
      then                                # If yes, then ...
        let "count += 1"                  # Increment count.
      fi	
    fi  

    let "row = $r - 1"                    # Count top row.          
    IsValid $t_top $row
    if [ $? -eq "$TRUE" ]
    then
      if [ ${array[$t_top]} = "$ALIVE1" ] # Redundancy here.
      then                                # Can it be optimized?
        let "count += 1"
      fi	
    fi  

    let "row = $r + 1"                    # Count bottom row.
    IsValid $t_bot $row
    if [ $? -eq "$TRUE" ]
    then
      if [ ${array[$t_bot]} = "$ALIVE1" ] 
      then
        let "count += 1"
      fi	
    fi  

  done  


  if [ ${array[$cell_number]} = "$ALIVE1" ]
  then
    let "count -= 1"        #  Make sure value of tested cell itself
  fi                        #+ is not counted.


  return $count
  
}

next_gen ()               # Update generation array.
{

local array
local i=0

array=( `echo "$1"` )     # Convert passed arg to array.

while [ "$i" -lt "$cells" ]
do
  IsAlive "$1" $i ${array[$i]}   # Is the cell alive?
  if [ $? -eq "$ALIVE" ]
  then                           #  If alive, then
    array[$i]=.                  #+ represent the cell as a period.
  else  
    array[$i]="_"                #  Otherwise underscore
   fi                            #+ (will later be converted to space).
  let "i += 1" 
done   


#    let "generation += 1"       # Increment generation count.
###  Why was the above line commented out?


# Set variable to pass as parameter to "display" function.
avar=`echo ${array[@]}`   # Convert array back to string variable.
display "$avar"           # Display it.
echo; echo
echo "Generation $generation  -  $alive alive"

if [ "$alive" -eq 0 ]
then
  echo
  echo "Premature exit: no more cells alive!"
  exit $NONE_ALIVE        #  No point in continuing
fi                        #+ if no live cells.

}


# =========================================================

# main ()
# {

# Load initial array with contents of startup file.
initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
# Delete lines containing '#' comment character.
           sed -e 's/\./\. /g' -e 's/_/_ /g'` )
# Remove linefeeds and insert space between elements.

clear          # Clear screen.

echo #         Title
setterm -reverse on
echo "======================="
setterm -reverse off
echo "    $GENERATIONS generations"
echo "           of"
echo "\"Life in the Slow Lane\""
setterm -reverse on
echo "======================="
setterm -reverse off

sleep $DELAY   # Display "splash screen" for 2 seconds.


# -------- Display first generation. --------
Gen0=`echo ${initial[@]}`
display "$Gen0"           # Display only.
echo; echo
echo "Generation $generation  -  $alive alive"
sleep $DELAY
# -------------------------------------------


let "generation += 1"     # Bump generation count.
echo

# ------- Display second generation. -------
Cur=`echo ${initial[@]}`
next_gen "$Cur"          # Update &amp; display.
sleep $DELAY
# ------------------------------------------

let "generation += 1"     # Increment generation count.

# ------ Main loop for displaying subsequent generations ------
while [ "$generation" -le "$GENERATIONS" ]
do
  Cur="$avar"
  next_gen "$Cur"
  let "generation += 1"
  sleep $DELAY
done
# ==============================================================

echo
# }

exit 0   # CEOF:EOF



# The grid in this script has a "boundary problem."
# The top, bottom, and sides border on a void of dead cells.
# Exercise: Change the script to have the grid wrap around,
# +         so that the left and right sides will "touch,"      
# +         as will the top and bottom.
#
# Exercise: Create a new "gen0" file to seed this script.
#           Use a 12 x 16 grid, instead of the original 10 x 10 one.
#           Make the necessary changes to the script,
#+          so it will run with the altered file.
#
# Exercise: Modify this script so that it can determine the grid size
#+          from the "gen0" file, and set any variables necessary
#+          for the script to run.
#           This would make unnecessary any changes to variables
#+          in the script for an altered grid size.
#
# Exercise: Optimize this script.
#           It has redundant code.
</programlisting>
    </example>

    <example xml:id="gen0data">
      <title>Data file for <firstterm>Game of Life</firstterm></title>
    <programlisting># gen0
#
# This is an example "generation 0" start-up file for "life.sh".
# --------------------------------------------------------------
#  The "gen0" file is a 10 x 10 grid using a period (.) for live cells,
#+ and an underscore (_) for dead ones. We cannot simply use spaces
#+ for dead cells in this file because of a peculiarity in Bash arrays.
#  [Exercise for the reader: explain this.]
#
# Lines beginning with a '#' are comments, and the script ignores them.
__.__..___
__.._.____
____.___..
_._______.
____._____
..__...___
____._____
___...____
__.._..___
_..___..__
</programlisting>
    </example>



    <para>+++</para>
    
    <para>The following script is by Mark Moraes of the University
    of Toronto. See the file <filename>Moraes-COPYRIGHT</filename>
    for permissions and restrictions. This file is included in the
    combined <link linkend="where_tarball">HTML/source tarball</link>
    of the <emphasis>ABS Guide</emphasis>.</para>

    <example xml:id="behead">
      <title><firstterm>behead</firstterm>: Removing mail and news
      message headers</title>
      <programlisting>#! /bin/sh
#  Strips off the header from a mail/News message i.e. till the first
#+ empty line.
#  Author: Mark Moraes, University of Toronto

# ==&gt; These comments added by author of this document.

if [ $# -eq 0 ]; then
# ==&gt; If no command-line args present, then works on file redirected to stdin.
	sed -e '1,/^$/d' -e '/^[ 	]*$/d'
	# --&gt; Delete empty lines and all lines until 
	# --&gt; first one beginning with white space.
else
# ==&gt; If command-line args present, then work on files named.
	for i do
		sed -e '1,/^$/d' -e '/^[ 	]*$/d' $i
		# --&gt; Ditto, as above.
	done
fi

exit

# ==&gt; Exercise: Add error checking and other options.
# ==&gt;
# ==&gt; Note that the small sed script repeats, except for the arg passed.
# ==&gt; Does it make sense to embed it in a function? Why or why not?


/*
 * Copyright University of Toronto 1988, 1989.
 * Written by Mark Moraes
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. The author and the University of Toronto are not responsible 
 *    for the consequences of use of this software, no matter how awful, 
 *    even if they arise from flaws in it.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Since few users ever read sources,
 *    credits must appear in the documentation.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.  Since few users
 *    ever read sources, credits must appear in the documentation.
 *
 * 4. This notice may not be removed or altered.
 */
</programlisting>
    </example>

    <para>+</para>

    <para>Antek Sawicki contributed the following script, which makes very
      clever use of the parameter substitution operators discussed in
      <xref linkend="Parameter-Substitution" />.</para>

    <para><anchor xml:id="pw0" /></para>
    <example xml:id="pw">
      <title><firstterm>password</firstterm>: Generating random
      8-character passwords</title>
      <programlisting>#!/bin/bash
#
#
#  Random password generator for Bash 2.x +
#+ by Antek Sawicki &lt;tenox@tenox.tc&gt;,
#+ who generously gave usage permission to the ABS Guide author.
#
# ==&gt; Comments added by document author ==&gt;


MATRIX="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
# ==&gt; Password will consist of alphanumeric characters.
LENGTH="8"
# ==&gt; May change 'LENGTH' for longer password.


while [ "${n:=1}" -le "$LENGTH" ]
# ==&gt; Recall that := is "default substitution" operator.
# ==&gt; So, if 'n' has not been initialized, set it to 1.
do
	PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
	# ==&gt; Very clever, but tricky.

	# ==&gt; Starting from the innermost nesting...
	# ==&gt; ${#MATRIX} returns length of array MATRIX.

	# ==&gt; $RANDOM%${#MATRIX} returns random number between 1
	# ==&gt; and [length of MATRIX] - 1.

	# ==&gt; ${MATRIX:$(($RANDOM%${#MATRIX})):1}
	# ==&gt; returns expansion of MATRIX at random position, by length 1. 
	# ==&gt; See {var:pos:len} parameter substitution in Chapter 9.
	# ==&gt; and the associated examples.

	# ==&gt; PASS=... simply pastes this result onto previous PASS (concatenation).

	# ==&gt; To visualize this more clearly, uncomment the following line
	#                 echo "$PASS"
	# ==&gt; to see PASS being built up,
	# ==&gt; one character at a time, each iteration of the loop.

	let n+=1
	# ==&gt; Increment 'n' for next pass.
done

echo "$PASS"      # ==&gt; Or, redirect to a file, as desired.

exit 0
</programlisting>
    </example>

    <para>+</para>

    <para><anchor xml:id="zfifo" />James R. Van Zandt contributed this script
      which uses named pipes and, in his words, <quote>really exercises
      quoting and escaping.</quote></para>

    <example xml:id="fifo">
      <title><firstterm>fifo</firstterm>: Making daily backups, using
      named pipes</title>
      <programlisting>#!/bin/bash
# ==&gt; Script by James R. Van Zandt, and used here with his permission.

# ==&gt; Comments added by author of this document.

  
  HERE=`uname -n`    # ==&gt; hostname
  THERE=bilbo
  echo "starting remote backup to $THERE at `date +%r`"
  # ==&gt; `date +%r` returns time in 12-hour format, i.e. "08:08:34 PM".
  
  # make sure /pipe really is a pipe and not a plain file
  rm -rf /pipe
  mkfifo /pipe       # ==&gt; Create a "named pipe", named "/pipe" ...
  
  # ==&gt; 'su xyz' runs commands as user "xyz".
  # ==&gt; 'ssh' invokes secure shell (remote login client).
  su xyz -c "ssh $THERE \"cat &gt; /home/xyz/backup/${HERE}-daily.tar.gz\" &lt; /pipe"&amp;
  cd /
  tar -czf - bin boot dev etc home info lib man root sbin share usr var &gt; /pipe
  # ==&gt; Uses named pipe, /pipe, to communicate between processes:
  # ==&gt; 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.

  # ==&gt; The end result is this backs up the main directories, from / on down.

  # ==&gt;  What are the advantages of a "named pipe" in this situation,
  # ==&gt;+ as opposed to an "anonymous pipe", with |?
  # ==&gt;  Will an anonymous pipe even work here?

  # ==&gt;  Is it necessary to delete the pipe before exiting the script?
  # ==&gt;  How could that be done?


  exit 0
</programlisting>
    </example>

    <para>+</para>

    <para><anchor xml:id="primes1" /></para>
    <para>StÃ©phane Chazelas used the following script to
      demonstrate generating prime numbers without arrays.</para>

    <para><anchor xml:id="primes00" /></para>
    <example xml:id="primes">
      <title>Generating prime numbers using the modulo operator</title>
      <programlisting>#!/bin/bash
# primes.sh: Generate prime numbers, without using arrays.
# Script contributed by Stephane Chazelas.

#  This does *not* use the classic "Sieve of Eratosthenes" algorithm,
#+ but instead the more intuitive method of testing each candidate number
#+ for factors (divisors), using the "%" modulo operator.


LIMIT=1000                    # Primes, 2 ... 1000.

Primes()
{
 (( n = $1 + 1 ))             # Bump to next integer.
 shift                        # Next parameter in list.
#  echo "_n=$n i=$i_"
 
 if (( n == LIMIT ))
 then echo $*
 return
 fi

 for i; do                    # "i" set to "@", previous values of $n.
#   echo "-n=$n i=$i-"
   (( i * i &gt; n )) &amp;&amp; break   # Optimization.
   (( n % i )) &amp;&amp; continue    # Sift out non-primes using modulo operator.
   Primes $n $@               # Recursion inside loop.
   return
   done

   Primes $n $@ $n            #  Recursion outside loop.
                              #  Successively accumulate
			      #+ positional parameters.
                              #  "$@" is the accumulating list of primes.
}

Primes 1

exit $?

# Pipe output of the script to 'fmt' for prettier printing.

#  Uncomment lines 16 and 24 to help figure out what is going on.

#  Compare the speed of this algorithm for generating primes
#+ with the Sieve of Eratosthenes (ex68.sh).


#  Exercise: Rewrite this script without recursion.
</programlisting>
    </example>
    
    <para>+</para>

    <para>Rick Boivie's revision of Jordi Sanfeliu's
      <emphasis>tree</emphasis> script.</para>

    <example xml:id="tree">
      <title><firstterm>tree</firstterm>: Displaying a directory tree</title>
      <programlisting>#!/bin/bash
# tree.sh

#  Written by Rick Boivie.
#  Used with permission.
#  This is a revised and simplified version of a script
#+ by Jordi Sanfeliu (the original author), and patched by Ian Kjos.
#  This script replaces the earlier version used in
#+ previous releases of the Advanced Bash Scripting Guide.
#  Copyright (c) 2002, by Jordi Sanfeliu, Rick Boivie, and Ian Kjos.

# ==&gt; Comments added by the author of this document.


search () {
for dir in `echo *`
#  ==&gt; `echo *` lists all the files in current working directory,
#+ ==&gt; without line breaks.
#  ==&gt; Similar effect to for dir in *
#  ==&gt; but "dir in `echo *`" will not handle filenames with blanks.
do
  if [ -d "$dir" ] ; then # ==&gt; If it is a directory (-d)...
  zz=0                    # ==&gt; Temp variable, keeping track of
                          #     directory level.
  while [ $zz != $1 ]     # Keep track of inner nested loop.
    do
      echo -n "| "        # ==&gt; Display vertical connector symbol,
                          # ==&gt; with 2 spaces &amp; no line feed
                          #     in order to indent.
      zz=`expr $zz + 1`   # ==&gt; Increment zz.
    done

    if [ -L "$dir" ] ; then # ==&gt; If directory is a symbolic link...
      echo "+---$dir" `ls -l $dir | sed 's/^.*'$dir' //'`
      # ==&gt; Display horiz. connector and list directory name, but...
      # ==&gt; delete date/time part of long listing.
    else
      echo "+---$dir"       # ==&gt; Display horizontal connector symbol...
      # ==&gt; and print directory name.
      numdirs=`expr $numdirs + 1` # ==&gt; Increment directory count.
      if cd "$dir" ; then         # ==&gt; If can move to subdirectory...
        search `expr $1 + 1`      # with recursion ;-)
        # ==&gt; Function calls itself.
        cd ..
      fi
    fi
  fi
done
}

if [ $# != 0 ] ; then
  cd $1   # Move to indicated directory.
  #else   # stay in current directory
fi

echo "Initial directory = `pwd`"
numdirs=0

search 0
echo "Total directories = $numdirs"

exit 0
</programlisting>
    </example>

    <para>Patsie's version of a directory <firstterm>tree</firstterm>
      script.</para>

    <example xml:id="tree2">
      <title><firstterm>tree2</firstterm>: Alternate directory tree script</title>
      <programlisting>#!/bin/bash
# tree2.sh

# Lightly modified/reformatted by ABS Guide author.
# Included in ABS Guide with permission of script author (thanks!).

## Recursive file/dirsize checking script, by Patsie
##
## This script builds a list of files/directories and their size (du -akx)
## and processes this list to a human readable tree shape
## The 'du -akx' is only as good as the permissions the owner has.
## So preferably run as root* to get the best results, or use only on
## directories for which you have read permissions. Anything you can't
## read is not in the list.

#* ABS Guide author advises caution when running scripts as root!


##########  THIS IS CONFIGURABLE  ##########

TOP=5                   # Top 5 biggest (sub)directories.
MAXRECURS=5             # Max 5 subdirectories/recursions deep.
E_BL=80                 # Blank line already returned.
E_DIR=81                # Directory not specified.


##########  DON'T CHANGE ANYTHING BELOW THIS LINE  ##########

PID=$$                            # Our own process ID.
SELF=`basename $0`                # Our own program name.
TMP="/tmp/${SELF}.${PID}.tmp"     # Temporary 'du' result.

# Convert number to dotted thousand.
function dot { echo "            $*" |
               sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' |
               tail -c 12; }

# Usage: tree &lt;recursion&gt; &lt;indent prefix&gt; &lt;min size&gt; &lt;directory&gt;
function tree {
  recurs="$1"           # How deep nested are we?
  prefix="$2"           # What do we display before file/dirname?
  minsize="$3"          # What is the minumum file/dirsize?
  dirname="$4"          # Which directory are we checking?

# Get ($TOP) biggest subdirs/subfiles from TMP file.
  LIST=`egrep "[[:space:]]${dirname}/[^/]*$" "$TMP" |
        awk '{if($1&gt;'$minsize') print;}' | sort -nr | head -$TOP`
  [ -z "$LIST" ] &amp;&amp; return        # Empty list, then go back.

  cnt=0
  num=`echo "$LIST" | wc -l`      # How many entries in the list.

  ## Main loop
  echo "$LIST" | while read size name; do
    ((cnt+=1))		          # Count entry number.
    bname=`basename "$name"`      # We only need a basename of the entry.
    [ -d "$name" ] &amp;&amp; bname="$bname/"
                                  # If it's a directory, append a slash.
    echo "`dot $size`$prefix +-$bname"
                                  # Display the result.
    #  Call ourself recursively if it's a directory
    #+ and we're not nested too deep ($MAXRECURS).
    #  The recursion goes up: $((recurs+1))
    #  The prefix gets a space if it's the last entry,
    #+ or a pipe if there are more entries.
    #  The minimum file/dirsize becomes
    #+ a tenth of his parent: $((size/10)).
    # Last argument is the full directory name to check.
    if [ -d "$name" -a $recurs -lt $MAXRECURS ]; then
      [ $cnt -lt $num ] \
        || (tree $((recurs+1)) "$prefix  " $((size/10)) "$name") \
        &amp;&amp; (tree $((recurs+1)) "$prefix |" $((size/10)) "$name")
    fi
  done

  [ $? -eq 0 ] &amp;&amp; echo "           $prefix"
  # Every time we jump back add a 'blank' line.
  return $E_BL
  # We return 80 to tell we added a blank line already.
}

###                ###
###  main program  ###
###                ###

rootdir="$@"
[ -d "$rootdir" ] ||
  { echo "$SELF: Usage: $SELF &lt;directory&gt;" &gt;&amp;2; exit $E_DIR; }
  # We should be called with a directory name.

echo "Building inventory list, please wait ..."
     # Show "please wait" message.
du -akx "$rootdir" 1&gt;"$TMP" 2&gt;/dev/null
     # Build a temporary list of all files/dirs and their size.
size=`tail -1 "$TMP" | awk '{print $1}'`
     # What is our rootdirectory's size?
echo "`dot $size` $rootdir"
     # Display rootdirectory's entry.
tree 0 "" 0 "$rootdir"
     # Display the tree below our rootdirectory.

rm "$TMP" 2&gt;/dev/null
     # Clean up TMP file.

exit $?
</programlisting>
    </example>

    <para>Noah Friedman permitted use of his <emphasis>string
      function</emphasis> script. It essentially reproduces some
      of the <firstterm>C</firstterm>-library string manipulation
      functions.</para>

    <example xml:id="string">
      <title><firstterm>string functions</firstterm>: C-style string
      functions</title>
      <programlisting>#!/bin/bash

# string.bash --- bash emulation of string(3) library routines
# Author: Noah Friedman &lt;friedman@prep.ai.mit.edu&gt;
# ==&gt;     Used with his kind permission in this document.
# Created: 1992-07-01
# Last modified: 1993-09-29
# Public domain

# Conversion to bash v2 syntax done by Chet Ramey

# Commentary:
# Code:

#:docstring strcat:
# Usage: strcat s1 s2
#
# Strcat appends the value of variable s2 to variable s1. 
#
# Example:
#    a="foo"
#    b="bar"
#    strcat a b
#    echo $a
#    =&gt; foobar
#
#:end docstring:

###;;;autoload   ==&gt; Autoloading of function commented out.
function strcat ()
{
    local s1_val s2_val

    s1_val=${!1}                        # indirect variable expansion
    s2_val=${!2}
    eval "$1"=\'"${s1_val}${s2_val}"\'
    # ==&gt; eval $1='${s1_val}${s2_val}' avoids problems,
    # ==&gt; if one of the variables contains a single quote.
}

#:docstring strncat:
# Usage: strncat s1 s2 $n
# 
# Line strcat, but strncat appends a maximum of n characters from the value
# of variable s2.  It copies fewer if the value of variabl s2 is shorter
# than n characters.  Echoes result on stdout.
#
# Example:
#    a=foo
#    b=barbaz
#    strncat a b 3
#    echo $a
#    =&gt; foobar
#
#:end docstring:

###;;;autoload
function strncat ()
{
    local s1="$1"
    local s2="$2"
    local -i n="$3"
    local s1_val s2_val

    s1_val=${!s1}                       # ==&gt; indirect variable expansion
    s2_val=${!s2}

    if [ ${#s2_val} -gt ${n} ]; then
       s2_val=${s2_val:0:$n}            # ==&gt; substring extraction
    fi

    eval "$s1"=\'"${s1_val}${s2_val}"\'
    # ==&gt; eval $1='${s1_val}${s2_val}' avoids problems,
    # ==&gt; if one of the variables contains a single quote.
}

#:docstring strcmp:
# Usage: strcmp $s1 $s2
#
# Strcmp compares its arguments and returns an integer less than, equal to,
# or greater than zero, depending on whether string s1 is lexicographically
# less than, equal to, or greater than string s2.
#:end docstring:

###;;;autoload
function strcmp ()
{
    [ "$1" = "$2" ] &amp;&amp; return 0

    [ "${1}" '&lt;' "${2}" ] &gt; /dev/null &amp;&amp; return -1

    return 1
}

#:docstring strncmp:
# Usage: strncmp $s1 $s2 $n
# 
# Like strcmp, but makes the comparison by examining a maximum of n
# characters (n less than or equal to zero yields equality).
#:end docstring:

###;;;autoload
function strncmp ()
{
    if [ -z "${3}" -o "${3}" -le "0" ]; then
       return 0
    fi
   
    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then
       strcmp "$1" "$2"
       return $?
    else
       s1=${1:0:$3}
       s2=${2:0:$3}
       strcmp $s1 $s2
       return $?
    fi
}

#:docstring strlen:
# Usage: strlen s
#
# Strlen returns the number of characters in string literal s.
#:end docstring:

###;;;autoload
function strlen ()
{
    eval echo "\${#${1}}"
    # ==&gt; Returns the length of the value of the variable
    # ==&gt; whose name is passed as an argument.
}

#:docstring strspn:
# Usage: strspn $s1 $s2
# 
# Strspn returns the length of the maximum initial segment of string s1,
# which consists entirely of characters from string s2.
#:end docstring:

###;;;autoload
function strspn ()
{
    # Unsetting IFS allows whitespace to be handled as normal chars. 
    local IFS=
    local result="${1%%[!${2}]*}"
 
    echo ${#result}
}

#:docstring strcspn:
# Usage: strcspn $s1 $s2
#
# Strcspn returns the length of the maximum initial segment of string s1,
# which consists entirely of characters not from string s2.
#:end docstring:

###;;;autoload
function strcspn ()
{
    # Unsetting IFS allows whitspace to be handled as normal chars. 
    local IFS=
    local result="${1%%[${2}]*}"
 
    echo ${#result}
}

#:docstring strstr:
# Usage: strstr s1 s2
# 
# Strstr echoes a substring starting at the first occurrence of string s2 in
# string s1, or nothing if s2 does not occur in the string.  If s2 points to
# a string of zero length, strstr echoes s1.
#:end docstring:

###;;;autoload
function strstr ()
{
    # if s2 points to a string of zero length, strstr echoes s1
    [ ${#2} -eq 0 ] &amp;&amp; { echo "$1" ; return 0; }

    # strstr echoes nothing if s2 does not occur in s1
    case "$1" in
    *$2*) ;;
    *) return 1;;
    esac

    # use the pattern matching code to strip off the match and everything
    # following it
    first=${1/$2*/}

    # then strip off the first unmatched portion of the string
    echo "${1##$first}"
}

#:docstring strtok:
# Usage: strtok s1 s2
#
# Strtok considers the string s1 to consist of a sequence of zero or more
# text tokens separated by spans of one or more characters from the
# separator string s2.  The first call (with a non-empty string s1
# specified) echoes a string consisting of the first token on stdout. The
# function keeps track of its position in the string s1 between separate
# calls, so that subsequent calls made with the first argument an empty
# string will work through the string immediately following that token.  In
# this way subsequent calls will work through the string s1 until no tokens
# remain.  The separator string s2 may be different from call to call.
# When no token remains in s1, an empty value is echoed on stdout.
#:end docstring:

###;;;autoload
function strtok ()
{
 :
}

#:docstring strtrunc:
# Usage: strtrunc $n $s1 {$s2} {$...}
#
# Used by many functions like strncmp to truncate arguments for comparison.
# Echoes the first n characters of each string s1 s2 ... on stdout. 
#:end docstring:

###;;;autoload
function strtrunc ()
{
    n=$1 ; shift
    for z; do
        echo "${z:0:$n}"
    done
}

# provide string

# string.bash ends here


# ========================================================================== #
# ==&gt; Everything below here added by the document author.

# ==&gt; Suggested use of this script is to delete everything below here,
# ==&gt; and "source" this file into your own scripts.

# strcat
string0=one
string1=two
echo
echo "Testing \"strcat\" function:"
echo "Original \"string0\" = $string0"
echo "\"string1\" = $string1"
strcat string0 string1
echo "New \"string0\" = $string0"
echo

# strlen
echo
echo "Testing \"strlen\" function:"
str=123456789
echo "\"str\" = $str"
echo -n "Length of \"str\" = "
strlen str
echo



# Exercise:
# --------
# Add code to test all the other string functions above.


exit 0
</programlisting>
    </example>

    <para>Michael Zick's complex array example uses the <link linkend="md5sumref">md5sum</link> check sum command to encode directory
      information.</para>

    <example xml:id="directoryinfo">
      <title>Directory information</title>
      <programlisting>#! /bin/bash
# directory-info.sh
# Parses and lists directory information.

# NOTE: Change lines 273 and 353 per "README" file.

# Michael Zick is the author of this script.
# Used here with his permission.

# Controls
# If overridden by command arguments, they must be in the order:
#   Arg1: "Descriptor Directory"
#   Arg2: "Exclude Paths"
#   Arg3: "Exclude Directories"
#
# Environment Settings override Defaults.
# Command arguments override Environment Settings.

# Default location for content addressed file descriptors.
MD5UCFS=${1:-${MD5UCFS:-'/tmpfs/ucfs'}}

# Directory paths never to list or enter
declare -a \
  EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-'(/proc /dev /devfs /tmpfs)'}}

# Directories never to list or enter
declare -a \
  EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-'(ucfs lost+found tmp wtmp)'}}

# Files never to list or enter
declare -a \
  EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-'(core "Name with Spaces")'}}


# Here document used as a comment block.
: &lt;&lt;LSfieldsDoc
# # # # # List Filesystem Directory Information # # # # #
#
#	ListDirectory "FileGlob" "Field-Array-Name"
# or
#	ListDirectory -of "FileGlob" "Field-Array-Filename"
#	'-of' meaning 'output to filename'
# # # # #

String format description based on: ls (GNU fileutils) version 4.0.36

Produces a line (or more) formatted:
inode permissions hard-links owner group ...
32736 -rw-------    1 mszick   mszick

size    day month date hh:mm:ss year path
2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core

Unless it is formatted:
inode permissions hard-links owner group ...
266705 crw-rw----    1    root  uucp

major minor day month date hh:mm:ss year path
4,  68 Sun Apr 20 09:27:33 2003 /dev/ttyS4
NOTE: that pesky comma after the major number

NOTE: the 'path' may be multiple fields:
/home/mszick/core
/proc/982/fd/0 -&gt; /dev/null
/proc/982/fd/1 -&gt; /home/mszick/.xsession-errors
/proc/982/fd/13 -&gt; /tmp/tmpfZVVOCs (deleted)
/proc/982/fd/7 -&gt; /tmp/kde-mszick/ksycoca
/proc/982/fd/8 -&gt; socket:[11586]
/proc/982/fd/9 -&gt; pipe:[11588]

If that isn't enough to keep your parser guessing,
either or both of the path components may be relative:
../Built-Shared -&gt; Built-Static
../linux-2.4.20.tar.bz2 -&gt; ../../../SRCS/linux-2.4.20.tar.bz2

The first character of the 11 (10?) character permissions field:
's' Socket
'd' Directory
'b' Block device
'c' Character device
'l' Symbolic link
NOTE: Hard links not marked - test for identical inode numbers
on identical filesystems.
All information about hard linked files are shared, except
for the names and the name's location in the directory system.
NOTE: A "Hard link" is known as a "File Alias" on some systems.
'-' An undistingushed file

Followed by three groups of letters for: User, Group, Others
Character 1: '-' Not readable; 'r' Readable
Character 2: '-' Not writable; 'w' Writable
Character 3, User and Group: Combined execute and special
'-' Not Executable, Not Special
'x' Executable, Not Special
's' Executable, Special
'S' Not Executable, Special
Character 3, Others: Combined execute and sticky (tacky?)
'-' Not Executable, Not Tacky
'x' Executable, Not Tacky
't' Executable, Tacky
'T' Not Executable, Tacky

Followed by an access indicator
Haven't tested this one, it may be the eleventh character
or it may generate another field
' ' No alternate access
'+' Alternate access
LSfieldsDoc


ListDirectory()
{
	local -a T
	local -i of=0		# Default return in variable
#	OLD_IFS=$IFS		# Using BASH default ' \t\n'

	case "$#" in
	3)	case "$1" in
		-of)	of=1 ; shift ;;
		 * )	return 1 ;;
		esac ;;
	2)	: ;;		# Poor man's "continue"
	*)	return 1 ;;
	esac

	# NOTE: the (ls) command is NOT quoted (")
	T=( $(ls --inode --ignore-backups --almost-all --directory \
	--full-time --color=none --time=status --sort=none \
	--format=long $1) )

	case $of in
	# Assign T back to the array whose name was passed as $2
		0) eval $2=\( \"\$\{T\[@\]\}\" \) ;;
	# Write T into filename passed as $2
		1) echo "${T[@]}" &gt; "$2" ;;
	esac
	return 0
   }

# # # # # Is that string a legal number? # # # # #
#
#	IsNumber "Var"
# # # # # There has to be a better way, sigh...

IsNumber()
{
	local -i int
	if [ $# -eq 0 ]
	then
		return 1
	else
		(let int=$1)  2&gt;/dev/null
		return $?	# Exit status of the let thread
	fi
}

# # # # # Index Filesystem Directory Information # # # # #
#
#	IndexList "Field-Array-Name" "Index-Array-Name"
# or
#	IndexList -if Field-Array-Filename Index-Array-Name
#	IndexList -of Field-Array-Name Index-Array-Filename
#	IndexList -if -of Field-Array-Filename Index-Array-Filename
# # # # #

: &lt;&lt;IndexListDoc
Walk an array of directory fields produced by ListDirectory

Having suppressed the line breaks in an otherwise line oriented
report, build an index to the array element which starts each line.

Each line gets two index entries, the first element of each line
(inode) and the element that holds the pathname of the file.

The first index entry pair (Line-Number==0) are informational:
Index-Array-Name[0] : Number of "Lines" indexed
Index-Array-Name[1] : "Current Line" pointer into Index-Array-Name

The following index pairs (if any) hold element indexes into
the Field-Array-Name per:
Index-Array-Name[Line-Number * 2] : The "inode" field element.
NOTE: This distance may be either +11 or +12 elements.
Index-Array-Name[(Line-Number * 2) + 1] : The "pathname" element.
NOTE: This distance may be a variable number of elements.
Next line index pair for Line-Number+1.
IndexListDoc



IndexList()
{
	local -a LIST			# Local of listname passed
	local -a -i INDEX=( 0 0 )	# Local of index to return
	local -i Lidx Lcnt
	local -i if=0 of=0		# Default to variable names

	case "$#" in			# Simplistic option testing
		0) return 1 ;;
		1) return 1 ;;
		2) : ;;			# Poor man's continue
		3) case "$1" in
			-if) if=1 ;;
			-of) of=1 ;;
			 * ) return 1 ;;
		   esac ; shift ;;
		4) if=1 ; of=1 ; shift ; shift ;;
		*) return 1
	esac

	# Make local copy of list
	case "$if" in
		0) eval LIST=\( \"\$\{$1\[@\]\}\" \) ;;
		1) LIST=( $(cat $1) ) ;;
	esac

	# Grok (grope?) the array
	Lcnt=${#LIST[@]}
	Lidx=0
	until (( Lidx &gt;= Lcnt ))
	do
	if IsNumber ${LIST[$Lidx]}
	then
		local -i inode name
		local ft
		inode=Lidx
		local m=${LIST[$Lidx+2]}	# Hard Links field
		ft=${LIST[$Lidx+1]:0:1} 	# Fast-Stat
		case $ft in
		b)	((Lidx+=12)) ;;		# Block device
		c)	((Lidx+=12)) ;;		# Character device
		*)	((Lidx+=11)) ;;		# Anything else
		esac
		name=Lidx
		case $ft in
		-)	((Lidx+=1)) ;;		# The easy one
		b)	((Lidx+=1)) ;;		# Block device
		c)	((Lidx+=1)) ;;		# Character device
		d)	((Lidx+=1)) ;;		# The other easy one
		l)	((Lidx+=3)) ;;		# At LEAST two more fields
#  A little more elegance here would handle pipes,
#+ sockets, deleted files - later.
		*)	until IsNumber ${LIST[$Lidx]} || ((Lidx &gt;= Lcnt))
			do
				((Lidx+=1))
			done
			;;			# Not required
		esac
		INDEX[${#INDEX[*]}]=$inode
		INDEX[${#INDEX[*]}]=$name
		INDEX[0]=${INDEX[0]}+1		# One more "line" found
# echo "Line: ${INDEX[0]} Type: $ft Links: $m Inode: \
# ${LIST[$inode]} Name: ${LIST[$name]}"

	else
		((Lidx+=1))
	fi
	done
	case "$of" in
		0) eval $2=\( \"\$\{INDEX\[@\]\}\" \) ;;
		1) echo "${INDEX[@]}" &gt; "$2" ;;
	esac
	return 0				# What could go wrong?
}

# # # # # Content Identify File # # # # #
#
#	DigestFile Input-Array-Name Digest-Array-Name
# or
#	DigestFile -if Input-FileName Digest-Array-Name
# # # # #

# Here document used as a comment block.
: &lt;&lt;DigestFilesDoc

The key (no pun intended) to a Unified Content File System (UCFS)
is to distinguish the files in the system based on their content.
Distinguishing files by their name is just so 20th Century.

The content is distinguished by computing a checksum of that content.
This version uses the md5sum program to generate a 128 bit checksum
representative of the file's contents.
There is a chance that two files having different content might
generate the same checksum using md5sum (or any checksum).  Should
that become a problem, then the use of md5sum can be replace by a
cyrptographic signature.  But until then...

The md5sum program is documented as outputting three fields (and it
does), but when read it appears as two fields (array elements).  This
is caused by the lack of whitespace between the second and third field.
So this function gropes the md5sum output and returns:
	[0]	32 character checksum in hexidecimal (UCFS filename)
	[1]	Single character: ' ' text file, '*' binary file
	[2]	Filesystem (20th Century Style) name
	Note: That name may be the character '-' indicating STDIN read.

DigestFilesDoc



DigestFile()
{
	local if=0		# Default, variable name
	local -a T1 T2

	case "$#" in
	3)	case "$1" in
		-if)	if=1 ; shift ;;
		 * )	return 1 ;;
		esac ;;
	2)	: ;;		# Poor man's "continue"
	*)	return 1 ;;
	esac

	case $if in
	0) eval T1=\( \"\$\{$1\[@\]\}\" \)
	   T2=( $(echo ${T1[@]} | md5sum -) )
	   ;;
	1) T2=( $(md5sum $1) )
	   ;;
	esac

	case ${#T2[@]} in
	0) return 1 ;;
	1) return 1 ;;
	2) case ${T2[1]:0:1} in		# SanScrit-2.0.5
	   \*) T2[${#T2[@]}]=${T2[1]:1}
	       T2[1]=\*
	       ;;
	    *) T2[${#T2[@]}]=${T2[1]}
	       T2[1]=" "
	       ;;
	   esac
	   ;;
	3) : ;; # Assume it worked
	*) return 1 ;;
	esac

	local -i len=${#T2[0]}
	if [ $len -ne 32 ] ; then return 1 ; fi
	eval $2=\( \"\$\{T2\[@\]\}\" \)
}

# # # # # Locate File # # # # #
#
#	LocateFile [-l] FileName Location-Array-Name
# or
#	LocateFile [-l] -of FileName Location-Array-FileName
# # # # #

# A file location is Filesystem-id and inode-number

# Here document used as a comment block.
: &lt;&lt;StatFieldsDoc
	Based on stat, version 2.2
	stat -t and stat -lt fields
	[0]	name
	[1]	Total size
		File - number of bytes
		Symbolic link - string length of pathname
	[2]	Number of (512 byte) blocks allocated
	[3]	File type and Access rights (hex)
	[4]	User ID of owner
	[5]	Group ID of owner
	[6]	Device number
	[7]	Inode number
	[8]	Number of hard links
	[9]	Device type (if inode device) Major
	[10]	Device type (if inode device) Minor
	[11]	Time of last access
		May be disabled in 'mount' with noatime
		atime of files changed by exec, read, pipe, utime, mknod (mmap?)
		atime of directories changed by addition/deletion of files
	[12]	Time of last modification
		mtime of files changed by write, truncate, utime, mknod
		mtime of directories changed by addtition/deletion of files
	[13]	Time of last change
		ctime reflects time of changed inode information (owner, group
		permissions, link count
-*-*- Per:
	Return code: 0
	Size of array: 14
	Contents of array
	Element 0: /home/mszick
	Element 1: 4096
	Element 2: 8
	Element 3: 41e8
	Element 4: 500
	Element 5: 500
	Element 6: 303
	Element 7: 32385
	Element 8: 22
	Element 9: 0
	Element 10: 0
	Element 11: 1051221030
	Element 12: 1051214068
	Element 13: 1051214068

	For a link in the form of linkname -&gt; realname
	stat -t  linkname returns the linkname (link) information
	stat -lt linkname returns the realname information

	stat -tf and stat -ltf fields
	[0]	name
	[1]	ID-0?		# Maybe someday, but Linux stat structure
	[2]	ID-0?		# does not have either LABEL nor UUID
				# fields, currently information must come
				# from file-system specific utilities
	These will be munged into:
	[1]	UUID if possible
	[2]	Volume Label if possible
	Note: 'mount -l' does return the label and could return the UUID

	[3]	Maximum length of filenames
	[4]	Filesystem type
	[5]	Total blocks in the filesystem
	[6]	Free blocks
	[7]	Free blocks for non-root user(s)
	[8]	Block size of the filesystem
	[9]	Total inodes
	[10]	Free inodes

-*-*- Per:
	Return code: 0
	Size of array: 11
	Contents of array
	Element 0: /home/mszick
	Element 1: 0
	Element 2: 0
	Element 3: 255
	Element 4: ef53
	Element 5: 2581445
	Element 6: 2277180
	Element 7: 2146050
	Element 8: 4096
	Element 9: 1311552
	Element 10: 1276425

StatFieldsDoc


#	LocateFile [-l] FileName Location-Array-Name
#	LocateFile [-l] -of FileName Location-Array-FileName

LocateFile()
{
	local -a LOC LOC1 LOC2
	local lk="" of=0

	case "$#" in
	0) return 1 ;;
	1) return 1 ;;
	2) : ;;
	*) while (( "$#" &gt; 2 ))
	   do
	      case "$1" in
	       -l) lk=-1 ;;
	      -of) of=1 ;;
	        *) return 1 ;;
	      esac
	   shift
           done ;;
	esac

# More Sanscrit-2.0.5
      # LOC1=( $(stat -t $lk $1) )
      # LOC2=( $(stat -tf $lk $1) )
      # Uncomment above two lines if system has "stat" command installed.
	LOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}
	      ${LOC2[@]:1:2} ${LOC2[@]:4:1} )

	case "$of" in
		0) eval $2=\( \"\$\{LOC\[@\]\}\" \) ;;
		1) echo "${LOC[@]}" &gt; "$2" ;;
	esac
	return 0
# Which yields (if you are lucky, and have "stat" installed)
# -*-*- Location Discriptor -*-*-
#	Return code: 0
#	Size of array: 15
#	Contents of array
#	Element 0: /home/mszick		20th Century name
#	Element 1: 41e8			Type and Permissions
#	Element 2: 500			User
#	Element 3: 500			Group
#	Element 4: 303			Device
#	Element 5: 32385		inode
#	Element 6: 22			Link count
#	Element 7: 0			Device Major
#	Element 8: 0			Device Minor
#	Element 9: 1051224608		Last Access
#	Element 10: 1051214068		Last Modify
#	Element 11: 1051214068		Last Status
#	Element 12: 0			UUID (to be)
#	Element 13: 0			Volume Label (to be)
#	Element 14: ef53		Filesystem type
}



# And then there was some test code

ListArray() # ListArray Name
{
	local -a Ta

	eval Ta=\( \"\$\{$1\[@\]\}\" \)
	echo
	echo "-*-*- List of Array -*-*-"
	echo "Size of array $1: ${#Ta[*]}"
	echo "Contents of array $1:"
	for (( i=0 ; i&lt;${#Ta[*]} ; i++ ))
	do
	    echo -e "\tElement $i: ${Ta[$i]}"
	done
	return 0
}

declare -a CUR_DIR
# For small arrays
ListDirectory "${PWD}" CUR_DIR
ListArray CUR_DIR

declare -a DIR_DIG
DigestFile CUR_DIR DIR_DIG
echo "The new \"name\" (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}"

declare -a DIR_ENT
# BIG_DIR # For really big arrays - use a temporary file in ramdisk
# BIG-DIR # ListDirectory -of "${CUR_DIR[11]}/*" "/tmpfs/junk2"
ListDirectory "${CUR_DIR[11]}/*" DIR_ENT

declare -a DIR_IDX
# BIG-DIR # IndexList -if "/tmpfs/junk2" DIR_IDX
IndexList DIR_ENT DIR_IDX

declare -a IDX_DIG
# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )
# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG
DigestFile DIR_ENT IDX_DIG
# Small (should) be able to parallize IndexList &amp; DigestFile
# Large (should) be able to parallize IndexList &amp; DigestFile &amp; the assignment
echo "The \"name\" (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}"

declare -a FILE_LOC
LocateFile ${PWD} FILE_LOC
ListArray FILE_LOC

exit 0
</programlisting>
    </example>


    <para>StÃ©phane Chazelas demonstrates object-oriented programming in a
      Bash script.</para>

    <para>Mariusz Gniazdowski contributed a <link linkend="hashref">hash</link>
      library for use in scripts.</para>

    <example xml:id="hashlib">
      <title>Library of hash functions</title>
      <programlisting># Hash:
# Hash function library
# Author: Mariusz Gniazdowski &lt;mariusz.gn-at-gmail.com&gt;
# Date: 2005-04-07

# Functions making emulating hashes in Bash a little less painful.


#    Limitations:
#  * Only global variables are supported.
#  * Each hash instance generates one global variable per value.
#  * Variable names collisions are possible
#+   if you define variable like __hash__hashname_key
#  * Keys must use chars that can be part of a Bash variable name
#+   (no dashes, periods, etc.).
#  * The hash is created as a variable:
#    ... hashname_keyname
#    So if somone will create hashes like:
#      myhash_ + mykey = myhash__mykey
#      myhash + _mykey = myhash__mykey
#    Then there will be a collision.
#    (This should not pose a major problem.)


Hash_config_varname_prefix=__hash__


# Emulates:  hash[key]=value
#
# Params:
# 1 - hash
# 2 - key
# 3 - value
function hash_set {
	eval "${Hash_config_varname_prefix}${1}_${2}=\"${3}\""
}


# Emulates:  value=hash[key]
#
# Params:
# 1 - hash
# 2 - key
# 3 - value (name of global variable to set)
function hash_get_into {
	eval "$3=\"\$${Hash_config_varname_prefix}${1}_${2}\""
}


# Emulates:  echo hash[key]
#
# Params:
# 1 - hash
# 2 - key
# 3 - echo params (like -n, for example)
function hash_echo {
	eval "echo $3 \"\$${Hash_config_varname_prefix}${1}_${2}\""
}


# Emulates:  hash1[key1]=hash2[key2]
#
# Params:
# 1 - hash1
# 2 - key1
# 3 - hash2
# 4 - key2
function hash_copy {
eval "${Hash_config_varname_prefix}${1}_${2}\
=\"\$${Hash_config_varname_prefix}${3}_${4}\""
}


# Emulates:  hash[keyN-1]=hash[key2]=...hash[key1]
#
# Copies first key to rest of keys.
#
# Params:
# 1 - hash1
# 2 - key1
# 3 - key2
# . . .
# N - keyN
function hash_dup {
  local hashName="$1" keyName="$2"
  shift 2
  until [ ${#} -le 0 ]; do
    eval "${Hash_config_varname_prefix}${hashName}_${1}\
=\"\$${Hash_config_varname_prefix}${hashName}_${keyName}\""
  shift;
  done;
}


# Emulates:  unset hash[key]
#
# Params:
# 1 - hash
# 2 - key
function hash_unset {
	eval "unset ${Hash_config_varname_prefix}${1}_${2}"
}


# Emulates something similar to:  ref=&amp;hash[key]
#
# The reference is name of the variable in which value is held.
#
# Params:
# 1 - hash
# 2 - key
# 3 - ref - Name of global variable to set.
function hash_get_ref_into {
	eval "$3=\"${Hash_config_varname_prefix}${1}_${2}\""
}


# Emulates something similar to:  echo &amp;hash[key]
#
# That reference is name of variable in which value is held.
#
# Params:
# 1 - hash
# 2 - key
# 3 - echo params (like -n for example)
function hash_echo_ref {
	eval "echo $3 \"${Hash_config_varname_prefix}${1}_${2}\""
}



# Emulates something similar to:  $$hash[key](param1, param2, ...)
#
# Params:
# 1 - hash
# 2 - key
# 3,4, ... - Function parameters
function hash_call {
  local hash key
  hash=$1
  key=$2
  shift 2
  eval "eval \"\$${Hash_config_varname_prefix}${hash}_${key} \\\"\\\$@\\\"\""
}


# Emulates something similar to:  isset(hash[key]) or hash[key]==NULL
#
# Params:
# 1 - hash
# 2 - key
# Returns:
# 0 - there is such key
# 1 - there is no such key
function hash_is_set {
  eval "if [[ \"\${${Hash_config_varname_prefix}${1}_${2}-a}\" = \"a\" &amp;&amp; 
  \"\${${Hash_config_varname_prefix}${1}_${2}-b}\" = \"b\" ]]
    then return 1; else return 0; fi"
}


# Emulates something similar to:
#   foreach($hash as $key =&gt; $value) { fun($key,$value); }
#
# It is possible to write different variations of this function.
# Here we use a function call to make it as "generic" as possible.
#
# Params:
# 1 - hash
# 2 - function name
function hash_foreach {
  local keyname oldIFS="$IFS"
  IFS=' '
  for i in $(eval "echo \${!${Hash_config_varname_prefix}${1}_*}"); do
    keyname=$(eval "echo \${i##${Hash_config_varname_prefix}${1}_}")
    eval "$2 $keyname \"\$$i\""
  done
IFS="$oldIFS"
}

#  NOTE: In lines 103 and 116, ampersand changed.
#  But, it doesn't matter, because these are comment lines anyhow.
</programlisting>
    </example>

    <para>Here is an example script using the foregoing hash library.</para>

    <example xml:id="hashexample">
      <title>Colorizing text using hash functions</title>
      <programlisting>#!/bin/bash
# hash-example.sh: Colorizing text.
# Author: Mariusz Gniazdowski &lt;mariusz.gn-at-gmail.com&gt;

. Hash.lib      # Load the library of functions.

hash_set colors red          "\033[0;31m"
hash_set colors blue         "\033[0;34m"
hash_set colors light_blue   "\033[1;34m"
hash_set colors light_red    "\033[1;31m"
hash_set colors cyan         "\033[0;36m"
hash_set colors light_green  "\033[1;32m"
hash_set colors light_gray   "\033[0;37m"
hash_set colors green        "\033[0;32m"
hash_set colors yellow       "\033[1;33m"
hash_set colors light_purple "\033[1;35m"
hash_set colors purple       "\033[0;35m"
hash_set colors reset_color  "\033[0;00m"


# $1 - keyname
# $2 - value
try_colors() {
	echo -en "$2"
	echo "This line is $1."
}
hash_foreach colors try_colors
hash_echo colors reset_color -en

echo -e '\nLet us overwrite some colors with yellow.\n'
# It's hard to read yellow text on some terminals.
hash_dup colors yellow   red light_green blue green light_gray cyan
hash_foreach colors try_colors
hash_echo colors reset_color -en

echo -e '\nLet us delete them and try colors once more . . .\n'

for i in red light_green blue green light_gray cyan; do
	hash_unset colors $i
done
hash_foreach colors try_colors
hash_echo colors reset_color -en

hash_set other txt "Other examples . . ."
hash_echo other txt
hash_get_into other txt text
echo $text

hash_set other my_fun try_colors
hash_call other my_fun   purple "`hash_echo colors purple`"
hash_echo colors reset_color -en

echo; echo "Back to normal?"; echo

exit $?

#  On some terminals, the "light" colors print in bold,
#  and end up looking darker than the normal ones.
#  Why is this?

</programlisting>
    </example>

    <para><anchor xml:id="hashex2_0" />An example illustrating the mechanics
      of hashing, but from a different point of view.</para>

    <example xml:id="hashex2">
      <title>More on hash functions</title>
      <programlisting>#!/bin/bash
# $Id$
# Copyright 2005 Oliver Beckstein
# Released under the GNU Public License
# Author of script granted permission for inclusion in ABS Guide.
# (Thank you!)

#----------------------------------------------------------------
# pseudo hash based on indirect parameter expansion
# API: access through functions:
# 
# create the hash:
#  
#      newhash Lovers
#
# add entries (note single quotes for spaces)
#    
#      addhash Lovers Tristan Isolde
#      addhash Lovers 'Romeo Montague' 'Juliet Capulet'
#
# access value by key
#
#      gethash Lovers Tristan   ----&gt;  Isolde
#
# show all keys
#
#      keyshash Lovers         ----&gt; 'Tristan'  'Romeo Montague'
#
#
# Convention: instead of perls' foo{bar} = boing' syntax,
# use
#       '_foo_bar=boing' (two underscores, no spaces)
#
# 1) store key   in _NAME_keys[]
# 2) store value in _NAME_values[] using the same integer index
# The integer index for the last entry is _NAME_ptr
#
# NOTE: No error or sanity checks, just bare bones.


function _inihash () {
    # private function
    # call at the beginning of each procedure
    # defines: _keys _values _ptr
    #
    # Usage: _inihash NAME
    local name=$1
    _keys=_${name}_keys
    _values=_${name}_values
    _ptr=_${name}_ptr
}

function newhash () {
    # Usage: newhash NAME
    #        NAME should not contain spaces or dots.
    #        Actually: it must be a legal name for a Bash variable.
    # We rely on Bash automatically recognising arrays.
    local name=$1 
    local _keys _values _ptr
    _inihash ${name}
    eval ${_ptr}=0
}


function addhash () {
    # Usage: addhash NAME KEY 'VALUE with spaces'
    #        arguments with spaces need to be quoted with single quotes ''
    local name=$1 k="$2" v="$3" 
    local _keys _values _ptr
    _inihash ${name}

    #echo "DEBUG(addhash): ${_ptr}=${!_ptr}"

    eval let ${_ptr}=${_ptr}+1
    eval "$_keys[${!_ptr}]=\"${k}\""
    eval "$_values[${!_ptr}]=\"${v}\""
}

function gethash () {
    #  Usage: gethash NAME KEY
    #         Returns boing
    #         ERR=0 if entry found, 1 otherwise
    #  That's not a proper hash --
    #+ we simply linearly search through the keys.
    local name=$1 key="$2" 
    local _keys _values _ptr 
    local k v i found h
    _inihash ${name}
    
    # _ptr holds the highest index in the hash
    found=0

    for i in $(seq 1 ${!_ptr}); do
	h="\${${_keys}[${i}]}"  #  Safer to do it in two steps,
	eval k=${h}             #+ especially when quoting for spaces.
	if [ "${k}" = "${key}" ]; then found=1; break; fi
    done;

    [ ${found} = 0 ] &amp;&amp; return 1;
    # else: i is the index that matches the key
    h="\${${_values}[${i}]}"
    eval echo "${h}"
    return 0;	
}

function keyshash () {
    # Usage: keyshash NAME
    # Returns list of all keys defined for hash name.
    local name=$1 key="$2" 
    local _keys _values _ptr 
    local k i h
    _inihash ${name}
    
    # _ptr holds the highest index in the hash
    for i in $(seq 1 ${!_ptr}); do
	h="\${${_keys}[${i}]}"   #  Safer to do it in two steps,
	eval k=${h}              #+ especially when quoting for spaces.
	echo -n "'${k}' "
    done;
}


# -----------------------------------------------------------------------

# Now, let's test it.
# (Per comments at the beginning of the script.)
newhash Lovers
addhash Lovers Tristan Isolde
addhash Lovers 'Romeo Montague' 'Juliet Capulet'

# Output results.
echo
gethash Lovers Tristan      # Isolde
echo
keyshash Lovers             # 'Tristan' 'Romeo Montague'
echo; echo


exit 0

# Exercise:
# --------

# Add error checks to the functions.
</programlisting>
    </example>

    <para>Now for a script that installs and mounts
      those cute USB keychain solid-state <quote>hard drives.</quote></para>

    <example xml:id="usbinst">
      <title>Mounting USB keychain storage devices</title>
      <programlisting>#!/bin/bash
# ==&gt; usb.sh
# ==&gt; Script for mounting and installing pen/keychain USB storage devices.
# ==&gt; Runs as root at system startup (see below).
# ==&gt;
# ==&gt; Newer Linux distros (2004 or later) autodetect
# ==&gt; and install USB pen drives, and therefore don't need this script.
# ==&gt; But, it's still instructive.
 
#  This code is free software covered by GNU GPL license version 2 or above.
#  Please refer to http://www.gnu.org/ for the full license text.
#
#  Some code lifted from usb-mount by Michael Hamilton's usb-mount (LGPL)
#+ see http://users.actrix.co.nz/michael/usbmount.html
#
#  INSTALL
#  -------
#  Put this in /etc/hotplug/usb/diskonkey.
#  Then look in /etc/hotplug/usb.distmap, and copy all usb-storage entries
#+ into /etc/hotplug/usb.usermap, substituting "usb-storage" for "diskonkey".
#  Otherwise this code is only run during the kernel module invocation/removal
#+ (at least in my tests), which defeats the purpose.
#
#  TODO
#  ----
#  Handle more than one diskonkey device at one time (e.g. /dev/diskonkey1
#+ and /mnt/diskonkey1), etc. The biggest problem here is the handling in
#+ devlabel, which I haven't yet tried.
#
#  AUTHOR and SUPPORT
#  ------------------
#  Konstantin Riabitsev, &lt;icon linux duke edu&gt;.
#  Send any problem reports to my email address at the moment.
#
# ==&gt; Comments added by ABS Guide author.



SYMLINKDEV=/dev/diskonkey
MOUNTPOINT=/mnt/diskonkey
DEVLABEL=/sbin/devlabel
DEVLABELCONFIG=/etc/sysconfig/devlabel
IAM=$0

##
# Functions lifted near-verbatim from usb-mount code.
#
function allAttachedScsiUsb {
  find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f |
  xargs grep -l 'Attached: Yes'
}
function scsiDevFromScsiUsb {
  echo $1 | awk -F"[-/]" '{ n=$(NF-1);
  print "/dev/sd" substr("abcdefghijklmnopqrstuvwxyz", n+1, 1) }'
}

if [ "${ACTION}" = "add" ] &amp;&amp; [ -f "${DEVICE}" ]; then
    ##
    # lifted from usbcam code.
    #
    if [ -f /var/run/console.lock ]; then
        CONSOLEOWNER=`cat /var/run/console.lock`
    elif [ -f /var/lock/console.lock ]; then
        CONSOLEOWNER=`cat /var/lock/console.lock`
    else
        CONSOLEOWNER=
    fi
    for procEntry in $(allAttachedScsiUsb); do
        scsiDev=$(scsiDevFromScsiUsb $procEntry)
        #  Some bug with usb-storage?
        #  Partitions are not in /proc/partitions until they are accessed
        #+ somehow.
        /sbin/fdisk -l $scsiDev &gt;/dev/null
        ##
        #  Most devices have partitioning info, so the data would be on
        #+ /dev/sd?1. However, some stupider ones don't have any partitioning
        #+ and use the entire device for data storage. This tries to
        #+ guess semi-intelligently if we have a /dev/sd?1 and if not, then
        #+ it uses the entire device and hopes for the better.
        #
        if grep -q `basename $scsiDev`1 /proc/partitions; then
            part="$scsiDev""1"
        else
            part=$scsiDev
        fi
        ##
        #  Change ownership of the partition to the console user so they can
        #+ mount it.
        #
        if [ ! -z "$CONSOLEOWNER" ]; then
            chown $CONSOLEOWNER:disk $part
        fi
        ##
        # This checks if we already have this UUID defined with devlabel.
        # If not, it then adds the device to the list.
        #
        prodid=`$DEVLABEL printid -d $part`
        if ! grep -q $prodid $DEVLABELCONFIG; then
            # cross our fingers and hope it works
            $DEVLABEL add -d $part -s $SYMLINKDEV 2&gt;/dev/null
        fi
        ##
        # Check if the mount point exists and create if it doesn't.
        #
        if [ ! -e $MOUNTPOINT ]; then
            mkdir -p $MOUNTPOINT
        fi
        ##
        # Take care of /etc/fstab so mounting is easy.
        #
        if ! grep -q "^$SYMLINKDEV" /etc/fstab; then
            # Add an fstab entry
            echo -e \
                "$SYMLINKDEV\t\t$MOUNTPOINT\t\tauto\tnoauto,owner,kudzu 0 0" \
                &gt;&gt; /etc/fstab
        fi
    done
    if [ ! -z "$REMOVER" ]; then
        ##
        # Make sure this script is triggered on device removal.
        #
        mkdir -p `dirname $REMOVER`
        ln -s $IAM $REMOVER
    fi
elif [ "${ACTION}" = "remove" ]; then
    ##
    # If the device is mounted, unmount it cleanly.
    #
    if grep -q "$MOUNTPOINT" /etc/mtab; then
        # unmount cleanly
        umount -l $MOUNTPOINT
    fi
    ##
    # Remove it from /etc/fstab if it's there.
    #
    if grep -q "^$SYMLINKDEV" /etc/fstab; then
        grep -v "^$SYMLINKDEV" /etc/fstab &gt; /etc/.fstab.new
        mv -f /etc/.fstab.new /etc/fstab
    fi
fi

exit 0
</programlisting>
    </example>

    <para>Converting a text file to HTML format.</para>

    <example xml:id="tohtml">
      <title>Converting to HTML</title>
      <programlisting>#!/bin/bash
# tohtml.sh [v. 0.2.01, reldate: 04/13/12, a teeny bit less buggy]

# Convert a text file to HTML format.
# Author: Mendel Cooper
# License: GPL3
# Usage: sh tohtml.sh &lt; textfile &gt; htmlfile
# Script can easily be modified to accept source and target filenames.

#    Assumptions:
# 1) Paragraphs in (target) text file are separated by a blank line.
# 2) Jpeg images (*.jpg) are located in "images" subdirectory.
#    In the target file, the image names are enclosed in square brackets,
#    for example, [image01.jpg].
# 3) Emphasized (italic) phrases begin with a space+underscore
#+   or the first character on the line is an underscore,
#+   and end with an underscore+space or underscore+end-of-line.


# Settings
FNTSIZE=2        # Small-medium font size
IMGDIR="images"  # Image directory
# Headers
HDR01='&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;'
HDR02='&lt;!-- Converted to HTML by ***tohtml.sh*** script --&gt;'
HDR03='&lt;!-- script author: M. Leo Cooper &lt;thegrendel.abs@gmail.com&gt; --&gt;'
HDR10='&lt;html&gt;'
HDR11='&lt;head&gt;'
HDR11a='&lt;/head&gt;'
HDR12a='&lt;title&gt;'
HDR12b='&lt;/title&gt;'
HDR121='&lt;META NAME="GENERATOR" CONTENT="tohtml.sh script"&gt;'
HDR13='&lt;body bgcolor="#dddddd"&gt;'   # Change background color to suit.
HDR14a='&lt;font size='
HDR14b='&gt;'
# Footers
FTR10='&lt;/body&gt;'
FTR11='&lt;/html&gt;'
# Tags
BOLD="&lt;b&gt;"
CENTER="&lt;center&gt;"
END_CENTER="&lt;/center&gt;"
LF="&lt;br&gt;"


write_headers ()
  {
  echo "$HDR01"
  echo
  echo "$HDR02"
  echo "$HDR03"
  echo
  echo
  echo "$HDR10"
  echo "$HDR11"
  echo "$HDR121"
  echo "$HDR11a"
  echo "$HDR13"
  echo
  echo -n "$HDR14a"
  echo -n "$FNTSIZE"
  echo "$HDR14b"
  echo
  echo "$BOLD"        # Everything in bold (more easily readable).
  }


process_text ()
  {
  while read line     # Read one line at a time.
  do
    {
    if [ ! "$line" ]  # Blank line?
    then              # Then new paragraph must follow.
      echo
      echo "$LF"      # Insert two &lt;br&gt; tags.
      echo "$LF"
      echo
      continue        # Skip the underscore test.
    else              # Otherwise . . .

      if [[ "$line" =~ \[*jpg\] ]]    # Is a graphic?
      then                            # Strip away brackets.
        temp=$( echo "$line" | sed -e 's/\[//' -e 's/\]//' )
        line=""$CENTER" &lt;img src="\"$IMGDIR"/$temp\"&gt; "$END_CENTER" "
                                      # Add image tag.
                                      # And, center it.
      fi

    fi


    echo "$line" | grep -q _
    if [ "$?" -eq 0 ]    # If line contains underscore ...
    then
      # ===================================================
      # Convert underscored phrase to italics.
      temp=$( echo "$line" |
              sed -e 's/ _/ &lt;i&gt;/' -e 's/_/&lt;\/i&gt; /' |
              sed -e 's/^_/&lt;i&gt;/'  -e 's/_/&lt;\/i&gt;/' )
      #  Process only underscores prefixed by space,
      #+ or at beginning or end of line.
      #  Do not convert underscores embedded within a word!
      line="$temp"
      # Slows script execution. Can be optimized?
      # ===================================================
    fi


   
#   echo
    echo "$line"
#   echo
#   Don't want extra blank lines in generated text!
    } # End while
  done
  }   # End process_text ()


write_footers ()  # Termination tags.
  {
  echo "$FTR10"
  echo "$FTR11"
  }


# main () {
# =========
write_headers
process_text
write_footers
# =========
#         }

exit $?

#  Exercises:
#  ---------
#  1) Fixup: Check for closing underscore before a comma or period.
#  2) Add a test for the presence of a closing underscore
#+    in phrases to be italicized.
</programlisting>
    </example>

    <para>Here is something to warm the hearts of webmasters and mistresses:
      a script that saves weblogs.</para>

    <example xml:id="archivweblogs">
      <title>Preserving weblogs</title>
      <programlisting>#!/bin/bash
# archiveweblogs.sh v1.0

# Troy Engel &lt;tengel@fluid.com&gt;
# Slightly modified by document author.
# Used with permission.
#
#  This script will preserve the normally rotated and
#+ thrown away weblogs from a default RedHat/Apache installation.
#  It will save the files with a date/time stamp in the filename,
#+ bzipped, to a given directory.
#
#  Run this from crontab nightly at an off hour,
#+ as bzip2 can suck up some serious CPU on huge logs:
#  0 2 * * * /opt/sbin/archiveweblogs.sh


PROBLEM=66

# Set this to your backup dir.
BKP_DIR=/opt/backups/weblogs

# Default Apache/RedHat stuff
LOG_DAYS="4 3 2 1"
LOG_DIR=/var/log/httpd
LOG_FILES="access_log error_log"

# Default RedHat program locations
LS=/bin/ls
MV=/bin/mv
ID=/usr/bin/id
CUT=/bin/cut
COL=/usr/bin/column
BZ2=/usr/bin/bzip2

# Are we root?
USER=`$ID -u`
if [ "X$USER" != "X0" ]; then
  echo "PANIC: Only root can run this script!"
  exit $PROBLEM
fi

# Backup dir exists/writable?
if [ ! -x $BKP_DIR ]; then
  echo "PANIC: $BKP_DIR doesn't exist or isn't writable!"
  exit $PROBLEM
fi

# Move, rename and bzip2 the logs
for logday in $LOG_DAYS; do
  for logfile in $LOG_FILES; do
    MYFILE="$LOG_DIR/$logfile.$logday"
    if [ -w $MYFILE ]; then
      DTS=`$LS -lgo --time-style=+%Y%m%d $MYFILE | $COL -t | $CUT -d ' ' -f7`
      $MV $MYFILE $BKP_DIR/$logfile.$DTS
      $BZ2 $BKP_DIR/$logfile.$DTS
    else
      # Only spew an error if the file exits (ergo non-writable).
      if [ -f $MYFILE ]; then
        echo "ERROR: $MYFILE not writable. Skipping."
      fi
    fi
  done
done

exit 0
</programlisting>
    </example>

    <para><anchor xml:id="protectliteral0" />How to keep the shell from
      expanding and reinterpreting text strings.</para>

    <example xml:id="protectliteral">
      <title>Protecting literal strings</title>
      <programlisting>#! /bin/bash
# protect_literal.sh

# set -vx

:&lt;&lt;-'_Protect_Literal_String_Doc'

    Copyright (c) Michael S. Zick, 2003; All Rights Reserved
    License: Unrestricted reuse in any form, for any purpose.
    Warranty: None
    Revision: $ID$

    Documentation redirected to the Bash no-operation.
    Bash will '/dev/null' this block when the script is first read.
    (Uncomment the above set command to see this action.)

    Remove the first (Sha-Bang) line when sourcing this as a library
    procedure.  Also comment out the example use code in the two
    places where shown.


    Usage:
        _protect_literal_str 'Whatever string meets your ${fancy}'
        Just echos the argument to standard out, hard quotes
        restored.

        $(_protect_literal_str 'Whatever string meets your ${fancy}')
        as the right-hand-side of an assignment statement.

    Does:
        As the right-hand-side of an assignment, preserves the
        hard quotes protecting the contents of the literal during
        assignment.

    Notes:
        The strange names (_*) are used to avoid trampling on
        the user's chosen names when this is sourced as a
        library.

_Protect_Literal_String_Doc

# The 'for illustration' function form

_protect_literal_str() {

# Pick an un-used, non-printing character as local IFS.
# Not required, but shows that we are ignoring it.
    local IFS=$'\x1B'               # \ESC character

# Enclose the All-Elements-Of in hard quotes during assignment.
    local tmp=$'\x27'$@$'\x27'
#    local tmp=$'\''$@$'\''         # Even uglier.

    local len=${#tmp}               # Info only.
    echo $tmp is $len long.         # Output AND information.
}

# This is the short-named version.
_pls() {
    local IFS=$'x1B'                # \ESC character (not required)
    echo $'\x27'$@$'\x27'           # Hard quoted parameter glob
}

# :&lt;&lt;-'_Protect_Literal_String_Test'
# # # Remove the above "# " to disable this code. # # #

# See how that looks when printed.
echo
echo "- - Test One - -"
_protect_literal_str 'Hello $user'
_protect_literal_str 'Hello "${username}"'
echo

# Which yields:
# - - Test One - -
# 'Hello $user' is 13 long.
# 'Hello "${username}"' is 21 long.

#  Looks as expected, but why all of the trouble?
#  The difference is hidden inside the Bash internal order
#+ of operations.
#  Which shows when you use it on the RHS of an assignment.

# Declare an array for test values.
declare -a arrayZ

# Assign elements with various types of quotes and escapes.
arrayZ=( zero "$(_pls 'Hello ${Me}')" 'Hello ${You}' "\'Pass: ${pw}\'" )

# Now list that array and see what is there.
echo "- - Test Two - -"
for (( i=0 ; i&lt;${#arrayZ[*]} ; i++ ))
do
    echo  Element $i: ${arrayZ[$i]} is: ${#arrayZ[$i]} long.
done
echo

# Which yields:
# - - Test Two - -
# Element 0: zero is: 4 long.           # Our marker element
# Element 1: 'Hello ${Me}' is: 13 long. # Our "$(_pls '...' )"
# Element 2: Hello ${You} is: 12 long.  # Quotes are missing
# Element 3: \'Pass: \' is: 10 long.    # ${pw} expanded to nothing

# Now make an assignment with that result.
declare -a array2=( ${arrayZ[@]} )

# And print what happened.
echo "- - Test Three - -"
for (( i=0 ; i&lt;${#array2[*]} ; i++ ))
do
    echo  Element $i: ${array2[$i]} is: ${#array2[$i]} long.
done
echo

# Which yields:
# - - Test Three - -
# Element 0: zero is: 4 long.           # Our marker element.
# Element 1: Hello ${Me} is: 11 long.   # Intended result.
# Element 2: Hello is: 5 long.          # ${You} expanded to nothing.
# Element 3: 'Pass: is: 6 long.         # Split on the whitespace.
# Element 4: ' is: 1 long.              # The end quote is here now.

#  Our Element 1 has had its leading and trailing hard quotes stripped.
#  Although not shown, leading and trailing whitespace is also stripped.
#  Now that the string contents are set, Bash will always, internally,
#+ hard quote the contents as required during its operations.

#  Why?
#  Considering our "$(_pls 'Hello ${Me}')" construction:
#  " ... " -&gt; Expansion required, strip the quotes.
#  $( ... ) -&gt; Replace with the result of..., strip this.
#  _pls ' ... ' -&gt; called with literal arguments, strip the quotes.
#  The result returned includes hard quotes; BUT the above processing
#+ has already been done, so they become part of the value assigned.
#
#  Similarly, during further usage of the string variable, the ${Me}
#+ is part of the contents (result) and survives any operations
#  (Until explicitly told to evaluate the string).

#  Hint: See what happens when the hard quotes ($'\x27') are replaced
#+ with soft quotes ($'\x22') in the above procedures.
#  Interesting also is to remove the addition of any quoting.

# _Protect_Literal_String_Test
# # # Remove the above "# " to disable this code. # # #

exit 0
</programlisting>
    </example>

    <para><anchor xml:id="unprotectliteral0" />But, what if you
      <emphasis>want</emphasis> the shell to expand
      and reinterpret strings?</para>

    <example xml:id="unprotectliteral">
      <title>Unprotecting literal strings</title>
      <programlisting>#! /bin/bash
# unprotect_literal.sh

# set -vx

:&lt;&lt;-'_UnProtect_Literal_String_Doc'

    Copyright (c) Michael S. Zick, 2003; All Rights Reserved
    License: Unrestricted reuse in any form, for any purpose.
    Warranty: None
    Revision: $ID$

    Documentation redirected to the Bash no-operation. Bash will
    '/dev/null' this block when the script is first read.
    (Uncomment the above set command to see this action.)

    Remove the first (Sha-Bang) line when sourcing this as a library
    procedure.  Also comment out the example use code in the two
    places where shown.


    Usage:
        Complement of the "$(_pls 'Literal String')" function.
        (See the protect_literal.sh example.)

        StringVar=$(_upls ProtectedSringVariable)

    Does:
        When used on the right-hand-side of an assignment statement;
        makes the substitions embedded in the protected string.

    Notes:
        The strange names (_*) are used to avoid trampling on
        the user's chosen names when this is sourced as a
        library.


_UnProtect_Literal_String_Doc

_upls() {
    local IFS=$'x1B'                # \ESC character (not required)
    eval echo $@                    # Substitution on the glob.
}

# :&lt;&lt;-'_UnProtect_Literal_String_Test'
# # # Remove the above "# " to disable this code. # # #


_pls() {
    local IFS=$'x1B'                # \ESC character (not required)
    echo $'\x27'$@$'\x27'           # Hard quoted parameter glob
}

# Declare an array for test values.
declare -a arrayZ

# Assign elements with various types of quotes and escapes.
arrayZ=( zero "$(_pls 'Hello ${Me}')" 'Hello ${You}' "\'Pass: ${pw}\'" )

# Now make an assignment with that result.
declare -a array2=( ${arrayZ[@]} )

# Which yielded:
# - - Test Three - -
# Element 0: zero is: 4 long            # Our marker element.
# Element 1: Hello ${Me} is: 11 long    # Intended result.
# Element 2: Hello is: 5 long           # ${You} expanded to nothing.
# Element 3: 'Pass: is: 6 long          # Split on the whitespace.
# Element 4: ' is: 1 long               # The end quote is here now.

# set -vx

#  Initialize 'Me' to something for the embedded ${Me} substitution.
#  This needs to be done ONLY just prior to evaluating the
#+ protected string.
#  (This is why it was protected to begin with.)

Me="to the array guy."

# Set a string variable destination to the result.
newVar=$(_upls ${array2[1]})

# Show what the contents are.
echo $newVar

# Do we really need a function to do this?
newerVar=$(eval echo ${array2[1]})
echo $newerVar

#  I guess not, but the _upls function gives us a place to hang
#+ the documentation on.
#  This helps when we forget what a # construction like:
#+ $(eval echo ... ) means.

# What if Me isn't set when the protected string is evaluated?
unset Me
newestVar=$(_upls ${array2[1]})
echo $newestVar

# Just gone, no hints, no runs, no errors.

#  Why in the world?
#  Setting the contents of a string variable containing character
#+ sequences that have a meaning in Bash is a general problem in
#+ script programming.
#
#  This problem is now solved in eight lines of code
#+ (and four pages of description).

#  Where is all this going?
#  Dynamic content Web pages as an array of Bash strings.
#  Content set per request by a Bash 'eval' command
#+ on the stored page template.
#  Not intended to replace PHP, just an interesting thing to do.
###
#  Don't have a webserver application?
#  No problem, check the example directory of the Bash source;
#+ there is a Bash script for that also.

# _UnProtect_Literal_String_Test
# # # Remove the above "# " to disable this code. # # #

exit 0
</programlisting>
    </example>


    <para>This interesting script helps hunt down spammers.</para>

    <para><anchor xml:id="isspammer2_0" /></para>
    <example xml:id="isspammer2">
      <title>Spammer Identification</title>
      <programlisting>#!/bin/bash

# $Id$
# Above line is RCS info.

# The latest version of this script is available from http://www.morethan.org.
#
# Spammer-identification
# by Michael S. Zick
# Used in the ABS Guide with permission.



#######################################################
# Documentation
# See also "Quickstart" at end of script.
#######################################################

:&lt;&lt;-'__is_spammer_Doc_'

    Copyright (c) Michael S. Zick, 2004
    License: Unrestricted reuse in any form, for any purpose.
    Warranty: None -{Its a script; the user is on their own.}-

Impatient?
    Application code: goto "# # # Hunt the Spammer' program code # # #"
    Example output: ":&lt;&lt;-'_is_spammer_outputs_'"
    How to use: Enter script name without arguments.
                Or goto "Quickstart" at end of script.

Provides
    Given a domain name or IP(v4) address as input:

    Does an exhaustive set of queries to find the associated
    network resources (short of recursing into TLDs).

    Checks the IP(v4) addresses found against Blacklist
    nameservers.

    If found to be a blacklisted IP(v4) address,
    reports the blacklist text records.
    (Usually hyper-links to the specific report.)

Requires
    A working Internet connection.
    (Exercise: Add check and/or abort if not on-line when running script.)
    Bash with arrays (2.05b+).

    The external program 'dig' --
    a utility program provided with the 'bind' set of programs.
    Specifically, the version which is part of Bind series 9.x
    See: http://www.isc.org

    All usages of 'dig' are limited to wrapper functions,
    which may be rewritten as required.
    See: dig_wrappers.bash for details.
         ("Additional documentation" -- below)

Usage
    Script requires a single argument, which may be:
    1) A domain name;
    2) An IP(v4) address;
    3) A filename, with one name or address per line.

    Script accepts an optional second argument, which may be:
    1) A Blacklist server name;
    2) A filename, with one Blacklist server name per line.

    If the second argument is not provided, the script uses
    a built-in set of (free) Blacklist servers.

    See also, the Quickstart at the end of this script (after 'exit').

Return Codes
    0 - All OK
    1 - Script failure
    2 - Something is Blacklisted

Optional environment variables
    SPAMMER_TRACE
        If set to a writable file,
        script will log an execution flow trace.

    SPAMMER_DATA
        If set to a writable file, script will dump its
        discovered data in the form of GraphViz file.
        See: http://www.research.att.com/sw/tools/graphviz

    SPAMMER_LIMIT
        Limits the depth of resource tracing.

        Default is 2 levels.

        A setting of 0 (zero) means 'unlimited' . . .
          Caution: script might recurse the whole Internet!

        A limit of 1 or 2 is most useful when processing
        a file of domain names and addresses.
        A higher limit can be useful when hunting spam gangs.


Additional documentation
    Download the archived set of scripts
    explaining and illustrating the function contained within this script.
    http://bash.deta.in/mszick_clf.tar.bz2


Study notes
    This script uses a large number of functions.
    Nearly all general functions have their own example script.
    Each of the example scripts have tutorial level comments.

Scripting project
    Add support for IP(v6) addresses.
    IP(v6) addresses are recognized but not processed.

Advanced project
    Add the reverse lookup detail to the discovered information.

    Report the delegation chain and abuse contacts.

    Modify the GraphViz file output to include the
    newly discovered information.

__is_spammer_Doc_

#######################################################




#### Special IFS settings used for string parsing. ####

# Whitespace == :Space:Tab:Line Feed:Carriage Return:
WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'

# No Whitespace == Line Feed:Carriage Return
NO_WSP=$'\x0A'$'\x0D'

# Field separator for dotted decimal IP addresses
ADR_IFS=${NO_WSP}'.'

# Array to dotted string conversions
DOT_IFS='.'${WSP_IFS}

# # # Pending operations stack machine # # #
# This set of functions described in func_stack.bash.
# (See "Additional documentation" above.)
# # #

# Global stack of pending operations.
declare -f -a _pending_
# Global sentinel for stack runners
declare -i _p_ctrl_
# Global holder for currently executing function
declare -f _pend_current_

# # # Debug version only - remove for regular use # # #
#
# The function stored in _pend_hook_ is called
# immediately before each pending function is
# evaluated.  Stack clean, _pend_current_ set.
#
# This thingy demonstrated in pend_hook.bash.
declare -f _pend_hook_
# # #

# The do nothing function
pend_dummy() { : ; }

# Clear and initialize the function stack.
pend_init() {
    unset _pending_[@]
    pend_func pend_stop_mark
    _pend_hook_='pend_dummy'  # Debug only.
}

# Discard the top function on the stack.
pend_pop() {
    if [ ${#_pending_[@]} -gt 0 ]
    then
        local -i _top_
        _top_=${#_pending_[@]}-1
        unset _pending_[$_top_]
    fi
}

# pend_func function_name [$(printf '%q\n' arguments)]
pend_func() {
    local IFS=${NO_WSP}
    set -f
    _pending_[${#_pending_[@]}]=$@
    set +f
}

# The function which stops the release:
pend_stop_mark() {
    _p_ctrl_=0
}

pend_mark() {
    pend_func pend_stop_mark
}

# Execute functions until 'pend_stop_mark' . . .
pend_release() {
    local -i _top_             # Declare _top_ as integer.
    _p_ctrl_=${#_pending_[@]}
    while [ ${_p_ctrl_} -gt 0 ]
    do
       _top_=${#_pending_[@]}-1
       _pend_current_=${_pending_[$_top_]}
       unset _pending_[$_top_]
       $_pend_hook_            # Debug only.
       eval $_pend_current_
    done
}

# Drop functions until 'pend_stop_mark' . . .
pend_drop() {
    local -i _top_
    local _pd_ctrl_=${#_pending_[@]}
    while [ ${_pd_ctrl_} -gt 0 ]
    do
       _top_=$_pd_ctrl_-1
       if [ "${_pending_[$_top_]}" == 'pend_stop_mark' ]
       then
           unset _pending_[$_top_]
           break
       else
           unset _pending_[$_top_]
           _pd_ctrl_=$_top_
       fi
    done
    if [ ${#_pending_[@]} -eq 0 ]
    then
        pend_func pend_stop_mark
    fi
}

#### Array editors ####

# This function described in edit_exact.bash.
# (See "Additional documentation," above.)
# edit_exact &lt;excludes_array_name&gt; &lt;target_array_name&gt;
edit_exact() {
    [ $# -eq 2 ] ||
    [ $# -eq 3 ] || return 1
    local -a _ee_Excludes
    local -a _ee_Target
    local _ee_x
    local _ee_t
    local IFS=${NO_WSP}
    set -f
    eval _ee_Excludes=\( \$\{$1\[@\]\} \)
    eval _ee_Target=\( \$\{$2\[@\]\} \)
    local _ee_len=${#_ee_Target[@]}     # Original length.
    local _ee_cnt=${#_ee_Excludes[@]}   # Exclude list length.
    [ ${_ee_len} -ne 0 ] || return 0    # Can't edit zero length.
    [ ${_ee_cnt} -ne 0 ] || return 0    # Can't edit zero length.
    for (( x = 0; x &lt; ${_ee_cnt} ; x++ ))
    do
        _ee_x=${_ee_Excludes[$x]}
        for (( n = 0 ; n &lt; ${_ee_len} ; n++ ))
        do
            _ee_t=${_ee_Target[$n]}
            if [ x"${_ee_t}" == x"${_ee_x}" ]
            then
                unset _ee_Target[$n]     # Discard match.
                [ $# -eq 2 ] &amp;&amp; break    # If 2 arguments, then done.
            fi
        done
    done
    eval $2=\( \$\{_ee_Target\[@\]\} \)
    set +f
    return 0
}

# This function described in edit_by_glob.bash.
# edit_by_glob &lt;excludes_array_name&gt; &lt;target_array_name&gt;
edit_by_glob() {
    [ $# -eq 2 ] ||
    [ $# -eq 3 ] || return 1
    local -a _ebg_Excludes
    local -a _ebg_Target
    local _ebg_x
    local _ebg_t
    local IFS=${NO_WSP}
    set -f
    eval _ebg_Excludes=\( \$\{$1\[@\]\} \)
    eval _ebg_Target=\( \$\{$2\[@\]\} \)
    local _ebg_len=${#_ebg_Target[@]}
    local _ebg_cnt=${#_ebg_Excludes[@]}
    [ ${_ebg_len} -ne 0 ] || return 0
    [ ${_ebg_cnt} -ne 0 ] || return 0
    for (( x = 0; x &lt; ${_ebg_cnt} ; x++ ))
    do
        _ebg_x=${_ebg_Excludes[$x]}
        for (( n = 0 ; n &lt; ${_ebg_len} ; n++ ))
        do
            [ $# -eq 3 ] &amp;&amp; _ebg_x=${_ebg_x}'*'  #  Do prefix edit
            if [ ${_ebg_Target[$n]:=} ]          #+ if defined &amp; set.
            then
                _ebg_t=${_ebg_Target[$n]/#${_ebg_x}/}
                [ ${#_ebg_t} -eq 0 ] &amp;&amp; unset _ebg_Target[$n]
            fi
        done
    done
    eval $2=\( \$\{_ebg_Target\[@\]\} \)
    set +f
    return 0
}

# This function described in unique_lines.bash.
# unique_lines &lt;in_name&gt; &lt;out_name&gt;
unique_lines() {
    [ $# -eq 2 ] || return 1
    local -a _ul_in
    local -a _ul_out
    local -i _ul_cnt
    local -i _ul_pos
    local _ul_tmp
    local IFS=${NO_WSP}
    set -f
    eval _ul_in=\( \$\{$1\[@\]\} \)
    _ul_cnt=${#_ul_in[@]}
    for (( _ul_pos = 0 ; _ul_pos &lt; ${_ul_cnt} ; _ul_pos++ ))
    do
        if [ ${_ul_in[${_ul_pos}]:=} ]      # If defined &amp; not empty
        then
            _ul_tmp=${_ul_in[${_ul_pos}]}
            _ul_out[${#_ul_out[@]}]=${_ul_tmp}
            for (( zap = _ul_pos ; zap &lt; ${_ul_cnt} ; zap++ ))
            do
                [ ${_ul_in[${zap}]:=} ] &amp;&amp;
                [ 'x'${_ul_in[${zap}]} == 'x'${_ul_tmp} ] &amp;&amp;
                    unset _ul_in[${zap}]
            done
        fi
    done
    eval $2=\( \$\{_ul_out\[@\]\} \)
    set +f
    return 0
}

# This function described in char_convert.bash.
# to_lower &lt;string&gt;
to_lower() {
    [ $# -eq 1 ] || return 1
    local _tl_out
    _tl_out=${1//A/a}
    _tl_out=${_tl_out//B/b}
    _tl_out=${_tl_out//C/c}
    _tl_out=${_tl_out//D/d}
    _tl_out=${_tl_out//E/e}
    _tl_out=${_tl_out//F/f}
    _tl_out=${_tl_out//G/g}
    _tl_out=${_tl_out//H/h}
    _tl_out=${_tl_out//I/i}
    _tl_out=${_tl_out//J/j}
    _tl_out=${_tl_out//K/k}
    _tl_out=${_tl_out//L/l}
    _tl_out=${_tl_out//M/m}
    _tl_out=${_tl_out//N/n}
    _tl_out=${_tl_out//O/o}
    _tl_out=${_tl_out//P/p}
    _tl_out=${_tl_out//Q/q}
    _tl_out=${_tl_out//R/r}
    _tl_out=${_tl_out//S/s}
    _tl_out=${_tl_out//T/t}
    _tl_out=${_tl_out//U/u}
    _tl_out=${_tl_out//V/v}
    _tl_out=${_tl_out//W/w}
    _tl_out=${_tl_out//X/x}
    _tl_out=${_tl_out//Y/y}
    _tl_out=${_tl_out//Z/z}
    echo ${_tl_out}
    return 0
}

#### Application helper functions ####

# Not everybody uses dots as separators (APNIC, for example).
# This function described in to_dot.bash
# to_dot &lt;string&gt;
to_dot() {
    [ $# -eq 1 ] || return 1
    echo ${1//[#|@|%]/.}
    return 0
}

# This function described in is_number.bash.
# is_number &lt;input&gt;
is_number() {
    [ "$#" -eq 1 ]    || return 1  # is blank?
    [ x"$1" == 'x0' ] &amp;&amp; return 0  # is zero?
    local -i tst
    let tst=$1 2&gt;/dev/null         # else is numeric!
    return $?
}

# This function described in is_address.bash.
# is_address &lt;input&gt;
is_address() {
    [ $# -eq 1 ] || return 1    # Blank ==&gt; false
    local -a _ia_input
    local IFS=${ADR_IFS}
    _ia_input=( $1 )
    if  [ ${#_ia_input[@]} -eq 4 ]  &amp;&amp;
        is_number ${_ia_input[0]}   &amp;&amp;
        is_number ${_ia_input[1]}   &amp;&amp;
        is_number ${_ia_input[2]}   &amp;&amp;
        is_number ${_ia_input[3]}   &amp;&amp;
        [ ${_ia_input[0]} -lt 256 ] &amp;&amp;
        [ ${_ia_input[1]} -lt 256 ] &amp;&amp;
        [ ${_ia_input[2]} -lt 256 ] &amp;&amp;
        [ ${_ia_input[3]} -lt 256 ]
    then
        return 0
    else
        return 1
    fi
}

#  This function described in split_ip.bash.
#  split_ip &lt;IP_address&gt;
#+ &lt;array_name_norm&gt; [&lt;array_name_rev&gt;]
split_ip() {
    [ $# -eq 3 ] ||              #  Either three
    [ $# -eq 2 ] || return 1     #+ or two arguments
    local -a _si_input
    local IFS=${ADR_IFS}
    _si_input=( $1 )
    IFS=${WSP_IFS}
    eval $2=\(\ \$\{_si_input\[@\]\}\ \)
    if [ $# -eq 3 ]
    then
        # Build query order array.
        local -a _dns_ip
        _dns_ip[0]=${_si_input[3]}
        _dns_ip[1]=${_si_input[2]}
        _dns_ip[2]=${_si_input[1]}
        _dns_ip[3]=${_si_input[0]}
        eval $3=\(\ \$\{_dns_ip\[@\]\}\ \)
    fi
    return 0
}

# This function described in dot_array.bash.
# dot_array &lt;array_name&gt;
dot_array() {
    [ $# -eq 1 ] || return 1     # Single argument required.
    local -a _da_input
    eval _da_input=\(\ \$\{$1\[@\]\}\ \)
    local IFS=${DOT_IFS}
    local _da_output=${_da_input[@]}
    IFS=${WSP_IFS}
    echo ${_da_output}
    return 0
}

# This function described in file_to_array.bash
# file_to_array &lt;file_name&gt; &lt;line_array_name&gt;
file_to_array() {
    [ $# -eq 2 ] || return 1  # Two arguments required.
    local IFS=${NO_WSP}
    local -a _fta_tmp_
    _fta_tmp_=( $(cat $1) )
    eval $2=\( \$\{_fta_tmp_\[@\]\} \)
    return 0
}

#  Columnized print of an array of multi-field strings.
#  col_print &lt;array_name&gt; &lt;min_space&gt; &lt;
#+ tab_stop [tab_stops]&gt;
col_print() {
    [ $# -gt 2 ] || return 0
    local -a _cp_inp
    local -a _cp_spc
    local -a _cp_line
    local _cp_min
    local _cp_mcnt
    local _cp_pos
    local _cp_cnt
    local _cp_tab
    local -i _cp
    local -i _cpf
    local _cp_fld
    # WARNING: FOLLOWING LINE NOT BLANK -- IT IS QUOTED SPACES.
    local _cp_max='                                                            '
    set -f
    local IFS=${NO_WSP}
    eval _cp_inp=\(\ \$\{$1\[@\]\}\ \)
    [ ${#_cp_inp[@]} -gt 0 ] || return 0 # Empty is easy.
    _cp_mcnt=$2
    _cp_min=${_cp_max:1:${_cp_mcnt}}
    shift
    shift
    _cp_cnt=$#
    for (( _cp = 0 ; _cp &lt; _cp_cnt ; _cp++ ))
    do
        _cp_spc[${#_cp_spc[@]}]="${_cp_max:2:$1}" #"
        shift
    done
    _cp_cnt=${#_cp_inp[@]}
    for (( _cp = 0 ; _cp &lt; _cp_cnt ; _cp++ ))
    do
        _cp_pos=1
        IFS=${NO_WSP}$'\x20'
        _cp_line=( ${_cp_inp[${_cp}]} )
        IFS=${NO_WSP}
        for (( _cpf = 0 ; _cpf &lt; ${#_cp_line[@]} ; _cpf++ ))
        do
            _cp_tab=${_cp_spc[${_cpf}]:${_cp_pos}}
            if [ ${#_cp_tab} -lt ${_cp_mcnt} ]
            then
                _cp_tab="${_cp_min}"
            fi
            echo -n "${_cp_tab}"
            (( _cp_pos = ${_cp_pos} + ${#_cp_tab} ))
            _cp_fld="${_cp_line[${_cpf}]}"
            echo -n ${_cp_fld}
            (( _cp_pos = ${_cp_pos} + ${#_cp_fld} ))
        done
        echo
    done
    set +f
    return 0
}

# # # # 'Hunt the Spammer' data flow # # # #

# Application return code
declare -i _hs_RC

# Original input, from which IP addresses are removed
# After which, domain names to check
declare -a uc_name

# Original input IP addresses are moved here
# After which, IP addresses to check
declare -a uc_address

# Names against which address expansion run
# Ready for name detail lookup
declare -a chk_name

# Addresses against which name expansion run
# Ready for address detail lookup
declare -a chk_address

#  Recursion is depth-first-by-name.
#  The expand_input_address maintains this list
#+ to prohibit looking up addresses twice during
#+ domain name recursion.
declare -a been_there_addr
been_there_addr=( '127.0.0.1' ) # Whitelist localhost

# Names which we have checked (or given up on)
declare -a known_name

# Addresses which we have checked (or given up on)
declare -a known_address

#  List of zero or more Blacklist servers to check.
#  Each 'known_address' will be checked against each server,
#+ with negative replies and failures suppressed.
declare -a list_server

# Indirection limit - set to zero == no limit
indirect=${SPAMMER_LIMIT:=2}

# # # # 'Hunt the Spammer' information output data # # # #

# Any domain name may have multiple IP addresses.
# Any IP address may have multiple domain names.
# Therefore, track unique address-name pairs.
declare -a known_pair
declare -a reverse_pair

#  In addition to the data flow variables; known_address
#+ known_name and list_server, the following are output to the
#+ external graphics interface file.

# Authority chain, parent -&gt; SOA fields.
declare -a auth_chain

# Reference chain, parent name -&gt; child name
declare -a ref_chain

# DNS chain - domain name -&gt; address
declare -a name_address

# Name and service pairs - domain name -&gt; service
declare -a name_srvc

# Name and resource pairs - domain name -&gt; Resource Record
declare -a name_resource

# Parent and Child pairs - parent name -&gt; child name
# This MAY NOT be the same as the ref_chain followed!
declare -a parent_child

# Address and Blacklist hit pairs - address-&gt;server
declare -a address_hits

# Dump interface file data
declare -f _dot_dump
_dot_dump=pend_dummy   # Initially a no-op

#  Data dump is enabled by setting the environment variable SPAMMER_DATA
#+ to the name of a writable file.
declare _dot_file

# Helper function for the dump-to-dot-file function
# dump_to_dot &lt;array_name&gt; &lt;prefix&gt;
dump_to_dot() {
    local -a _dda_tmp
    local -i _dda_cnt
    local _dda_form='    '${2}'%04u %s\n'
    local IFS=${NO_WSP}
    eval _dda_tmp=\(\ \$\{$1\[@\]\}\ \)
    _dda_cnt=${#_dda_tmp[@]}
    if [ ${_dda_cnt} -gt 0 ]
    then
        for (( _dda = 0 ; _dda &lt; _dda_cnt ; _dda++ ))
        do
            printf "${_dda_form}" \
                   "${_dda}" "${_dda_tmp[${_dda}]}" &gt;&gt;${_dot_file}
        done
    fi
}

# Which will also set _dot_dump to this function . . .
dump_dot() {
    local -i _dd_cnt
    echo '# Data vintage: '$(date -R) &gt;${_dot_file}
    echo '# ABS Guide: is_spammer.bash; v2, 2004-msz' &gt;&gt;${_dot_file}
    echo &gt;&gt;${_dot_file}
    echo 'digraph G {' &gt;&gt;${_dot_file}

    if [ ${#known_name[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known domain name nodes' &gt;&gt;${_dot_file}
        _dd_cnt=${#known_name[@]}
        for (( _dd = 0 ; _dd &lt; _dd_cnt ; _dd++ ))
        do
            printf '    N%04u [label="%s"] ;\n' \
                   "${_dd}" "${known_name[${_dd}]}" &gt;&gt;${_dot_file}
        done
    fi

    if [ ${#known_address[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known address nodes' &gt;&gt;${_dot_file}
        _dd_cnt=${#known_address[@]}
        for (( _dd = 0 ; _dd &lt; _dd_cnt ; _dd++ ))
        do
            printf '    A%04u [label="%s"] ;\n' \
                   "${_dd}" "${known_address[${_dd}]}" &gt;&gt;${_dot_file}
        done
    fi

    echo                                   &gt;&gt;${_dot_file}
    echo '/*'                              &gt;&gt;${_dot_file}
    echo ' * Known relationships :: User conversion to'  &gt;&gt;${_dot_file}
    echo ' * graphic form by hand or program required.'  &gt;&gt;${_dot_file}
    echo ' *'                              &gt;&gt;${_dot_file}

    if [ ${#auth_chain[@]} -gt 0 ]
    then
      echo &gt;&gt;${_dot_file}
      echo '# Authority ref. edges followed &amp; field source.' &gt;&gt;${_dot_file}
        dump_to_dot auth_chain AC
    fi

    if [ ${#ref_chain[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Name ref. edges followed and field source.' &gt;&gt;${_dot_file}
        dump_to_dot ref_chain RC
    fi

    if [ ${#name_address[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known name-&gt;address edges' &gt;&gt;${_dot_file}
        dump_to_dot name_address NA
    fi

    if [ ${#name_srvc[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known name-&gt;service edges' &gt;&gt;${_dot_file}
        dump_to_dot name_srvc NS
    fi

    if [ ${#name_resource[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known name-&gt;resource edges' &gt;&gt;${_dot_file}
        dump_to_dot name_resource NR
    fi

    if [ ${#parent_child[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known parent-&gt;child edges' &gt;&gt;${_dot_file}
        dump_to_dot parent_child PC
    fi

    if [ ${#list_server[@]} -gt 0 ]
    then
        echo &gt;&gt;${_dot_file}
        echo '# Known Blacklist nodes' &gt;&gt;${_dot_file}
        _dd_cnt=${#list_server[@]}
        for (( _dd = 0 ; _dd &lt; _dd_cnt ; _dd++ ))
        do
            printf '    LS%04u [label="%s"] ;\n' \
                   "${_dd}" "${list_server[${_dd}]}" &gt;&gt;${_dot_file}
        done
    fi

    unique_lines address_hits address_hits
    if [ ${#address_hits[@]} -gt 0 ]
    then
      echo &gt;&gt;${_dot_file}
      echo '# Known address-&gt;Blacklist_hit edges' &gt;&gt;${_dot_file}
      echo '# CAUTION: dig warnings can trigger false hits.' &gt;&gt;${_dot_file}
       dump_to_dot address_hits AH
    fi
    echo          &gt;&gt;${_dot_file}
    echo ' *'     &gt;&gt;${_dot_file}
    echo ' * That is a lot of relationships. Happy graphing.' &gt;&gt;${_dot_file}
    echo ' */'    &gt;&gt;${_dot_file}
    echo '}'      &gt;&gt;${_dot_file}
    return 0
}

# # # # 'Hunt the Spammer' execution flow # # # #

#  Execution trace is enabled by setting the
#+ environment variable SPAMMER_TRACE to the name of a writable file.
declare -a _trace_log
declare _log_file

# Function to fill the trace log
trace_logger() {
    _trace_log[${#_trace_log[@]}]=${_pend_current_}
}

# Dump trace log to file function variable.
declare -f _log_dump
_log_dump=pend_dummy   # Initially a no-op.

# Dump the trace log to a file.
dump_log() {
    local -i _dl_cnt
    _dl_cnt=${#_trace_log[@]}
    for (( _dl = 0 ; _dl &lt; _dl_cnt ; _dl++ ))
    do
        echo ${_trace_log[${_dl}]} &gt;&gt; ${_log_file}
    done
    _dl_cnt=${#_pending_[@]}
    if [ ${_dl_cnt} -gt 0 ]
    then
        _dl_cnt=${_dl_cnt}-1
        echo '# # # Operations stack not empty # # #' &gt;&gt; ${_log_file}
        for (( _dl = ${_dl_cnt} ; _dl &gt;= 0 ; _dl-- ))
        do
            echo ${_pending_[${_dl}]} &gt;&gt; ${_log_file}
        done
    fi
}

# # # Utility program 'dig' wrappers # # #
#
#  These wrappers are derived from the
#+ examples shown in dig_wrappers.bash.
#
#  The major difference is these return
#+ their results as a list in an array.
#
#  See dig_wrappers.bash for details and
#+ use that script to develop any changes.
#
# # #

# Short form answer: 'dig' parses answer.

# Forward lookup :: Name -&gt; Address
# short_fwd &lt;domain_name&gt; &lt;array_name&gt;
short_fwd() {
    local -a _sf_reply
    local -i _sf_rc
    local -i _sf_cnt
    IFS=${NO_WSP}
echo -n '.'
# echo 'sfwd: '${1}
  _sf_reply=( $(dig +short ${1} -c in -t a 2&gt;/dev/null) )
  _sf_rc=$?
  if [ ${_sf_rc} -ne 0 ]
  then
    _trace_log[${#_trace_log[@]}]='## Lookup error '${_sf_rc}' on '${1}' ##'
# [ ${_sf_rc} -ne 9 ] &amp;&amp; pend_drop
        return ${_sf_rc}
    else
        # Some versions of 'dig' return warnings on stdout.
        _sf_cnt=${#_sf_reply[@]}
        for (( _sf = 0 ; _sf &lt; ${_sf_cnt} ; _sf++ ))
        do
            [ 'x'${_sf_reply[${_sf}]:0:2} == 'x;;' ] &amp;&amp;
                unset _sf_reply[${_sf}]
        done
        eval $2=\( \$\{_sf_reply\[@\]\} \)
    fi
    return 0
}

# Reverse lookup :: Address -&gt; Name
# short_rev &lt;ip_address&gt; &lt;array_name&gt;
short_rev() {
    local -a _sr_reply
    local -i _sr_rc
    local -i _sr_cnt
    IFS=${NO_WSP}
echo -n '.'
# echo 'srev: '${1}
  _sr_reply=( $(dig +short -x ${1} 2&gt;/dev/null) )
  _sr_rc=$?
  if [ ${_sr_rc} -ne 0 ]
  then
    _trace_log[${#_trace_log[@]}]='## Lookup error '${_sr_rc}' on '${1}' ##'
# [ ${_sr_rc} -ne 9 ] &amp;&amp; pend_drop
        return ${_sr_rc}
    else
        # Some versions of 'dig' return warnings on stdout.
        _sr_cnt=${#_sr_reply[@]}
        for (( _sr = 0 ; _sr &lt; ${_sr_cnt} ; _sr++ ))
        do
            [ 'x'${_sr_reply[${_sr}]:0:2} == 'x;;' ] &amp;&amp;
                unset _sr_reply[${_sr}]
        done
        eval $2=\( \$\{_sr_reply\[@\]\} \)
    fi
    return 0
}

# Special format lookup used to query blacklist servers.
# short_text &lt;ip_address&gt; &lt;array_name&gt;
short_text() {
    local -a _st_reply
    local -i _st_rc
    local -i _st_cnt
    IFS=${NO_WSP}
# echo 'stxt: '${1}
  _st_reply=( $(dig +short ${1} -c in -t txt 2&gt;/dev/null) )
  _st_rc=$?
  if [ ${_st_rc} -ne 0 ]
  then
    _trace_log[${#_trace_log[@]}]='##Text lookup error '${_st_rc}' on '${1}'##'
# [ ${_st_rc} -ne 9 ] &amp;&amp; pend_drop
        return ${_st_rc}
    else
        # Some versions of 'dig' return warnings on stdout.
        _st_cnt=${#_st_reply[@]}
        for (( _st = 0 ; _st &lt; ${#_st_cnt} ; _st++ ))
        do
            [ 'x'${_st_reply[${_st}]:0:2} == 'x;;' ] &amp;&amp;
                unset _st_reply[${_st}]
        done
        eval $2=\( \$\{_st_reply\[@\]\} \)
    fi
    return 0
}

# The long forms, a.k.a., the parse it yourself versions

# RFC 2782   Service lookups
# dig +noall +nofail +answer _ldap._tcp.openldap.org -t srv
# _&lt;service&gt;._&lt;protocol&gt;.&lt;domain_name&gt;
# _ldap._tcp.openldap.org. 3600   IN     SRV    0 0 389 ldap.openldap.org.
# domain TTL Class SRV Priority Weight Port Target

# Forward lookup :: Name -&gt; poor man's zone transfer
# long_fwd &lt;domain_name&gt; &lt;array_name&gt;
long_fwd() {
    local -a _lf_reply
    local -i _lf_rc
    local -i _lf_cnt
    IFS=${NO_WSP}
echo -n ':'
# echo 'lfwd: '${1}
  _lf_reply=( $(
     dig +noall +nofail +answer +authority +additional \
         ${1} -t soa ${1} -t mx ${1} -t any 2&gt;/dev/null) )
  _lf_rc=$?
  if [ ${_lf_rc} -ne 0 ]
  then
    _trace_log[${#_trace_log[@]}]='# Zone lookup err '${_lf_rc}' on '${1}' #'
# [ ${_lf_rc} -ne 9 ] &amp;&amp; pend_drop
        return ${_lf_rc}
    else
        # Some versions of 'dig' return warnings on stdout.
        _lf_cnt=${#_lf_reply[@]}
        for (( _lf = 0 ; _lf &lt; ${_lf_cnt} ; _lf++ ))
        do
            [ 'x'${_lf_reply[${_lf}]:0:2} == 'x;;' ] &amp;&amp;
                unset _lf_reply[${_lf}]
        done
        eval $2=\( \$\{_lf_reply\[@\]\} \)
    fi
    return 0
}
#  The reverse lookup domain name corresponding to the IPv6 address:
#      4321:0:1:2:3:4:567:89ab
#  would be (nibble, I.E: Hexdigit) reversed:
#  b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.

# Reverse lookup :: Address -&gt; poor man's delegation chain
# long_rev &lt;rev_ip_address&gt; &lt;array_name&gt;
long_rev() {
    local -a _lr_reply
    local -i _lr_rc
    local -i _lr_cnt
    local _lr_dns
    _lr_dns=${1}'.in-addr.arpa.'
    IFS=${NO_WSP}
echo -n ':'
# echo 'lrev: '${1}
  _lr_reply=( $(
       dig +noall +nofail +answer +authority +additional \
           ${_lr_dns} -t soa ${_lr_dns} -t any 2&gt;/dev/null) )
  _lr_rc=$?
  if [ ${_lr_rc} -ne 0 ]
  then
    _trace_log[${#_trace_log[@]}]='# Deleg lkp error '${_lr_rc}' on '${1}' #'
# [ ${_lr_rc} -ne 9 ] &amp;&amp; pend_drop
        return ${_lr_rc}
    else
        # Some versions of 'dig' return warnings on stdout.
        _lr_cnt=${#_lr_reply[@]}
        for (( _lr = 0 ; _lr &lt; ${_lr_cnt} ; _lr++ ))
        do
            [ 'x'${_lr_reply[${_lr}]:0:2} == 'x;;' ] &amp;&amp;
                unset _lr_reply[${_lr}]
        done
        eval $2=\( \$\{_lr_reply\[@\]\} \)
    fi
    return 0
}

# # # Application specific functions # # #

# Mung a possible name; suppresses root and TLDs.
# name_fixup &lt;string&gt;
name_fixup(){
    local -a _nf_tmp
    local -i _nf_end
    local _nf_str
    local IFS
    _nf_str=$(to_lower ${1})
    _nf_str=$(to_dot ${_nf_str})
    _nf_end=${#_nf_str}-1
    [ ${_nf_str:${_nf_end}} != '.' ] &amp;&amp;
        _nf_str=${_nf_str}'.'
    IFS=${ADR_IFS}
    _nf_tmp=( ${_nf_str} )
    IFS=${WSP_IFS}
    _nf_end=${#_nf_tmp[@]}
    case ${_nf_end} in
    0) # No dots, only dots.
        echo
        return 1
    ;;
    1) # Only a TLD.
        echo
        return 1
    ;;
    2) # Maybe okay.
       echo ${_nf_str}
       return 0
       # Needs a lookup table?
       if [ ${#_nf_tmp[1]} -eq 2 ]
       then # Country coded TLD.
           echo
           return 1
       else
           echo ${_nf_str}
           return 0
       fi
    ;;
    esac
    echo ${_nf_str}
    return 0
}

# Grope and mung original input(s).
split_input() {
    [ ${#uc_name[@]} -gt 0 ] || return 0
    local -i _si_cnt
    local -i _si_len
    local _si_str
    unique_lines uc_name uc_name
    _si_cnt=${#uc_name[@]}
    for (( _si = 0 ; _si &lt; _si_cnt ; _si++ ))
    do
        _si_str=${uc_name[$_si]}
        if is_address ${_si_str}
        then
            uc_address[${#uc_address[@]}]=${_si_str}
            unset uc_name[$_si]
        else
            if ! uc_name[$_si]=$(name_fixup ${_si_str})
            then
                unset ucname[$_si]
            fi
        fi
    done
  uc_name=( ${uc_name[@]} )
  _si_cnt=${#uc_name[@]}
  _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd name input(s).#'
  _si_cnt=${#uc_address[@]}
  _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd addr input(s).#'
    return 0
}

# # # Discovery functions -- recursively interlocked by external data # # #
# # # The leading 'if list is empty; return 0' in each is required. # # #

# Recursion limiter
# limit_chk() &lt;next_level&gt;
limit_chk() {
    local -i _lc_lmt
    # Check indirection limit.
    if [ ${indirect} -eq 0 ] || [ $# -eq 0 ]
    then
        # The 'do-forever' choice
        echo 1                 # Any value will do.
        return 0               # OK to continue.
    else
        # Limiting is in effect.
        if [ ${indirect} -lt ${1} ]
        then
            echo ${1}          # Whatever.
            return 1           # Stop here.
        else
            _lc_lmt=${1}+1     # Bump the given limit.
            echo ${_lc_lmt}    # Echo it.
            return 0           # OK to continue.
        fi
    fi
}

# For each name in uc_name:
#     Move name to chk_name.
#     Add addresses to uc_address.
#     Pend expand_input_address.
#     Repeat until nothing new found.
# expand_input_name &lt;indirection_limit&gt;
expand_input_name() {
    [ ${#uc_name[@]} -gt 0 ] || return 0
    local -a _ein_addr
    local -a _ein_new
    local -i _ucn_cnt
    local -i _ein_cnt
    local _ein_tst
    _ucn_cnt=${#uc_name[@]}

    if  ! _ein_cnt=$(limit_chk ${1})
    then
        return 0
    fi

    for (( _ein = 0 ; _ein &lt; _ucn_cnt ; _ein++ ))
    do
        if short_fwd ${uc_name[${_ein}]} _ein_new
        then
          for (( _ein_cnt = 0 ; _ein_cnt &lt; ${#_ein_new[@]}; _ein_cnt++ ))
          do
              _ein_tst=${_ein_new[${_ein_cnt}]}
              if is_address ${_ein_tst}
              then
                  _ein_addr[${#_ein_addr[@]}]=${_ein_tst}
              fi
    done
        fi
    done
    unique_lines _ein_addr _ein_addr     # Scrub duplicates.
    edit_exact chk_address _ein_addr     # Scrub pending detail.
    edit_exact known_address _ein_addr   # Scrub already detailed.
 if [ ${#_ein_addr[@]} -gt 0 ]        # Anything new?
 then
   uc_address=( ${uc_address[@]} ${_ein_addr[@]} )
   pend_func expand_input_address ${1}
   _trace_log[${#_trace_log[@]}]='#Add '${#_ein_addr[@]}' unchkd addr inp.#'
    fi
    edit_exact chk_name uc_name          # Scrub pending detail.
    edit_exact known_name uc_name        # Scrub already detailed.
    if [ ${#uc_name[@]} -gt 0 ]
    then
        chk_name=( ${chk_name[@]} ${uc_name[@]}  )
        pend_func detail_each_name ${1}
    fi
    unset uc_name[@]
    return 0
}

# For each address in uc_address:
#     Move address to chk_address.
#     Add names to uc_name.
#     Pend expand_input_name.
#     Repeat until nothing new found.
# expand_input_address &lt;indirection_limit&gt;
expand_input_address() {
    [ ${#uc_address[@]} -gt 0 ] || return 0
    local -a _eia_addr
    local -a _eia_name
    local -a _eia_new
    local -i _uca_cnt
    local -i _eia_cnt
    local _eia_tst
    unique_lines uc_address _eia_addr
    unset uc_address[@]
    edit_exact been_there_addr _eia_addr
    _uca_cnt=${#_eia_addr[@]}
    [ ${_uca_cnt} -gt 0 ] &amp;&amp;
        been_there_addr=( ${been_there_addr[@]} ${_eia_addr[@]} )

    for (( _eia = 0 ; _eia &lt; _uca_cnt ; _eia++ ))
     do
       if short_rev ${_eia_addr[${_eia}]} _eia_new
       then
         for (( _eia_cnt = 0 ; _eia_cnt &lt; ${#_eia_new[@]} ; _eia_cnt++ ))
         do
           _eia_tst=${_eia_new[${_eia_cnt}]}
           if _eia_tst=$(name_fixup ${_eia_tst})
           then
             _eia_name[${#_eia_name[@]}]=${_eia_tst}
       fi
     done
           fi
    done
    unique_lines _eia_name _eia_name     # Scrub duplicates.
    edit_exact chk_name _eia_name        # Scrub pending detail.
    edit_exact known_name _eia_name      # Scrub already detailed.
 if [ ${#_eia_name[@]} -gt 0 ]        # Anything new?
 then
   uc_name=( ${uc_name[@]} ${_eia_name[@]} )
   pend_func expand_input_name ${1}
   _trace_log[${#_trace_log[@]}]='#Add '${#_eia_name[@]}' unchkd name inp.#'
    fi
    edit_exact chk_address _eia_addr     # Scrub pending detail.
    edit_exact known_address _eia_addr   # Scrub already detailed.
    if [ ${#_eia_addr[@]} -gt 0 ]        # Anything new?
    then
        chk_address=( ${chk_address[@]} ${_eia_addr[@]} )
        pend_func detail_each_address ${1}
    fi
    return 0
}

# The parse-it-yourself zone reply.
# The input is the chk_name list.
# detail_each_name &lt;indirection_limit&gt;
detail_each_name() {
    [ ${#chk_name[@]} -gt 0 ] || return 0
    local -a _den_chk       # Names to check
    local -a _den_name      # Names found here
    local -a _den_address   # Addresses found here
    local -a _den_pair      # Pairs found here
    local -a _den_rev       # Reverse pairs found here
    local -a _den_tmp       # Line being parsed
    local -a _den_auth      # SOA contact being parsed
    local -a _den_new       # The zone reply
    local -a _den_pc        # Parent-Child gets big fast
    local -a _den_ref       # So does reference chain
    local -a _den_nr        # Name-Resource can be big
    local -a _den_na        # Name-Address
    local -a _den_ns        # Name-Service
    local -a _den_achn      # Chain of Authority
    local -i _den_cnt       # Count of names to detail
    local -i _den_lmt       # Indirection limit
    local _den_who          # Named being processed
    local _den_rec          # Record type being processed
    local _den_cont         # Contact domain
    local _den_str          # Fixed up name string
    local _den_str2         # Fixed up reverse
    local IFS=${WSP_IFS}

    # Local, unique copy of names to check
    unique_lines chk_name _den_chk
    unset chk_name[@]       # Done with globals.

    # Less any names already known
    edit_exact known_name _den_chk
    _den_cnt=${#_den_chk[@]}

    # If anything left, add to known_name.
    [ ${_den_cnt} -gt 0 ] &amp;&amp;
        known_name=( ${known_name[@]} ${_den_chk[@]} )

    # for the list of (previously) unknown names . . .
    for (( _den = 0 ; _den &lt; _den_cnt ; _den++ ))
    do
        _den_who=${_den_chk[${_den}]}
        if long_fwd ${_den_who} _den_new
        then
            unique_lines _den_new _den_new
            if [ ${#_den_new[@]} -eq 0 ]
            then
                _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}
            fi

            # Parse each line in the reply.
            for (( _line = 0 ; _line &lt; ${#_den_new[@]} ; _line++ ))
            do
                IFS=${NO_WSP}$'\x09'$'\x20'
                _den_tmp=( ${_den_new[${_line}]} )
                IFS=${WSP_IFS}
              # If usable record and not a warning message . . .
              if [ ${#_den_tmp[@]} -gt 4 ] &amp;&amp; [ 'x'${_den_tmp[0]} != 'x;;' ]
              then
                    _den_rec=${_den_tmp[3]}
                    _den_nr[${#_den_nr[@]}]=${_den_who}' '${_den_rec}
                    # Begin at RFC1033 (+++)
                    case ${_den_rec} in

#&lt;name&gt; [&lt;ttl&gt;]  [&lt;class&gt;] SOA &lt;origin&gt; &lt;person&gt;
                    SOA) # Start Of Authority
    if _den_str=$(name_fixup ${_den_tmp[0]})
    then
      _den_name[${#_den_name[@]}]=${_den_str}
      _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str}' SOA'
      # SOA origin -- domain name of master zone record
      if _den_str2=$(name_fixup ${_den_tmp[4]})
      then
        _den_name[${#_den_name[@]}]=${_den_str2}
        _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str2}' SOA.O'
      fi
      # Responsible party e-mail address (possibly bogus).
      # Possibility of first.last@domain.name ignored.
      set -f
      if _den_str2=$(name_fixup ${_den_tmp[5]})
      then
        IFS=${ADR_IFS}
        _den_auth=( ${_den_str2} )
        IFS=${WSP_IFS}
        if [ ${#_den_auth[@]} -gt 2 ]
        then
          _den_cont=${_den_auth[1]}
          for (( _auth = 2 ; _auth &lt; ${#_den_auth[@]} ; _auth++ ))
          do
            _den_cont=${_den_cont}'.'${_den_auth[${_auth}]}
          done
          _den_name[${#_den_name[@]}]=${_den_cont}'.'
          _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_cont}'. SOA.C'
                                fi
        fi
        set +f
                        fi
                    ;;


      A) # IP(v4) Address Record
      if _den_str=$(name_fixup ${_den_tmp[0]})
      then
        _den_name[${#_den_name[@]}]=${_den_str}
        _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}
        _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}
        _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' A'
      else
        _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'
        _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}
        _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain A'
      fi
      _den_address[${#_den_address[@]}]=${_den_tmp[4]}
      _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}
             ;;

             NS) # Name Server Record
             # Domain name being serviced (may be other than current)
               if _den_str=$(name_fixup ${_den_tmp[0]})
                 then
                   _den_name[${#_den_name[@]}]=${_den_str}
                   _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' NS'

             # Domain name of service provider
             if _den_str2=$(name_fixup ${_den_tmp[4]})
             then
               _den_name[${#_den_name[@]}]=${_den_str2}
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' NSH'
               _den_ns[${#_den_ns[@]}]=${_den_str2}' NS'
               _den_pc[${#_den_pc[@]}]=${_den_str}' '${_den_str2}
              fi
               fi
                    ;;

             MX) # Mail Server Record
                 # Domain name being serviced (wildcards not handled here)
             if _den_str=$(name_fixup ${_den_tmp[0]})
             then
               _den_name[${#_den_name[@]}]=${_den_str}
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MX'
             fi
             # Domain name of service provider
             if _den_str=$(name_fixup ${_den_tmp[5]})
             then
               _den_name[${#_den_name[@]}]=${_den_str}
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MXH'
               _den_ns[${#_den_ns[@]}]=${_den_str}' MX'
               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
             fi
                    ;;

             PTR) # Reverse address record
                  # Special name
             if _den_str=$(name_fixup ${_den_tmp[0]})
             then
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' PTR'
               # Host name (not a CNAME)
               if _den_str2=$(name_fixup ${_den_tmp[4]})
               then
                 _den_rev[${#_den_rev[@]}]=${_den_str}' '${_den_str2}
                 _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' PTRH'
                 _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
               fi
             fi
                    ;;

             AAAA) # IP(v6) Address Record
             if _den_str=$(name_fixup ${_den_tmp[0]})
             then
               _den_name[${#_den_name[@]}]=${_den_str}
               _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}
               _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' AAAA'
               else
                 _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'
                 _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}
                 _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain'
               fi
               # No processing for IPv6 addresses
               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}
                    ;;

             CNAME) # Alias name record
                    # Nickname
             if _den_str=$(name_fixup ${_den_tmp[0]})
             then
               _den_name[${#_den_name[@]}]=${_den_str}
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CNAME'
               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
             fi
                    # Hostname
             if _den_str=$(name_fixup ${_den_tmp[4]})
             then
               _den_name[${#_den_name[@]}]=${_den_str}
               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CHOST'
               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
             fi
                    ;;
#            TXT)
#            ;;
                    esac
                fi
            done
        else # Lookup error == 'A' record 'unknown address'
            _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}
        fi
    done

    # Control dot array growth.
    unique_lines _den_achn _den_achn      # Works best, all the same.
    edit_exact auth_chain _den_achn       # Works best, unique items.
    if [ ${#_den_achn[@]} -gt 0 ]
    then
        IFS=${NO_WSP}
        auth_chain=( ${auth_chain[@]} ${_den_achn[@]} )
        IFS=${WSP_IFS}
    fi

    unique_lines _den_ref _den_ref      # Works best, all the same.
    edit_exact ref_chain _den_ref       # Works best, unique items.
    if [ ${#_den_ref[@]} -gt 0 ]
    then
        IFS=${NO_WSP}
        ref_chain=( ${ref_chain[@]} ${_den_ref[@]} )
        IFS=${WSP_IFS}
    fi

    unique_lines _den_na _den_na
    edit_exact name_address _den_na
    if [ ${#_den_na[@]} -gt 0 ]
    then
        IFS=${NO_WSP}
        name_address=( ${name_address[@]} ${_den_na[@]} )
        IFS=${WSP_IFS}
    fi

    unique_lines _den_ns _den_ns
    edit_exact name_srvc _den_ns
    if [ ${#_den_ns[@]} -gt 0 ]
    then
        IFS=${NO_WSP}
        name_srvc=( ${name_srvc[@]} ${_den_ns[@]} )
        IFS=${WSP_IFS}
    fi

    unique_lines _den_nr _den_nr
    edit_exact name_resource _den_nr
    if [ ${#_den_nr[@]} -gt 0 ]
    then
        IFS=${NO_WSP}
        name_resource=( ${name_resource[@]} ${_den_nr[@]} )
        IFS=${WSP_IFS}
    fi

    unique_lines _den_pc _den_pc
    edit_exact parent_child _den_pc
    if [ ${#_den_pc[@]} -gt 0 ]
    then
        IFS=${NO_WSP}
        parent_child=( ${parent_child[@]} ${_den_pc[@]} )
        IFS=${WSP_IFS}
    fi

    # Update list known_pair (Address and Name).
    unique_lines _den_pair _den_pair
    edit_exact known_pair _den_pair
    if [ ${#_den_pair[@]} -gt 0 ]  # Anything new?
    then
        IFS=${NO_WSP}
        known_pair=( ${known_pair[@]} ${_den_pair[@]} )
        IFS=${WSP_IFS}
    fi

    # Update list of reverse pairs.
    unique_lines _den_rev _den_rev
    edit_exact reverse_pair _den_rev
    if [ ${#_den_rev[@]} -gt 0 ]   # Anything new?
    then
        IFS=${NO_WSP}
        reverse_pair=( ${reverse_pair[@]} ${_den_rev[@]} )
        IFS=${WSP_IFS}
    fi

    # Check indirection limit -- give up if reached.
    if ! _den_lmt=$(limit_chk ${1})
    then
        return 0
    fi

# Execution engine is LIFO. Order of pend operations is important.
# Did we define any new addresses?
unique_lines _den_address _den_address    # Scrub duplicates.
edit_exact known_address _den_address     # Scrub already processed.
edit_exact un_address _den_address        # Scrub already waiting.
if [ ${#_den_address[@]} -gt 0 ]          # Anything new?
then
  uc_address=( ${uc_address[@]} ${_den_address[@]} )
  pend_func expand_input_address ${_den_lmt}
  _trace_log[${#_trace_log[@]}]='# Add '${#_den_address[@]}' unchkd addr. #'
    fi

# Did we find any new names?
unique_lines _den_name _den_name          # Scrub duplicates.
edit_exact known_name _den_name           # Scrub already processed.
edit_exact uc_name _den_name              # Scrub already waiting.
if [ ${#_den_name[@]} -gt 0 ]             # Anything new?
then
  uc_name=( ${uc_name[@]} ${_den_name[@]} )
  pend_func expand_input_name ${_den_lmt}
  _trace_log[${#_trace_log[@]}]='#Added '${#_den_name[@]}' unchkd name#'
    fi
    return 0
}

# The parse-it-yourself delegation reply
# Input is the chk_address list.
# detail_each_address &lt;indirection_limit&gt;
detail_each_address() {
    [ ${#chk_address[@]} -gt 0 ] || return 0
    unique_lines chk_address chk_address
    edit_exact known_address chk_address
    if [ ${#chk_address[@]} -gt 0 ]
    then
        known_address=( ${known_address[@]} ${chk_address[@]} )
        unset chk_address[@]
    fi
    return 0
}

# # # Application specific output functions # # #

# Pretty print the known pairs.
report_pairs() {
    echo
    echo 'Known network pairs.'
    col_print known_pair 2 5 30

    if [ ${#auth_chain[@]} -gt 0 ]
    then
        echo
        echo 'Known chain of authority.'
        col_print auth_chain 2 5 30 55
    fi

    if [ ${#reverse_pair[@]} -gt 0 ]
    then
        echo
        echo 'Known reverse pairs.'
        col_print reverse_pair 2 5 55
    fi
    return 0
}

# Check an address against the list of blacklist servers.
# A good place to capture for GraphViz: address-&gt;status(server(reports))
# check_lists &lt;ip_address&gt;
check_lists() {
    [ $# -eq 1 ] || return 1
    local -a _cl_fwd_addr
    local -a _cl_rev_addr
    local -a _cl_reply
    local -i _cl_rc
    local -i _ls_cnt
    local _cl_dns_addr
    local _cl_lkup

    split_ip ${1} _cl_fwd_addr _cl_rev_addr
    _cl_dns_addr=$(dot_array _cl_rev_addr)'.'
    _ls_cnt=${#list_server[@]}
    echo '    Checking address '${1}
    for (( _cl = 0 ; _cl &lt; _ls_cnt ; _cl++ ))
    do
      _cl_lkup=${_cl_dns_addr}${list_server[${_cl}]}
      if short_text ${_cl_lkup} _cl_reply
      then
        if [ ${#_cl_reply[@]} -gt 0 ]
        then
          echo '        Records from '${list_server[${_cl}]}
          address_hits[${#address_hits[@]}]=${1}' '${list_server[${_cl}]}
          _hs_RC=2
          for (( _clr = 0 ; _clr &lt; ${#_cl_reply[@]} ; _clr++ ))
          do
            echo '            '${_cl_reply[${_clr}]}
          done
        fi
      fi
    done
    return 0
}

# # # The usual application glue # # #

# Who did it?
credits() {
   echo
   echo 'Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz'
}

# How to use it?
# (See also, "Quickstart" at end of script.)
usage() {
    cat &lt;&lt;-'_usage_statement_'
    The script is_spammer.bash requires either one or two arguments.

    arg 1) May be one of:
        a) A domain name
        b) An IPv4 address
        c) The name of a file with any mix of names
           and addresses, one per line.

    arg 2) May be one of:
        a) A Blacklist server domain name
        b) The name of a file with Blacklist server
           domain names, one per line.
        c) If not present, a default list of (free)
           Blacklist servers is used.
        d) If a filename of an empty, readable, file
           is given,
           Blacklist server lookup is disabled.

    All script output is written to stdout.

    Return codes: 0 -&gt; All OK, 1 -&gt; Script failure,
                  2 -&gt; Something is Blacklisted.

    Requires the external program 'dig' from the 'bind-9'
    set of DNS programs.  See: http://www.isc.org

    The domain name lookup depth limit defaults to 2 levels.
    Set the environment variable SPAMMER_LIMIT to change.
    SPAMMER_LIMIT=0 means 'unlimited'

    Limit may also be set on the command-line.
    If arg#1 is an integer, the limit is set to that value
    and then the above argument rules are applied.

    Setting the environment variable 'SPAMMER_DATA' to a filename
    will cause the script to write a GraphViz graphic file.

    For the development version;
    Setting the environment variable 'SPAMMER_TRACE' to a filename
    will cause the execution engine to log a function call trace.

_usage_statement_
}

# The default list of Blacklist servers:
# Many choices, see: http://www.spews.org/lists.html

declare -a default_servers
# See: http://www.spamhaus.org (Conservative, well maintained)
default_servers[0]='sbl-xbl.spamhaus.org'
# See: http://ordb.org (Open mail relays)
default_servers[1]='relays.ordb.org'
# See: http://www.spamcop.net/ (You can report spammers here)
default_servers[2]='bl.spamcop.net'
# See: http://www.spews.org (An 'early detect' system)
default_servers[3]='l2.spews.dnsbl.sorbs.net'
# See: http://www.dnsbl.us.sorbs.net/using.shtml
default_servers[4]='dnsbl.sorbs.net'
# See: http://dsbl.org/usage (Various mail relay lists)
default_servers[5]='list.dsbl.org'
default_servers[6]='multihop.dsbl.org'
default_servers[7]='unconfirmed.dsbl.org'

# User input argument #1
setup_input() {
    if [ -e ${1} ] &amp;&amp; [ -r ${1} ]  # Name of readable file
    then
        file_to_array ${1} uc_name
        echo 'Using filename &gt;'${1}'&lt; as input.'
    else
        if is_address ${1}          # IP address?
        then
            uc_address=( ${1} )
            echo 'Starting with address &gt;'${1}'&lt;'
        else                       # Must be a name.
            uc_name=( ${1} )
            echo 'Starting with domain name &gt;'${1}'&lt;'
        fi
    fi
    return 0
}

# User input argument #2
setup_servers() {
    if [ -e ${1} ] &amp;&amp; [ -r ${1} ]  # Name of a readable file
    then
        file_to_array ${1} list_server
        echo 'Using filename &gt;'${1}'&lt; as blacklist server list.'
    else
        list_server=( ${1} )
        echo 'Using blacklist server &gt;'${1}'&lt;'
    fi
    return 0
}

# User environment variable SPAMMER_TRACE
live_log_die() {
    if [ ${SPAMMER_TRACE:=} ]    # Wants trace log?
    then
        if [ ! -e ${SPAMMER_TRACE} ]
        then
            if ! touch ${SPAMMER_TRACE} 2&gt;/dev/null
            then
                pend_func echo $(printf '%q\n' \
                'Unable to create log file &gt;'${SPAMMER_TRACE}'&lt;')
                pend_release
                exit 1
            fi
            _log_file=${SPAMMER_TRACE}
            _pend_hook_=trace_logger
            _log_dump=dump_log
        else
            if [ ! -w ${SPAMMER_TRACE} ]
            then
                pend_func echo $(printf '%q\n' \
                'Unable to write log file &gt;'${SPAMMER_TRACE}'&lt;')
                pend_release
                exit 1
            fi
            _log_file=${SPAMMER_TRACE}
            echo '' &gt; ${_log_file}
            _pend_hook_=trace_logger
            _log_dump=dump_log
        fi
    fi
    return 0
}

# User environment variable SPAMMER_DATA
data_capture() {
    if [ ${SPAMMER_DATA:=} ]    # Wants a data dump?
    then
        if [ ! -e ${SPAMMER_DATA} ]
        then
            if ! touch ${SPAMMER_DATA} 2&gt;/dev/null
            then
                pend_func echo $(printf '%q]n' \
                'Unable to create data output file &gt;'${SPAMMER_DATA}'&lt;')
                pend_release
                exit 1
            fi
            _dot_file=${SPAMMER_DATA}
            _dot_dump=dump_dot
        else
            if [ ! -w ${SPAMMER_DATA} ]
            then
                pend_func echo $(printf '%q\n' \
                'Unable to write data output file &gt;'${SPAMMER_DATA}'&lt;')
                pend_release
                exit 1
            fi
            _dot_file=${SPAMMER_DATA}
            _dot_dump=dump_dot
        fi
    fi
    return 0
}

# Grope user specified arguments.
do_user_args() {
    if [ $# -gt 0 ] &amp;&amp; is_number $1
    then
        indirect=$1
        shift
    fi

    case $# in                     # Did user treat us well?
        1)
            if ! setup_input $1    # Needs error checking.
            then
                pend_release
                $_log_dump
                exit 1
            fi
            list_server=( ${default_servers[@]} )
            _list_cnt=${#list_server[@]}
            echo 'Using default blacklist server list.'
            echo 'Search depth limit: '${indirect}
            ;;
        2)
            if ! setup_input $1    # Needs error checking.
            then
                pend_release
                $_log_dump
                exit 1
            fi
            if ! setup_servers $2  # Needs error checking.
            then
                pend_release
                $_log_dump
                exit 1
            fi
            echo 'Search depth limit: '${indirect}
            ;;
        *)
            pend_func usage
            pend_release
            $_log_dump
            exit 1
            ;;
    esac
    return 0
}

# A general purpose debug tool.
# list_array &lt;array_name&gt;
list_array() {
    [ $# -eq 1 ] || return 1  # One argument required.

    local -a _la_lines
    set -f
    local IFS=${NO_WSP}
    eval _la_lines=\(\ \$\{$1\[@\]\}\ \)
    echo
    echo "Element count "${#_la_lines[@]}" array "${1}
    local _ln_cnt=${#_la_lines[@]}

    for (( _i = 0; _i &lt; ${_ln_cnt}; _i++ ))
    do
        echo 'Element '$_i' &gt;'${_la_lines[$_i]}'&lt;'
    done
    set +f
    return 0
}

# # # 'Hunt the Spammer' program code # # #
pend_init                               # Ready stack engine.
pend_func credits                       # Last thing to print.

# # # Deal with user # # #
live_log_die                            # Setup debug trace log.
data_capture                            # Setup data capture file.
echo
do_user_args $@

# # # Haven't exited yet - There is some hope # # #
# Discovery group - Execution engine is LIFO - pend
# in reverse order of execution.
_hs_RC=0                                # Hunt the Spammer return code
pend_mark
    pend_func report_pairs              # Report name-address pairs.

    # The two detail_* are mutually recursive functions.
    # They also pend expand_* functions as required.
    # These two (the last of ???) exit the recursion.
    pend_func detail_each_address       # Get all resources of addresses.
    pend_func detail_each_name          # Get all resources of names.

    #  The two expand_* are mutually recursive functions,
    #+ which pend additional detail_* functions as required.
    pend_func expand_input_address 1    # Expand input names by address.
    pend_func expand_input_name 1       # #xpand input addresses by name.

    # Start with a unique set of names and addresses.
    pend_func unique_lines uc_address uc_address
    pend_func unique_lines uc_name uc_name

    # Separate mixed input of names and addresses.
    pend_func split_input
pend_release

# # # Pairs reported -- Unique list of IP addresses found
echo
_ip_cnt=${#known_address[@]}
if [ ${#list_server[@]} -eq 0 ]
then
    echo 'Blacklist server list empty, none checked.'
else
    if [ ${_ip_cnt} -eq 0 ]
    then
        echo 'Known address list empty, none checked.'
    else
        _ip_cnt=${_ip_cnt}-1   # Start at top.
        echo 'Checking Blacklist servers.'
        for (( _ip = _ip_cnt ; _ip &gt;= 0 ; _ip-- ))
        do
          pend_func check_lists $( printf '%q\n' ${known_address[$_ip]} )
        done
    fi
fi
pend_release
$_dot_dump                   # Graphics file dump
$_log_dump                   # Execution trace
echo


##############################
# Example output from script #
##############################
:&lt;&lt;-'_is_spammer_outputs_'

./is_spammer.bash 0 web4.alojamentos7.com

Starting with domain name &gt;web4.alojamentos7.com&lt;
Using default blacklist server list.
Search depth limit: 0
.:....::::...:::...:::.......::..::...:::.......::
Known network pairs.
    66.98.208.97             web4.alojamentos7.com.
    66.98.208.97             ns1.alojamentos7.com.
    69.56.202.147            ns2.alojamentos.ws.
    66.98.208.97             alojamentos7.com.
    66.98.208.97             web.alojamentos7.com.
    69.56.202.146            ns1.alojamentos.ws.
    69.56.202.146            alojamentos.ws.
    66.235.180.113           ns1.alojamentos.org.
    66.235.181.192           ns2.alojamentos.org.
    66.235.180.113           alojamentos.org.
    66.235.180.113           web6.alojamentos.org.
    216.234.234.30           ns1.theplanet.com.
    12.96.160.115            ns2.theplanet.com.
    216.185.111.52           mail1.theplanet.com.
    69.56.141.4              spooling.theplanet.com.
    216.185.111.40           theplanet.com.
    216.185.111.40           www.theplanet.com.
    216.185.111.52           mail.theplanet.com.

Checking Blacklist servers.
  Checking address 66.98.208.97
      Records from dnsbl.sorbs.net
  "Spam Received See: http://www.dnsbl.sorbs.net/lookup.shtml?66.98.208.97"
    Checking address 69.56.202.147
    Checking address 69.56.202.146
    Checking address 66.235.180.113
    Checking address 66.235.181.192
    Checking address 216.185.111.40
    Checking address 216.234.234.30
    Checking address 12.96.160.115
    Checking address 216.185.111.52
    Checking address 69.56.141.4

Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz

_is_spammer_outputs_

exit ${_hs_RC}

####################################################
#  The script ignores everything from here on down #
#+ because of the 'exit' command, just above.      #
####################################################



Quickstart
==========

 Prerequisites

  Bash version 2.05b or 3.00 (bash --version)
  A version of Bash which supports arrays. Array 
  support is included by default Bash configurations.

  'dig,' version 9.x.x (dig $HOSTNAME, see first line of output)
  A version of dig which supports the +short options. 
  See: dig_wrappers.bash for details.


 Optional Prerequisites

  'named,' a local DNS caching program. Any flavor will do.
  Do twice: dig $HOSTNAME 
  Check near bottom of output for: SERVER: 127.0.0.1#53
  That means you have one running.


 Optional Graphics Support

  'date,' a standard *nix thing. (date -R)

  dot Program to convert graphic description file to a 
  diagram. (dot -V)
  A part of the Graph-Viz set of programs.
  See: [http://www.research.att.com/sw/tools/graphviz||GraphViz]

  'dotty,' a visual editor for graphic description files.
  Also a part of the Graph-Viz set of programs.




 Quick Start

In the same directory as the is_spammer.bash script; 
Do: ./is_spammer.bash

 Usage Details

1. Blacklist server choices.

  (a) To use default, built-in list: Do nothing.

  (b) To use your own list: 

    i. Create a file with a single Blacklist server 
       domain name per line.

    ii. Provide that filename as the last argument to 
        the script.

  (c) To use a single Blacklist server: Last argument 
      to the script.

  (d) To disable Blacklist lookups:

    i. Create an empty file (touch spammer.nul)
       Your choice of filename.

    ii. Provide the filename of that empty file as the 
        last argument to the script.

2. Search depth limit.

  (a) To use the default value of 2: Do nothing.

  (b) To set a different limit: 
      A limit of 0 means: no limit.

    i. export SPAMMER_LIMIT=1
       or whatever limit you want.

    ii. OR provide the desired limit as the first 
       argument to the script.

3. Optional execution trace log.

  (a) To use the default setting of no log output: Do nothing.

  (b) To write an execution trace log:
      export SPAMMER_TRACE=spammer.log
      or whatever filename you want.

4. Optional graphic description file.

  (a) To use the default setting of no graphic file: Do nothing.

  (b) To write a Graph-Viz graphic description file:
      export SPAMMER_DATA=spammer.dot
      or whatever filename you want.

5. Where to start the search.

  (a) Starting with a single domain name:

    i. Without a command-line search limit: First 
       argument to script.

    ii. With a command-line search limit: Second 
        argument to script.

  (b) Starting with a single IP address:

    i. Without a command-line search limit: First 
       argument to script.

    ii. With a command-line search limit: Second 
        argument to script.

  (c) Starting with (mixed) multiple name(s) and/or address(es):
      Create a file with one name or address per line.
      Your choice of filename.

    i. Without a command-line search limit: Filename as 
       first argument to script.

    ii. With a command-line search limit: Filename as 
        second argument to script.

6. What to do with the display output.

  (a) To view display output on screen: Do nothing.

  (b) To save display output to a file: Redirect stdout to a filename.

  (c) To discard display output: Redirect stdout to /dev/null.

7. Temporary end of decision making. 
   press RETURN 
   wait (optionally, watch the dots and colons).

8. Optionally check the return code.

  (a) Return code 0: All OK

  (b) Return code 1: Script setup failure

  (c) Return code 2: Something was blacklisted.

9. Where is my graph (diagram)?

The script does not directly produce a graph (diagram). 
It only produces a graphic description file. You can 
process the graphic descriptor file that was output 
with the 'dot' program.

Until you edit that descriptor file, to describe the 
relationships you want shown, all that you will get is 
a bunch of labeled name and address nodes.

All of the script's discovered relationships are within 
a comment block in the graphic descriptor file, each 
with a descriptive heading.

The editing required to draw a line between a pair of 
nodes from the information in the descriptor file may 
be done with a text editor. 

Given these lines somewhere in the descriptor file:

# Known domain name nodes

N0000 [label="guardproof.info."] ;

N0002 [label="third.guardproof.info."] ;



# Known address nodes

A0000 [label="61.141.32.197"] ;



/*

# Known name-&gt;address edges

NA0000 third.guardproof.info. 61.141.32.197



# Known parent-&gt;child edges

PC0000 guardproof.info. third.guardproof.info.

 */

Turn that into the following lines by substituting node 
identifiers into the relationships:

# Known domain name nodes

N0000 [label="guardproof.info."] ;

N0002 [label="third.guardproof.info."] ;



# Known address nodes

A0000 [label="61.141.32.197"] ;



# PC0000 guardproof.info. third.guardproof.info.

N0000-&gt;N0002 ;



# NA0000 third.guardproof.info. 61.141.32.197

N0002-&gt;A0000 ;



/*

# Known name-&gt;address edges

NA0000 third.guardproof.info. 61.141.32.197



# Known parent-&gt;child edges

PC0000 guardproof.info. third.guardproof.info.

 */

Process that with the 'dot' program, and you have your 
first network diagram.

In addition to the conventional graphic edges, the 
descriptor file includes similar format pair-data that 
describes services, zone records (sub-graphs?), 
blacklisted addresses, and other things which might be 
interesting to include in your graph. This additional 
information could be displayed as different node 
shapes, colors, line sizes, etc.

The descriptor file can also be read and edited by a 
Bash script (of course). You should be able to find 
most of the functions required within the 
"is_spammer.bash" script.

# End Quickstart.



Additional Note
========== ====

Michael Zick points out that there is a "makeviz.bash" interactive
Web site at rediris.es. Can't give the full URL, since this is not
a publically accessible site.
</programlisting>
    </example>


    <para>Another anti-spam script.</para>

    <para><anchor xml:id="whx0" /></para>
    <example xml:id="whx">
      <title>Spammer Hunt</title>
      <programlisting>#!/bin/bash
# whx.sh: "whois" spammer lookup
# Author: Walter Dnes
# Slight revisions (first section) by ABS Guide author.
# Used in ABS Guide with permission.

# Needs version 3.x or greater of Bash to run (because of =~ operator).
# Commented by script author and ABS Guide author.



E_BADARGS=85        # Missing command-line arg.
E_NOHOST=86         # Host not found.
E_TIMEOUT=87        # Host lookup timed out.
E_UNDEF=88          # Some other (undefined) error.

HOSTWAIT=10         # Specify up to 10 seconds for host query reply.
                    # The actual wait may be a bit longer.
OUTFILE=whois.txt   # Output file.
PORT=4321


if [ -z "$1" ]      # Check for (required) command-line arg.
then
  echo "Usage: $0 domain name or IP address"
  exit $E_BADARGS
fi


if [[ "$1" =~ [a-zA-Z][a-zA-Z]$ ]]  #  Ends in two alpha chars?
then                                  #  It's a domain name &amp;&amp;
                                      #+ must do host lookup.
  IPADDR=$(host -W $HOSTWAIT $1 | awk '{print $4}')
                                      #  Doing host lookup
                                      #+ to get IP address.
				      #  Extract final field.
else
  IPADDR="$1"                         #  Command-line arg was IP address.
fi

echo; echo "IP Address is: "$IPADDR""; echo

if [ -e "$OUTFILE" ]
then
  rm -f "$OUTFILE"
  echo "Stale output file \"$OUTFILE\" removed."; echo
fi


#  Sanity checks.
#  (This section needs more work.)
#  ===============================
if [ -z "$IPADDR" ]
# No response.
then
  echo "Host not found!"
  exit $E_NOHOST    # Bail out.
fi

if [[ "$IPADDR" =~ ^[;;] ]]
#  ;; Connection timed out; no servers could be reached.
then
  echo "Host lookup timed out!"
  exit $E_TIMEOUT   # Bail out.
fi

if [[ "$IPADDR" =~ [(NXDOMAIN)]$ ]]
#  Host xxxxxxxxx.xxx not found: 3(NXDOMAIN)
then
  echo "Host not found!"
  exit $E_NOHOST    # Bail out.
fi

if [[ "$IPADDR" =~ [(SERVFAIL)]$ ]]
#  Host xxxxxxxxx.xxx not found: 2(SERVFAIL)
then
  echo "Host not found!"
  exit $E_NOHOST    # Bail out.
fi




# ======================== Main body of script ========================

AFRINICquery() {
#  Define the function that queries AFRINIC. Echo a notification to the
#+ screen, and then run the actual query, redirecting output to $OUTFILE.

  echo "Searching for $IPADDR in whois.afrinic.net"
  whois -h whois.afrinic.net "$IPADDR" &gt; $OUTFILE

#  Check for presence of reference to an rwhois.
#  Warn about non-functional rwhois.infosat.net server
#+ and attempt rwhois query.
  if grep -e "^remarks: .*rwhois\.[^ ]\+" "$OUTFILE"
  then
    echo " " &gt;&gt; $OUTFILE
    echo "***" &gt;&gt; $OUTFILE
    echo "***" &gt;&gt; $OUTFILE
    echo "Warning: rwhois.infosat.net was not working \
      as of 2005/02/02" &gt;&gt; $OUTFILE
    echo "         when this script was written." &gt;&gt; $OUTFILE
    echo "***" &gt;&gt; $OUTFILE
    echo "***" &gt;&gt; $OUTFILE
    echo " " &gt;&gt; $OUTFILE
    RWHOIS=`grep "^remarks: .*rwhois\.[^ ]\+" "$OUTFILE" | tail -n 1 |\
    sed "s/\(^.*\)\(rwhois\..*\)\(:4.*\)/\2/"`
    whois -h ${RWHOIS}:${PORT} "$IPADDR" &gt;&gt; $OUTFILE
  fi
}

APNICquery() {
  echo "Searching for $IPADDR in whois.apnic.net"
  whois -h whois.apnic.net "$IPADDR" &gt; $OUTFILE

#  Just  about  every  country has its own internet registrar.
#  I don't normally bother consulting them, because the regional registry
#+ usually supplies sufficient information.
#  There are a few exceptions, where the regional registry simply
#+ refers to the national registry for direct data.
#  These are Japan and South Korea in APNIC, and Brasil in LACNIC.
#  The following if statement checks $OUTFILE (whois.txt) for the presence
#+ of "KR" (South Korea) or "JP" (Japan) in the country field.
#  If either is found, the query is re-run against the appropriate
#+ national registry.

  if grep -E "^country:[ ]+KR$" "$OUTFILE"
  then
    echo "Searching for $IPADDR in whois.krnic.net"
    whois -h whois.krnic.net "$IPADDR" &gt;&gt; $OUTFILE
  elif grep -E "^country:[ ]+JP$" "$OUTFILE"
  then
    echo "Searching for $IPADDR in whois.nic.ad.jp"
    whois -h whois.nic.ad.jp "$IPADDR"/e &gt;&gt; $OUTFILE
  fi
}

ARINquery() {
  echo "Searching for $IPADDR in whois.arin.net"
  whois -h whois.arin.net "$IPADDR" &gt; $OUTFILE

#  Several large internet providers listed by ARIN have their own
#+ internal whois service, referred to as "rwhois".
#  A large block of IP addresses is listed with the provider
#+ under the ARIN registry.
#  To get the IP addresses of 2nd-level ISPs or other large customers,
#+ one has to refer to the rwhois server on port 4321.
#  I originally started with a bunch of "if" statements checking for
#+ the larger providers.
#  This approach is unwieldy, and there's always another rwhois server
#+ that I didn't know about.
#  A more elegant approach is to check $OUTFILE for a reference
#+ to a whois server, parse that server name out of the comment section,
#+ and re-run the query against the appropriate rwhois server.
#  The parsing looks a bit ugly, with a long continued line inside
#+ backticks.
#  But it only has to be done once, and will work as new servers are added.
#@   ABS Guide author comment: it isn't all that ugly, and is, in fact,
#@+  an instructive use of Regular Expressions.

  if grep -E "^Comment: .*rwhois.[^ ]+" "$OUTFILE"
  then
    RWHOIS=`grep -e "^Comment:.*rwhois\.[^ ]\+" "$OUTFILE" | tail -n 1 |\
    sed "s/^\(.*\)\(rwhois\.[^ ]\+\)\(.*$\)/\2/"`
    echo "Searching for $IPADDR in ${RWHOIS}"
    whois -h ${RWHOIS}:${PORT} "$IPADDR" &gt;&gt; $OUTFILE
  fi
}

LACNICquery() {
  echo "Searching for $IPADDR in whois.lacnic.net"
  whois -h whois.lacnic.net "$IPADDR" &gt; $OUTFILE

#  The  following if statement checks $OUTFILE (whois.txt) for
#+ the presence of "BR" (Brasil) in the country field.
#  If it is found, the query is re-run against whois.registro.br.

  if grep -E "^country:[ ]+BR$" "$OUTFILE"
  then
    echo "Searching for $IPADDR in whois.registro.br"
    whois -h whois.registro.br "$IPADDR" &gt;&gt; $OUTFILE
  fi
}

RIPEquery() {
  echo "Searching for $IPADDR in whois.ripe.net"
  whois -h whois.ripe.net "$IPADDR" &gt; $OUTFILE
}

#  Initialize a few variables.
#  * slash8 is the most significant octet
#  * slash16 consists of the two most significant octets
#  * octet2 is the second most significant octet




slash8=`echo $IPADDR | cut -d. -f 1`
  if [ -z "$slash8" ]  # Yet another sanity check.
  then
    echo "Undefined error!"
    exit $E_UNDEF
  fi
slash16=`echo $IPADDR | cut -d. -f 1-2`
#                             ^ Period specified as 'cut" delimiter.
  if [ -z "$slash16" ]
  then
    echo "Undefined error!"
    exit $E_UNDEF
  fi
octet2=`echo $slash16 | cut -d. -f 2`
  if [ -z "$octet2" ]
  then
    echo "Undefined error!"
    exit $E_UNDEF
  fi


#  Check for various odds and ends of reserved space.
#  There is no point in querying for those addresses.

if [ $slash8 == 0 ]; then
  echo $IPADDR is '"This Network"' space\; Not querying
elif [ $slash8 == 10 ]; then
  echo $IPADDR is RFC1918 space\; Not querying
elif [ $slash8 == 14 ]; then
  echo $IPADDR is '"Public Data Network"' space\; Not querying
elif [ $slash8 == 127 ]; then
  echo $IPADDR is loopback space\; Not querying
elif [ $slash16 == 169.254 ]; then
  echo $IPADDR is link-local space\; Not querying
elif [ $slash8 == 172 ] &amp;&amp; [ $octet2 -ge 16 ] &amp;&amp; [ $octet2 -le 31 ];then
  echo $IPADDR is RFC1918 space\; Not querying
elif [ $slash16 == 192.168 ]; then
  echo $IPADDR is RFC1918 space\; Not querying
elif [ $slash8 -ge 224 ]; then
  echo $IPADDR is either Multicast or reserved space\; Not querying
elif [ $slash8 -ge 200 ] &amp;&amp; [ $slash8 -le 201 ]; then LACNICquery "$IPADDR"
elif [ $slash8 -ge 202 ] &amp;&amp; [ $slash8 -le 203 ]; then APNICquery "$IPADDR"
elif [ $slash8 -ge 210 ] &amp;&amp; [ $slash8 -le 211 ]; then APNICquery "$IPADDR"
elif [ $slash8 -ge 218 ] &amp;&amp; [ $slash8 -le 223 ]; then APNICquery "$IPADDR"

#  If we got this far without making a decision, query ARIN.
#  If a reference is found in $OUTFILE to APNIC, AFRINIC, LACNIC, or RIPE,
#+ query the appropriate whois server.

else
  ARINquery "$IPADDR"
  if grep "whois.afrinic.net" "$OUTFILE"; then
    AFRINICquery "$IPADDR"
  elif grep -E "^OrgID:[ ]+RIPE$" "$OUTFILE"; then
    RIPEquery "$IPADDR"
  elif grep -E "^OrgID:[ ]+APNIC$" "$OUTFILE"; then
    APNICquery "$IPADDR"
  elif grep -E "^OrgID:[ ]+LACNIC$" "$OUTFILE"; then
    LACNICquery "$IPADDR"
  fi
fi

#@  ---------------------------------------------------------------
#   Try also:
#   wget http://logi.cc/nw/whois.php3?ACTION=doQuery&amp;DOMAIN=$IPADDR
#@  ---------------------------------------------------------------

#  We've  now  finished  the querying.
#  Echo a copy of the final result to the screen.

cat $OUTFILE
# Or "less $OUTFILE" . . .


exit 0

#@  ABS Guide author comments:
#@  Nothing fancy here, but still a very useful tool for hunting spammers.
#@  Sure, the script can be cleaned up some, and it's still a bit buggy,
#@+ (exercise for reader), but all the same, it's a nice piece of coding
#@+ by Walter Dnes.
#@  Thank you!
</programlisting>
    </example>


    <para><quote>Little Monster's</quote> front end to <link linkend="wgetref">wget</link>.</para>

    <example xml:id="wgetter2">
      <title>Making <firstterm>wget</firstterm> easier to use</title>
      <programlisting>#!/bin/bash
# wgetter2.bash

# Author: Little Monster [monster@monstruum.co.uk]
# ==&gt; Used in ABS Guide with permission of script author.
# ==&gt; This script still needs debugging and fixups (exercise for reader).
# ==&gt; It could also use some additional editing in the comments.


#  This is wgetter2 --
#+ a Bash script to make wget a bit more friendly, and save typing.

#  Carefully crafted by Little Monster.
#  More or less complete on 02/02/2005.
#  If you think this script can be improved,
#+ email me at: monster@monstruum.co.uk
# ==&gt; and cc: to the author of the ABS Guide, please.
#  This script is licenced under the GPL.
#  You are free to copy, alter and re-use it,
#+ but please don't try to claim you wrote it.
#  Log your changes here instead.

# =======================================================================
# changelog:

# 07/02/2005.  Fixups by Little Monster.
# 02/02/2005.  Minor additions by Little Monster.
#              (See after # +++++++++++ )
# 29/01/2005.  Minor stylistic edits and cleanups by author of ABS Guide.
#              Added exit error codes.
# 22/11/2004.  Finished initial version of second version of wgetter:
#              wgetter2 is born.
# 01/12/2004.  Changed 'runn' function so it can be run 2 ways --
#              either ask for a file name or have one input on the CL.
# 01/12/2004.  Made sensible handling of no URL's given.
# 01/12/2004.  Made loop of main options, so you don't
#              have to keep calling wgetter 2 all the time.
#              Runs as a session instead.
# 01/12/2004.  Added looping to 'runn' function.
#              Simplified and improved.
# 01/12/2004.  Added state to recursion setting.
#              Enables re-use of previous value.
# 05/12/2004.  Modified the file detection routine in the 'runn' function
#              so it's not fooled by empty values, and is cleaner.
# 01/02/2004.  Added cookie finding routine from later version (which 
#              isn't ready yet), so as not to have hard-coded paths.
# =======================================================================

# Error codes for abnormal exit.
E_USAGE=67        # Usage message, then quit.
E_NO_OPTS=68      # No command-line args entered.
E_NO_URLS=69      # No URLs passed to script.
E_NO_SAVEFILE=70  # No save filename passed to script.
E_USER_EXIT=71    # User decides to quit.


#  Basic default wget command we want to use.
#  This is the place to change it, if required.
#  NB: if using a proxy, set http_proxy = yourproxy in .wgetrc.
#  Otherwise delete --proxy=on, below.
# ====================================================================
CommandA="wget -nc -c -t 5 --progress=bar --random-wait --proxy=on -r"
# ====================================================================



# --------------------------------------------------------------------
# Set some other variables and explain them.

pattern=" -A .jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.htm,.html,.shtml,.php"
                    # wget's option to only get certain types of file.
                    # comment out if not using
today=`date +%F`    # Used for a filename.
home=$HOME          # Set HOME to an internal variable.
                    # In case some other path is used, change it here.
depthDefault=3      # Set a sensible default recursion.
Depth=$depthDefault # Otherwise user feedback doesn't tie in properly.
RefA=""             # Set blank referring page.
Flag=""             #  Default to not saving anything,
                    #+ or whatever else might be wanted in future.
lister=""           # Used for passing a list of urls directly to wget.
Woptions=""         # Used for passing wget some options for itself.
inFile=""           # Used for the run function.
newFile=""          # Used for the run function.
savePath="$home/w-save"
Config="$home/.wgetter2rc"
                    #  This is where some variables can be stored, 
                    #+ if permanently changed from within the script.
Cookie_List="$home/.cookielist"
                    # So we know where the cookies are kept . . .
cFlag=""            # Part of the cookie file selection routine.

# Define the options available. Easy to change letters here if needed.
# These are the optional options; you don't just wait to be asked.

save=s   # Save command instead of executing it.
cook=c   # Change cookie file for this session.
help=h   # Usage guide.
list=l   # Pass wget the -i option and URL list.
runn=r   # Run saved commands as an argument to the option.
inpu=i   # Run saved commands interactively.
wopt=w   # Allow to enter options to pass directly to wget.
# --------------------------------------------------------------------


if [ -z "$1" ]; then   # Make sure we get something for wget to eat.
   echo "You must at least enter a URL or option!"
   echo "-$help for usage."
   exit $E_NO_OPTS
fi



# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# added added added added added added added added added added added added

if [ ! -e "$Config" ]; then   # See if configuration file exists.
   echo "Creating configuration file, $Config"
   echo "# This is the configuration file for wgetter2" &gt; "$Config"
   echo "# Your customised settings will be saved in this file" &gt;&gt; "$Config"
else
   source $Config             # Import variables we set outside the script.
fi

if [ ! -e "$Cookie_List" ]; then
   # Set up a list of cookie files, if there isn't one.
   echo "Hunting for cookies . . ."
   find -name cookies.txt &gt;&gt; $Cookie_List # Create the list of cookie files.
fi #  Isolate this in its own 'if' statement,
   #+ in case we got interrupted while searching.

if [ -z "$cFlag" ]; then # If we haven't already done this . . .
   echo                  # Make a nice space after the command prompt.
   echo "Looks like you haven't set up your source of cookies yet."
   n=0                   #  Make sure the counter
                         #+ doesn't contain random values.
   while read; do
      Cookies[$n]=$REPLY # Put the cookie files we found into an array.
      echo "$n) ${Cookies[$n]}"  # Create a menu.
      n=$(( n + 1 ))     # Increment the counter.
   done &lt; $Cookie_List   # Feed the read statement.
   echo "Enter the number of the cookie file you want to use."
   echo "If you won't be using cookies, just press RETURN."
   echo
   echo "I won't be asking this again. Edit $Config"
   echo "If you decide to change at a later date"
   echo "or use the -${cook} option for per session changes."
   read
   if [ ! -z $REPLY ]; then   # User didn't just press return.
      Cookie=" --load-cookies ${Cookies[$REPLY]}"
      # Set the variable here as well as in the config file.

      echo "Cookie=\" --load-cookies ${Cookies[$REPLY]}\"" &gt;&gt; $Config
   fi
   echo "cFlag=1" &gt;&gt; $Config  # So we know not to ask again.
fi

# end added section end added section end added section end added section
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



# Another variable.
# This one may or may not be subject to variation.
# A bit like the small print.
CookiesON=$Cookie
# echo "cookie file is $CookiesON" # For debugging.
# echo "home is ${home}"           # For debugging.
                                   # Got caught with this one!


wopts()
{
echo "Enter options to pass to wget."
echo "It is assumed you know what you're doing."
echo
echo "You can pass their arguments here too."
# That is to say, everything passed here is passed to wget.

read Wopts
# Read in the options to be passed to wget.

Woptions=" $Wopts"
#         ^  Why the leading space?
# Assign to another variable.
# Just for fun, or something . . .

echo "passing options ${Wopts} to wget"
# Mainly for debugging.
# Is cute.

return
}


save_func()
{
echo "Settings will be saved."
if [ ! -d $savePath ]; then  #  See if directory exists.
   mkdir $savePath           #  Create the directory to save things in
                             #+ if it isn't already there.
fi

Flag=S
# Tell the final bit of code what to do.
# Set a flag since stuff is done in main.

return
}


usage() # Tell them how it works.
{
    echo "Welcome to wgetter.  This is a front end to wget."
    echo "It will always run wget with these options:"
    echo "$CommandA"
    echo "and the pattern to match: $pattern \
(which you can change at the top of this script)."
    echo "It will also ask you for recursion depth, \
and if you want to use a referring page."
    echo "Wgetter accepts the following options:"
    echo ""
    echo "-$help : Display this help."
    echo "-$save : Save the command to a file $savePath/wget-($today) \
instead of running it."
    echo "-$runn : Run saved wget commands instead of starting a new one -"
    echo "Enter filename as argument to this option."
    echo "-$inpu : Run saved wget commands interactively --"
    echo "The script will ask you for the filename."
    echo "-$cook : Change the cookies file for this session."
    echo "-$list : Tell wget to use URL's from a list instead of \
from the command-line."
    echo "-$wopt : Pass any other options direct to wget."
    echo ""
    echo "See the wget man page for additional options \
you can pass to wget."
    echo ""

    exit $E_USAGE  # End here. Don't process anything else.
}



list_func() #  Gives the user the option to use the -i option to wget,
            #+ and a list of URLs.
{
while [ 1 ]; do
   echo "Enter the name of the file containing URL's (press q to change
your mind)."
   read urlfile
   if [ ! -e "$urlfile" ] &amp;&amp; [ "$urlfile" != q ]; then
       # Look for a file, or the quit option.
       echo "That file does not exist!"
   elif [ "$urlfile" = q ]; then # Check quit option.
       echo "Not using a url list."
       return
   else
      echo "using $urlfile."
      echo "If you gave url's on the command-line, I'll use those first."
                            # Report wget standard behaviour to the user.
      lister=" -i $urlfile" # This is what we want to pass to wget.
      return
   fi
done
}


cookie_func() # Give the user the option to use a different cookie file.
{
while [ 1 ]; do
   echo "Change the cookies file. Press return if you don't want to change 
it."
   read Cookies
   # NB: this is not the same as Cookie, earlier.
   # There is an 's' on the end.
   # Bit like chocolate chips.
   if [ -z "$Cookies" ]; then                 # Escape clause for wusses.
      return
   elif [ ! -e "$Cookies" ]; then
      echo "File does not exist.  Try again." # Keep em going . . .
   else
       CookiesON=" --load-cookies $Cookies"   # File is good -- use it!
       return
   fi
done
}



run_func()
{
if [ -z "$OPTARG" ]; then
# Test to see if we used the in-line option or the query one.
   if [ ! -d "$savePath" ]; then      # If directory doesn't exist . . .
      echo "$savePath does not appear to exist."
      echo "Please supply path and filename of saved wget commands:"
      read newFile
         until [ -f "$newFile" ]; do  # Keep going till we get something.
            echo "Sorry, that file does not exist.  Please try again."
            # Try really hard to get something.
            read newFile
         done


# -----------------------------------------------------------------------
#       if [ -z ( grep wget ${newfile} ) ]; then
        # Assume they haven't got the right file and bail out.
#       echo "Sorry, that file does not contain wget commands.  Aborting."
#       exit
#       fi
#
# This is bogus code.
# It doesn't actually work.
# If anyone wants to fix it, feel free!
# -----------------------------------------------------------------------


      filePath="${newFile}"
   else
   echo "Save path is $savePath"
     echo "Please enter name of the file which you want to use."
     echo "You have a choice of:"
     ls $savePath                                    # Give them a choice.
     read inFile
       until [ -f "$savePath/$inFile" ]; do         #  Keep going till
                                                    #+ we get something.
          if [ ! -f "${savePath}/${inFile}" ]; then # If file doesn't exist.
             echo "Sorry, that file does not exist.  Please choose from:"
             ls $savePath                           # If a mistake is made.
             read inFile
          fi
         done
      filePath="${savePath}/${inFile}"  # Make one variable . . .
   fi
else filePath="${savePath}/${OPTARG}"   # Which can be many things . . .
fi

if [ ! -f "$filePath" ]; then           # If a bogus file got through.
   echo "You did not specify a suitable file."
   echo "Run this script with the -${save} option first."
   echo "Aborting."
   exit $E_NO_SAVEFILE
fi
echo "Using: $filePath"
while read; do
    eval $REPLY
    echo "Completed: $REPLY"
done &lt; $filePath  # Feed the actual file we are using into a 'while' loop.

exit
}



# Fish out any options we are using for the script.
# This is based on the demo in "Learning The Bash Shell" (O'Reilly).
while getopts ":$save$cook$help$list$runn:$inpu$wopt" opt
do
  case $opt in
     $save) save_func;;   #  Save some wgetter sessions for later.
     $cook) cookie_func;; #  Change cookie file.
     $help) usage;;       #  Get help.
     $list) list_func;;   #  Allow wget to use a list of URLs.
     $runn) run_func;;    #  Useful if you are calling wgetter from,
                          #+ for example, a cron script.
     $inpu) run_func;;    #  When you don't know what your files are named.
     $wopt) wopts;;       #  Pass options directly to wget.
        \?) echo "Not a valid option."
            echo "Use -${wopt} to pass options directly to wget,"
            echo "or -${help} for help";;      # Catch anything else.
  esac
done
shift $((OPTIND - 1))     # Do funky magic stuff with $#.


if [ -z "$1" ] &amp;&amp; [ -z "$lister" ]; then
                          #  We should be left with at least one URL
                          #+ on the command-line, unless a list is 
			  #+ being used -- catch empty CL's.
   echo "No URL's given! You must enter them on the same line as wgetter2."
   echo "E.g.,  wgetter2 http://somesite http://anothersite."
   echo "Use $help option for more information."
   exit $E_NO_URLS        # Bail out, with appropriate error code.
fi

URLS=" $@"
# Use this so that URL list can be changed if we stay in the option loop.

while [ 1 ]; do
   # This is where we ask for the most used options.
   # (Mostly unchanged from version 1 of wgetter)
   if [ -z $curDepth ]; then
      Current=""
   else Current=" Current value is $curDepth"
   fi
       echo "How deep should I go? \
(integer: Default is $depthDefault.$Current)"
       read Depth   # Recursion -- how far should we go?
       inputB=""    # Reset this to blank on each pass of the loop.
       echo "Enter the name of the referring page (default is none)."
       read inputB  # Need this for some sites.

       echo "Do you want to have the output logged to the terminal"
       echo "(y/n, default is yes)?"
       read noHide  # Otherwise wget will just log it to a file.

       case $noHide in    # Now you see me, now you don't.
          y|Y ) hide="";;
          n|N ) hide=" -b";;
            * ) hide="";;
       esac

       if [ -z ${Depth} ]; then
       #  User accepted either default or current depth,
       #+ in which case Depth is now empty.
          if [ -z ${curDepth} ]; then
          #  See if a depth was set on a previous iteration.
             Depth="$depthDefault"
             #  Set the default recursion depth if nothing
             #+ else to use.
          else Depth="$curDepth" #  Otherwise, set the one we used before.
          fi
       fi
   Recurse=" -l $Depth"          # Set how deep we want to go.
   curDepth=$Depth               # Remember setting for next time.

       if [ ! -z $inputB ]; then
          RefA=" --referer=$inputB"   # Option to use referring page.
       fi

   WGETTER="${CommandA}${pattern}${hide}${RefA}${Recurse}\
${CookiesON}${lister}${Woptions}${URLS}"
   #  Just string the whole lot together . . .
   #  NB: no embedded spaces.
   #  They are in the individual elements so that if any are empty,
   #+ we don't get an extra space.

   if [ -z "${CookiesON}" ] &amp;&amp; [ "$cFlag" = "1" ] ; then
       echo "Warning -- can't find cookie file"
       #  This should be changed,
       #+ in case the user has opted to not use cookies.
   fi

   if [ "$Flag" = "S" ]; then
      echo "$WGETTER" &gt;&gt; $savePath/wget-${today}
      #  Create a unique filename for today, or append to it if it exists.
      echo "$inputB" &gt;&gt; $savePath/site-list-${today}
      #  Make a list, so it's easy to refer back to,
      #+ since the whole command is a bit confusing to look at.
      echo "Command saved to the file $savePath/wget-${today}"
           # Tell the user.
      echo "Referring page URL saved to the file$ \
savePath/site-list-${today}"
           # Tell the user.
      Saver=" with save option"
      # Stick this somewhere, so it appears in the loop if set.
   else
       echo "*****************"
       echo "*****Getting*****"
       echo "*****************"
       echo ""
       echo "$WGETTER"
       echo ""
       echo "*****************"
       eval "$WGETTER"
   fi

       echo ""
       echo "Starting over$Saver."
       echo "If you want to stop, press q."
       echo "Otherwise, enter some URL's:"
       # Let them go again. Tell about save option being set.

       read
       case $REPLY in
       # Need to change this to a 'trap' clause.
          q|Q ) exit $E_USER_EXIT;;  # Exercise for the reader?
            * ) URLS=" $REPLY";;
       esac

       echo ""
done


exit 0
</programlisting>
    </example>

    <example xml:id="bashpodder">
      <title>A <firstterm>podcasting</firstterm> script</title>
      <programlisting>#!/bin/bash

#  bashpodder.sh:
#  By Linc 10/1/2004
#  Find the latest script at
#+ http://linc.homeunix.org:8080/scripts/bashpodder
#  Last revision 12/14/2004 - Many Contributors!
#  If you use this and have made improvements or have comments
#+ drop me an email at linc dot fessenden at gmail dot com
#  I'd appreciate it!

# ==&gt;  ABS Guide extra comments.

# ==&gt;  Author of this script has kindly granted permission
# ==&gt;+ for inclusion in ABS Guide.


# ==&gt; ################################################################
# 
# ==&gt; What is "podcasting"?

# ==&gt; It's broadcasting "radio shows" over the Internet.
# ==&gt; These shows can be played on iPods and other music file players.

# ==&gt; This script makes it possible.
# ==&gt; See documentation at the script author's site, above.

# ==&gt; ################################################################


# Make script crontab friendly:
cd $(dirname $0)
# ==&gt; Change to directory where this script lives.

# datadir is the directory you want podcasts saved to:
datadir=$(date +%Y-%m-%d)
# ==&gt; Will create a date-labeled directory, named: YYYY-MM-DD

# Check for and create datadir if necessary:
if test ! -d $datadir
        then
        mkdir $datadir
fi

# Delete any temp file:
rm -f temp.log

#  Read the bp.conf file and wget any url not already
#+ in the podcast.log file:
while read podcast
  do # ==&gt; Main action follows.
  file=$(wget -q $podcast -O - | tr '\r' '\n' | tr \' \" | \
sed -n 's/.*url="\([^"]*\)".*/\1/p')
  for url in $file
                do
                echo $url &gt;&gt; temp.log
                if ! grep "$url" podcast.log &gt; /dev/null
                        then
                        wget -q -P $datadir "$url"
                fi
                done
    done &lt; bp.conf

# Move dynamically created log file to permanent log file:
cat podcast.log &gt;&gt; temp.log
sort temp.log | uniq &gt; podcast.log
rm temp.log
# Create an m3u playlist:
ls $datadir | grep -v m3u &gt; $datadir/podcast.m3u


exit 0

#################################################
For a different scripting approach to Podcasting,
see Phil Salkie's article, 
"Internet Radio to Podcast with Shell Tools"
in the September, 2005 issue of LINUX JOURNAL,
http://www.linuxjournal.com/article/8171
#################################################
</programlisting>
    </example>

    <example xml:id="nightlybackup">
      <title>Nightly backup to a firewire HD</title>
      <programlisting>#!/bin/bash
# nightly-backup.sh
# http://www.richardneill.org/source.php#nightly-backup-rsync
# Copyright (c) 2005 Richard Neill &lt;backup@richardneill.org&gt;.
# This is Free Software licensed under the GNU GPL.
# ==&gt; Included in ABS Guide with script author's kind permission.
# ==&gt; (Thanks!)

#  This does a backup from the host computer to a locally connected
#+ firewire HDD using rsync and ssh.
#  (Script should work with USB-connected device (see lines 40-43).
#  It then rotates the backups.
#  Run it via cron every night at 5am.
#  This only backs up the home directory.
#  If ownerships (other than the user's) should be preserved,
#+ then run the rsync process as root (and re-instate the -o).
#  We save every day for 7 days, then every week for 4 weeks,
#+ then every month for 3 months.

#  See: http://www.mikerubel.org/computers/rsync_snapshots/
#+ for more explanation of the theory.
#  Save as: $HOME/bin/nightly-backup_firewire-hdd.sh

#  Known bugs:
#  ----------
#  i)  Ideally, we want to exclude ~/.tmp and the browser caches.

#  ii) If the user is sitting at the computer at 5am,
#+     and files are modified while the rsync is occurring,
#+     then the BACKUP_JUSTINCASE branch gets triggered.
#      To some extent, this is a 
#+     feature, but it also causes a "disk-space leak".





##### BEGIN CONFIGURATION SECTION ############################################
LOCAL_USER=rjn                # User whose home directory should be backed up.
MOUNT_POINT=/backup           # Mountpoint of backup drive.
                              # NO trailing slash!
                              # This must be unique (eg using a udev symlink)
# MOUNT_POINT=/media/disk     # For USB-connected device.
SOURCE_DIR=/home/$LOCAL_USER  # NO trailing slash - it DOES matter to rsync.
BACKUP_DEST_DIR=$MOUNT_POINT/backup/`hostname -s`.${LOCAL_USER}.nightly_backup
DRY_RUN=false                 #If true, invoke rsync with -n, to do a dry run.
                              # Comment out or set to false for normal use.
VERBOSE=false                 # If true, make rsync verbose.
                              # Comment out or set to false otherwise.
COMPRESS=false                # If true, compress.
                              # Good for internet, bad on LAN.
                              # Comment out or set to false otherwise.

### Exit Codes ###
E_VARS_NOT_SET=64
E_COMMANDLINE=65
E_MOUNT_FAIL=70
E_NOSOURCEDIR=71
E_UNMOUNTED=72
E_BACKUP=73
##### END CONFIGURATION SECTION ##############################################


# Check that all the important variables have been set:
if [ -z "$LOCAL_USER" ] ||
   [ -z "$SOURCE_DIR" ] ||
   [ -z "$MOUNT_POINT" ]  ||
   [ -z "$BACKUP_DEST_DIR" ]
then
   echo 'One of the variables is not set! Edit the file: $0. BACKUP FAILED.'
   exit $E_VARS_NOT_SET
fi

if [ "$#" != 0 ]  # If command-line param(s) . . .
then              # Here document(ation).
  cat &lt;&lt;-ENDOFTEXT
    Automatic Nightly backup run from cron.
    Read the source for more details: $0
    The backup directory is $BACKUP_DEST_DIR .
    It will be created if necessary; initialisation is no longer required.

    WARNING: Contents of $BACKUP_DEST_DIR are rotated.
    Directories named 'backup.\$i' will eventually be DELETED.
    We keep backups from every day for 7 days (1-8),
    then every week for 4 weeks (9-12),
    then every month for 3 months (13-15).

    You may wish to add this to your crontab using 'crontab -e'
    #  Back up files: $SOURCE_DIR to $BACKUP_DEST_DIR
    #+ every night at 3:15 am
         15 03 * * * /home/$LOCAL_USER/bin/nightly-backup_firewire-hdd.sh

    Don't forget to verify the backups are working,
    especially if you don't read cron's mail!"
	ENDOFTEXT
   exit $E_COMMANDLINE
fi


# Parse the options.
# ==================

if [ "$DRY_RUN" == "true" ]; then
  DRY_RUN="-n"
  echo "WARNING:"
  echo "THIS IS A 'DRY RUN'!"
  echo "No data will actually be transferred!"
else
  DRY_RUN=""
fi

if [ "$VERBOSE" == "true" ]; then
  VERBOSE="-v"
else
  VERBOSE=""
fi

if [ "$COMPRESS" == "true" ]; then
  COMPRESS="-z"
else
  COMPRESS=""
fi


#  Every week (actually of 8 days) and every month,
#+ extra backups are preserved.
DAY_OF_MONTH=`date +%d`            # Day of month (01..31).
if [ $DAY_OF_MONTH = 01 ]; then    # First of month.
  MONTHSTART=true
elif [ $DAY_OF_MONTH = 08 \
    -o $DAY_OF_MONTH = 16 \
    -o $DAY_OF_MONTH = 24 ]; then
    # Day 8,16,24  (use 8, not 7 to better handle 31-day months)
      WEEKSTART=true
fi



#  Check that the HDD is mounted.
#  At least, check that *something* is mounted here!
#  We can use something unique to the device, rather than just guessing
#+ the scsi-id by having an appropriate udev rule in
#+ /etc/udev/rules.d/10-rules.local
#+ and by putting a relevant entry in /etc/fstab.
#  Eg: this udev rule:
# BUS="scsi", KERNEL="sd*", SYSFS{vendor}="WDC WD16",
# SYSFS{model}="00JB-00GVA0     ", NAME="%k", SYMLINK="lacie_1394d%n"

if mount | grep $MOUNT_POINT &gt;/dev/null; then
  echo "Mount point $MOUNT_POINT is indeed mounted. OK"
else
  echo -n "Attempting to mount $MOUNT_POINT..."	
           # If it isn't mounted, try to mount it.
  sudo mount $MOUNT_POINT 2&gt;/dev/null

  if mount | grep $MOUNT_POINT &gt;/dev/null; then
    UNMOUNT_LATER=TRUE
    echo "OK"
    #  Note: Ensure that this is also unmounted
    #+ if we exit prematurely with failure.
  else
    echo "FAILED"
    echo -e "Nothing is mounted at $MOUNT_POINT. BACKUP FAILED!"
    exit $E_MOUNT_FAIL
  fi
fi


# Check that source dir exists and is readable.
if [ ! -r  $SOURCE_DIR ] ; then
  echo "$SOURCE_DIR does not exist, or cannot be read. BACKUP FAILED."
  exit $E_NOSOURCEDIR
fi


# Check that the backup directory structure is as it should be.
# If not, create it.
# Create the subdirectories.
# Note that backup.0 will be created as needed by rsync.

for ((i=1;i&lt;=15;i++)); do
  if [ ! -d $BACKUP_DEST_DIR/backup.$i ]; then
    if /bin/mkdir -p $BACKUP_DEST_DIR/backup.$i ; then
    #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  No [ ] test brackets. Why?
      echo "Warning: directory $BACKUP_DEST_DIR/backup.$i is missing,"
      echo "or was not initialised. (Re-)creating it."
    else
      echo "ERROR: directory $BACKUP_DEST_DIR/backup.$i"
      echo "is missing and could not be created."
    if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
        # Before we exit, unmount the mount point if necessary.
        cd
	sudo umount $MOUNT_POINT &amp;&amp;
	echo "Unmounted $MOUNT_POINT again. Giving up."
    fi
      exit $E_UNMOUNTED
  fi
fi
done


#  Set the permission to 700 for security
#+ on an otherwise permissive multi-user system.
if ! /bin/chmod 700 $BACKUP_DEST_DIR ; then
  echo "ERROR: Could not set permissions on $BACKUP_DEST_DIR to 700."

  if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
  # Before we exit, unmount the mount point if necessary.
     cd ; sudo umount $MOUNT_POINT \
     &amp;&amp; echo "Unmounted $MOUNT_POINT again. Giving up."
  fi

  exit $E_UNMOUNTED
fi

# Create the symlink: current -&gt; backup.1 if required.
# A failure here is not critical.
cd $BACKUP_DEST_DIR
if [ ! -h current ] ; then
  if ! /bin/ln -s backup.1 current ; then
    echo "WARNING: could not create symlink current -&gt; backup.1"
  fi
fi


# Now, do the rsync.
echo "Now doing backup with rsync..."
echo "Source dir: $SOURCE_DIR"
echo -e "Backup destination dir: $BACKUP_DEST_DIR\n"


/usr/bin/rsync $DRY_RUN $VERBOSE -a -S --delete --modify-window=60 \
--link-dest=../backup.1 $SOURCE_DIR $BACKUP_DEST_DIR/backup.0/

#  Only warn, rather than exit if the rsync failed,
#+ since it may only be a minor problem.
#  E.g., if one file is not readable, rsync will fail.
#  This shouldn't prevent the rotation.
#  Not using, e.g., `date +%a`  since these directories
#+ are just full of links and don't consume *that much* space.

if [ $? != 0 ]; then
  BACKUP_JUSTINCASE=backup.`date +%F_%T`.justincase
  echo "WARNING: the rsync process did not entirely succeed."
  echo "Something might be wrong."
  echo "Saving an extra copy at: $BACKUP_JUSTINCASE"
  echo "WARNING: if this occurs regularly, a LOT of space will be consumed,"
  echo "even though these are just hard-links!"
fi

# Save a readme in the backup parent directory.
# Save another one in the recent subdirectory.
echo "Backup of $SOURCE_DIR on `hostname` was last run on \
`date`" &gt; $BACKUP_DEST_DIR/README.txt
echo "This backup of $SOURCE_DIR on `hostname` was created on \
`date`" &gt; $BACKUP_DEST_DIR/backup.0/README.txt

# If we are not in a dry run, rotate the backups.
[ -z "$DRY_RUN" ] &amp;&amp;

  #  Check how full the backup disk is.
  #  Warn if 90%. if 98% or more, we'll probably fail, so give up.
  #  (Note: df can output to more than one line.)
  #  We test this here, rather than before
  #+ so that rsync may possibly have a chance.
  DISK_FULL_PERCENT=`/bin/df $BACKUP_DEST_DIR |
  tr "\n" ' ' | awk '{print $12}' | grep -oE [0-9]+ `
  echo "Disk space check on backup partition \
  $MOUNT_POINT $DISK_FULL_PERCENT% full."
  if [ $DISK_FULL_PERCENT -gt 90 ]; then
    echo "Warning: Disk is greater than 90% full."
  fi
  if [ $DISK_FULL_PERCENT -gt 98 ]; then
    echo "Error: Disk is full! Giving up."
      if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
        # Before we exit, unmount the mount point if necessary.
        cd; sudo umount $MOUNT_POINT &amp;&amp;
        echo "Unmounted $MOUNT_POINT again. Giving up."
      fi
    exit $E_UNMOUNTED
  fi


 # Create an extra backup.
 # If this copy fails, give up.
 if [ -n "$BACKUP_JUSTINCASE" ]; then
   if ! /bin/cp -al $BACKUP_DEST_DIR/backup.0 \
      $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE
   then
     echo "ERROR: Failed to create extra copy \
     $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE"
     if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
       # Before we exit, unmount the mount point if necessary.
       cd ;sudo umount $MOUNT_POINT &amp;&amp;
       echo "Unmounted $MOUNT_POINT again. Giving up."
     fi
     exit $E_UNMOUNTED
   fi
 fi


 # At start of month, rotate the oldest 8.
 if [ "$MONTHSTART" == "true" ]; then
   echo -e "\nStart of month. \
   Removing oldest backup: $BACKUP_DEST_DIR/backup.15"  &amp;&amp;
   /bin/rm -rf  $BACKUP_DEST_DIR/backup.15  &amp;&amp;
   echo "Rotating monthly,weekly backups: \
   $BACKUP_DEST_DIR/backup.[8-14] -&gt; $BACKUP_DEST_DIR/backup.[9-15]"  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.14 $BACKUP_DEST_DIR/backup.15  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.13 $BACKUP_DEST_DIR/backup.14  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.12 $BACKUP_DEST_DIR/backup.13  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9

 # At start of week, rotate the second-oldest 4.
 elif [ "$WEEKSTART" == "true" ]; then
   echo -e "\nStart of week. \
   Removing oldest weekly backup: $BACKUP_DEST_DIR/backup.12"  &amp;&amp;
   /bin/rm -rf  $BACKUP_DEST_DIR/backup.12  &amp;&amp;

   echo "Rotating weekly backups: \
   $BACKUP_DEST_DIR/backup.[8-11] -&gt; $BACKUP_DEST_DIR/backup.[9-12]"  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9

 else
   echo -e "\nRemoving oldest daily backup: $BACKUP_DEST_DIR/backup.8"  &amp;&amp;
     /bin/rm -rf  $BACKUP_DEST_DIR/backup.8

 fi  &amp;&amp;

 # Every day, rotate the newest 8.
 echo "Rotating daily backups: \
 $BACKUP_DEST_DIR/backup.[1-7] -&gt; $BACKUP_DEST_DIR/backup.[2-8]"  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.7 $BACKUP_DEST_DIR/backup.8  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.6 $BACKUP_DEST_DIR/backup.7  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.5 $BACKUP_DEST_DIR/backup.6  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.4 $BACKUP_DEST_DIR/backup.5  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.3 $BACKUP_DEST_DIR/backup.4  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.2 $BACKUP_DEST_DIR/backup.3  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.1 $BACKUP_DEST_DIR/backup.2  &amp;&amp;
     /bin/mv $BACKUP_DEST_DIR/backup.0 $BACKUP_DEST_DIR/backup.1  &amp;&amp;

 SUCCESS=true


if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
  # Unmount the mount point if it wasn't mounted to begin with.
  cd ; sudo umount $MOUNT_POINT &amp;&amp; echo "Unmounted $MOUNT_POINT again."
fi


if [ "$SUCCESS" == "true" ]; then
  echo 'SUCCESS!'
  exit 0
fi

# Should have already exited if backup worked.
echo 'BACKUP FAILED! Is this just a dry run? Is the disk full?) '
exit $E_BACKUP
</programlisting>
    </example>

    <example xml:id="cdll">
      <title>An expanded <firstterm>cd</firstterm> command</title>
      <programlisting>###########################################################################
#
#       cdll
#       by Phil Braham
#
#       ############################################
#       Latest version of this script available from
#       http://freshmeat.net/projects/cd/
#       ############################################
#
#       .cd_new
#
#       An enhancement of the Unix cd command
#
#       There are unlimited stack entries and special entries. The stack
#       entries keep the last cd_maxhistory
#       directories that have been used. The special entries can be
#       assigned to commonly used directories.
#
#       The special entries may be pre-assigned by setting the environment
#       variables CDSn or by using the -u or -U command.
#
#       The following is a suggestion for the .profile file:
#
#               . cdll              #  Set up the cd command
#       alias cd='cd_new'           #  Replace the cd command
#               cd -U               #  Upload pre-assigned entries for
#                                   #+ the stack and special entries
#               cd -D               #  Set non-default mode
#               alias @="cd_new @"  #  Allow @ to be used to get history
#
#       For help type:
#
#               cd -h or
#               cd -H
#
#
###########################################################################
#
#       Version 1.2.1
#
#       Written by Phil Braham - Realtime Software Pty Ltd
#       (realtime@mpx.com.au)
#       Please send any suggestions or enhancements to the author (also at
#       phil@braham.net)
#
############################################################################

cd_hm ()
{
        ${PRINTF} "%s" "cd [dir] [0-9] [@[s|h] [-g [&lt;dir&gt;]] [-d] \
[-D] [-r&lt;n&gt;] [dir|0-9] [-R&lt;n&gt;] [&lt;dir&gt;|0-9]
   [-s&lt;n&gt;] [-S&lt;n&gt;] [-u] [-U] [-f] [-F] [-h] [-H] [-v]
    &lt;dir&gt; Go to directory
    0-n         Go to previous directory (0 is previous, 1 is last but 1 etc)
                n is up to max history (default is 50)
    @           List history and special entries
    @h          List history entries
    @s          List special entries
    -g [&lt;dir&gt;]  Go to literal name (bypass special names)
                This is to allow access to dirs called '0','1','-h' etc
    -d          Change default action - verbose. (See note)
    -D          Change default action - silent. (See note)
    -s&lt;n&gt; Go to the special entry &lt;n&gt;*
    -S&lt;n&gt; Go to the special entry &lt;n&gt;
                and replace it with the current dir*
    -r&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;
                              and then put it on special entry &lt;n&gt;*
    -R&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;
                              and put current dir on special entry &lt;n&gt;*
    -a&lt;n&gt;       Alternative suggested directory. See note below.
    -f [&lt;file&gt;] File entries to &lt;file&gt;.
    -u [&lt;file&gt;] Update entries from &lt;file&gt;.
                If no filename supplied then default file
                (${CDPath}${2:-"$CDFile"}) is used
                -F and -U are silent versions
    -v          Print version number
    -h          Help
    -H          Detailed help

    *The special entries (0 - 9) are held until log off, replaced by another
     entry or updated with the -u command

    Alternative suggested directories:
    If a directory is not found then CD will suggest any
    possibilities. These are directories starting with the same letters
    and if any are found they are listed prefixed with -a&lt;n&gt;
    where &lt;n&gt; is a number.
    It's possible to go to the directory by entering cd -a&lt;n&gt;
    on the command line.
    
    The directory for -r&lt;n&gt; or -R&lt;n&gt; may be a number.
    For example:
        $ cd -r3 4  Go to history entry 4 and put it on special entry 3
        $ cd -R3 4  Put current dir on the special entry 3
                    and go to history entry 4
        $ cd -s3    Go to special entry 3
    
    Note that commands R,r,S and s may be used without a number
    and refer to 0:
        $ cd -s     Go to special entry 0
        $ cd -S     Go to special entry 0 and make special
                    entry 0 current dir
        $ cd -r 1   Go to history entry 1 and put it on special entry 0
        $ cd -r     Go to history entry 0 and put it on special entry 0
    "
        if ${TEST} "$CD_MODE" = "PREV"
        then
                ${PRINTF} "$cd_mnset"
        else
                ${PRINTF} "$cd_mset"
        fi
}

cd_Hm ()
{
        cd_hm
        ${PRINTF} "%s" "
        The previous directories (0-$cd_maxhistory) are stored in the
        environment variables CD[0] - CD[$cd_maxhistory]
        Similarly the special directories S0 - $cd_maxspecial are in
        the environment variable CDS[0] - CDS[$cd_maxspecial]
        and may be accessed from the command line

        The default pathname for the -f and -u commands is $CDPath
        The default filename for the -f and -u commands is $CDFile

        Set the following environment variables:
            CDL_PROMPTLEN  - Set to the length of prompt you require.
                Prompt string is set to the right characters of the
                current directory.
                If not set then prompt is left unchanged
            CDL_PROMPT_PRE - Set to the string to prefix the prompt.
                Default is:
                    non-root:  \"\\[\\e[01;34m\\]\"  (sets colour to blue).
                    root:      \"\\[\\e[01;31m\\]\"  (sets colour to red).
            CDL_PROMPT_POST    - Set to the string to suffix the prompt.
                Default is:
                    non-root:  \"\\[\\e[00m\\]$\"
                                (resets colour and displays $).
                    root:      \"\\[\\e[00m\\]#\"
                                (resets colour and displays #).
            CDPath - Set the default path for the -f &amp; -u options.
                     Default is home directory
            CDFile - Set the default filename for the -f &amp; -u options.
                     Default is cdfile
        
"
    cd_version

}

cd_version ()
{
 printf "Version: ${VERSION_MAJOR}.${VERSION_MINOR} Date: ${VERSION_DATE}\n"
}

#
# Truncate right.
#
# params:
#   p1 - string
#   p2 - length to truncate to
#
# returns string in tcd
#
cd_right_trunc ()
{
    local tlen=${2}
    local plen=${#1}
    local str="${1}"
    local diff
    local filler="&lt;--"
    if ${TEST} ${plen} -le ${tlen}
    then
        tcd="${str}"
    else
        let diff=${plen}-${tlen}
        elen=3
        if ${TEST} ${diff} -le 2
        then
            let elen=${diff}
        fi
        tlen=-${tlen}
        let tlen=${tlen}+${elen}
        tcd=${filler:0:elen}${str:tlen}
    fi
}

#
# Three versions of do history:
#    cd_dohistory  - packs history and specials side by side
#    cd_dohistoryH - Shows only hstory
#    cd_dohistoryS - Shows only specials
#
cd_dohistory ()
{
    cd_getrc
        ${PRINTF} "History:\n"
    local -i count=${cd_histcount}
    while ${TEST} ${count} -ge 0
    do
        cd_right_trunc "${CD[count]}" ${cd_lchar}
            ${PRINTF} "%2d %-${cd_lchar}.${cd_lchar}s " ${count} "${tcd}"

        cd_right_trunc "${CDS[count]}" ${cd_rchar}
            ${PRINTF} "S%d %-${cd_rchar}.${cd_rchar}s\n" ${count} "${tcd}"
        count=${count}-1
    done
}

cd_dohistoryH ()
{
    cd_getrc
        ${PRINTF} "History:\n"
        local -i count=${cd_maxhistory}
        while ${TEST} ${count} -ge 0
        do
          ${PRINTF} "${count} %-${cd_flchar}.${cd_flchar}s\n" ${CD[$count]}
          count=${count}-1
        done
}

cd_dohistoryS ()
{
    cd_getrc
        ${PRINTF} "Specials:\n"
        local -i count=${cd_maxspecial}
        while ${TEST} ${count} -ge 0
        do
          ${PRINTF} "S${count} %-${cd_flchar}.${cd_flchar}s\n" ${CDS[$count]}
          count=${count}-1
        done
}

cd_getrc ()
{
    cd_flchar=$(stty -a | awk -F \;
    '/rows/ { print $2 $3 }' | awk -F \  '{ print $4 }')
    if ${TEST} ${cd_flchar} -ne 0
    then
        cd_lchar=${cd_flchar}/2-5
        cd_rchar=${cd_flchar}/2-5
            cd_flchar=${cd_flchar}-5
    else
            cd_flchar=${FLCHAR:=75}
	    # cd_flchar is used for the @s &amp; @h history
            cd_lchar=${LCHAR:=35}
            cd_rchar=${RCHAR:=35}
    fi
}

cd_doselection ()
{
        local -i nm=0
        cd_doflag="TRUE"
        if ${TEST} "${CD_MODE}" = "PREV"
        then
                if ${TEST} -z "$cd_npwd"
                then
                        cd_npwd=0
                fi
        fi
        tm=$(echo "${cd_npwd}" | cut -b 1)
    if ${TEST} "${tm}" = "-"
    then
        pm=$(echo "${cd_npwd}" | cut -b 2)
        nm=$(echo "${cd_npwd}" | cut -d $pm -f2)
        case "${pm}" in
             a) cd_npwd=${cd_sugg[$nm]} ;;
             s) cd_npwd="${CDS[$nm]}" ;;
             S) cd_npwd="${CDS[$nm]}" ; CDS[$nm]=`pwd` ;;
             r) cd_npwd="$2" ; cd_specDir=$nm ; cd_doselection "$1" "$2";;
             R) cd_npwd="$2" ; CDS[$nm]=`pwd` ; cd_doselection "$1" "$2";;
        esac
    fi

    if ${TEST} "${cd_npwd}" != "." -a "${cd_npwd}" \
!= ".." -a "${cd_npwd}" -le ${cd_maxhistory} &gt;&gt;/dev/null 2&gt;&amp;1
    then
      cd_npwd=${CD[$cd_npwd]}
     else
       case "$cd_npwd" in
                @)  cd_dohistory ; cd_doflag="FALSE" ;;
               @h) cd_dohistoryH ; cd_doflag="FALSE" ;;
               @s) cd_dohistoryS ; cd_doflag="FALSE" ;;
               -h) cd_hm ; cd_doflag="FALSE" ;;
               -H) cd_Hm ; cd_doflag="FALSE" ;;
               -f) cd_fsave "SHOW" $2 ; cd_doflag="FALSE" ;;
               -u) cd_upload "SHOW" $2 ; cd_doflag="FALSE" ;;
               -F) cd_fsave "NOSHOW" $2 ; cd_doflag="FALSE" ;;
               -U) cd_upload "NOSHOW" $2 ; cd_doflag="FALSE" ;;
               -g) cd_npwd="$2" ;;
               -d) cd_chdefm 1; cd_doflag="FALSE" ;;
               -D) cd_chdefm 0; cd_doflag="FALSE" ;;
               -r) cd_npwd="$2" ; cd_specDir=0 ; cd_doselection "$1" "$2";;
               -R) cd_npwd="$2" ; CDS[0]=`pwd` ; cd_doselection "$1" "$2";;
               -s) cd_npwd="${CDS[0]}" ;;
               -S) cd_npwd="${CDS[0]}"  ; CDS[0]=`pwd` ;;
               -v) cd_version ; cd_doflag="FALSE";;
       esac
    fi
}

cd_chdefm ()
{
        if ${TEST} "${CD_MODE}" = "PREV"
        then
                CD_MODE=""
                if ${TEST} $1 -eq 1
                then
                        ${PRINTF} "${cd_mset}"
                fi
        else
                CD_MODE="PREV"
                if ${TEST} $1 -eq 1
                then
                        ${PRINTF} "${cd_mnset}"
                fi
        fi
}

cd_fsave ()
{
        local sfile=${CDPath}${2:-"$CDFile"}
        if ${TEST} "$1" = "SHOW"
        then
                ${PRINTF} "Saved to %s\n" $sfile
        fi
        ${RM} -f ${sfile}
        local -i count=0
        while ${TEST} ${count} -le ${cd_maxhistory}
        do
                echo "CD[$count]=\"${CD[$count]}\"" &gt;&gt; ${sfile}
                count=${count}+1
        done
        count=0
        while ${TEST} ${count} -le ${cd_maxspecial}
        do
                echo "CDS[$count]=\"${CDS[$count]}\"" &gt;&gt; ${sfile}
                count=${count}+1
        done
}

cd_upload ()
{
        local sfile=${CDPath}${2:-"$CDFile"}
        if ${TEST} "${1}" = "SHOW"
        then
                ${PRINTF} "Loading from %s\n" ${sfile}
        fi
        . ${sfile}
}

cd_new ()
{
    local -i count
    local -i choose=0

        cd_npwd="${1}"
        cd_specDir=-1
        cd_doselection "${1}" "${2}"

        if ${TEST} ${cd_doflag} = "TRUE"
        then
                if ${TEST} "${CD[0]}" != "`pwd`"
                then
                        count=$cd_maxhistory
                        while ${TEST} $count -gt 0
                        do
                                CD[$count]=${CD[$count-1]}
                                count=${count}-1
                        done
                        CD[0]=`pwd`
                fi
                command cd "${cd_npwd}" 2&gt;/dev/null
        if ${TEST} $? -eq 1
        then
            ${PRINTF} "Unknown dir: %s\n" "${cd_npwd}"
            local -i ftflag=0
            for i in "${cd_npwd}"*
            do
                if ${TEST} -d "${i}"
                then
                    if ${TEST} ${ftflag} -eq 0
                    then
                        ${PRINTF} "Suggest:\n"
                        ftflag=1
                fi
                    ${PRINTF} "\t-a${choose} %s\n" "$i"
                                        cd_sugg[$choose]="${i}"
                    choose=${choose}+1
        fi
            done
        fi
        fi

        if ${TEST} ${cd_specDir} -ne -1
        then
                CDS[${cd_specDir}]=`pwd`
        fi

        if ${TEST} ! -z "${CDL_PROMPTLEN}"
        then
        cd_right_trunc "${PWD}" ${CDL_PROMPTLEN}
            cd_rp=${CDL_PROMPT_PRE}${tcd}${CDL_PROMPT_POST}
                export PS1="$(echo -ne ${cd_rp})"
        fi
}
#########################################################################
#                                                                       #
#                        Initialisation here                            #
#                                                                       #
#########################################################################
#
VERSION_MAJOR="1"
VERSION_MINOR="2.1"
VERSION_DATE="24-MAY-2003"
#
alias cd=cd_new
#
# Set up commands
RM=/bin/rm
TEST=test
PRINTF=printf              # Use builtin printf

#########################################################################
#                                                                       #
# Change this to modify the default pre- and post prompt strings.       #
# These only come into effect if CDL_PROMPTLEN is set.                  #
#                                                                       #
#########################################################################
if ${TEST} ${EUID} -eq 0
then
#   CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="$HOSTNAME@"}
    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="\\[\\e[01;31m\\]"}  # Root is in red
    CDL_PROMPT_POST=${CDL_PROMPT_POST:="\\[\\e[00m\\]#"}
else
    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="\\[\\e[01;34m\\]"}  # Users in blue
    CDL_PROMPT_POST=${CDL_PROMPT_POST:="\\[\\e[00m\\]$"}
fi
#########################################################################
#
# cd_maxhistory defines the max number of history entries allowed.
typeset -i cd_maxhistory=50

#########################################################################
#
# cd_maxspecial defines the number of special entries.
typeset -i cd_maxspecial=9
#
#
#########################################################################
#
#  cd_histcount defines the number of entries displayed in
#+ the history command.
typeset -i cd_histcount=9
#
#########################################################################
export CDPath=${HOME}/
#  Change these to use a different                                      #
#+ default path and filename                                            #
export CDFile=${CDFILE:=cdfile}           # for the -u and -f commands  #
#
#########################################################################
                                                                        #
typeset -i cd_lchar cd_rchar cd_flchar
                        #  This is the number of chars to allow for the #
cd_flchar=${FLCHAR:=75} #+ cd_flchar is used for the @s &amp; @h history#

typeset -ax CD CDS
#
cd_mset="\n\tDefault mode is now set - entering cd with no parameters \
has the default action\n\tUse cd -d or -D for cd to go to \
previous directory with no parameters\n"
cd_mnset="\n\tNon-default mode is now set - entering cd with no \
parameters is the same as entering cd 0\n\tUse cd -d or \
-D to change default cd action\n"

# ==================================================================== #



: &lt;&lt;DOCUMENTATION

Written by Phil Braham. Realtime Software Pty Ltd.
Released under GNU license. Free to use. Please pass any modifications
or comments to the author Phil Braham:

realtime@mpx.com.au
=======================================================================

cdll is a replacement for cd and incorporates similar functionality to
the bash pushd and popd commands but is independent of them.

This version of cdll has been tested on Linux using Bash. It will work
on most Linux versions but will probably not work on other shells without
modification.

Introduction
============

cdll allows easy moving about between directories. When changing to a new
directory the current one is automatically put onto a stack. By default
50 entries are kept, but this is configurable. Special directories can be
kept for easy access - by default up to 10, but this is configurable. The
most recent stack entries and the special entries can be easily viewed.

The directory stack and special entries can be saved to, and loaded from,
a file. This allows them to be set up on login, saved before logging out
or changed when moving project to project.

In addition, cdll provides a flexible command prompt facility that allows,
for example, a directory name in colour that is truncated from the left
if it gets too long.


Setting up cdll
===============

Copy cdll to either your local home directory or a central directory
such as /usr/bin (this will require root access).

Copy the file cdfile to your home directory. It will require read and
write access. This a default file that contains a directory stack and
special entries.

To replace the cd command you must add commands to your login script.
The login script is one or more of:

    /etc/profile
    ~/.bash_profile
    ~/.bash_login
    ~/.profile
    ~/.bashrc
    /etc/bash.bashrc.local
    
To setup your login, ~/.bashrc is recommended, for global (and root) setup
add the commands to /etc/bash.bashrc.local
    
To set up on login, add the command:
    . &lt;dir&gt;/cdll
For example if cdll is in your local home directory:
    . ~/cdll
If in /usr/bin then:
    . /usr/bin/cdll

If you want to use this instead of the buitin cd command then add:
    alias cd='cd_new'
We would also recommend the following commands:
    alias @='cd_new @'
    cd -U
    cd -D

If you want to use cdll's prompt facilty then add the following:
    CDL_PROMPTLEN=nn
Where nn is a number described below. Initially 99 would be suitable
number.

Thus the script looks something like this:

    ######################################################################
    # CD Setup
    ######################################################################
    CDL_PROMPTLEN=21        # Allow a prompt length of up to 21 characters
    . /usr/bin/cdll         # Initialise cdll
    alias cd='cd_new'       # Replace the built in cd command
    alias @='cd_new @'      # Allow @ at the prompt to display history
    cd -U                   # Upload directories
    cd -D                   # Set default action to non-posix
    ######################################################################

The full meaning of these commands will become clear later.

There are a couple of caveats. If another program changes the directory
without calling cdll, then the directory won't be put on the stack and
also if the prompt facility is used then this will not be updated. Two
programs that can do this are pushd and popd. To update the prompt and
stack simply enter:

    cd .
    
Note that if the previous entry on the stack is the current directory
then the stack is not updated.

Usage
=====  
cd [dir] [0-9] [@[s|h] [-g &lt;dir&gt;] [-d] [-D] [-r&lt;n&gt;]
   [dir|0-9] [-R&lt;n&gt;] [&lt;dir&gt;|0-9] [-s&lt;n&gt;] [-S&lt;n&gt;]
   [-u] [-U] [-f] [-F] [-h] [-H] [-v]

    &lt;dir&gt;       Go to directory
    0-n         Goto previous directory (0 is previous,
                1 is last but 1, etc.)
                n is up to max history (default is 50)
    @           List history and special entries (Usually available as $ @)
    @h          List history entries
    @s          List special entries
    -g [&lt;dir&gt;]  Go to literal name (bypass special names)
                This is to allow access to dirs called '0','1','-h' etc
    -d          Change default action - verbose. (See note)
    -D          Change default action - silent. (See note)
    -s&lt;n&gt;       Go to the special entry &lt;n&gt;
    -S&lt;n&gt;       Go to the special entry &lt;n&gt;
                      and replace it with the current dir
    -r&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;
                              and then put it on special entry &lt;n&gt;
    -R&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;
                              and put current dir on special entry &lt;n&gt;
    -a&lt;n&gt;       Alternative suggested directory. See note below.
    -f [&lt;file&gt;] File entries to &lt;file&gt;.
    -u [&lt;file&gt;] Update entries from &lt;file&gt;.
                If no filename supplied then default file (~/cdfile) is used
                -F and -U are silent versions
    -v          Print version number
    -h          Help
    -H          Detailed help



Examples
========

These examples assume non-default mode is set (that is, cd with no
parameters will go to the most recent stack directory), that aliases
have been set up for cd and @ as described above and that cd's prompt
facility is active and the prompt length is 21 characters.

    /home/phil$ @
    # List the entries with the @
    History:
    # Output of the @ command
    .....
    # Skipped these entries for brevity
    1 /home/phil/ummdev               S1 /home/phil/perl
    # Most recent two history entries
    0 /home/phil/perl/eg              S0 /home/phil/umm/ummdev
    # and two special entries are shown
    
    /home/phil$ cd /home/phil/utils/Cdll
    # Now change directories
    /home/phil/utils/Cdll$ @
    # Prompt reflects the directory.
    History:
    # New history
    .....   
    1 /home/phil/perl/eg              S1 /home/phil/perl
    # History entry 0 has moved to 1
    0 /home/phil                      S0 /home/phil/umm/ummdev
    # and the most recent has entered
       
To go to a history entry:

    /home/phil/utils/Cdll$ cd 1
    # Go to history entry 1.
    /home/phil/perl/eg$
    # Current directory is now what was 1
    
To go to a special entry:

    /home/phil/perl/eg$ cd -s1
    # Go to special entry 1
    /home/phil/umm/ummdev$
    # Current directory is S1

To go to a directory called, for example, 1:

    /home/phil$ cd -g 1
    # -g ignores the special meaning of 1
    /home/phil/1$
    
To put current directory on the special list as S1:
    cd -r1 .        #  OR
    cd -R1 .        #  These have the same effect if the directory is
                    #+ . (the current directory)

To go to a directory and add it as a special  
  The directory for -r&lt;n&gt; or -R&lt;n&gt; may be a number.
  For example:
        $ cd -r3 4  Go to history entry 4 and put it on special entry 3
        $ cd -R3 4  Put current dir on the special entry 3 and go to
                    history entry 4
        $ cd -s3    Go to special entry 3

    Note that commands R,r,S and s may be used without a number and
    refer to 0:
        $ cd -s     Go to special entry 0
        $ cd -S     Go to special entry 0 and make special entry 0
                    current dir
        $ cd -r 1   Go to history entry 1 and put it on special entry 0
        $ cd -r     Go to history entry 0 and put it on special entry 0


    Alternative suggested directories:

    If a directory is not found, then CD will suggest any
    possibilities. These are directories starting with the same letters
    and if any are found they are listed prefixed with -a&lt;n&gt;
    where &lt;n&gt; is a number. It's possible to go to the directory
    by entering cd -a&lt;n&gt; on the command line.

        Use cd -d or -D to change default cd action. cd -H will show
        current action.

        The history entries (0-n) are stored in the environment variables
        CD[0] - CD[n]
        Similarly the special directories S0 - 9 are in the environment
        variable CDS[0] - CDS[9]
        and may be accessed from the command line, for example:
        
            ls -l ${CDS[3]}
            cat ${CD[8]}/file.txt

        The default pathname for the -f and -u commands is ~
        The default filename for the -f and -u commands is cdfile


Configuration
=============

    The following environment variables can be set:
    
        CDL_PROMPTLEN  - Set to the length of prompt you require.
            Prompt string is set to the right characters of the current
            directory. If not set, then prompt is left unchanged. Note
            that this is the number of characters that the directory is
            shortened to, not the total characters in the prompt.

            CDL_PROMPT_PRE - Set to the string to prefix the prompt.
                Default is:
                    non-root:  "\\[\\e[01;34m\\]"  (sets colour to blue).
                    root:      "\\[\\e[01;31m\\]"  (sets colour to red).

            CDL_PROMPT_POST    - Set to the string to suffix the prompt.
                Default is:
                    non-root:  "\\[\\e[00m\\]$"
                               (resets colour and displays $).
                    root:      "\\[\\e[00m\\]#"
                               (resets colour and displays #).

        Note:
            CDL_PROMPT_PRE &amp; _POST only t

        CDPath - Set the default path for the -f &amp; -u options.
                 Default is home directory
        CDFile - Set the default filename for the -f &amp; -u options.
                 Default is cdfile


    There are three variables defined in the file cdll which control the
    number of entries stored or displayed. They are in the section labeled
    'Initialisation here' towards the end of the file.

        cd_maxhistory       - The number of history entries stored.
                              Default is 50.
        cd_maxspecial       - The number of special entries allowed.
                              Default is 9.
        cd_histcount        - The number of history and special entries
                              displayed. Default is 9.

    Note that cd_maxspecial should be &gt;= cd_histcount to avoid displaying
    special entries that can't be set.


Version: 1.2.1 Date: 24-MAY-2003

DOCUMENTATION
</programlisting>
    </example>

    <example xml:id="soundcardon">
      <title>A soundcard setup script</title>
      <programlisting>#!/bin/bash
# soundcard-on.sh

#  Script author: Mkarcher
#  http://www.thinkwiki.org/wiki  ...
#  /Script_for_configuring_the_CS4239_sound_chip_in_PnP_mode
#  ABS Guide author made minor changes and added comments.
#  Couldn't contact script author to ask for permission to use, but ...
#+ the script was released under the FDL,
#+ so its use here should be both legal and ethical.

#  Sound-via-pnp-script for Thinkpad 600E
#+ and possibly other computers with onboard CS4239/CS4610
#+ that do not work with the PCI driver
#+ and are not recognized by the PnP code of snd-cs4236.
#  Also for some 770-series Thinkpads, such as the 770x.
#  Run as root user, of course.
#
#  These are old and very obsolete laptop computers,
#+ but this particular script is very instructive,
#+ as it shows how to set up and hack device files.



#  Search for sound card pnp device:

for dev in /sys/bus/pnp/devices/*
do
  grep CSC0100 $dev/id &gt; /dev/null &amp;&amp; WSSDEV=$dev
  grep CSC0110 $dev/id &gt; /dev/null &amp;&amp; CTLDEV=$dev
done
# On 770x:
# WSSDEV = /sys/bus/pnp/devices/00:07
# CTLDEV = /sys/bus/pnp/devices/00:06
# These are symbolic links to /sys/devices/pnp0/ ...


#  Activate devices:
#  Thinkpad boots with devices disabled unless "fast boot" is turned off
#+ (in BIOS).

echo activate &gt; $WSSDEV/resources
echo activate &gt; $CTLDEV/resources


# Parse resource settings.

{ read # Discard "state = active" (see below).
  read bla port1
  read bla port2
  read bla port3
  read bla irq
  read bla dma1
  read bla dma2
 # The "bla's" are labels in the first field: "io," "state," etc.
 # These are discarded.

 #  Hack: with PnPBIOS: ports are: port1: WSS, port2:
 #+ OPL, port3: sb (unneeded)
 #       with ACPI-PnP:ports are: port1: OPL, port2: sb, port3: WSS
 #  (ACPI bios seems to be wrong here, the PnP-card-code in snd-cs4236.c
 #+  uses the PnPBIOS port order)
 #  Detect port order using the fixed OPL port as reference.
  if [ ${port2%%-*} = 0x388 ]
 #            ^^^^  Strip out everything following hyphen in port address.
 #                  So, if port1 is 0x530-0x537
 #+                 we're left with 0x530 -- the start address of the port.
 then
   # PnPBIOS: usual order
   port=${port1%%-*}
   oplport=${port2%%-*}
 else
   # ACPI: mixed-up order
   port=${port3%%-*}
   oplport=${port1%%-*}
 fi
 } &lt; $WSSDEV/resources
# To see what's going on here:
# ---------------------------
#   cat /sys/devices/pnp0/00:07/resources
#
#   state = active
#   io 0x530-0x537
#   io 0x388-0x38b
#   io 0x220-0x233
#   irq 5
#   dma 1
#   dma 0
#   ^^^   "bla" labels in first field (discarded). 


{ read # Discard first line, as above.
  read bla port1
  cport=${port1%%-*}
  #            ^^^^
  # Just want _start_ address of port.
} &lt; $CTLDEV/resources


# Load the module:

modprobe --ignore-install snd-cs4236 port=$port cport=$cport\
fm_port=$oplport irq=$irq dma1=$dma1 dma2=$dma2 isapnp=0 index=0
# See the modprobe manpage.

exit $?
</programlisting>
    </example>

    <para><anchor xml:id="findsplit0" /></para>
    <example xml:id="findsplit">
      <title>Locating split paragraphs in a text file</title>
      <programlisting>#!/bin/bash
# find-splitpara.sh
#  Finds split paragraphs in a text file,
#+ and tags the line numbers.


ARGCOUNT=1       # Expect one arg.
OFF=0            # Flag states.
ON=1
E_WRONGARGS=85

file="$1"        # Target filename.
lineno=1         # Line number. Start at 1.
Flag=$OFF        # Blank line flag.

if [ $# -ne "$ARGCOUNT" ]
then
  echo "Usage: `basename $0` FILENAME"
  exit $E_WRONGARGS
fi  

file_read ()     # Scan file for pattern, then print line.
{
while read line
do

  if [[ "$line" =~ ^[a-z] &amp;&amp; $Flag -eq $ON ]]
     then  # Line begins with lowercase character, following blank line.
     echo -n "$lineno::   "
     echo "$line"
  fi


  if [[ "$line" =~ ^$ ]]
     then       #  If blank line,
     Flag=$ON   #+ set flag.
  else
     Flag=$OFF
  fi

  ((lineno++))

done
} &lt; $file  # Redirect file into function's stdin.

file_read


exit $?


# ----------------------------------------------------------------
This is line one of an example paragraph, bla, bla, bla.
This is line two, and line three should follow on next line, but

there is a blank line separating the two parts of the paragraph.
# ----------------------------------------------------------------

Running this script on a file containing the above paragraph
yields:

4::   there is a blank line separating the two parts of the paragraph.


There will be additional output for all the other split paragraphs
in the target file.
</programlisting>
    </example>

    <para><anchor xml:id="insertionsort0" /></para>
    <example xml:id="insertionsort">
      <title>Insertion sort</title>
      <programlisting>#!/bin/bash
# insertion-sort.bash: Insertion sort implementation in Bash
#                      Heavy use of Bash array features:
#+                     (string) slicing, merging, etc
# URL: http://www.lugmen.org.ar/~jjo/jjotip/insertion-sort.bash.d
#+          /insertion-sort.bash.sh
#
# Author: JuanJo Ciarlante &lt;jjo@irrigacion.gov.ar&gt;
# Lightly reformatted by ABS Guide author.
# License: GPLv2
# Used in ABS Guide with author's permission (thanks!).
#
# Test with:   ./insertion-sort.bash -t
# Or:          bash insertion-sort.bash -t
# The following *doesn't* work:
#              sh insertion-sort.bash -t
#  Why not? Hint: which Bash-specific features are disabled
#+ when running a script by 'sh script.sh'?
#
: ${DEBUG:=0}  # Debug, override with:  DEBUG=1 ./scriptname . . .
# Parameter substitution -- set DEBUG to 0 if not previously set.

# Global array: "list"
typeset -a list
# Load whitespace-separated numbers from stdin.
if [ "$1" = "-t" ]; then
DEBUG=1
        read -a list &lt; &lt;( od -Ad -w24 -t u2 /dev/urandom ) # Random list.
#                    ^ ^  process substition
else
        read -a list
fi
numelem=${#list[*]}

#  Shows the list, marking the element whose index is $1
#+ by surrounding it with the two chars passed as $2.
#  Whole line prefixed with $3.
showlist()
  {
  echo "$3"${list[@]:0:$1} ${2:0:1}${list[$1]}${2:1:1} ${list[@]:$1+1};
  }

# Loop _pivot_ -- from second element to end of list.
for(( i=1; i&lt;numelem; i++ )) do
        ((DEBUG))&amp;&amp;showlist i "[]" " "
        # From current _pivot_, back to first element.
        for(( j=i; j; j-- )) do
                # Search for the 1st elem. less than current "pivot" . . .
                [[ "${list[j-1]}" -le "${list[i]}" ]] &amp;&amp; break
        done
	(( i==j )) &amp;&amp; continue ## No insertion was needed for this element.
	# . . . Move list[i] (pivot) to the left of list[j]:
        list=(${list[@]:0:j} ${list[i]} ${list[j]}\
	#         {0,j-1}        {i}       {j}
              ${list[@]:j+1:i-(j+1)} ${list[@]:i+1})
	#         {j+1,i-1}              {i+1,last}
	((DEBUG))&amp;&amp;showlist j "&lt;&gt;" "*"
done


echo
echo  "------"
echo $'Result:\n'${list[@]}

exit $?
</programlisting>
    </example>

    <example xml:id="stddev">
      <title>Standard Deviation</title>
      <programlisting>#!/bin/bash
# sd.sh: Standard Deviation

#  The Standard Deviation indicates how consistent a set of data is.
#  It shows to what extent the individual data points deviate from the
#+ arithmetic mean, i.e., how much they "bounce around" (or cluster).
#  It is essentially the average deviation-distance of the
#+ data points from the mean.

# =========================================================== #
#    To calculate the Standard Deviation:
#
# 1  Find the arithmetic mean (average) of all the data points.
# 2  Subtract each data point from the arithmetic mean,
#    and square that difference.
# 3  Add all of the individual difference-squares in # 2.
# 4  Divide the sum in # 3 by the number of data points.
#    This is known as the "variance."
# 5  The square root of # 4 gives the Standard Deviation.
# =========================================================== #

count=0         # Number of data points; global.
SC=9            # Scale to be used by bc. Nine decimal places.
E_DATAFILE=90   # Data file error.

# ----------------- Set data file ---------------------
if [ ! -z "$1" ]  # Specify filename as cmd-line arg?
then
  datafile="$1" #  ASCII text file,
else            #+ one (numerical) data point per line!
  datafile=sample.dat
fi              #  See example data file, below.

if [ ! -e "$datafile" ]
then
  echo "\""$datafile"\" does not exist!"
  exit $E_DATAFILE
fi
# -----------------------------------------------------


arith_mean ()
{
  local rt=0         # Running total.
  local am=0         # Arithmetic mean.
  local ct=0         # Number of data points.

  while read value   # Read one data point at a time.
  do
    rt=$(echo "scale=$SC; $rt + $value" | bc)
    (( ct++ ))
  done

  am=$(echo "scale=$SC; $rt / $ct" | bc)

  echo $am; return $ct   # This function "returns" TWO values!
  #  Caution: This little trick will not work if $ct &gt; 255!
  #  To handle a larger number of data points,
  #+ simply comment out the "return $ct" above.
} &lt;"$datafile"   # Feed in data file.

sd ()
{
  mean1=$1  # Arithmetic mean (passed to function).
  n=$2      # How many data points.
  sum2=0    # Sum of squared differences ("variance").
  avg2=0    # Average of $sum2.
  sdev=0    # Standard Deviation.

  while read value   # Read one line at a time.
  do
    diff=$(echo "scale=$SC; $mean1 - $value" | bc)
    # Difference between arith. mean and data point.
    dif2=$(echo "scale=$SC; $diff * $diff" | bc) # Squared.
    sum2=$(echo "scale=$SC; $sum2 + $dif2" | bc) # Sum of squares.
  done

    avg2=$(echo "scale=$SC; $sum2 / $n" | bc)  # Avg. of sum of squares.
    sdev=$(echo "scale=$SC; sqrt($avg2)" | bc) # Square root =
    echo $sdev                                 # Standard Deviation.

} &lt;"$datafile"   # Rewinds data file.


# ======================================================= #
mean=$(arith_mean); count=$?   # Two returns from function!
std_dev=$(sd $mean $count)

echo
echo "Number of data points in \""$datafile"\" = $count"
echo "Arithmetic mean (average) = $mean"
echo "Standard Deviation = $std_dev"
echo
# ======================================================= #

exit

#  This script could stand some drastic streamlining,
#+ but not at the cost of reduced legibility, please.


# ++++++++++++++++++++++++++++++++++++++++ #
# A sample data file (sample1.dat):

# 18.35
# 19.0
# 18.88
# 18.91
# 18.64


# $ sh sd.sh sample1.dat

# Number of data points in "sample1.dat" = 5
# Arithmetic mean (average) = 18.756000000
# Standard Deviation = .235338054
# ++++++++++++++++++++++++++++++++++++++++ #
</programlisting>
    </example>

    <example xml:id="padsw">
      <title>A <firstterm>pad</firstterm> file generator for shareware
        authors</title>
      <programlisting>#!/bin/bash
# pad.sh

#######################################################
#               PAD (xml) file creator
#+ Written by Mendel Cooper &lt;thegrendel.abs@gmail.com&gt;.
#+ Released to the Public Domain.
#
#  Generates a "PAD" descriptor file for shareware
#+ packages, according to the specifications
#+ of the ASP.
#  http://www.asp-shareware.org/pad
#######################################################


# Accepts (optional) save filename as a command-line argument.
if [ -n "$1" ]
then
  savefile=$1
else
  savefile=save_file.xml               # Default save_file name.
fi  


# ===== PAD file headers =====
HDR1="&lt;?xml version=\"1.0\" encoding=\"Windows-1252\" ?&gt;"
HDR2="&lt;XML_DIZ_INFO&gt;"
HDR3="&lt;MASTER_PAD_VERSION_INFO&gt;"
HDR4="\t&lt;MASTER_PAD_VERSION&gt;1.15&lt;/MASTER_PAD_VERSION&gt;"
HDR5="\t&lt;MASTER_PAD_INFO&gt;Portable Application Description, or PAD
for short, is a data set that is used by shareware authors to
disseminate information to anyone interested in their software products.
To find out more go to http://www.asp-shareware.org/pad&lt;/MASTER_PAD_INFO&gt;"
HDR6="&lt;/MASTER_PAD_VERSION_INFO&gt;"
# ============================


fill_in ()
{
  if [ -z "$2" ]
  then
    echo -n "$1? "     # Get user input.
  else
    echo -n "$1 $2? "  # Additional query?
  fi  

  read var             # May paste to fill in field.
                       # This shows how flexible "read" can be.

  if [ -z "$var" ]
  then
    echo -e "\t\t&lt;$1 /&gt;" &gt;&gt;$savefile    # Indent with 2 tabs.
    return
  else
    echo -e "\t\t&lt;$1&gt;$var&lt;/$1&gt;" &gt;&gt;$savefile
    return ${#var}     # Return length of input string.
  fi
}    

check_field_length ()  # Check length of program description fields.
{
  # $1 = maximum field length
  # $2 = actual field length
  if [ "$2" -gt "$1" ]
  then
    echo "Warning: Maximum field length of $1 characters exceeded!"
  fi
}  

clear                  # Clear screen.
echo "PAD File Creator"
echo "--- ---- -------"
echo

# Write File Headers to file.
echo $HDR1 &gt;$savefile
echo $HDR2 &gt;&gt;$savefile
echo $HDR3 &gt;&gt;$savefile
echo -e $HDR4 &gt;&gt;$savefile
echo -e $HDR5 &gt;&gt;$savefile
echo $HDR6 &gt;&gt;$savefile


# Company_Info
echo "COMPANY INFO"
CO_HDR="Company_Info"
echo "&lt;$CO_HDR&gt;" &gt;&gt;$savefile

fill_in Company_Name
fill_in Address_1
fill_in Address_2
fill_in City_Town 
fill_in State_Province
fill_in Zip_Postal_Code
fill_in Country

# If applicable:
# fill_in ASP_Member "[Y/N]"
# fill_in ASP_Member_Number
# fill_in ESC_Member "[Y/N]"

fill_in Company_WebSite_URL

clear   # Clear screen between sections.

   # Contact_Info
echo "CONTACT INFO"
CONTACT_HDR="Contact_Info"
echo "&lt;$CONTACT_HDR&gt;" &gt;&gt;$savefile
fill_in Author_First_Name
fill_in Author_Last_Name
fill_in Author_Email
fill_in Contact_First_Name
fill_in Contact_Last_Name
fill_in Contact_Email
echo -e "\t&lt;/$CONTACT_HDR&gt;" &gt;&gt;$savefile
   # END Contact_Info

clear

   # Support_Info
echo "SUPPORT INFO"
SUPPORT_HDR="Support_Info"
echo "&lt;$SUPPORT_HDR&gt;" &gt;&gt;$savefile
fill_in Sales_Email
fill_in Support_Email
fill_in General_Email
fill_in Sales_Phone
fill_in Support_Phone
fill_in General_Phone
fill_in Fax_Phone
echo -e "\t&lt;/$SUPPORT_HDR&gt;" &gt;&gt;$savefile
   # END Support_Info

echo "&lt;/$CO_HDR&gt;" &gt;&gt;$savefile
# END Company_Info

clear

# Program_Info 
echo "PROGRAM INFO"
PROGRAM_HDR="Program_Info"
echo "&lt;$PROGRAM_HDR&gt;" &gt;&gt;$savefile
fill_in Program_Name
fill_in Program_Version
fill_in Program_Release_Month
fill_in Program_Release_Day
fill_in Program_Release_Year
fill_in Program_Cost_Dollars
fill_in Program_Cost_Other
fill_in Program_Type "[Shareware/Freeware/GPL]"
fill_in Program_Release_Status "[Beta, Major Upgrade, etc.]"
fill_in Program_Install_Support
fill_in Program_OS_Support "[Win9x/Win2k/Linux/etc.]"
fill_in Program_Language "[English/Spanish/etc.]"

echo; echo

  # File_Info 
echo "FILE INFO"
FILEINFO_HDR="File_Info"
echo "&lt;$FILEINFO_HDR&gt;" &gt;&gt;$savefile
fill_in Filename_Versioned
fill_in Filename_Previous
fill_in Filename_Generic
fill_in Filename_Long
fill_in File_Size_Bytes
fill_in File_Size_K
fill_in File_Size_MB
echo -e "\t&lt;/$FILEINFO_HDR&gt;" &gt;&gt;$savefile
  # END File_Info 

clear

  # Expire_Info 
echo "EXPIRE INFO"
EXPIRE_HDR="Expire_Info"
echo "&lt;$EXPIRE_HDR&gt;" &gt;&gt;$savefile
fill_in Has_Expire_Info "Y/N"
fill_in Expire_Count
fill_in Expire_Based_On
fill_in Expire_Other_Info
fill_in Expire_Month
fill_in Expire_Day
fill_in Expire_Year
echo -e "\t&lt;/$EXPIRE_HDR&gt;" &gt;&gt;$savefile
  # END Expire_Info 

clear

  # More Program_Info
echo "ADDITIONAL PROGRAM INFO"
fill_in Program_Change_Info
fill_in Program_Specific_Category
fill_in Program_Categories
fill_in Includes_JAVA_VM "[Y/N]"
fill_in Includes_VB_Runtime "[Y/N]"
fill_in Includes_DirectX "[Y/N]"
  # END More Program_Info

echo "&lt;/$PROGRAM_HDR&gt;" &gt;&gt;$savefile
# END Program_Info 

clear

# Program Description
echo "PROGRAM DESCRIPTIONS"
PROGDESC_HDR="Program_Descriptions"
echo "&lt;$PROGDESC_HDR&gt;" &gt;&gt;$savefile

LANG="English"
echo "&lt;$LANG&gt;" &gt;&gt;$savefile

fill_in Keywords "[comma + space separated]"
echo
echo "45, 80, 250, 450, 2000 word program descriptions"
echo "(may cut and paste into field)"
#  It would be highly appropriate to compose the following
#+ "Char_Desc" fields with a text editor,
#+ then cut-and-paste the text into the answer fields.
echo
echo "              |---------------45 characters---------------|"
fill_in Char_Desc_45
check_field_length 45 "$?"
echo
fill_in Char_Desc_80
check_field_length 80 "$?"

fill_in Char_Desc_250
check_field_length 250 "$?"

fill_in Char_Desc_450
fill_in Char_Desc_2000

echo "&lt;/$LANG&gt;" &gt;&gt;$savefile
echo "&lt;/$PROGDESC_HDR&gt;" &gt;&gt;$savefile
# END Program Description

clear
echo "Done."; echo; echo
echo "Save file is:  \""$savefile"\""

exit 0
</programlisting>
    </example>

    <example xml:id="maned">
      <title>A <firstterm>man page</firstterm> editor</title>
      <programlisting>#!/bin/bash
# maned.sh
# A rudimentary man page editor

# Version: 0.1 (Alpha, probably buggy)
# Author: Mendel Cooper &lt;thegrendel.abs@gmail.com&gt;
# Reldate: 16 June 2008
# License: GPL3


savefile=      # Global, used in multiple functions.
E_NOINPUT=90   # User input missing (error). May or may not be critical.

# =========== Markup Tags ============ #
TopHeader=".TH"
NameHeader=".SH NAME"
SyntaxHeader=".SH SYNTAX"
SynopsisHeader=".SH SYNOPSIS"
InstallationHeader=".SH INSTALLATION"
DescHeader=".SH DESCRIPTION"
OptHeader=".SH OPTIONS"
FilesHeader=".SH FILES"
EnvHeader=".SH ENVIRONMENT"
AuthHeader=".SH AUTHOR"
BugsHeader=".SH BUGS"
SeeAlsoHeader=".SH SEE ALSO"
BOLD=".B"
# Add more tags, as needed.
# See groff docs for markup meanings.
# ==================================== #

start ()
{
clear                  # Clear screen.
echo "ManEd"
echo "-----"
echo
echo "Simple man page creator"
echo "Author: Mendel Cooper"
echo "License: GPL3"
echo; echo; echo
}

progname ()
{
  echo -n "Program name? "
  read name

  echo -n "Manpage section? [Hit RETURN for default (\"1\") ]  "
  read section
  if [ -z "$section" ]
  then
    section=1   # Most man pages are in section 1.
  fi

  if [ -n "$name" ]
  then
    savefile=""$name"."$section""       #  Filename suffix = section.
    echo -n "$1 " &gt;&gt;$savefile
    name1=$(echo "$name" | tr a-z A-Z)  #  Change to uppercase,
                                        #+ per man page convention.
    echo -n "$name1" &gt;&gt;$savefile
  else
    echo "Error! No input."             # Mandatory input.
    exit $E_NOINPUT                     # Critical!
    #  Exercise: The script-abort if no filename input is a bit clumsy.
    #            Rewrite this section so a default filename is used
    #+           if no input.
  fi

  echo -n "  \"$section\""&gt;&gt;$savefile   # Append, always append.

  echo -n "Version? "
  read ver
  echo -n " \"Version $ver \""&gt;&gt;$savefile
  echo &gt;&gt;$savefile

  echo -n "Short description [0 - 5 words]? "
  read sdesc
  echo "$NameHeader"&gt;&gt;$savefile
  echo ""$BOLD" "$name""&gt;&gt;$savefile
  echo "\- "$sdesc""&gt;&gt;$savefile

}

fill_in ()
{ # This function more or less copied from "pad.sh" script.
  echo -n "$2? "       # Get user input.
  read var             # May paste (a single line only!) to fill in field.

  if [ -n "$var" ]
  then
    echo "$1 " &gt;&gt;$savefile
    echo -n "$var" &gt;&gt;$savefile
  else                 # Don't append empty field to file.
    return $E_NOINPUT  # Not critical here.
  fi

  echo &gt;&gt;$savefile

}    


end ()
{
clear
echo -n "Would you like to view the saved man page (y/n)? "
read ans
if [ "$ans" = "n" -o "$ans" = "N" ]; then exit; fi
exec less "$savefile"  #  Exit script and hand off control to "less" ...
                       #+ ... which formats for viewing man page source.
}


# ---------------------------------------- #
start
progname "$TopHeader"
fill_in "$SynopsisHeader" "Synopsis"
fill_in "$DescHeader" "Long description"
# May paste in *single line* of text.
fill_in "$OptHeader" "Options"
fill_in "$FilesHeader" "Files"
fill_in "$AuthHeader" "Author"
fill_in "$BugsHeader" "Bugs"
fill_in "$SeeAlsoHeader" "See also"
# fill_in "$OtherHeader" ... as necessary.
end    # ... exit not needed.
# ---------------------------------------- #

#  Note that the generated man page will usually
#+ require manual fine-tuning with a text editor.
#  However, it's a distinct improvement upon
#+ writing man source from scratch
#+ or even editing a blank man page template.

#  The main deficiency of the script is that it permits
#+ pasting only a single text line into the input fields.
#  This may be a long, cobbled-together line, which groff
#  will automatically wrap and hyphenate.
#  However, if you want multiple (newline-separated) paragraphs,
#+ these must be inserted by manual text editing on the
#+ script-generated man page.
#  Exercise (difficult): Fix this!

#  This script is not nearly as elaborate as the
#+ full-featured "manedit" package
#+ http://freshmeat.net/projects/manedit/
#+ but it's much easier to use.
</programlisting>
    </example>

    <example xml:id="petals">
      <title>Petals Around the Rose</title>
      <programlisting>#!/bin/bash -i
# petals.sh

#########################################################################
# Petals Around the Rose                                                #
#                                                                       #
# Version 0.1 Created by Serghey Rodin                                  #
# Version 0.2 Modded by ABS Guide Author                                #
#                                                                       #
# License: GPL3                                                         #
# Used in ABS Guide with permission.                                    #
# ##################################################################### #

hits=0      # Correct guesses.
WIN=6       # Mastered the game.
ALMOST=5    # One short of mastery.
EXIT=exit   # Give up early?

RANDOM=$$   # Seeds the random number generator from PID of script.


# Bones (ASCII graphics for dice)
bone1[1]="|         |"
bone1[2]="|       o |"
bone1[3]="|       o |"
bone1[4]="| o     o |"
bone1[5]="| o     o |"
bone1[6]="| o     o |"
bone2[1]="|    o    |"
bone2[2]="|         |"
bone2[3]="|    o    |"
bone2[4]="|         |"
bone2[5]="|    o    |"
bone2[6]="| o     o |"
bone3[1]="|         |"
bone3[2]="| o       |"
bone3[3]="| o       |"
bone3[4]="| o     o |"
bone3[5]="| o     o |"
bone3[6]="| o     o |"
bone="+---------+"



# Functions

instructions () {

  clear
  echo -n "Do you need instructions? (y/n) "; read ans
  if [ "$ans" = "y" -o "$ans" = "Y" ]; then
    clear
    echo -e '\E[34;47m'  # Blue type.

#  "cat document"
    cat &lt;&lt;INSTRUCTIONSZZZ
The name of the game is Petals Around the Rose,
and that name is significant.
Five dice will roll and you must guess the "answer" for each roll.
It will be zero or an even number.
After your guess, you will be told the answer for the roll, but . . .
that's ALL the information you will get.

Six consecutive correct guesses admits you to the
Fellowship of the Rose.
INSTRUCTIONSZZZ

    echo -e "\033[0m"    # Turn off blue.
    else clear
  fi

}


fortune ()
{
  RANGE=7
  FLOOR=0
  number=0
  while [ "$number" -le $FLOOR ]
  do
    number=$RANDOM
    let "number %= $RANGE"   # 1 - 6.
  done

  return $number
}



throw () { # Calculate each individual die.
  fortune; B1=$?
  fortune; B2=$?
  fortune; B3=$?
  fortune; B4=$?
  fortune; B5=$?

  calc () { # Function embedded within a function!
    case "$1" in
       3   ) rose=2;;
       5   ) rose=4;;
       *   ) rose=0;;
    esac    # Simplified algorithm.
            # Doesn't really get to the heart of the matter.
    return $rose
  }

  answer=0
  calc "$B1"; answer=$(expr $answer + $(echo $?))
  calc "$B2"; answer=$(expr $answer + $(echo $?))
  calc "$B3"; answer=$(expr $answer + $(echo $?))
  calc "$B4"; answer=$(expr $answer + $(echo $?))
  calc "$B5"; answer=$(expr $answer + $(echo $?))
}



game ()
{ # Generate graphic display of dice throw.
  throw
    echo -e "\033[1m"    # Bold.
  echo -e "\n"
  echo -e "$bone\t$bone\t$bone\t$bone\t$bone"
  echo -e \
 "${bone1[$B1]}\t${bone1[$B2]}\t${bone1[$B3]}\t${bone1[$B4]}\t${bone1[$B5]}"
  echo -e \
 "${bone2[$B1]}\t${bone2[$B2]}\t${bone2[$B3]}\t${bone2[$B4]}\t${bone2[$B5]}"
  echo -e \
 "${bone3[$B1]}\t${bone3[$B2]}\t${bone3[$B3]}\t${bone3[$B4]}\t${bone3[$B5]}"
  echo -e "$bone\t$bone\t$bone\t$bone\t$bone"
  echo -e "\n\n\t\t"
    echo -e "\033[0m"    # Turn off bold.
  echo -n "There are how many petals around the rose? "
}



# ============================================================== #

instructions

while [ "$petal" != "$EXIT" ]    # Main loop.
do
  game
  read petal
  echo "$petal" | grep [0-9] &gt;/dev/null  # Filter response for digit.
                                         # Otherwise just roll dice again.
  if [ "$?" -eq 0 ]   # If-loop #1.
  then
    if [ "$petal" == "$answer" ]; then    # If-loop #2.
    	echo -e "\nCorrect. There are $petal petals around the rose.\n"
        (( hits++ ))

        if [ "$hits" -eq "$WIN" ]; then   # If-loop #3.
          echo -e '\E[31;47m'  # Red type.
          echo -e "\033[1m"    # Bold.
          echo "You have unraveled the mystery of the Rose Petals!"
          echo "Welcome to the Fellowship of the Rose!!!"
          echo "(You are herewith sworn to secrecy.)"; echo
          echo -e "\033[0m"    # Turn off red &amp; bold.
          break                # Exit!
        else echo "You have $hits correct so far."; echo

        if [ "$hits" -eq "$ALMOST" ]; then
          echo "Just one more gets you to the heart of the mystery!"; echo
        fi

      fi                                  # Close if-loop #3.

    else
      echo -e "\nWrong. There are $answer petals around the rose.\n"
      hits=0   # Reset number of correct guesses.
    fi                                    # Close if-loop #2.

    echo -n "Hit ENTER for the next roll, or type \"exit\" to end. "
    read
    if [ "$REPLY" = "$EXIT" ]; then exit
    fi

  fi                  # Close if-loop #1.

  clear
done                  # End of main (while) loop.

###

exit $?

# Resources:
# ---------
# 1) http://en.wikipedia.org/wiki/Petals_Around_the_Rose
#    (Wikipedia entry.)
# 2) http://www.borrett.id.au/computing/petals-bg.htm
#    (How Bill Gates coped with the Petals Around the Rose challenge.)
</programlisting>
    </example>

    <example xml:id="qky">
      <title>Quacky: a Perquackey-type word game</title>
      <programlisting>#!/bin/bash
# qky.sh

##############################################################
# QUACKEY: a somewhat simplified version of Perquackey [TM]. #
#                                                            #
# Author: Mendel Cooper  &lt;thegrendel.abs@gmail.com&gt;          #
# version 0.1.02      03 May, 2008                           #
# License: GPL3                                              #
##############################################################

WLIST=/usr/share/dict/word.lst
#                     ^^^^^^^^  Word list file found here.
#  ASCII word list, one word per line, UNIX format.
#  A suggested list is the script author's "yawl" word list package.
#  http://bash.deta.in/yawl-0.3.2.tar.gz
#    or
#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz

NONCONS=0     # Word not constructable from letter set.
CONS=1        # Constructable.
SUCCESS=0
NG=1
FAILURE=''
NULL=0        # Zero out value of letter (if found).
MINWLEN=3     # Minimum word length.
MAXCAT=5      # Maximum number of words in a given category.
PENALTY=200   # General-purpose penalty for unacceptable words.
total=
E_DUP=70      # Duplicate word error.

TIMEOUT=10    # Time for word input.

NVLET=10      # 10 letters for non-vulnerable.
VULET=13      # 13 letters for vulnerable (not yet implemented!).

declare -a Words
declare -a Status
declare -a Score=( 0 0 0 0 0 0 0 0 0 0 0 )


letters=( a n s r t m l k p r b c i d s i d z e w u e t f
e y e r e f e g t g h h i t r s c i t i d i j a t a o l a
m n a n o v n w o s e l n o s p a q e e r a b r s a o d s
t g t i t l u e u v n e o x y m r k )
#  Letter distribution table shamelessly borrowed from "Wordy" game,
#+ ca. 1992, written by a certain fine fellow named Mendel Cooper.

declare -a LS

numelements=${#letters[@]}
randseed="$1"

instructions ()
{
  clear
  echo "Welcome to QUACKEY, the anagramming word construction game."; echo
  echo -n "Do you need instructions? (y/n) "; read ans

   if [ "$ans" = "y" -o "$ans" = "Y" ]; then
     clear
     echo -e '\E[31;47m'  # Red foreground. '\E[34;47m' for blue.
     cat &lt;&lt;INSTRUCTION1

QUACKEY is a variant of Perquackey [TM].
The rules are the same, but the scoring is simplified
and plurals of previously played words are allowed.
"Vulnerable" play is not yet implemented,
but it is otherwise feature-complete.

As the game begins, the player gets 10 letters.
The object is to construct valid dictionary words
of at least 3-letter length from the letterset.
Each word-length category
-- 3-letter, 4-letter, 5-letter, ... --
fills up with the fifth word entered,
and no further words in that category are accepted.

The penalty for too-short (two-letter), duplicate, unconstructable,
and invalid (not in dictionary) words is -200. The same penalty applies
to attempts to enter a word in a filled-up category.

INSTRUCTION1

  echo -n "Hit ENTER for next page of instructions. "; read az1

     cat &lt;&lt;INSTRUCTION2

The scoring mostly corresponds to classic Perquackey:
The first 3-letter word scores    60, plus   10 for each additional one.
The first 4-letter word scores   120, plus   20 for each additional one.
The first 5-letter word scores   200, plus   50 for each additional one.
The first 6-letter word scores   300, plus  100 for each additional one.
The first 7-letter word scores   500, plus  150 for each additional one.
The first 8-letter word scores   750, plus  250 for each additional one.
The first 9-letter word scores  1000, plus  500 for each additional one.
The first 10-letter word scores 2000, plus 2000 for each additional one.

Category completion bonuses are:
3-letter words   100
4-letter words   200
5-letter words   400
6-letter words   800
7-letter words  2000
8-letter words 10000
This is a simplification of the absurdly baroque Perquackey bonus
scoring system.

INSTRUCTION2

  echo -n "Hit ENTER for final page of instructions. "; read az1

     cat &lt;&lt;INSTRUCTION3


Hitting just ENTER for a word entry ends the game.

Individual word entry is timed to a maximum of 10 seconds.
*** Timing out on an entry ends the game. ***
Aside from that, the game is untimed.

--------------------------------------------------
Game statistics are automatically saved to a file.
--------------------------------------------------

For competitive ("duplicate") play, a previous letterset
may be duplicated by repeating the script's random seed,
command-line parameter \$1.
For example, "qky 7633" specifies the letterset 
c a d i f r h u s k ...
INSTRUCTION3

  echo; echo -n "Hit ENTER to begin game. "; read az1

       echo -e "\033[0m"    # Turn off red.
     else clear
  fi

  clear

}



seed_random ()
{                         #  Seed random number generator.
  if [ -n "$randseed" ]   #  Can specify random seed.
  then                    #+ for play in competitive mode.
#   RANDOM="$randseed"
    echo "RANDOM seed set to "$randseed""
  else
    randseed="$$"         # Or get random seed from process ID.
    echo "RANDOM seed not specified, set to Process ID of script ($$)."
  fi

  RANDOM="$randseed"

  echo
}


get_letset ()
{
  element=0
  echo -n "Letterset:"

  for lset in $(seq $NVLET)
  do  # Pick random letters to fill out letterset.
    LS[element]="${letters[$((RANDOM%numelements))]}"
    ((element++))
  done

  echo
  echo "${LS[@]}"

}


add_word ()
{
  wrd="$1"
  local idx=0

  Status[0]=""
  Status[3]=""
  Status[4]=""

  while [ "${Words[idx]}" != '' ]
  do
    if [ "${Words[idx]}" = "$wrd" ]
    then
      Status[3]="Duplicate-word-PENALTY"
      let "Score[0]= 0 - $PENALTY"
      let "Score[1]-=$PENALTY"
      return $E_DUP
    fi

    ((idx++))
  done

  Words[idx]="$wrd"
  get_score

}

get_score()
{
  local wlen=0
  local score=0
  local bonus=0
  local first_word=0
  local add_word=0
  local numwords=0

  wlen=${#wrd}
  numwords=${Score[wlen]}
  Score[2]=0
  Status[4]=""   # Initialize "bonus" to 0.

  case "$wlen" in
    3) first_word=60
       add_word=10;;
    4) first_word=120
       add_word=20;;
    5) first_word=200
       add_word=50;;
    6) first_word=300
       add_word=100;;
    7) first_word=500
       add_word=150;;
    8) first_word=750
       add_word=250;;
    9) first_word=1000
       add_word=500;;
   10) first_word=2000
       add_word=2000;;   # This category modified from original rules!
      esac

  ((Score[wlen]++))
  if [ ${Score[wlen]} -eq $MAXCAT ]
  then   # Category completion bonus scoring simplified!
    case $wlen in
      3 ) bonus=100;;
      4 ) bonus=200;;
      5 ) bonus=400;;
      6 ) bonus=800;;
      7 ) bonus=2000;;
      8 ) bonus=10000;;
    esac  # Needn't worry about 9's and 10's.
    Status[4]="Category-$wlen-completion***BONUS***"
    Score[2]=$bonus
  else
    Status[4]=""   # Erase it.
  fi


    let "score =  $first_word +   $add_word * $numwords"
    if [ "$numwords" -eq 0 ]
    then
      Score[0]=$score
    else
      Score[0]=$add_word
    fi   #  All this to distinguish last-word score
         #+ from total running score.
  let "Score[1] += ${Score[0]}"
  let "Score[1] += ${Score[2]}"

}



get_word ()
{
  local wrd=''
  read -t $TIMEOUT wrd   # Timed read.
  echo $wrd
}

is_constructable ()
{ # This is the most complex and difficult-to-write function.
  local -a local_LS=( "${LS[@]}" )  # Local copy of letter set.
  local is_found=0
  local idx=0
  local pos
  local strlen
  local local_word=( "$1" )
  strlen=${#local_word}

  while [ "$idx" -lt "$strlen" ]
  do
    is_found=$(expr index "${local_LS[*]}" "${local_word:idx:1}")
    if [ "$is_found" -eq "$NONCONS" ] # Not constructable!
    then
      echo "$FAILURE"; return
    else
      ((pos = ($is_found - 1) / 2))   # Compensate for spaces betw. letters!
      local_LS[pos]=$NULL             # Zero out used letters.
      ((idx++))                       # Bump index.
    fi
  done

  echo "$SUCCESS"
  return
}

is_valid ()
{ # Surprisingly easy to check if word in dictionary ...
  fgrep -qw "$1" "$WLIST"   # ... courtesy of 'grep' ...
  echo $?
}

check_word ()
{
  if [ -z "$1" ]
  then
    return
  fi

  Status[1]=""
  Status[2]=""
  Status[3]=""
  Status[4]=""

  iscons=$(is_constructable "$1")
  if [ "$iscons" ]
  then
    Status[1]="constructable" 
    v=$(is_valid "$1")
    if [ "$v" -eq "$SUCCESS" ]
    then
      Status[2]="valid" 
      strlen=${#1}

      if [ ${Score[strlen]} -eq "$MAXCAT" ]   # Category full!
      then
        Status[3]="Category-$strlen-overflow-PENALTY"
        return $NG
      fi

      case "$strlen" in
        1 | 2 )
        Status[3]="Two-letter-word-PENALTY"
        return $NG;;
        * ) 
	Status[3]=""
	return $SUCCESS;;
      esac
    else
      Status[3]="Not-valid-PENALTY"
      return $NG
    fi
  else
    Status[3]="Not-constructable-PENALTY" 
      return $NG
  fi

  ### FIXME: Streamline the above code block.

}


display_words ()
{
  local idx=0
  local wlen0

  clear
  echo "Letterset:   ${LS[@]}"
  echo "Threes:    Fours:    Fives:     Sixes:    Sevens:    Eights:"
  echo "------------------------------------------------------------"


   
  while [ "${Words[idx]}" != '' ]
  do
   wlen0=${#Words[idx]}
   case "$wlen0" in
     3) ;;
     4) echo -n "           " ;;
     5) echo -n "                     " ;;
     6) echo -n "                                " ;;
     7) echo -n "                                          " ;;
     8) echo -n "                                                     " ;;
   esac
   echo "${Words[idx]}"
   ((idx++))
  done

  ### FIXME: The word display is pretty crude.
}


play ()
{
  word="Start game"   # Dummy word, to start ...

  while [ "$word" ]   #  If player just hits return (null word),
  do                  #+ then game ends.
    echo "$word: "${Status[@]}""
    echo -n "Last score: [${Score[0]}]   TOTAL score: [${Score[1]}]:     Next word: "
    total=${Score[1]}
    word=$(get_word)
    check_word "$word"

    if [ "$?" -eq "$SUCCESS" ]
    then
      add_word "$word"
    else
      let "Score[0]= 0 - $PENALTY"
      let "Score[1]-=$PENALTY"
    fi

  display_words
  done   # Exit game.

  ### FIXME: The play () function calls too many other functions.
  ### This verges on "spaghetti code" !!!
}

end_of_game ()
{ # Save and display stats.

  #######################Autosave##########################
  savefile=qky.save.$$
  #                 ^^ PID of script
  echo `date` &gt;&gt; $savefile
  echo "Letterset # $randseed  (random seed) "&gt;&gt; $savefile
  echo -n "Letterset: " &gt;&gt; $savefile
  echo "${LS[@]}" &gt;&gt; $savefile
  echo "---------" &gt;&gt; $savefile
  echo "Words constructed:" &gt;&gt; $savefile
  echo "${Words[@]}" &gt;&gt; $savefile
  echo &gt;&gt; $savefile
  echo "Score: $total" &gt;&gt; $savefile

  echo "Statistics for this round saved in \""$savefile"\""
  #########################################################

  echo "Score for this round: $total"
  echo "Words:  ${Words[@]}"
}

# ---------#
instructions
seed_random
get_letset
play
end_of_game
# ---------#

exit $?

# TODO:
#
# 1) Clean up code!
# 2) Prettify the display_words () function (maybe with widgets?).
# 3) Improve the time-out ... maybe change to untimed entry,
#+   but with a time limit for the overall round.   
# 4) An on-screen countdown timer would be nice.
# 5) Implement "vulnerable" mode of play for compatibility with classic
#+   version of the game.
# 6) Improve save-to-file capability (and maybe make it optional).
# 7) Fix bugs!!!

# For more info, reference:
# http://bash.deta.in/qky.README.html
</programlisting>
    </example>

    <example xml:id="nim">
      <title>Nim</title>
      <programlisting>#!/bin/bash
# nim.sh: Game of Nim

# Author: Mendel Cooper
# Reldate: 15 July 2008
# License: GPL3

ROWS=5     # Five rows of pegs (or matchsticks).
WON=91     # Exit codes to keep track of wins/losses.
LOST=92    # Possibly useful if running in batch mode.  
QUIT=99
peg_msg=   # Peg/Pegs?
Rows=( 0 5 4 3 2 1 )   # Array holding play info.
# ${Rows[0]} holds total number of pegs, updated after each turn.
# Other array elements hold number of pegs in corresponding row.

instructions ()
{
  clear
  tput bold
  echo "Welcome to the game of Nim."; echo
  echo -n "Do you need instructions? (y/n) "; read ans

   if [ "$ans" = "y" -o "$ans" = "Y" ]; then
     clear
     echo -e '\E[33;41m'  # Yellow fg., over red bg.; bold.
     cat &lt;&lt;INSTRUCTIONS

Nim is a game with roots in the distant past.
This particular variant starts with five rows of pegs.

1:    | | | | | 
2:     | | | | 
3:      | | | 
4:       | | 
5:        | 

The number at the left identifies the row.

The human player moves first, and alternates turns with the bot.
A turn consists of removing at least one peg from a single row.
It is permissable to remove ALL the pegs from a row.
For example, in row 2, above, the player can remove 1, 2, 3, or 4 pegs.
The player who removes the last peg loses.

The strategy consists of trying to be the one who removes
the next-to-last peg(s), leaving the loser with the final peg.

To exit the game early, hit ENTER during your turn.
INSTRUCTIONS

echo; echo -n "Hit ENTER to begin game. "; read azx

      echo -e "\033[0m"    # Restore display.
      else tput sgr0; clear
  fi

clear

}


tally_up ()
{
  let "Rows[0] = ${Rows[1]} + ${Rows[2]} + ${Rows[3]} + ${Rows[4]} + \
  ${Rows[5]}"    # Add up how many pegs remaining.
}


display ()
{
  index=1   # Start with top row.
  echo

  while [ "$index" -le "$ROWS" ]
  do
    p=${Rows[index]}
    echo -n "$index:   "          # Show row number.

  # ------------------------------------------------
  # Two concurrent inner loops.

      indent=$index
      while [ "$indent" -gt 0 ]
      do
        echo -n " "               # Staggered rows.
        ((indent--))              # Spacing between pegs.
      done

    while [ "$p" -gt 0 ]
    do
      echo -n "| "
      ((p--))
    done
  # -----------------------------------------------

  echo
  ((index++))
  done  

  tally_up

  rp=${Rows[0]}

  if [ "$rp" -eq 1 ]
  then
    peg_msg=peg
    final_msg="Game over."
  else             # Game not yet over . . .
    peg_msg=pegs
    final_msg=""   # . . . So "final message" is blank.
  fi

  echo "      $rp $peg_msg remaining."
  echo "      "$final_msg""


  echo
}

player_move ()
{

  echo "Your move:"

  echo -n "Which row? "
  while read idx
  do                   # Validity check, etc.

    if [ -z "$idx" ]   # Hitting return quits.
    then
        echo "Premature exit."; echo
        tput sgr0      # Restore display.
        exit $QUIT
    fi

    if [ "$idx" -gt "$ROWS" -o "$idx" -lt 1 ]   # Bounds check.
    then
      echo "Invalid row number!"
      echo -n "Which row? "
    else
      break
    fi
    # TODO:
    # Add check for non-numeric input.
    # Also, script crashes on input outside of range of long double.
    # Fix this.

  done

  echo -n "Remove how many? "
  while read num
  do                   # Validity check.

  if [ -z "$num" ]
  then
    echo "Premature exit."; echo
    tput sgr0          # Restore display.
    exit $QUIT
  fi

    if [ "$num" -gt ${Rows[idx]} -o "$num" -lt 1 ]
    then
      echo "Cannot remove $num!"
      echo -n "Remove how many? "
    else
      break
    fi
  done
  # TODO:
  # Add check for non-numeric input.
  # Also, script crashes on input outside of range of long double.
  # Fix this.

  let "Rows[idx] -= $num"

  display
  tally_up

  if [ ${Rows[0]} -eq 1 ]
  then
   echo "      Human wins!"
   echo "      Congratulations!"
   tput sgr0   # Restore display.
   echo
   exit $WON
  fi

  if [ ${Rows[0]} -eq 0 ]
  then          # Snatching defeat from the jaws of victory . . .
    echo "      Fool!"
    echo "      You just removed the last peg!"
    echo "      Bot wins!"
    tput sgr0   # Restore display.
    echo
    exit $LOST
  fi
}


bot_move ()
{

  row_b=0
  while [[ $row_b -eq 0 || ${Rows[row_b]} -eq 0 ]]
  do
    row_b=$RANDOM          # Choose random row.
    let "row_b %= $ROWS"
  done


  num_b=0
  r0=${Rows[row_b]}

  if [ "$r0" -eq 1 ]
  then
    num_b=1
  else
    let "num_b = $r0 - 1"
         #  Leave only a single peg in the row.
  fi     #  Not a very strong strategy,
         #+ but probably a bit better than totally random.

  let "Rows[row_b] -= $num_b"
  echo -n "Bot:  "
  echo "Removing from row $row_b ... "

  if [ "$num_b" -eq 1 ]
  then
    peg_msg=peg
  else
    peg_msg=pegs
  fi

  echo "      $num_b $peg_msg."

  display
  tally_up

  if [ ${Rows[0]} -eq 1 ]
  then
   echo "      Bot wins!"
   tput sgr0   # Restore display.
   exit $WON
  fi

}


# ================================================== #
instructions     # If human player needs them . . .
tput bold        # Bold characters for easier viewing.
display          # Show game board.

while [ true ]   # Main loop.
do               # Alternate human and bot turns.
  player_move
  bot_move
done
# ================================================== #

# Exercise:
# --------
# Improve the bot's strategy.
# There is, in fact, a Nim strategy that can force a win.
# See the Wikipedia article on Nim:  http://en.wikipedia.org/wiki/Nim
# Recode the bot to use this strategy (rather difficult).

#  Curiosities:
#  -----------
#  Nim played a prominent role in Alain Resnais' 1961 New Wave film,
#+ Last Year at Marienbad.
#
#  In 1978, Leo Christopherson wrote an animated version of Nim,
#+ Android Nim, for the TRS-80 Model I.
</programlisting>
    </example>

    <example xml:id="stopwatch">
      <title>A command-line stopwatch</title>
      <programlisting>#!/bin/sh
# sw.sh
# A command-line Stopwatch

# Author: PÃ¡draig Brady
#    http://www.pixelbeat.org/scripts/sw
#    (Minor reformatting by ABS Guide author.)
#    Used in ABS Guide with script author's permission.
# Notes:
#    This script starts a few processes per lap, in addition to
#    the shell loop processing, so the assumption is made that
#    this takes an insignificant amount of time compared to
#    the response time of humans (~.1s) (or the keyboard
#    interrupt rate (~.05s)).
#    '?' for splits must be entered twice if characters
#    (erroneously) entered before it (on the same line).
#    '?' since not generating a signal may be slightly delayed
#    on heavily loaded systems.
#    Lap timings on ubuntu may be slightly delayed due to:
#    https://bugs.launchpad.net/bugs/62511
# Changes:
#    V1.0, 23 Aug 2005, Initial release
#    V1.1, 26 Jul 2007, Allow both splits and laps from single invocation.
#                       Only start timer after a key is pressed.
#                       Indicate lap number
#                       Cache programs at startup so there is less error
#                       due to startup delays.
#    V1.2, 01 Aug 2007, Work around `date` commands that don't have
#                       nanoseconds.
#                       Use stty to change interrupt keys to space for
#                       laps etc.
#                       Ignore other input as it causes problems.
#    V1.3, 01 Aug 2007, Testing release.
#    V1.4, 02 Aug 2007, Various tweaks to get working under ubuntu
#                       and Mac OS X.
#    V1.5, 27 Jun 2008, set LANG=C as got vague bug report about it.

export LANG=C

ulimit -c 0   # No coredumps from SIGQUIT.
trap '' TSTP  # Ignore Ctrl-Z just in case.
save_tty=`stty -g` &amp;&amp; trap "stty $save_tty" EXIT  # Restore tty on exit.
stty quit ' ' # Space for laps rather than Ctrl-\.
stty eof  '?' # ? for splits rather than Ctrl-D.
stty -echo    # Don't echo input.

cache_progs() {
    stty &gt; /dev/null
    date &gt; /dev/null
    grep . &lt; /dev/null
    (echo "import time" | python) 2&gt; /dev/null
    bc &lt; /dev/null
    sed '' &lt; /dev/null
    printf '1' &gt; /dev/null
    /usr/bin/time false 2&gt; /dev/null
    cat &lt; /dev/null
}
cache_progs   # To minimise startup delay.

date +%s.%N | grep -qF 'N' &amp;&amp; use_python=1 # If `date` lacks nanoseconds.
now() {
    if [ "$use_python" ]; then
        echo "import time; print time.time()" 2&gt;/dev/null | python
    else
        printf "%.2f" `date +%s.%N`
    fi
}

fmt_seconds() {
    seconds=$1
    mins=`echo $seconds/60 | bc`
    if [ "$mins" != "0" ]; then
        seconds=`echo "$seconds - ($mins*60)" | bc`
        echo "$mins:$seconds"
    else
        echo "$seconds"
    fi
}

total() {
    end=`now`
    total=`echo "$end - $start" | bc`
    fmt_seconds $total
}

stop() {
    [ "$lapped" ] &amp;&amp; lap "$laptime" "display"
    total
    exit
}

lap() {
    laptime=`echo "$1" | sed -n 's/.*real[^0-9.]*\(.*\)/\1/p'`
    [ ! "$laptime" -o "$laptime" = "0.00" ] &amp;&amp; return
    # Signals too frequent.
    laptotal=`echo $laptime+0$laptotal | bc`
    if [ "$2" = "display" ]; then
        lapcount=`echo 0$lapcount+1 | bc`
        laptime=`fmt_seconds $laptotal`
        echo $laptime "($lapcount)"
        lapped="true"
        laptotal="0"
    fi
}

echo -n "Space for lap | ? for split | Ctrl-C to stop | Space to start..."&gt;&amp;2

while true; do
    trap true INT QUIT  # Set signal handlers.
    laptime=`/usr/bin/time -p 2&gt;&amp;1 cat &gt;/dev/null`
    ret=$?
    trap '' INT QUIT    # Ignore signals within this script.
    if [ $ret -eq 1 -o $ret -eq 2 -o $ret -eq 130 ]; then # SIGINT = stop
        [ ! "$start" ] &amp;&amp; { echo &gt;&amp;2; exit; }
        stop
    elif [ $ret -eq 3 -o $ret -eq 131 ]; then             # SIGQUIT = lap
        if [ ! "$start" ]; then
            start=`now` || exit 1
            echo &gt;&amp;2
            continue
        fi
        lap "$laptime" "display"
    else                # eof = split
        [ ! "$start" ] &amp;&amp; continue
        total
        lap "$laptime"  # Update laptotal.
    fi
done

exit $?
</programlisting>
    </example>

    <example xml:id="homework">
      <title>An all-purpose shell scripting homework assignment solution</title>
      <programlisting>#!/bin/bash
#  homework.sh: All-purpose homework assignment solution.
#  Author: M. Leo Cooper
#  If you substitute your own name as author, then it is plagiarism,
#+ possibly a lesser sin than cheating on your homework!
#  License: Public Domain

#  This script may be turned in to your instructor
#+ in fulfillment of ALL shell scripting homework assignments.
#  It's sparsely commented, but you, the student, can easily remedy that.
#  The script author repudiates all responsibility!

DLA=1
P1=2
P2=4
P3=7
PP1=0
PP2=8
MAXL=9
E_LZY=99

declare -a L
L[0]="3 4 0 17 29 8 13 18 19 17 20 2 19 14 17 28"
L[1]="8 29 12 14 18 19 29 4 12 15 7 0 19 8 2 0 11 11 24 29 17 4 6 17 4 19"
L[2]="29 19 7 0 19 29 8 29 7 0 21 4 29 13 4 6 11 4 2 19 4 3"
L[3]="19 14 29 2 14 12 15 11 4 19 4 29 19 7 8 18 29"
L[4]="18 2 7 14 14 11 22 14 17 10 29 0 18 18 8 6 13 12 4 13 19 26"
L[5]="15 11 4 0 18 4 29 0 2 2 4 15 19 29 12 24 29 7 20 12 1 11 4 29"
L[6]="4 23 2 20 18 4 29 14 5 29 4 6 17 4 6 8 14 20 18 29"
L[7]="11 0 25 8 13 4 18 18 27"
L[8]="0 13 3 29 6 17 0 3 4 29 12 4 29 0 2 2 14 17 3 8 13 6 11 24 26"
L[9]="19 7 0 13 10 29 24 14 20 26"

declare -a \
alph=( A B C D E F G H I J K L M N O P Q R S T U V W X Y Z . , : ' ' )


pt_lt ()
{
  echo -n "${alph[$1]}"
  echo -n -e "\a"
  sleep $DLA
}

b_r ()
{
 echo -e '\E[31;48m\033[1m'
}

cr ()
{
 echo -e "\a"
 sleep $DLA
}

restore ()
{
  echo -e '\033[0m'            # Bold off.
  tput sgr0                    # Normal.
}


p_l ()
{
  for ltr in $1
  do
    pt_lt "$ltr"
  done
}

# ----------------------
b_r

for i in $(seq 0 $MAXL)
do
  p_l "${L[i]}"
  if [[ "$i" -eq "$P1" || "$i" -eq "$P2" || "$i" -eq "$P3" ]]
  then
    cr
  elif [[ "$i" -eq "$PP1" || "$i" -eq "$PP2" ]]
  then
    cr; cr
  fi
done

restore
# ----------------------

echo

exit $E_LZY

#  A typical example of an obfuscated script that is difficult
#+ to understand, and frustrating to maintain.
#  In your career as a sysadmin, you'll run into these critters
#+ all too often.
</programlisting>
    </example>

	<para><anchor xml:id="ktour0" /></para>
    <example xml:id="ktour">
	    <title>The Knight's Tour</title>
      <programlisting>#!/bin/bash
# ktour.sh

# author: mendel cooper
# reldate: 12 Jan 2009
# license: public domain
# (Not much sense GPLing something that's pretty much in the common
#+ domain anyhow.)

###################################################################
#             The Knight's Tour, a classic problem.               #
#             =====================================               #
#  The knight must move onto every square of the chess board,     #
#  but cannot revisit any square he has already visited.          #
#                                                                 #
#  And just why is Sir Knight unwelcome for a return visit?       #
#  Could it be that he has a habit of partying into the wee hours #
#+ of the morning?                                                #
#  Possibly he leaves pizza crusts in the bed, empty beer bottles #
#+ all over the floor, and clogs the plumbing. . . .              #
#                                                                 #
#  -------------------------------------------------------------  #
#                                                                 #
#  Usage: ktour.sh [start-square] [stupid]                        #
#                                                                 #
#  Note that start-square can be a square number                  #
#+ in the range 0 - 63 ... or                                     #
#  a square designator in conventional chess notation,            #
#  such as a1, f5, h3, etc.                                       #
#                                                                 #
#  If start-square-number not supplied,                           #
#+ then starts on a random square somewhere on the board.         #
#                                                                 #
# "stupid" as second parameter sets the stupid strategy.          #
#                                                                 #
#  Examples:                                                      #
#  ktour.sh 23          starts on square #23 (h3)                 #
#  ktour.sh g6 stupid   starts on square #46,                     #
#                       using "stupid" (non-Warnsdorff) strategy. #
###################################################################

DEBUG=      # Set this to echo debugging info to stdout.
SUCCESS=0
FAIL=99
BADMOVE=-999
FAILURE=1
LINELEN=21  # How many moves to display per line.
# ---------------------------------------- #
# Board array params
ROWS=8   # 8 x 8 board.
COLS=8
let "SQUARES = $ROWS * $COLS"
let "MAX = $SQUARES - 1"
MIN=0
# 64 squares on board, indexed from 0 to 63.

VISITED=1
UNVISITED=-1
UNVSYM="##"
# ---------------------------------------- #
# Global variables.
startpos=    # Starting position (square #, 0 - 63).
currpos=     # Current position.
movenum=     # Move number.
CRITPOS=37   # Have to patch for f5 starting position!

declare -i board
# Use a one-dimensional array to simulate a two-dimensional one.
# This can make life difficult and result in ugly kludges; see below.
declare -i moves  # Offsets from current knight position.


initialize_board ()
{
  local idx

  for idx in {0..63}
  do
    board[$idx]=$UNVISITED
  done
}



print_board ()
{
  local idx

  echo "    _____________________________________"
  for row in {7..0}               #  Reverse order of rows ...
  do                              #+ so it prints in chessboard order.
    let "rownum = $row + 1"       #  Start numbering rows at 1.
    echo -n "$rownum  |"          #  Mark board edge with border and
    for column in {0..7}          #+ "algebraic notation."
    do
      let "idx = $ROWS*$row + $column"
      if [ ${board[idx]} -eq $UNVISITED ]
      then
        echo -n "$UNVSYM   "      ##
      else                        # Mark square with move number.
        printf "%02d " "${board[idx]}"; echo -n "  "
      fi
    done
    echo -e -n "\b\b\b|"  # \b is a backspace.
    echo                  # -e enables echoing escaped chars.
  done

  echo "    -------------------------------------"
  echo "     a    b    c    d    e    f    g    h"
}



failure()
{ # Whine, then bail out.
  echo
  print_board
  echo
  echo    "   Waah!!! Ran out of squares to move to!"
  echo -n "   Knight's Tour attempt ended"
  echo    " on $(to_algebraic $currpos) [square #$currpos]"
  echo    "   after just $movenum moves!"
  echo
  exit $FAIL
}



xlat_coords ()   #  Translate x/y coordinates to board position
{                #+ (board-array element #).
  #  For user input of starting board position as x/y coords.
  #  This function not used in initial release of ktour.sh.
  #  May be used in an updated version, for compatibility with
  #+ standard implementation of the Knight's Tour in C, Python, etc.
  if [ -z "$1" -o -z "$2" ]
  then
    return $FAIL
  fi

  local xc=$1
  local yc=$2

  let "board_index = $xc * $ROWS + yc"

  if [ $board_index -lt $MIN -o $board_index -gt $MAX ]
  then
    return $FAIL    # Strayed off the board!
  else
    return $board_index
  fi
}



to_algebraic ()   #  Translate board position (board-array element #)
{                 #+ to standard algebraic notation used by chess players.
  if [ -z "$1" ]
  then
    return $FAIL
  fi

  local element_no=$1   # Numerical board position.
  local col_arr=( a b c d e f g h )
  local row_arr=( 1 2 3 4 5 6 7 8 )

  let "row_no = $element_no / $ROWS"
  let "col_no = $element_no % $ROWS"
  t1=${col_arr[col_no]}; t2=${row_arr[row_no]}
  local apos=$t1$t2   # Concatenate.
  echo $apos
}



from_algebraic ()   #  Translate standard algebraic chess notation
{                   #+ to numerical board position (board-array element #).
                    #  Or recognize numerical input &amp; return it unchanged.
  if [ -z "$1" ]
  then
    return $FAIL
  fi   # If no command-line arg, then will default to random start pos.

  local ix
  local ix_count=0
  local b_index     # Board index [0-63]
  local alpos="$1"

  arow=${alpos:0:1} # position = 0, length = 1
  acol=${alpos:1:1}

  if [[ $arow =~ [[:digit:]] ]]   #  Numerical input?
  then       #  POSIX char class
    if [[ $acol =~ [[:alpha:]] ]] # Number followed by a letter? Illegal!
      then return $FAIL
    else if [ $alpos -gt $MAX ]   # Off board?
      then return $FAIL
    else return $alpos            #  Return digit(s) unchanged . . .
      fi                          #+ if within range.
    fi
  fi

  if [[ $acol -eq $MIN || $acol -gt $ROWS ]]
  then        # Outside of range 1 - 8?
    return $FAIL
  fi

  for ix in a b c d e f g h
  do  # Convert column letter to column number.
   if [ "$arow" = "$ix" ]
   then
     break
   fi
  ((ix_count++))    # Find index count.
  done

  ((acol--))        # Decrementing converts to zero-based array.
  let "b_index = $ix_count + $acol * $ROWS"

  if [ $b_index -gt $MAX ]   # Off board?
  then
    return $FAIL
  fi
    
  return $b_index

}


generate_moves ()   #  Calculate all valid knight moves,
{                   #+ relative to current position ($1),
                    #+ and store in ${moves} array.
  local kt_hop=1    #  One square  :: short leg of knight move.
  local kt_skip=2   #  Two squares :: long leg  of knight move.
  local valmov=0    #  Valid moves.
  local row_pos; let "row_pos = $1 % $COLS"


  let "move1 = -$kt_skip + $ROWS"           # 2 sideways to-the-left,  1 up
    if [[ `expr $row_pos - $kt_skip` -lt $MIN ]]   # An ugly, ugly kludge!
    then                                           # Can't move off board.
      move1=$BADMOVE                               # Not even temporarily.
    else
      ((valmov++))
    fi
  let "move2 = -$kt_hop + $kt_skip * $ROWS" # 1 sideways to-the-left,  2 up
    if [[ `expr $row_pos - $kt_hop` -lt $MIN ]]    # Kludge continued ...
    then
      move2=$BADMOVE
    else
      ((valmov++))
    fi
  let "move3 =  $kt_hop + $kt_skip * $ROWS" # 1 sideways to-the-right, 2 up
    if [[ `expr $row_pos + $kt_hop` -ge $COLS ]]
    then
      move3=$BADMOVE
    else
      ((valmov++))
    fi
  let "move4 =  $kt_skip + $ROWS"           # 2 sideways to-the-right, 1 up
    if [[ `expr $row_pos + $kt_skip` -ge $COLS ]]
    then
      move4=$BADMOVE
    else
      ((valmov++))
    fi
  let "move5 =  $kt_skip - $ROWS"           # 2 sideways to-the-right, 1 dn
    if [[ `expr $row_pos + $kt_skip` -ge $COLS ]]
    then
      move5=$BADMOVE
    else
      ((valmov++))
    fi
  let "move6 =  $kt_hop - $kt_skip * $ROWS" # 1 sideways to-the-right, 2 dn
    if [[ `expr $row_pos + $kt_hop` -ge $COLS ]]
    then
      move6=$BADMOVE
    else
      ((valmov++))
    fi
  let "move7 = -$kt_hop - $kt_skip * $ROWS" # 1 sideways to-the-left,  2 dn
    if [[ `expr $row_pos - $kt_hop` -lt $MIN ]]
    then
      move7=$BADMOVE
    else
      ((valmov++))
    fi
  let "move8 = -$kt_skip - $ROWS"           # 2 sideways to-the-left,  1 dn
    if [[ `expr $row_pos - $kt_skip` -lt $MIN ]]
    then
      move8=$BADMOVE
    else
      ((valmov++))
    fi   # There must be a better way to do this.

  local m=( $valmov $move1 $move2 $move3 $move4 $move5 $move6 $move7 $move8 )
  # ${moves[0]} = number of valid moves.
  # ${moves[1]} ... ${moves[8]} = possible moves.
  echo "${m[*]}"    # Elements of array to stdout for capture in a var.

}



is_on_board ()  # Is position actually on the board?
{
  if [[ "$1" -lt "$MIN" || "$1" -gt "$MAX" ]]
  then
    return $FAILURE
  else
    return $SUCCESS
  fi
}



do_move ()      # Move the knight!
{
  local valid_moves=0
  local aapos
  currposl="$1"
  lmin=$ROWS
  iex=0
  squarel=
  mpm=
  mov=
  declare -a p_moves

  ########################## DECIDE-MOVE #############################
  if [ $startpos -ne $CRITPOS ]
  then   # CRITPOS = square #37
    decide_move
  else                     # Needs a special patch for startpos=37 !!!
    decide_move_patched    # Why this particular move and no other ???
  fi
  ####################################################################

  (( ++movenum ))          # Increment move count.
  let "square = $currposl + ${moves[iex]}"

  ##################    DEBUG    ###############
  if [ "$DEBUG" ]
    then debug   # Echo debugging information.
  fi
  ##############################################

  if [[ "$square" -gt $MAX || "$square" -lt $MIN ||
        ${board[square]} -ne $UNVISITED ]]
  then
    (( --movenum ))              #  Decrement move count,
    echo "RAN OUT OF SQUARES!!!" #+ since previous one was invalid.
    return $FAIL
  fi

  board[square]=$movenum
  currpos=$square       # Update current position.
  ((valid_moves++));    # moves[0]=$valid_moves
  aapos=$(to_algebraic $square)
  echo -n "$aapos "
  test $(( $Moves % $LINELEN )) -eq 0 &amp;&amp; echo
  # Print LINELEN=21 moves per line. A valid tour shows 3 complete lines.
  return $valid_moves   # Found a square to move to!
}



do_move_stupid()   #  Dingbat algorithm,
{                  #+ courtesy of script author, *not* Warnsdorff.
  local valid_moves=0
  local movloc
  local squareloc
  local aapos
  local cposloc="$1"

  for movloc in {1..8}
  do       # Move to first-found unvisited square.
    let "squareloc = $cposloc + ${moves[movloc]}"
    is_on_board $squareloc
    if [ $? -eq $SUCCESS ] &amp;&amp; [ ${board[squareloc]} -eq $UNVISITED ]
    then   # Add conditions to above if-test to improve algorithm.
      (( ++movenum ))
      board[squareloc]=$movenum
      currpos=$squareloc     # Update current position.
      ((valid_moves++));     # moves[0]=$valid_moves
      aapos=$(to_algebraic $squareloc)
      echo -n "$aapos "
      test $(( $Moves % $LINELEN )) -eq 0 &amp;&amp; echo   # Print 21 moves/line.
      return $valid_moves    # Found a square to move to!
    fi
  done

  return $FAIL
  #  If no square found in all 8 loop iterations,
  #+ then Knight's Tour attempt ends in failure.

  #  Dingbat algorithm will typically fail after about 30 - 40 moves,
  #+ but executes _much_ faster than Warnsdorff's in do_move() function.
}



decide_move ()         #  Which move will we make?
{                      #  But, fails on startpos=37 !!!
  for mov in {1..8}
  do
    let "squarel = $currposl + ${moves[mov]}"
    is_on_board $squarel
    if [[ $? -eq $SUCCESS &amp;&amp; ${board[squarel]} -eq $UNVISITED ]]
    then   #  Find accessible square with least possible future moves.
           #  This is Warnsdorff's algorithm.
           #  What happens is that the knight wanders toward the outer edge
           #+ of the board, then pretty much spirals inward.
           #  Given two or more possible moves with same value of
           #+ least-possible-future-moves, this implementation chooses
           #+ the _first_ of those moves.
           #  This means that there is not necessarily a unique solution
           #+ for any given starting position.

      possible_moves $squarel
      mpm=$?
      p_moves[mov]=$mpm
      
      if [ $mpm -lt $lmin ]  # If less than previous minimum ...
      then #     ^^
        lmin=$mpm            # Update minimum.
        iex=$mov             # Save index.
      fi

    fi
  done
}



decide_move_patched ()         #  Decide which move to make,
{  #        ^^^^^^^            #+ but only if startpos=37 !!!
  for mov in {1..8}
  do
    let "squarel = $currposl + ${moves[mov]}"
    is_on_board $squarel
    if [[ $? -eq $SUCCESS &amp;&amp; ${board[squarel]} -eq $UNVISITED ]]
    then
      possible_moves $squarel
      mpm=$?
      p_moves[mov]=$mpm
      
      if [ $mpm -le $lmin ]  # If less-than-or equal to prev. minimum!
      then #     ^^
        lmin=$mpm
        iex=$mov
      fi

    fi
  done                       # There has to be a better way to do this.
}



possible_moves ()            #  Calculate number of possible moves,
{                            #+ given the current position.

  if [ -z "$1" ]
  then
    return $FAIL
  fi

  local curr_pos=$1
  local valid_movl=0
  local icx=0
  local movl
  local sq
  declare -a movesloc

  movesloc=( $(generate_moves $curr_pos) )

  for movl in {1..8}
  do
    let "sq = $curr_pos + ${movesloc[movl]}"
    is_on_board $sq
    if [ $? -eq $SUCCESS ] &amp;&amp; [ ${board[sq]} -eq $UNVISITED ]
    then
      ((valid_movl++));
    fi
  done

  return $valid_movl         # Found a square to move to!
}


strategy ()
{
  echo

  if [ -n "$STUPID" ]
  then
    for Moves in {1..63}
    do
      cposl=$1
      moves=( $(generate_moves $currpos) )
      do_move_stupid "$currpos"
      if [ $? -eq $FAIL ]
      then
        failure
      fi
      done
  fi

  #  Don't need an "else" clause here,
  #+ because Stupid Strategy will always fail and exit!
  for Moves in {1..63}
  do
    cposl=$1
    moves=( $(generate_moves $currpos) )
    do_move "$currpos"
    if [ $? -eq $FAIL ]
    then
      failure
    fi

  done
        #  Could have condensed above two do-loops into a single one,
  echo  #+ but this would have slowed execution.

  print_board
  echo
  echo "Knight's Tour ends on $(to_algebraic $currpos) [square #$currpos]."
  return $SUCCESS
}

debug ()
{       # Enable this by setting DEBUG=1 near beginning of script.
  local n

  echo "================================="
  echo "  At move number  $movenum:"
  echo " *** possible moves = $mpm ***"
# echo "### square = $square ###"
  echo "lmin = $lmin"
  echo "${moves[@]}"

  for n in {1..8}
  do
    echo -n "($n):${p_moves[n]} "
  done

  echo
  echo "iex = $iex :: moves[iex] = ${moves[iex]}"
  echo "square = $square"
  echo "================================="
  echo
} # Gives pretty complete status after ea. move.



# =============================================================== #
# int main () {
from_algebraic "$1"
startpos=$?
if [ "$startpos" -eq "$FAIL" ]          # Okay even if no $1.
then   #         ^^^^^^^^^^^              Okay even if input -lt 0.
  echo "No starting square specified (or illegal input)."
  let "startpos = $RANDOM % $SQUARES"   # 0 - 63 permissable range.
fi


if [ "$2" = "stupid" ]
then
  STUPID=1
  echo -n "     ### Stupid Strategy ###"
else
  STUPID=''
  echo -n "  *** Warnsdorff's Algorithm ***"
fi


initialize_board

movenum=0
board[startpos]=$movenum   # Mark each board square with move number.
currpos=$startpos
algpos=$(to_algebraic $startpos)

echo; echo "Starting from $algpos [square #$startpos] ..."; echo
echo -n "Moves:"

strategy "$currpos"

echo

exit 0   # return 0;

# }      # End of main() pseudo-function.
# =============================================================== #


# Exercises:
# ---------
#
# 1) Extend this example to a 10 x 10 board or larger.
# 2) Improve the "stupid strategy" by modifying the
#    do_move_stupid function.
#    Hint: Prevent straying into corner squares in early moves
#          (the exact opposite of Warnsdorff's algorithm!).
# 3) This script could stand considerable improvement and
#    streamlining, especially in the poorly-written
#    generate_moves() function
#    and in the DECIDE-MOVE patch in the do_move() function.
#    Must figure out why standard algorithm fails for startpos=37 ...
#+   but _not_ on any other, including symmetrical startpos=26.
#    Possibly, when calculating possible moves, counts the move back
#+   to the originating square. If so, it might be a relatively easy fix.
</programlisting>
    </example>

    <example xml:id="msquare">
	    <title>Magic Squares</title>
      <programlisting>#!/bin/bash
# msquare.sh
# Magic Square generator (odd-order squares only!)

# Author: mendel cooper
# reldate: 19 Jan. 2009
# License: Public Domain
# A C-program by the very talented Kwon Young Shin inspired this script.
#     http://user.chollian.net/~brainstm/MagicSquare.htm

# Definition: A "magic square" is a two-dimensional array
#             of integers in which all the rows, columns,
#             and *long* diagonals add up to the same number.
#             Being "square," the array has the same number
#             of rows and columns. That number is the "order."
# An example of a magic square of order 3 is:
#   8  1  6   
#   3  5  7   
#   4  9  2   
# All the rows, columns, and the two long diagonals add up to 15.


# Globals
EVEN=2
MAXSIZE=31   # 31 rows x 31 cols.
E_usage=90   # Invocation error.
dimension=
declare -i square

usage_message ()
{
  echo "Usage: $0 order"
  echo "   ... where \"order\" (square size) is an ODD integer"
  echo "       in the range 3 - 31."
  #  Actually works for squares up to order 159,
  #+ but large squares will not display pretty-printed in a term window.
  #  Try increasing MAXSIZE, above.
  exit $E_usage
}


calculate ()       # Here's where the actual work gets done.
{
  local row col index dimadj j k cell_val=1
  dimension=$1

  let "dimadj = $dimension * 3"; let "dimadj /= 2"   # x 1.5, then truncate.

  for ((j=0; j &lt; dimension; j++))
  do
    for ((k=0; k &lt; dimension; k++))
    do  # Calculate indices, then convert to 1-dim. array index.
        # Bash doesn't support multidimensional arrays. Pity.
      let "col = $k - $j + $dimadj"; let "col %= $dimension"
      let "row = $j * 2 - $k + $dimension"; let "row %= $dimension"
      let "index = $row*($dimension) + $col"
      square[$index]=cell_val; ((cell_val++))
    done
  done
}     # Plain math, visualization not required.


print_square ()               # Output square, one row at a time.
{
  local row col idx d1
  let "d1 = $dimension - 1"   # Adjust for zero-indexed array.
 
  for row in $(seq 0 $d1)
  do

    for col in $(seq 0 $d1)
    do
      let "idx = $row * $dimension + $col"
      printf "%3d " "${square[idx]}"; echo -n "  "
    done   # Displays up to 13th order neatly in 80-column term window.

    echo   # Newline after each row.
  done
}


#################################################
if [[ -z "$1" ]] || [[ "$1" -gt $MAXSIZE ]]
then
  usage_message
fi

let "test_even = $1 % $EVEN"
if [ $test_even -eq 0 ]
then           # Can't handle even-order squares.
  usage_message
fi

calculate $1
print_square   # echo "${square[@]}"   # DEBUG

exit $?
#################################################


# Exercises:
# ---------
# 1) Add a function to calculate the sum of each row, column,
#    and *long* diagonal. The sums must match.
#    This is the "magic constant" of that particular order square.
# 2) Have the print_square function auto-calculate how much space
#    to allot between square elements for optimized display.
#    This might require parameterizing the "printf" line.
# 3) Add appropriate functions for generating magic squares
#    with an *even* number of rows/columns.
#    This is non-trivial(!).
#    See the URL for Kwon Young Shin, above, for help.
</programlisting>
    </example>

    <example xml:id="fifteen">
	    <title>Fifteen Puzzle</title>
      <programlisting>#!/bin/bash
# fifteen.sh

# Classic "Fifteen Puzzle"
# Author: Antonio Macchi
# Lightly edited and commented by ABS Guide author.
# Used in ABS Guide with permission. (Thanks!)

#  The invention of the Fifteen Puzzle is attributed to either
#+ Sam Loyd or Noyes Palmer Chapman.
#  The puzzle was wildly popular in the late 19th-century.

#  Object: Rearrange the numbers so they read in order,
#+ from 1 - 15:   ________________
#                |  1   2   3   4 |
#                |  5   6   7   8 |
#                |  9  10  11  12 |
#                | 13  14  15     |
#                 ----------------


#######################
# Constants           #
  SQUARES=16          #
  FAIL=70             #
  E_PREMATURE_EXIT=80 #
#######################


########
# Data #
########

Puzzle=( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 " " )


#############
# Functions #
#############

function swap
{
  local tmp

  tmp=${Puzzle[$1]}
  Puzzle[$1]=${Puzzle[$2]}
  Puzzle[$2]=$tmp
}


function Jumble
{ # Scramble the pieces at beginning of round.
  local i pos1 pos2

  for i in {1..100}
  do
    pos1=$(( $RANDOM % $SQUARES))
    pos2=$(( $RANDOM % $SQUARES ))
    swap $pos1 $pos2
  done
}


function PrintPuzzle
{
  local i1 i2 puzpos
  puzpos=0

  clear
  echo "Enter  quit  to exit."; echo   # Better that than Ctl-C.

  echo ",----.----.----.----."   # Top border.
  for i1 in {1..4}
  do
    for i2 in {1..4} 
    do
      printf "| %2s " "${Puzzle[$puzpos]}"
      (( puzpos++ ))
    done
    echo "|"                     # Right-side border.
    test $i1 = 4 || echo "+----+----+----+----+"
  done
  echo "'----'----'----'----'"   # Bottom border.
}


function GetNum
{ # Test for valid input.
  local puznum garbage

  while true
  do 
	  echo "Moves: $moves" # Also counts invalid moves.
    read -p "Number to move: " puznum garbage
      if [ "$puznum" = "quit" ]; then echo; exit $E_PREMATURE_EXIT; fi
    test -z "$puznum" -o -n "${puznum//[0-9]/}" &amp;&amp; continue
    test $puznum -gt 0 -a $puznum -lt $SQUARES &amp;&amp; break
  done
  return $puznum
}


function GetPosFromNum
{ # $1 = puzzle-number
  local puzpos

  for puzpos in {0..15}
  do
    test "${Puzzle[$puzpos]}" = "$1" &amp;&amp; break
  done
  return $puzpos
}


function Move
{ # $1=Puzzle-pos
  test $1 -gt 3 &amp;&amp; test "${Puzzle[$(( $1 - 4 ))]}" = " "\
       &amp;&amp; swap $1 $(( $1 - 4 )) &amp;&amp; return 0
  test $(( $1%4 )) -ne 3 &amp;&amp; test "${Puzzle[$(( $1 + 1 ))]}" = " "\
       &amp;&amp; swap $1 $(( $1 + 1 )) &amp;&amp; return 0
  test $1 -lt 12 &amp;&amp; test "${Puzzle[$(( $1 + 4 ))]}" = " "\
       &amp;&amp; swap $1 $(( $1 + 4 )) &amp;&amp; return 0
  test $(( $1%4 )) -ne 0 &amp;&amp; test "${Puzzle[$(( $1 - 1 ))]}" = " " &amp;&amp;\
       swap $1 $(( $1 - 1 )) &amp;&amp; return 0
  return 1
}


function Solved
{
  local pos

  for pos in {0..14}
  do
    test "${Puzzle[$pos]}" = $(( $pos + 1 )) || return $FAIL
    # Check whether number in each square = square number.
  done
  return 0   # Successful solution.
}


################### MAIN () #######################{
moves=0
Jumble

while true   # Loop continuously until puzzle solved.
do
  echo; echo
  PrintPuzzle
  echo
  while true
  do
    GetNum
    puznum=$?
    GetPosFromNum $puznum
    puzpos=$?
    ((moves++))
    Move $puzpos &amp;&amp; break
  done
  Solved &amp;&amp; break
done

echo;echo
PrintPuzzle
echo; echo "BRAVO!"; echo

exit 0
###################################################}

#  Exercise:
#  --------
#  Rewrite the script to display the letters A - O,
#+ rather than the numbers 1 - 15.
</programlisting>
    </example>

    <para><anchor xml:id="hanoi2ref" /></para>
    <example xml:id="hanoi2">
            <title><firstterm>The Towers of Hanoi, graphic
	        version</firstterm></title>
       <programlisting>#! /bin/bash
# The Towers Of Hanoi
# Original script (hanoi.bash) copyright (C) 2000 Amit Singh.
# All Rights Reserved.
# http://hanoi.kernelthread.com

#  hanoi2.bash
#  Version 2.00: modded for ASCII-graphic display.
#  Version 2.01: fixed no command-line param bug.
#  Uses code contributed by Antonio Macchi,
#+ with heavy editing by ABS Guide author.
#  This variant falls under the original copyright, see above.
#  Used in ABS Guide with Amit Singh's permission (thanks!).


###   Variables &amp;&amp; sanity check   ###

E_NOPARAM=86
E_BADPARAM=87            # Illegal no. of disks passed to script.
E_NOEXIT=88

DISKS=${1:-$E_NOPARAM}   # Must specify how many disks.
Moves=0

MWIDTH=7
MARGIN=2
# Arbitrary "magic" constants; work okay for relatively small # of disks.
# BASEWIDTH=51   # Original code.
let "basewidth = $MWIDTH * $DISKS + $MARGIN"       # "Base" beneath rods.
# Above "algorithm" could likely stand improvement.

###   Display variables   ###
let "disks1 = $DISKS - 1"
let "spaces1 = $DISKS" 
let "spaces2 = 2 * $DISKS" 

let "lastmove_t = $DISKS - 1"                      # Final move?


declare -a Rod1 Rod2 Rod3

###   #########################   ###


function repeat  {  # $1=char $2=number of repetitions
  local n           # Repeat-print a character.
  
  for (( n=0; n&lt;$2; n++ )); do
    echo -n "$1"
  done
}

function FromRod  {
  local rod summit weight sequence

  while true; do
    rod=$1
    test ${rod/[^123]/} || continue

    sequence=$(echo $(seq 0 $disks1 | tac))
    for summit in $sequence; do
      eval weight=\${Rod${rod}[$summit]}
      test $weight -ne 0 &amp;&amp;
           { echo "$rod $summit $weight"; return; }
    done
  done
}


function ToRod  { # $1=previous (FromRod) weight
  local rod firstfree weight sequence
  
  while true; do
    rod=$2
    test ${rod/[^123]} || continue

    sequence=$(echo $(seq 0 $disks1 | tac))
    for firstfree in $sequence; do
      eval weight=\${Rod${rod}[$firstfree]}
      test $weight -gt 0 &amp;&amp; { (( firstfree++ )); break; }
    done
    test $weight -gt $1 -o $firstfree = 0 &amp;&amp;
         { echo "$rod $firstfree"; return; }
  done
}


function PrintRods  {
  local disk rod empty fill sp sequence


  repeat " " $spaces1
  echo -n "|"
  repeat " " $spaces2
  echo -n "|"
  repeat " " $spaces2
  echo "|"

  sequence=$(echo $(seq 0 $disks1 | tac))
  for disk in $sequence; do
    for rod in {1..3}; do
      eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) ))
      eval fill=\${Rod${rod}[$disk]}
      repeat " " $empty
      test $fill -gt 0 &amp;&amp; repeat "*" $fill || echo -n "|"
      repeat " " $empty
    done
    echo
  done
  repeat "=" $basewidth   # Print "base" beneath rods.
  echo
}


display ()
{
  echo
  PrintRods

  # Get rod-number, summit and weight
  first=( `FromRod $1` )
  eval Rod${first[0]}[${first[1]}]=0

  # Get rod-number and first-free position
  second=( `ToRod ${first[2]} $2` )
  eval Rod${second[0]}[${second[1]}]=${first[2]}


echo; echo; echo
if [ "${Rod3[lastmove_t]}" = 1 ]
then   # Last move? If yes, then display final position.
    echo "+  Final Position: $Moves moves"; echo
    PrintRods
  fi
}


# From here down, almost the same as original (hanoi.bash) script.

dohanoi() {   # Recursive function.
    case $1 in
    0)
        ;;
    *)
        dohanoi "$(($1-1))" $2 $4 $3
	if [ "$Moves" -ne 0 ]
        then
	  echo "+  Position after move $Moves"
        fi
        ((Moves++))
        echo -n "   Next move will be:  "
        echo $2 "--&gt;" $3
          display $2 $3
        dohanoi "$(($1-1))" $4 $3 $2
        ;;
    esac
}


setup_arrays ()
{
  local dim n elem

  let "dim1 = $1 - 1"
  elem=$dim1

  for n in $(seq 0 $dim1)
  do
   let "Rod1[$elem] = 2 * $n + 1"
   Rod2[$n]=0
   Rod3[$n]=0
   ((elem--))
  done
}


###   Main   ###

setup_arrays $DISKS
echo; echo "+  Start Position"

case $# in
    1) case $(($1&gt;0)) in     # Must have at least one disk.
       1)
           disks=$1
           dohanoi $1 1 3 2
#          Total moves = 2^n - 1, where n = number of disks.
	   echo
           exit 0;
           ;;
       *)
           echo "$0: Illegal value for number of disks";
           exit $E_BADPARAM;
           ;;
       esac
    ;;
    *)
       clear
       echo "usage: $0 N"
       echo "       Where \"N\" is the number of disks."
       exit $E_NOPARAM;
       ;;
esac

exit $E_NOEXIT   # Shouldn't exit here.

# Note:
# Redirect script output to a file, otherwise it scrolls off display.
</programlisting>
    </example>

    <para><anchor xml:id="hanoi2aref" /></para>
    <example xml:id="hanoi2a">
            <title><firstterm>The Towers of Hanoi, alternate graphic
	        version</firstterm></title>
       <programlisting>#! /bin/bash
# The Towers Of Hanoi
# Original script (hanoi.bash) copyright (C) 2000 Amit Singh.
# All Rights Reserved.
# http://hanoi.kernelthread.com

#  hanoi2.bash
#  Version 2: modded for ASCII-graphic display.
#  Uses code contributed by Antonio Macchi,
#+ with heavy editing by ABS Guide author.
#  This variant also falls under the original copyright, see above.
#  Used in ABS Guide with Amit Singh's permission (thanks!).


#   Variables   #
E_NOPARAM=86
E_BADPARAM=87   # Illegal no. of disks passed to script.
E_NOEXIT=88
DELAY=2         # Interval, in seconds, between moves. Change, if desired.
DISKS=$1
Moves=0

MWIDTH=7
MARGIN=2
# Arbitrary "magic" constants, work okay for relatively small # of disks.
# BASEWIDTH=51   # Original code.
let "basewidth = $MWIDTH * $DISKS + $MARGIN" # "Base" beneath rods.
# Above "algorithm" could likely stand improvement.

# Display variables.
let "disks1 = $DISKS - 1"
let "spaces1 = $DISKS" 
let "spaces2 = 2 * $DISKS" 

let "lastmove_t = $DISKS - 1"                # Final move?


declare -a Rod1 Rod2 Rod3

#################


function repeat  {  # $1=char $2=number of repetitions
  local n           # Repeat-print a character.
  
  for (( n=0; n&lt;$2; n++ )); do
    echo -n "$1"
  done
}

function FromRod  {
  local rod summit weight sequence

  while true; do
    rod=$1
    test ${rod/[^123]/} || continue

    sequence=$(echo $(seq 0 $disks1 | tac))
    for summit in $sequence; do
      eval weight=\${Rod${rod}[$summit]}
      test $weight -ne 0 &amp;&amp;
           { echo "$rod $summit $weight"; return; }
    done
  done
}


function ToRod  { # $1=previous (FromRod) weight
  local rod firstfree weight sequence
  
  while true; do
    rod=$2
    test ${rod/[^123]} || continue

    sequence=$(echo $(seq 0 $disks1 | tac))
    for firstfree in $sequence; do
      eval weight=\${Rod${rod}[$firstfree]}
      test $weight -gt 0 &amp;&amp; { (( firstfree++ )); break; }
    done
    test $weight -gt $1 -o $firstfree = 0 &amp;&amp;
         { echo "$rod $firstfree"; return; }
  done
}


function PrintRods  {
  local disk rod empty fill sp sequence

  tput cup 5 0

  repeat " " $spaces1
  echo -n "|"
  repeat " " $spaces2
  echo -n "|"
  repeat " " $spaces2
  echo "|"

  sequence=$(echo $(seq 0 $disks1 | tac))
  for disk in $sequence; do
    for rod in {1..3}; do
      eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) ))
      eval fill=\${Rod${rod}[$disk]}
      repeat " " $empty
      test $fill -gt 0 &amp;&amp; repeat "*" $fill || echo -n "|"
      repeat " " $empty
    done
    echo
  done
  repeat "=" $basewidth   # Print "base" beneath rods.
  echo
}


display ()
{
  echo
  PrintRods

  # Get rod-number, summit and weight
  first=( `FromRod $1` )
  eval Rod${first[0]}[${first[1]}]=0

  # Get rod-number and first-free position
  second=( `ToRod ${first[2]} $2` )
  eval Rod${second[0]}[${second[1]}]=${first[2]}


  if [ "${Rod3[lastmove_t]}" = 1 ]
  then   # Last move? If yes, then display final position.
    tput cup 0 0
    echo; echo "+  Final Position: $Moves moves"
    PrintRods
  fi

  sleep $DELAY
}

# From here down, almost the same as original (hanoi.bash) script.

dohanoi() {   # Recursive function.
    case $1 in
    0)
        ;;
    *)
        dohanoi "$(($1-1))" $2 $4 $3
	if [ "$Moves" -ne 0 ]
        then
	  tput cup 0 0
	  echo; echo "+  Position after move $Moves"
        fi
        ((Moves++))
        echo -n "   Next move will be:  "
        echo $2 "--&gt;" $3
        display $2 $3
        dohanoi "$(($1-1))" $4 $3 $2
        ;;
    esac
}

setup_arrays ()
{
  local dim n elem

  let "dim1 = $1 - 1"
  elem=$dim1

  for n in $(seq 0 $dim1)
  do
   let "Rod1[$elem] = 2 * $n + 1"
   Rod2[$n]=0
   Rod3[$n]=0
   ((elem--))
  done
}


###   Main   ###

trap "tput cnorm" 0
tput civis
clear

setup_arrays $DISKS

tput cup 0 0
echo; echo "+  Start Position"

case $# in
    1) case $(($1&gt;0)) in     # Must have at least one disk.
       1)
           disks=$1
           dohanoi $1 1 3 2
#          Total moves = 2^n - 1, where n = # of disks.
	   echo
           exit 0;
           ;;
       *)
           echo "$0: Illegal value for number of disks";
           exit $E_BADPARAM;
           ;;
       esac
    ;;
    *)
       echo "usage: $0 N"
       echo "       Where \"N\" is the number of disks."
       exit $E_NOPARAM;
       ;;
esac

exit $E_NOEXIT   # Shouldn't exit here.

#  Exercise:
#  --------
#  There is a minor bug in the script that causes the display of
#+ the next-to-last move to be skipped.
#+ Fix this.
</programlisting>
    </example>

    <example xml:id="usegetopt">
      <title>An alternate version of the
      <link linkend="getoptsimple">getopt-simple.sh</link> script</title>
      <programlisting>#!/bin/bash
# UseGetOpt.sh

# Author: Peggy Russell &lt;prusselltechgroup@gmail.com&gt;

UseGetOpt () {
  declare inputOptions
  declare -r E_OPTERR=85
  declare -r ScriptName=${0##*/}
  declare -r ShortOpts="adf:hlt"
  declare -r LongOpts="aoption,debug,file:,help,log,test"

DoSomething () {
    echo "The function name is '${FUNCNAME}'"
    #  Recall that $FUNCNAME is an internal variable
    #+ holding the name of the function it is in.
  }

  inputOptions=$(getopt -o "${ShortOpts}" --long \
              "${LongOpts}" --name "${ScriptName}" -- "${@}")

  if [[ ($? -ne 0) || ($# -eq 0) ]]; then
    echo "Usage: ${ScriptName} [-dhlt] {OPTION...}"
    exit $E_OPTERR
  fi

  eval set -- "${inputOptions}"

  # Only for educational purposes. Can be removed.
  #-----------------------------------------------
  echo "++ Test: Number of arguments: [$#]"
  echo '++ Test: Looping through "$@"'
  for a in "$@"; do
    echo "  ++ [$a]"
  done
  #-----------------------------------------------

  while true; do
    case "${1}" in
      --aoption | -a)  # Argument found.
        echo "Option [$1]"
        ;;

      --debug | -d)    # Enable informational messages.
        echo "Option [$1] Debugging enabled"
        ;;

      --file | -f)     #  Check for optional argument.
        case "$2" in   #+ Double colon is optional argument.
          "")          #  Not there.
              echo "Option [$1] Use default"
              shift
              ;;

          *) # Got it
             echo "Option [$1] Using input [$2]"
             shift
             ;;

        esac
        DoSomething
        ;;

      --log | -l) # Enable Logging.
        echo "Option [$1] Logging enabled"
        ;;

      --test | -t) # Enable testing.
        echo "Option [$1] Testing enabled"
        ;;

      --help | -h)
        echo "Option [$1] Display help"
        break
        ;;

      --)   # Done! $# is argument number for "--", $@ is "--"
        echo "Option [$1] Dash Dash"
        break
        ;;

       *)
        echo "Major internal error!"
        exit 8
        ;;

    esac
    echo "Number of arguments: [$#]"
    shift
  done

  shift
  # Only for educational purposes. Can be removed.
  #----------------------------------------------------------------------
  echo "++ Test: Number of arguments after \"--\" is [$#] They are: [$@]"
  echo '++ Test: Looping through "$@"'
  for a in "$@"; do
    echo "  ++ [$a]"
  done
  #----------------------------------------------------------------------
  
}

################################### M A I N ########################
#  If you remove "function UseGetOpt () {" and corresponding "}",
#+ you can uncomment the "exit 0" line below, and invoke this script
#+ with the various options from the command-line.
#-------------------------------------------------------------------
# exit 0

echo "Test 1"
UseGetOpt -f myfile one "two three" four

echo;echo "Test 2"
UseGetOpt -h

echo;echo "Test 3 - Short Options"
UseGetOpt -adltf myfile  anotherfile

echo;echo "Test 4 - Long Options"
UseGetOpt --aoption --debug --log --test --file myfile anotherfile

exit
</programlisting>
    </example>

    <example xml:id="usegetopt2">
      <title>The version of the
      <firstterm>UseGetOpt.sh</firstterm> example used in the <link linkend="tabexpansion">Tab Expansion appendix</link></title>
      <programlisting>#!/bin/bash

#  UseGetOpt-2.sh
#  Modified version of the script for illustrating tab-expansion
#+ of command-line options.
#  See the "Introduction to Tab Expansion" appendix.

#  Possible options: -a -d -f -l -t -h
#+                   --aoption, --debug --file --log --test -- help --

#  Author of original script: Peggy Russell &lt;prusselltechgroup@gmail.com&gt;


# UseGetOpt () {
  declare inputOptions
  declare -r E_OPTERR=85
  declare -r ScriptName=${0##*/}
  declare -r ShortOpts="adf:hlt"
  declare -r LongOpts="aoption,debug,file:,help,log,test"

DoSomething () {
    echo "The function name is '${FUNCNAME}'"
  }

  inputOptions=$(getopt -o "${ShortOpts}" --long \
              "${LongOpts}" --name "${ScriptName}" -- "${@}")

  if [[ ($? -ne 0) || ($# -eq 0) ]]; then
    echo "Usage: ${ScriptName} [-dhlt] {OPTION...}"
    exit $E_OPTERR
  fi

  eval set -- "${inputOptions}"


  while true; do
    case "${1}" in
      --aoption | -a)  # Argument found.
        echo "Option [$1]"
        ;;

      --debug | -d)    # Enable informational messages.
        echo "Option [$1] Debugging enabled"
        ;;

      --file | -f)     #  Check for optional argument.
        case "$2" in   #+ Double colon is optional argument.
          "")          #  Not there.
              echo "Option [$1] Use default"
              shift
              ;;

          *) # Got it
             echo "Option [$1] Using input [$2]"
             shift
             ;;

        esac
        DoSomething
        ;;

      --log | -l) # Enable Logging.
        echo "Option [$1] Logging enabled"
        ;;

      --test | -t) # Enable testing.
        echo "Option [$1] Testing enabled"
        ;;

      --help | -h)
        echo "Option [$1] Display help"
        break
        ;;

      --)   # Done! $# is argument number for "--", $@ is "--"
        echo "Option [$1] Dash Dash"
        break
        ;;

       *)
        echo "Major internal error!"
        exit 8
        ;;

    esac
    echo "Number of arguments: [$#]"
    shift
  done

  shift
  
#  }

exit
</programlisting>
    </example>

    <example xml:id="showallc">
      <title>Cycling through all the possible color backgrounds</title>
      <programlisting>#!/bin/bash

# show-all-colors.sh
# Displays all 256 possible background colors, using ANSI escape sequences.
# Author: Chetankumar Phulpagare
# Used in ABS Guide with permission.

T1=8
T2=6
T3=36
offset=0

for num1 in {0..7}
do {
   for num2 in {0,1}
       do {
          shownum=`echo "$offset + $T1 * ${num2} + $num1" | bc`
          echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
          }
       done
   echo
   }
done

offset=16
for num1 in {0..5}
do {
   for num2 in {0..5}
       do {
          for num3 in {0..5}
              do {
                 shownum=`echo "$offset + $T2 * ${num3} \
                 + $num2 + $T3 * ${num1}" | bc`
                 echo -en "\E[0;48;5;${shownum}m color ${shownum} \E[0m"
                 }
               done
          echo
          }
       done
}
done

offset=232
for num1 in {0..23}
do {
   shownum=`expr $offset + $num1`
   echo -en "\E[0;48;5;${shownum}m ${shownum}\E[0m"
}
done

echo
</programlisting>
    </example>

    <example xml:id="samorse">
      <title>Morse Code Practice</title>
      <programlisting>#!/bin/bash
# sam.sh, v. .01a
# Still Another Morse (code training script)
# With profuse apologies to Sam (F.B.) Morse.
# Author: Mendel Cooper
# License: GPL3
# Reldate: 05/25/11

# Morse code training script.
# Converts arguments to audible dots and dashes.
# Note: lowercase input only at this time.



# Get the wav files from the source tarball:
# http://bash.deta.in/abs-guide-latest.tar.bz2
DOT='soundfiles/dot.wav'
DASH='soundfiles/dash.wav'
# Maybe move soundfiles to /usr/local/sounds?

LETTERSPACE=300000  # Microseconds.
WORDSPACE=980000
# Nice and slow, for beginners. Maybe 5 wpm?

EXIT_MSG="May the Morse be with you!"
E_NOARGS=75         # No command-line args?



declare -A morse    # Associative array!
# ======================================= #
morse[a]="dot; dash"
morse[b]="dash; dot; dot; dot"
morse[c]="dash; dot; dash; dot"
morse[d]="dash; dot; dot"
morse[e]="dot"
morse[f]="dot; dot; dash; dot"
morse[g]="dash; dash; dot"
morse[h]="dot; dot; dot; dot"
morse[i]="dot; dot;"
morse[j]="dot; dash; dash; dash"
morse[k]="dash; dot; dash"
morse[l]="dot; dash; dot; dot"
morse[m]="dash; dash"
morse[n]="dash; dot"
morse[o]="dash; dash; dash"
morse[p]="dot; dash; dash; dot"
morse[q]="dash; dash; dot; dash"
morse[r]="dot; dash; dot"
morse[s]="dot; dot; dot"
morse[t]="dash"
morse[u]="dot; dot; dash"
morse[v]="dot; dot; dot; dash"
morse[w]="dot; dash; dash"
morse[x]="dash; dot; dot; dash"
morse[y]="dash; dot; dash; dash"
morse[z]="dash; dash; dot; dot"
morse[0]="dash; dash; dash; dash; dash"
morse[1]="dot; dash; dash; dash; dash"
morse[2]="dot; dot; dash; dash; dash"
morse[3]="dot; dot; dot; dash; dash"
morse[4]="dot; dot; dot; dot; dash"
morse[5]="dot; dot; dot; dot; dot"
morse[6]="dash; dot; dot; dot; dot"
morse[7]="dash; dash; dot; dot; dot"
morse[8]="dash; dash; dash; dot; dot"
morse[9]="dash; dash; dash; dash; dot"
# The following must be escaped or quoted.
morse[?]="dot; dot; dash; dash; dot; dot"
morse[.]="dot; dash; dot; dash; dot; dash"
morse[,]="dash; dash; dot; dot; dash; dash"
morse[/]="dash; dot; dot; dash; dot"
morse[\@]="dot; dash; dash; dot; dash; dot"
# ======================================= #

play_letter ()
{
  eval ${morse[$1]}   # Play dots, dashes from appropriate sound files.
  # Why is 'eval' necessary here?
  usleep $LETTERSPACE # Pause in between letters.
}

extract_letters ()
{                     # Slice string apart, letter by letter.
  local pos=0         # Starting at left end of string.
  local len=1         # One letter at a time.
  strlen=${#1}

  while [ $pos -lt $strlen ]
  do
    letter=${1:pos:len}
    #      ^^^^^^^^^^^^    See Chapter 10.1.
    play_letter $letter
    echo -n "*"       #    Mark letter just played.
    ((pos++))
  done
}

######### Play the sounds ############
dot()  { aplay "$DOT" 2&amp;&gt;/dev/null;  }
dash() { aplay "$DASH" 2&amp;&gt;/dev/null; }
######################################

no_args ()
{
    declare -a usage
    usage=( $0 word1 word2 ... )

    echo "Usage:"; echo
    echo ${usage[*]}
    for index in 0 1 2 3
    do
      extract_letters ${usage[index]}     
      usleep $WORDSPACE
      echo -n " "     # Print space between words.
    done
#   echo "Usage: $0 word1 word2 ... "
    echo; echo
}


# int main()
# {

clear                 # Clear the terminal screen.
echo "            SAM"
echo "Still Another Morse code trainer"
echo "    Author: Mendel Cooper"
echo; echo;

if [ -z "$1" ]
then
  no_args
  echo; echo; echo "$EXIT_MSG"; echo
  exit $E_NOARGS
fi

echo; echo "$*"       # Print text that will be played.

until [ -z "$1" ]
do
  extract_letters $1
  shift           # On to next word.
  usleep $WORDSPACE
  echo -n " "     # Print space between words.
done

echo; echo; echo "$EXIT_MSG"; echo

exit 0
# }

#  Exercises:
#  ---------
#  1) Have the script accept either lowercase or uppercase words
#+    as arguments. Hint: Use 'tr' . . .
#  2) Have the script optionally accept input from a text file.
</programlisting>
    </example>

    <example xml:id="base64">
      <title>Base64 encoding/decoding</title>
      <programlisting>#!/bin/bash
# base64.sh: Bash implementation of Base64 encoding and decoding.
#
# Copyright (c) 2011 vladz &lt;vladz@devzero.fr&gt;
# Used in ABSG with permission (thanks!).
#
#  Encode or decode original Base64 (and also Base64url)
#+ from STDIN to STDOUT.
#
#    Usage:
#
#    Encode
#    $ ./base64.sh &lt; binary-file &gt; binary-file.base64
#    Decode
#    $ ./base64.sh -d &lt; binary-file.base64 &gt; binary-file
#
# Reference:
#
#    [1]  RFC4648 - "The Base16, Base32, and Base64 Data Encodings"
#         http://tools.ietf.org/html/rfc4648#section-5


# The base64_charset[] array contains entire base64 charset,
# and additionally the character "=" ...
base64_charset=( {A..Z} {a..z} {0..9} + / = )
                # Nice illustration of brace expansion.

#  Uncomment the ### line below to use base64url encoding instead of
#+ original base64.
### base64_charset=( {A..Z} {a..z} {0..9} - _ = )

#  Output text width when encoding
#+ (64 characters, just like openssl output).
text_width=64

function display_base64_char {
#  Convert a 6-bit number (between 0 and 63) into its corresponding values
#+ in Base64, then display the result with the specified text width.
  printf "${base64_charset[$1]}"; (( width++ ))
  (( width % text_width == 0 )) &amp;&amp; printf "\n"
}

function encode_base64 {
# Encode three 8-bit hexadecimal codes into four 6-bit numbers.
  #    We need two local int array variables:
  #    c8[]: to store the codes of the 8-bit characters to encode
  #    c6[]: to store the corresponding encoded values on 6-bit
  declare -a -i c8 c6

  #  Convert hexadecimal to decimal.
  c8=( $(printf "ibase=16; ${1:0:2}\n${1:2:2}\n${1:4:2}\n" | bc) )

  #  Let's play with bitwise operators
  #+ (3x8-bit into 4x6-bits conversion).
  (( c6[0] = c8[0] &gt;&gt; 2 ))
  (( c6[1] = ((c8[0] &amp;  3) &lt;&lt; 4) | (c8[1] &gt;&gt; 4) ))

  # The following operations depend on the c8 element number.
  case ${#c8[*]} in 
    3) (( c6[2] = ((c8[1] &amp; 15) &lt;&lt; 2) | (c8[2] &gt;&gt; 6) ))
       (( c6[3] = c8[2] &amp; 63 )) ;;
    2) (( c6[2] = (c8[1] &amp; 15) &lt;&lt; 2 ))
       (( c6[3] = 64 )) ;;
    1) (( c6[2] = c6[3] = 64 )) ;;
  esac

  for char in ${c6[@]}; do
    display_base64_char ${char}
  done
}

function decode_base64 {
# Decode four base64 characters into three hexadecimal ASCII characters.
  #  c8[]: to store the codes of the 8-bit characters
  #  c6[]: to store the corresponding Base64 values on 6-bit
  declare -a -i c8 c6

  # Find decimal value corresponding to the current base64 character.
  for current_char in ${1:0:1} ${1:1:1} ${1:2:1} ${1:3:1}; do
     [ "${current_char}" = "=" ] &amp;&amp; break

     position=0
     while [ "${current_char}" != "${base64_charset[${position}]}" ]; do
        (( position++ ))
     done

     c6=( ${c6[*]} ${position} )
  done

  #  Let's play with bitwise operators
  #+ (4x8-bit into 3x6-bits conversion).
  (( c8[0] = (c6[0] &lt;&lt; 2) | (c6[1] &gt;&gt; 4) ))

  # The next operations depends on the c6 elements number.
  case ${#c6[*]} in
    3) (( c8[1] = ( (c6[1] &amp; 15) &lt;&lt; 4) | (c6[2] &gt;&gt; 2) ))
       (( c8[2] = (c6[2] &amp; 3) &lt;&lt; 6 )); unset c8[2] ;;
    4) (( c8[1] = ( (c6[1] &amp; 15) &lt;&lt; 4) | (c6[2] &gt;&gt; 2) ))
       (( c8[2] = ( (c6[2] &amp;  3) &lt;&lt; 6) |  c6[3] )) ;;
  esac

  for char in ${c8[*]}; do
     printf "\x$(printf "%x" ${char})"
  done
}


# main ()

if [ "$1" = "-d" ]; then   # decode

  # Reformat STDIN in pseudo 4x6-bit groups.
  content=$(cat - | tr -d "\n" | sed -r "s/(.{4})/\1 /g")

  for chars in ${content}; do decode_base64 ${chars}; done

else
  # Make a hexdump of stdin and reformat in 3-byte groups.
  content=$(cat - | xxd -ps -u | sed -r "s/(\w{6})/\1 /g" |
            tr -d "\n")

  for chars in ${content}; do encode_base64 ${chars}; done

  echo

fi
</programlisting>
    </example>

    <example xml:id="sedappend">
       <title>Inserting text in a file using
       <firstterm>sed</firstterm></title>
      <programlisting>#!/bin/bash
#  Prepends a string at a specified line
#+ in files with names ending in "sample"
#+ in the current working directory.
#  000000000000000000000000000000000000
#  This script overwrites files!
#  Be careful running it in a directory
#+ where you have important files!!!
#  000000000000000000000000000000000000

#  Create a couple of files to operate on ...
#  01sample
#  02sample
#  ... etc.
#  These files must not be empty, else the prepend will not work.

lineno=1            # Append at line 1 (prepend).
filespec="*sample"  # Filename pattern to operate on.

string=$(whoami)    # Will set your username as string to insert.
                    # It could just as easily be any other string.

for file in $filespec # Specify which files to alter.
do #        ^^^^^^^^^
 sed -i ""$lineno"i "$string"" $file
#    ^^ -i option edits files in-place.
#                 ^ Insert (i) command.
 echo ""$file" altered!"
done

echo "Warning: files possibly clobbered!"

exit 0

# Exercise:
# Add error checking to this script.
# It needs it badly.
</programlisting>
    </example>

    <example xml:id="gronsfeld">
      <title>The Gronsfeld Cipher</title>
      <programlisting>#!/bin/bash
# gronsfeld.bash

# License: GPL3
# Reldate 06/23/11

#  This is an implementation of the Gronsfeld Cipher.
#  It's essentially a stripped-down variant of the 
#+ polyalphabetic VigenÃ¨re Tableau, but with only 10 alphabets.
#  The classic Gronsfeld has a numeric sequence as the key word,
#+ but here we substitute a letter string, for ease of use.
#  Allegedly, this cipher was invented by the eponymous Count Gronsfeld
#+ in the 17th Century. It was at one time considered to be unbreakable.
#  Note that this is ###not### a secure cipher by modern standards.

#  Global Variables  #
Enc_suffix="29379"   #  Encrypted text output with this 5-digit suffix. 
                     #  This functions as a decryption flag,
                     #+ and when used to generate passwords adds security.
Default_key="gronsfeldk"
                     #  The script uses this if key not entered below
                     #  (at "Keychain").
                     #  Change the above two values frequently
                     #+ for added security.

GROUPLEN=5           #  Output in groups of 5 letters, per tradition.
alpha1=( abcdefghijklmnopqrstuvwxyz )
alpha2=( {A..Z} )    #  Output in all caps, per tradition.
                     #  Use   alpha2=( {a..z} )   for password generator.
wraplen=26           #  Wrap around if past end of alphabet.
dflag=               #  Decrypt flag (set if $Enc_suffix present).
E_NOARGS=76          #  Missing command-line args?
DEBUG=77             #  Debugging flag.
declare -a offsets   #  This array holds the numeric shift values for
                     #+ encryption/decryption.

########Keychain#########
key=  ### Put key here!!!
      # 10 characters!
#########################



# Function
: ()
{ # Encrypt or decrypt, depending on whether $dflag is set.
  # Why ": ()" as a function name? Just to prove that it can be done.

  local idx keydx mlen off1 shft
  local plaintext="$1"
  local mlen=${#plaintext}

for (( idx=0; idx&lt;$mlen; idx++ ))
do
  let "keydx = $idx % $keylen"
  shft=${offsets[keydx]}

  if [ -n "$dflag" ]
  then                  # Decrypt!
    let "off1 = $(expr index "${alpha1[*]}" ${plaintext:idx:1}) - $shft"
    # Shift backward to decrypt.
  else                  # Encrypt!
    let "off1 = $(expr index "${alpha1[*]}" ${plaintext:idx:1}) + $shft"
    # Shift forward to encrypt.
    test $(( $idx % $GROUPLEN)) = 0 &amp;&amp; echo -n " "  # Groups of 5 letters.
    #  Comment out above line for output as a string without whitespace,
    #+ for example, if using the script as a password generator.
  fi

  ((off1--))   # Normalize. Why is this necessary?

      if [ $off1 -lt 0 ]
      then     # Catch negative indices.
        let "off1 += $wraplen"
      fi

  ((off1 %= $wraplen))   # Wrap around if past end of alphabet.

  echo -n "${alpha2[off1]}"

done

  if [ -z "$dflag" ]
  then
    echo " $Enc_suffix"
#   echo "$Enc_suffix"  # For password generator.
  else
    echo
  fi
} # End encrypt/decrypt function.



# int main () {

# Check for command-line args.
if [ -z "$1" ]
then
   echo "Usage: $0 TEXT TO ENCODE/DECODE"
   exit $E_NOARGS
fi

if [ ${!#} == "$Enc_suffix" ]
#    ^^^^^ Final command-line arg.
then
  dflag=ON
  echo -n "+"           # Flag decrypted text with a "+" for easy ID.
fi

if [ -z "$key" ]
then
  key="$Default_key"    # "gronsfeldk" per above.
fi

keylen=${#key}

for (( idx=0; idx&lt;$keylen; idx++ ))
do  # Calculate shift values for encryption/decryption.
  offsets[idx]=$(expr index "${alpha1[*]}" ${key:idx:1})   # Normalize.
  ((offsets[idx]--))  #  Necessary because "expr index" starts at 1,
                      #+ whereas array count starts at 0.
  # Generate array of numerical offsets corresponding to the key.
  # There are simpler ways to accomplish this.
done

args=$(echo "$*" | sed -e 's/ //g' | tr A-Z a-z | sed -e 's/[0-9]//g')
# Remove whitespace and digits from command-line args.
# Can modify to also remove punctuation characters, if desired.

         # Debug:
         # echo "$args"; exit $DEBUG

: "$args"               # Call the function named ":".
# : is a null operator, except . . . when it's a function name!

exit $?    # } End-of-script


#   **************************************************************   #
#   This script can function as a  password generator,
#+  with several minor mods, see above.
#   That would allow an easy-to-remember password, even the word
#+ "password" itself, which encrypts to vrgfotvo29379
#+  a fairly secure password not susceptible to a dictionary attack.
#   Or, you could use your own name (surely that's easy to remember!).
#   For example, Bozo Bozeman encrypts to hfnbttdppkt29379.
#   **************************************************************   #
</programlisting>
    </example>

    <example xml:id="bingo">
      <title>Bingo Number Generator</title>
      <programlisting>#!/bin/bash
# bingo.sh
# Bingo number generator
# Reldate 20Aug12, License: Public Domain

#######################################################################
# This script generates bingo numbers.
# Hitting a key generates a new number.
# Hitting 'q' terminates the script.
# In a given run of the script, there will be no duplicate numbers.
# When the script terminates, it prints a log of the numbers generated.
#######################################################################

MIN=1       # Lowest allowable bingo number.
MAX=75      # Highest allowable bingo number.
COLS=15     # Numbers in each column (B I N G O).
SINGLE_DIGIT_MAX=9

declare -a Numbers
Prefix=(B I N G O)

initialize_Numbers ()
{  # Zero them out to start.
   # They'll be incremented if chosen.
   local index=0
   until [ "$index" -gt $MAX ]
   do
     Numbers[index]=0
     ((index++))
   done

   Numbers[0]=1   # Flag zero, so it won't be selected.
}


generate_number ()
{
   local number

   while [ 1 ]
   do
     let "number = $(expr $RANDOM % $MAX)"
     if [ ${Numbers[number]} -eq 0 ]    # Number not yet called.
     then
       let "Numbers[number]+=1"         # Flag it in the array.
       break                            # And terminate loop.
     fi   # Else if already called, loop and generate another number.
   done
   # Exercise: Rewrite this more elegantly as an until-loop.

   return $number
}


print_numbers_called ()
{   # Print out the called number log in neat columns.
    # echo ${Numbers[@]}

local pre2=0                #  Prefix a zero, so columns will align
                            #+ on single-digit numbers.

echo "Number Stats"

for (( index=1; index&lt;=MAX; index++))
do
  count=${Numbers[index]}
  let "t = $index - 1"      # Normalize, since array begins with index 0.
  let "column = $(expr $t / $COLS)"
  pre=${Prefix[column]}
# echo -n "${Prefix[column]} "

if [ $(expr $t % $COLS) -eq 0 ]
then
  echo   # Newline at end of row.
fi

  if [ "$index" -gt $SINGLE_DIGIT_MAX ]  # Check for single-digit number.
  then
    echo -n "$pre$index#$count "
  else    # Prefix a zero.
    echo -n "$pre$pre2$index#$count "
  fi

done
}



# main () {
RANDOM=$$   # Seed random number generator.

initialize_Numbers   # Zero out the number tracking array.

clear
echo "Bingo Number Caller"; echo

while [[ "$key" != "q" ]]   # Main loop.
do
  read -s -n1 -p "Hit a key for the next number [q to exit] " key
  # Usually 'q' exits, but not always.
  # Can always hit Ctl-C if q fails.
  echo

  generate_number; new_number=$?

  let "column = $(expr $new_number / $COLS)"
  echo -n "${Prefix[column]} "   # B-I-N-G-O

  echo $new_number
done

echo; echo

# Game over ...
print_numbers_called
echo; echo "[#0 = not called . . . #1 = called]"

echo

exit 0
# }


# Certainly, this script could stand some improvement.
#See also the author's Instructable:
#www.instructables.com/id/Binguino-An-Arduino-based-Bingo-Number-Generato/
</programlisting>
    </example>

    <para><anchor xml:id="basicsrev0" />To end this section, a review of the
      basics . . . and more.</para>

    <example xml:id="basicsreviewed">
      <title>Basics Reviewed</title>
      <programlisting>#!/bin/bash
# basics-reviewed.bash

# File extension == *.bash == specific to Bash

#   Copyright (c) Michael S. Zick, 2003; All rights reserved.
#   License: Use in any form, for any purpose.
#   Revision: $ID$
#
#              Edited for layout by M.C.
#   (author of the "Advanced Bash Scripting Guide")
#   Fixes and updates (04/08) by Cliff Bamford.


#  This script tested under Bash versions 2.04, 2.05a and 2.05b.
#  It may not work with earlier versions.
#  This demonstration script generates one --intentional--
#+ "command not found" error message. See line 436.

#  The current Bash maintainer, Chet Ramey, has fixed the items noted
#+ for later versions of Bash.



        ###-------------------------------------------###
        ###  Pipe the output of this script to 'more' ###
        ###+ else it will scroll off the page.        ###
        ###                                           ###
        ###  You may also redirect its output         ###
        ###+ to a file for examination.               ###  
        ###-------------------------------------------###



#  Most of the following points are described at length in
#+ the text of the foregoing "Advanced Bash Scripting Guide."
#  This demonstration script is mostly just a reorganized presentation.
#      -- msz

# Variables are not typed unless otherwise specified.

#  Variables are named. Names must contain a non-digit.
#  File descriptor names (as in, for example: 2&gt;&amp;1)
#+ contain ONLY digits.

# Parameters and Bash array elements are numbered.
# (Parameters are very similar to Bash arrays.)

# A variable name may be undefined (null reference).
unset VarNull

# A variable name may be defined but empty (null contents).
VarEmpty=''                         # Two, adjacent, single quotes.

# A variable name may be defined and non-empty.
VarSomething='Literal'

# A variable may contain:
#   * A whole number as a signed 32-bit (or larger) integer
#   * A string
# A variable may also be an array.

#  A string may contain embedded blanks and may be treated
#+ as if it where a function name with optional arguments.

#  The names of variables and the names of functions
#+ are in different namespaces.


#  A variable may be defined as a Bash array either explicitly or
#+ implicitly by the syntax of the assignment statement.
#  Explicit:
declare -a ArrayVar



# The echo command is a builtin.
echo $VarSomething

# The printf command is a builtin.
# Translate %s as: String-Format
printf %s $VarSomething         # No linebreak specified, none output.
echo                            # Default, only linebreak output.




# The Bash parser word breaks on whitespace.
# Whitespace, or the lack of it is significant.
# (This holds true in general; there are, of course, exceptions.)




# Translate the DOLLAR_SIGN character as: Content-Of.

# Extended-Syntax way of writing Content-Of:
echo ${VarSomething}

#  The ${ ... } Extended-Syntax allows more than just the variable
#+ name to be specified.
#  In general, $VarSomething can always be written as: ${VarSomething}.

# Call this script with arguments to see the following in action.



#  Outside of double-quotes, the special characters @ and *
#+ specify identical behavior.
#  May be pronounced as: All-Elements-Of.

#  Without specification of a name, they refer to the
#+ pre-defined parameter Bash-Array.



# Glob-Pattern references
echo $*                         # All parameters to script or function
echo ${*}                       # Same

# Bash disables filename expansion for Glob-Patterns.
# Only character matching is active.


# All-Elements-Of references
echo $@                         # Same as above
echo ${@}                       # Same as above




#  Within double-quotes, the behavior of Glob-Pattern references
#+ depends on the setting of IFS (Input Field Separator).
#  Within double-quotes, All-Elements-Of references behave the same.


#  Specifying only the name of a variable holding a string refers
#+ to all elements (characters) of a string.


#  To specify an element (character) of a string,
#+ the Extended-Syntax reference notation (see below) MAY be used.




#  Specifying only the name of a Bash array references
#+ the subscript zero element,
#+ NOT the FIRST DEFINED nor the FIRST WITH CONTENTS element.

#  Additional qualification is needed to reference other elements,
#+ which means that the reference MUST be written in Extended-Syntax.
#  The general form is: ${name[subscript]}.

#  The string forms may also be used: ${name:subscript}
#+ for Bash-Arrays when referencing the subscript zero element.


# Bash-Arrays are implemented internally as linked lists,
#+ not as a fixed area of storage as in some programming languages.


#   Characteristics of Bash arrays (Bash-Arrays):
#   --------------------------------------------

#   If not otherwise specified, Bash-Array subscripts begin with
#+  subscript number zero. Literally: [0]
#   This is called zero-based indexing.
###
#   If not otherwise specified, Bash-Arrays are subscript packed
#+  (sequential subscripts without subscript gaps).
###
#   Negative subscripts are not allowed.
###
#   Elements of a Bash-Array need not all be of the same type.
###
#   Elements of a Bash-Array may be undefined (null reference).
#       That is, a Bash-Array may be "subscript sparse."
###
#   Elements of a Bash-Array may be defined and empty (null contents).
###
#   Elements of a Bash-Array may contain:
#     * A whole number as a signed 32-bit (or larger) integer
#     * A string
#     * A string formated so that it appears to be a function name
#     + with optional arguments
###
#   Defined elements of a Bash-Array may be undefined (unset).
#       That is, a subscript packed Bash-Array may be changed
#   +   into a subscript sparse Bash-Array.
###
#   Elements may be added to a Bash-Array by defining an element
#+  not previously defined.
###
# For these reasons, I have been calling them "Bash-Arrays".
# I'll return to the generic term "array" from now on.
#     -- msz


echo "========================================================="

#  Lines 202 - 334 supplied by Cliff Bamford. (Thanks!)
#  Demo --- Interaction with Arrays, quoting, IFS, echo, * and @   ---  
#+ all affect how things work

ArrayVar[0]='zero'                    # 0 normal
ArrayVar[1]=one                       # 1 unquoted literal
ArrayVar[2]='two'                     # 2 normal
ArrayVar[3]='three'                   # 3 normal
ArrayVar[4]='I am four'               # 4 normal with spaces
ArrayVar[5]='five'                    # 5 normal
unset ArrayVar[6]                     # 6 undefined
ArrayValue[7]='seven'                 # 7 normal
ArrayValue[8]=''                      # 8 defined but empty
ArrayValue[9]='nine'                  # 9 normal


echo '--- Here is the array we are using for this test'
echo
echo "ArrayVar[0]='zero'             # 0 normal"
echo "ArrayVar[1]=one                # 1 unquoted literal"
echo "ArrayVar[2]='two'              # 2 normal"
echo "ArrayVar[3]='three'            # 3 normal"
echo "ArrayVar[4]='I am four'        # 4 normal with spaces"
echo "ArrayVar[5]='five'             # 5 normal"
echo "unset ArrayVar[6]              # 6 undefined"
echo "ArrayValue[7]='seven'          # 7 normal"
echo "ArrayValue[8]=''               # 8 defined but empty"
echo "ArrayValue[9]='nine'           # 9 normal"
echo


echo
echo '---Case0: No double-quotes, Default IFS of space,tab,newline ---'
IFS=$'\x20'$'\x09'$'\x0A'            # In exactly this order.
echo 'Here is: printf %q {${ArrayVar[*]}'
printf %q ${ArrayVar[*]}
echo
echo 'Here is: printf %q {${ArrayVar[@]}'
printf %q ${ArrayVar[@]}
echo
echo 'Here is: echo ${ArrayVar[*]}'
echo  ${ArrayVar[@]}
echo 'Here is: echo {${ArrayVar[@]}'
echo ${ArrayVar[@]}

echo
echo '---Case1: Within double-quotes - Default IFS of space-tab- 
newline ---'
IFS=$'\x20'$'\x09'$'\x0A'	    #  These three bytes,
echo 'Here is: printf %q "{${ArrayVar[*]}"'
printf %q "${ArrayVar[*]}"
echo
echo 'Here is: printf %q "{${ArrayVar[@]}"'
printf %q "${ArrayVar[@]}"
echo
echo 'Here is: echo "${ArrayVar[*]}"'
echo  "${ArrayVar[@]}"
echo 'Here is: echo "{${ArrayVar[@]}"'
echo "${ArrayVar[@]}"

echo
echo '---Case2: Within double-quotes - IFS is q'
IFS='q'
echo 'Here is: printf %q "{${ArrayVar[*]}"'
printf %q "${ArrayVar[*]}"
echo
echo 'Here is: printf %q "{${ArrayVar[@]}"'
printf %q "${ArrayVar[@]}"
echo
echo 'Here is: echo "${ArrayVar[*]}"'
echo  "${ArrayVar[@]}"
echo 'Here is: echo "{${ArrayVar[@]}"'
echo "${ArrayVar[@]}"

echo
echo '---Case3: Within double-quotes - IFS is ^'
IFS='^'
echo 'Here is: printf %q "{${ArrayVar[*]}"'
printf %q "${ArrayVar[*]}"
echo
echo 'Here is: printf %q "{${ArrayVar[@]}"'
printf %q "${ArrayVar[@]}"
echo
echo 'Here is: echo "${ArrayVar[*]}"'
echo  "${ArrayVar[@]}"
echo 'Here is: echo "{${ArrayVar[@]}"'
echo "${ArrayVar[@]}"

echo
echo '---Case4: Within double-quotes - IFS is ^ followed by  
space,tab,newline'
IFS=$'^'$'\x20'$'\x09'$'\x0A'       # ^ + space tab newline
echo 'Here is: printf %q "{${ArrayVar[*]}"'
printf %q "${ArrayVar[*]}"
echo
echo 'Here is: printf %q "{${ArrayVar[@]}"'
printf %q "${ArrayVar[@]}"
echo
echo 'Here is: echo "${ArrayVar[*]}"'
echo  "${ArrayVar[@]}"
echo 'Here is: echo "{${ArrayVar[@]}"'
echo "${ArrayVar[@]}"

echo
echo '---Case6: Within double-quotes - IFS set and empty '
IFS=''
echo 'Here is: printf %q "{${ArrayVar[*]}"'
printf %q "${ArrayVar[*]}"
echo
echo 'Here is: printf %q "{${ArrayVar[@]}"'
printf %q "${ArrayVar[@]}"
echo
echo 'Here is: echo "${ArrayVar[*]}"'
echo  "${ArrayVar[@]}"
echo 'Here is: echo "{${ArrayVar[@]}"'
echo "${ArrayVar[@]}"

echo
echo '---Case7: Within double-quotes - IFS is unset'
unset IFS
echo 'Here is: printf %q "{${ArrayVar[*]}"'
printf %q "${ArrayVar[*]}"
echo
echo 'Here is: printf %q "{${ArrayVar[@]}"'
printf %q "${ArrayVar[@]}"
echo
echo 'Here is: echo "${ArrayVar[*]}"'
echo  "${ArrayVar[@]}"
echo 'Here is: echo "{${ArrayVar[@]}"'
echo "${ArrayVar[@]}"

echo
echo '---End of Cases---'
echo "========================================================="; echo



# Put IFS back to the default.
# Default is exactly these three bytes.
IFS=$'\x20'$'\x09'$'\x0A'           # In exactly this order.

# Interpretation of the above outputs:
#   A Glob-Pattern is I/O; the setting of IFS matters.
###
#   An All-Elements-Of does not consider IFS settings.
###
#   Note the different output using the echo command and the
#+  quoted format operator of the printf command.


#  Recall:
#   Parameters are similar to arrays and have the similar behaviors.
###
#  The above examples demonstrate the possible variations.
#  To retain the shape of a sparse array, additional script
#+ programming is required.
###
#  The source code of Bash has a routine to output the
#+ [subscript]=value   array assignment format.
#  As of version 2.05b, that routine is not used,
#+ but that might change in future releases.



# The length of a string, measured in non-null elements (characters):
echo
echo '- - Non-quoted references - -'
echo 'Non-Null character count: '${#VarSomething}' characters.'

# test='Lit'$'\x00''eral'           # $'\x00' is a null character.
# echo ${#test}                     # See that?



#  The length of an array, measured in defined elements,
#+ including null content elements.
echo
echo 'Defined content count: '${#ArrayVar[@]}' elements.'
# That is NOT the maximum subscript (4).
# That is NOT the range of the subscripts (1 . . 4 inclusive).
# It IS the length of the linked list.
###
#  Both the maximum subscript and the range of the subscripts may
#+ be found with additional script programming.

# The length of a string, measured in non-null elements (characters):
echo
echo '- - Quoted, Glob-Pattern references - -'
echo 'Non-Null character count: '"${#VarSomething}"' characters.'

#  The length of an array, measured in defined elements,
#+ including null-content elements.
echo
echo 'Defined element count: '"${#ArrayVar[*]}"' elements.'

#  Interpretation: Substitution does not effect the ${# ... } operation.
#  Suggestion:
#  Always use the All-Elements-Of character
#+ if that is what is intended (independence from IFS).



#  Define a simple function.
#  I include an underscore in the name
#+ to make it distinctive in the examples below.
###
#  Bash separates variable names and function names
#+ in different namespaces.
#  The Mark-One eyeball isn't that advanced.
###
_simple() {
    echo -n 'SimpleFunc'$@          #  Newlines are swallowed in
}                                   #+ result returned in any case.


# The ( ... ) notation invokes a command or function.
# The $( ... ) notation is pronounced: Result-Of.


# Invoke the function _simple
echo
echo '- - Output of function _simple - -'
_simple                             # Try passing arguments.
echo
# or
(_simple)                           # Try passing arguments.
echo

echo '- Is there a variable of that name? -'
echo $_simple not defined           # No variable by that name.

# Invoke the result of function _simple (Error msg intended)

###
$(_simple)                          # Gives an error message:
#                          line 436: SimpleFunc: command not found
#                          ---------------------------------------

echo
###

#  The first word of the result of function _simple
#+ is neither a valid Bash command nor the name of a defined function.
###
# This demonstrates that the output of _simple is subject to evaluation.
###
# Interpretation:
#   A function can be used to generate in-line Bash commands.


# A simple function where the first word of result IS a bash command:
###
_print() {
    echo -n 'printf %q '$@
}

echo '- - Outputs of function _print - -'
_print parm1 parm2                  # An Output NOT A Command.
echo

$(_print parm1 parm2)               #  Executes: printf %q parm1 parm2
                                    #  See above IFS examples for the
                                    #+ various possibilities.
echo

$(_print $VarSomething)             # The predictable result.
echo



# Function variables
# ------------------

echo
echo '- - Function variables - -'
# A variable may represent a signed integer, a string or an array.
# A string may be used like a function name with optional arguments.

# set -vx                           #  Enable if desired
declare -f funcVar                  #+ in namespace of functions

funcVar=_print                      # Contains name of function.
$funcVar parm1                      # Same as _print at this point.
echo

funcVar=$(_print )                  # Contains result of function.
$funcVar                            # No input, No output.
$funcVar $VarSomething              # The predictable result.
echo

funcVar=$(_print $VarSomething)     #  $VarSomething replaced HERE.
$funcVar                            #  The expansion is part of the
echo                                #+ variable contents.

funcVar="$(_print $VarSomething)"   #  $VarSomething replaced HERE.
$funcVar                            #  The expansion is part of the
echo                                #+ variable contents.

#  The difference between the unquoted and the double-quoted versions
#+ above can be seen in the "protect_literal.sh" example.
#  The first case above is processed as two, unquoted, Bash-Words.
#  The second case above is processed as one, quoted, Bash-Word.




# Delayed replacement
# -------------------

echo
echo '- - Delayed replacement - -'
funcVar="$(_print '$VarSomething')" # No replacement, single Bash-Word.
eval $funcVar                       # $VarSomething replaced HERE.
echo

VarSomething='NewThing'
eval $funcVar                       # $VarSomething replaced HERE.
echo

# Restore the original setting trashed above.
VarSomething=Literal

#  There are a pair of functions demonstrated in the
#+ "protect_literal.sh" and "unprotect_literal.sh" examples.
#  These are general purpose functions for delayed replacement literals
#+ containing variables.





# REVIEW:
# ------

#  A string can be considered a Classic-Array of elements (characters).
#  A string operation applies to all elements (characters) of the string
#+ (in concept, anyway).
###
#  The notation: ${array_name[@]} represents all elements of the
#+ Bash-Array: array_name.
###
#  The Extended-Syntax string operations can be applied to all
#+ elements of an array.
###
#  This may be thought of as a For-Each operation on a vector of strings.
###
#  Parameters are similar to an array.
#  The initialization of a parameter array for a script
#+ and a parameter array for a function only differ
#+ in the initialization of ${0}, which never changes its setting.
###
#  Subscript zero of the script's parameter array contains
#+ the name of the script.
###
#  Subscript zero of a function's parameter array DOES NOT contain
#+ the name of the function.
#  The name of the current function is accessed by the $FUNCNAME variable.
###
#  A quick, review list follows (quick, not short).

echo
echo '- - Test (but not change) - -'
echo '- null reference -'
echo -n ${VarNull-'NotSet'}' '          # NotSet
echo ${VarNull}                         # NewLine only
echo -n ${VarNull:-'NotSet'}' '         # NotSet
echo ${VarNull}                         # Newline only

echo '- null contents -'
echo -n ${VarEmpty-'Empty'}' '          # Only the space
echo ${VarEmpty}                        # Newline only
echo -n ${VarEmpty:-'Empty'}' '         # Empty
echo ${VarEmpty}                        # Newline only

echo '- contents -'
echo ${VarSomething-'Content'}          # Literal
echo ${VarSomething:-'Content'}         # Literal

echo '- Sparse Array -'
echo ${ArrayVar[@]-'not set'}

# ASCII-Art time
# State     Y==yes, N==no
#           -       :-
# Unset     Y       Y       ${# ... } == 0
# Empty     N       Y       ${# ... } == 0
# Contents  N       N       ${# ... } &gt; 0

#  Either the first and/or the second part of the tests
#+ may be a command or a function invocation string.
echo
echo '- - Test 1 for undefined - -'
declare -i t
_decT() {
    t=$t-1
}

# Null reference, set: t == -1
t=${#VarNull}                           # Results in zero.
${VarNull- _decT }                      # Function executes, t now -1.
echo $t

# Null contents, set: t == 0
t=${#VarEmpty}                          # Results in zero.
${VarEmpty- _decT }                     # _decT function NOT executed.
echo $t

# Contents, set: t == number of non-null characters
VarSomething='_simple'                  # Set to valid function name.
t=${#VarSomething}                      # non-zero length
${VarSomething- _decT }                 # Function _simple executed.
echo $t                                 # Note the Append-To action.

# Exercise: clean up that example.
unset t
unset _decT
VarSomething=Literal

echo
echo '- - Test and Change - -'
echo '- Assignment if null reference -'
echo -n ${VarNull='NotSet'}' '          # NotSet NotSet
echo ${VarNull}
unset VarNull

echo '- Assignment if null reference -'
echo -n ${VarNull:='NotSet'}' '         # NotSet NotSet
echo ${VarNull}
unset VarNull

echo '- No assignment if null contents -'
echo -n ${VarEmpty='Empty'}' '          # Space only
echo ${VarEmpty}
VarEmpty=''

echo '- Assignment if null contents -'
echo -n ${VarEmpty:='Empty'}' '         # Empty Empty
echo ${VarEmpty}
VarEmpty=''

echo '- No change if already has contents -'
echo ${VarSomething='Content'}          # Literal
echo ${VarSomething:='Content'}         # Literal


# "Subscript sparse" Bash-Arrays
###
#  Bash-Arrays are subscript packed, beginning with
#+ subscript zero unless otherwise specified.
###
#  The initialization of ArrayVar was one way
#+ to "otherwise specify".  Here is the other way:
###
echo
declare -a ArraySparse
ArraySparse=( [1]=one [2]='' [4]='four' )
# [0]=null reference, [2]=null content, [3]=null reference

echo '- - Array-Sparse List - -'
# Within double-quotes, default IFS, Glob-Pattern

IFS=$'\x20'$'\x09'$'\x0A'
printf %q "${ArraySparse[*]}"
echo

#  Note that the output does not distinguish between "null content"
#+ and "null reference".
#  Both print as escaped whitespace.
###
#  Note also that the output does NOT contain escaped whitespace
#+ for the "null reference(s)" prior to the first defined element.
###
# This behavior of 2.04, 2.05a and 2.05b has been reported
#+ and may change in a future version of Bash.

#  To output a sparse array and maintain the [subscript]=value
#+ relationship without change requires a bit of programming.
#  One possible code fragment:
###
# local l=${#ArraySparse[@]}        # Count of defined elements
# local f=0                         # Count of found subscripts
# local i=0                         # Subscript to test
(                                   # Anonymous in-line function
    for (( l=${#ArraySparse[@]}, f = 0, i = 0 ; f &lt; l ; i++ ))
    do
        # 'if defined then...'
        ${ArraySparse[$i]+ eval echo '\ ['$i']='${ArraySparse[$i]} ; (( f++ )) }
    done
)

# The reader coming upon the above code fragment cold
#+ might want to review "command lists" and "multiple commands on a line"
#+ in the text of the foregoing "Advanced Bash Scripting Guide."
###
#  Note:
#  The "read -a array_name" version of the "read" command
#+ begins filling array_name at subscript zero.
#  ArraySparse does not define a value at subscript zero.
###
#  The user needing to read/write a sparse array to either
#+ external storage or a communications socket must invent
#+ a read/write code pair suitable for their purpose.
###
# Exercise: clean it up.

unset ArraySparse

echo
echo '- - Conditional alternate (But not change)- -'
echo '- No alternate if null reference -'
echo -n ${VarNull+'NotSet'}' '
echo ${VarNull}
unset VarNull

echo '- No alternate if null reference -'
echo -n ${VarNull:+'NotSet'}' '
echo ${VarNull}
unset VarNull

echo '- Alternate if null contents -'
echo -n ${VarEmpty+'Empty'}' '              # Empty
echo ${VarEmpty}
VarEmpty=''

echo '- No alternate if null contents -'
echo -n ${VarEmpty:+'Empty'}' '             # Space only
echo ${VarEmpty}
VarEmpty=''

echo '- Alternate if already has contents -'

# Alternate literal
echo -n ${VarSomething+'Content'}' '        # Content Literal
echo ${VarSomething}

# Invoke function
echo -n ${VarSomething:+ $(_simple) }' '    # SimpleFunc Literal
echo ${VarSomething}
echo

echo '- - Sparse Array - -'
echo ${ArrayVar[@]+'Empty'}                 # An array of 'Empty'(ies)
echo

echo '- - Test 2 for undefined - -'

declare -i t
_incT() {
    t=$t+1
}

#  Note:
#  This is the same test used in the sparse array
#+ listing code fragment.

# Null reference, set: t == -1
t=${#VarNull}-1                     # Results in minus-one.
${VarNull+ _incT }                  # Does not execute.
echo $t' Null reference'

# Null contents, set: t == 0
t=${#VarEmpty}-1                    # Results in minus-one.
${VarEmpty+ _incT }                 # Executes.
echo $t'  Null content'

# Contents, set: t == (number of non-null characters)
t=${#VarSomething}-1                # non-null length minus-one
${VarSomething+ _incT }             # Executes.
echo $t'  Contents'

# Exercise: clean up that example.
unset t
unset _incT

# ${name?err_msg} ${name:?err_msg}
#  These follow the same rules but always exit afterwards
#+ if an action is specified following the question mark.
#  The action following the question mark may be a literal
#+ or a function result.
###
#  ${name?} ${name:?} are test-only, the return can be tested.




# Element operations
# ------------------

echo
echo '- - Trailing sub-element selection - -'

#  Strings, Arrays and Positional parameters

#  Call this script with multiple arguments
#+ to see the parameter selections.

echo '- All -'
echo ${VarSomething:0}              # all non-null characters
echo ${ArrayVar[@]:0}               # all elements with content
echo ${@:0}                         # all parameters with content;
                                    # ignoring parameter[0]

echo
echo '- All after -'
echo ${VarSomething:1}              # all non-null after character[0]
echo ${ArrayVar[@]:1}               # all after element[0] with content
echo ${@:2}                         # all after param[1] with content

echo
echo '- Range after -'
echo ${VarSomething:4:3}            # ral
                                    # Three characters after
                                    # character[3]

echo '- Sparse array gotch -'
echo ${ArrayVar[@]:1:2}     #  four - The only element with content.
                            #  Two elements after (if that many exist).
                            #  the FIRST WITH CONTENTS
                            #+ (the FIRST WITH  CONTENTS is being
                            #+ considered as if it
                            #+ were subscript zero).
#  Executed as if Bash considers ONLY array elements with CONTENT
#  printf %q "${ArrayVar[@]:0:3}"    # Try this one

#  In versions 2.04, 2.05a and 2.05b,
#+ Bash does not handle sparse arrays as expected using this notation.
#
#  The current Bash maintainer, Chet Ramey, has corrected this.


echo '- Non-sparse array -'
echo ${@:2:2}               # Two parameters following parameter[1]

# New victims for string vector examples:
stringZ=abcABC123ABCabc
arrayZ=( abcabc ABCABC 123123 ABCABC abcabc )
sparseZ=( [1]='abcabc' [3]='ABCABC' [4]='' [5]='123123' )

echo
echo ' - - Victim string - -'$stringZ'- - '
echo ' - - Victim array - -'${arrayZ[@]}'- - '
echo ' - - Sparse array - -'${sparseZ[@]}'- - '
echo ' - [0]==null ref, [2]==null ref, [4]==null content - '
echo ' - [1]=abcabc [3]=ABCABC [5]=123123 - '
echo ' - non-null-reference count: '${#sparseZ[@]}' elements'

echo
echo '- - Prefix sub-element removal - -'
echo '- - Glob-Pattern match must include the first character. - -'
echo '- - Glob-Pattern may be a literal or a function result. - -'
echo


# Function returning a simple, Literal, Glob-Pattern
_abc() {
    echo -n 'abc'
}

echo '- Shortest prefix -'
echo ${stringZ#123}                 # Unchanged (not a prefix).
echo ${stringZ#$(_abc)}             # ABC123ABCabc
echo ${arrayZ[@]#abc}               # Applied to each element.

# echo ${sparseZ[@]#abc}            # Version-2.05b core dumps.
# Has since been fixed by Chet Ramey.

# The -it would be nice- First-Subscript-Of
# echo ${#sparseZ[@]#*}             # This is NOT valid Bash.

echo
echo '- Longest prefix -'
echo ${stringZ##1*3}                # Unchanged (not a prefix)
echo ${stringZ##a*C}                # abc
echo ${arrayZ[@]##a*c}              # ABCABC 123123 ABCABC

# echo ${sparseZ[@]##a*c}           # Version-2.05b core dumps.
# Has since been fixed by Chet Ramey.

echo
echo '- - Suffix sub-element removal - -'
echo '- - Glob-Pattern match must include the last character. - -'
echo '- - Glob-Pattern may be a literal or a function result. - -'
echo
echo '- Shortest suffix -'
echo ${stringZ%1*3}                 # Unchanged (not a suffix).
echo ${stringZ%$(_abc)}             # abcABC123ABC
echo ${arrayZ[@]%abc}               # Applied to each element.

# echo ${sparseZ[@]%abc}            # Version-2.05b core dumps.
# Has since been fixed by Chet Ramey.

# The -it would be nice- Last-Subscript-Of
# echo ${#sparseZ[@]%*}             # This is NOT valid Bash.

echo
echo '- Longest suffix -'
echo ${stringZ%%1*3}                # Unchanged (not a suffix)
echo ${stringZ%%b*c}                # a
echo ${arrayZ[@]%%b*c}              # a ABCABC 123123 ABCABC a

# echo ${sparseZ[@]%%b*c}           # Version-2.05b core dumps.
# Has since been fixed by Chet Ramey.

echo
echo '- - Sub-element replacement - -'
echo '- - Sub-element at any location in string. - -'
echo '- - First specification is a Glob-Pattern - -'
echo '- - Glob-Pattern may be a literal or Glob-Pattern function result. - -'
echo '- - Second specification may be a literal or function result. - -'
echo '- - Second specification may be unspecified. Pronounce that'
echo '    as: Replace-With-Nothing (Delete) - -'
echo



# Function returning a simple, Literal, Glob-Pattern
_123() {
    echo -n '123'
}

echo '- Replace first occurrence -'
echo ${stringZ/$(_123)/999}         # Changed (123 is a component).
echo ${stringZ/ABC/xyz}             # xyzABC123ABCabc
echo ${arrayZ[@]/ABC/xyz}           # Applied to each element.
echo ${sparseZ[@]/ABC/xyz}          # Works as expected.

echo
echo '- Delete first occurrence -'
echo ${stringZ/$(_123)/}
echo ${stringZ/ABC/}
echo ${arrayZ[@]/ABC/}
echo ${sparseZ[@]/ABC/}

#  The replacement need not be a literal,
#+ since the result of a function invocation is allowed.
#  This is general to all forms of replacement.
echo
echo '- Replace first occurrence with Result-Of -'
echo ${stringZ/$(_123)/$(_simple)}  # Works as expected.
echo ${arrayZ[@]/ca/$(_simple)}     # Applied to each element.
echo ${sparseZ[@]/ca/$(_simple)}    # Works as expected.

echo
echo '- Replace all occurrences -'
echo ${stringZ//[b2]/X}             # X-out b's and 2's
echo ${stringZ//abc/xyz}            # xyzABC123ABCxyz
echo ${arrayZ[@]//abc/xyz}          # Applied to each element.
echo ${sparseZ[@]//abc/xyz}         # Works as expected.

echo
echo '- Delete all occurrences -'
echo ${stringZ//[b2]/}
echo ${stringZ//abc/}
echo ${arrayZ[@]//abc/}
echo ${sparseZ[@]//abc/}

echo
echo '- - Prefix sub-element replacement - -'
echo '- - Match must include the first character. - -'
echo

echo '- Replace prefix occurrences -'
echo ${stringZ/#[b2]/X}             # Unchanged (neither is a prefix).
echo ${stringZ/#$(_abc)/XYZ}        # XYZABC123ABCabc
echo ${arrayZ[@]/#abc/XYZ}          # Applied to each element.
echo ${sparseZ[@]/#abc/XYZ}         # Works as expected.

echo
echo '- Delete prefix occurrences -'
echo ${stringZ/#[b2]/}
echo ${stringZ/#$(_abc)/}
echo ${arrayZ[@]/#abc/}
echo ${sparseZ[@]/#abc/}

echo
echo '- - Suffix sub-element replacement - -'
echo '- - Match must include the last character. - -'
echo

echo '- Replace suffix occurrences -'
echo ${stringZ/%[b2]/X}             # Unchanged (neither is a suffix).
echo ${stringZ/%$(_abc)/XYZ}        # abcABC123ABCXYZ
echo ${arrayZ[@]/%abc/XYZ}          # Applied to each element.
echo ${sparseZ[@]/%abc/XYZ}         # Works as expected.

echo
echo '- Delete suffix occurrences -'
echo ${stringZ/%[b2]/}
echo ${stringZ/%$(_abc)/}
echo ${arrayZ[@]/%abc/}
echo ${sparseZ[@]/%abc/}

echo
echo '- - Special cases of null Glob-Pattern - -'
echo

echo '- Prefix all -'
# null substring pattern means 'prefix'
echo ${stringZ/#/NEW}               # NEWabcABC123ABCabc
echo ${arrayZ[@]/#/NEW}             # Applied to each element.
echo ${sparseZ[@]/#/NEW}            # Applied to null-content also.
                                    # That seems reasonable.

echo
echo '- Suffix all -'
# null substring pattern means 'suffix'
echo ${stringZ/%/NEW}               # abcABC123ABCabcNEW
echo ${arrayZ[@]/%/NEW}             # Applied to each element.
echo ${sparseZ[@]/%/NEW}            # Applied to null-content also.
                                    # That seems reasonable.

echo
echo '- - Special case For-Each Glob-Pattern - -'
echo '- - - - This is a nice-to-have dream - - - -'
echo

_GenFunc() {
    echo -n ${0}                    # Illustration only.
    # Actually, that would be an arbitrary computation.
}

# All occurrences, matching the AnyThing pattern.
# Currently //*/ does not match null-content nor null-reference.
# /#/ and /%/ does match null-content but not null-reference.
echo ${sparseZ[@]//*/$(_GenFunc)}


#  A possible syntax would be to make
#+ the parameter notation used within this construct mean:
#   ${1} - The full element
#   ${2} - The prefix, if any, to the matched sub-element
#   ${3} - The matched sub-element
#   ${4} - The suffix, if any, to the matched sub-element
#
# echo ${sparseZ[@]//*/$(_GenFunc ${3})}   # Same as ${1} here.
# Perhaps it will be implemented in a future version of Bash.


exit 0
</programlisting>
    </example>

    <example xml:id="testexectime">
      <title>Testing execution times of various commands</title>
      <programlisting>#!/bin/bash
#  test-execution-time.sh
#  Example by Erik Brandsberg, for testing execution time
#+ of certain operations.
#  Referenced in the "Optimizations" section of "Miscellany" chapter.

count=50000
echo "Math tests"
echo "Math via \$(( ))"
time for (( i=0; i&lt; $count; i++))
do
  result=$(( $i%2 ))
done

echo "Math via *expr*:"
time for (( i=0; i&lt; $count; i++))
do
  result=`expr "$i%2"`
done

echo "Math via *let*:"
time for (( i=0; i&lt; $count; i++))
do
  let result=$i%2
done

echo
echo "Conditional testing tests"

echo "Test via case:"
time for (( i=0; i&lt; $count; i++))
do
  case $(( $i%2 )) in
    0) : ;;
    1) : ;;
  esac
done

echo "Test with if [], no quotes:"
time for (( i=0; i&lt; $count; i++))
do
  if [ $(( $i%2 )) = 0 ]; then
     :
  else
     :
  fi
done

echo "Test with if [], quotes:"
time for (( i=0; i&lt; $count; i++))
do
  if [ "$(( $i%2 ))" = "0" ]; then
     :
  else
     :
  fi
done

echo "Test with if [], using -eq:"
time for (( i=0; i&lt; $count; i++))
do
  if [ $(( $i%2 )) -eq 0 ]; then
     :
  else
     :
  fi
done

exit $?
</programlisting>
    </example>

    <example xml:id="assocarrtest">
	    <title>Associative arrays vs. conventional arrays (execution
	    times)</title>
      <programlisting>#!/bin/bash
#  assoc-arr-test.sh
#  Benchmark test script to compare execution times of
#  numeric-indexed array vs. associative array.
#     Thank you, Erik Brandsberg.

count=100000       # May take a while for some of the tests below.
declare simple     # Can change to 20000, if desired.
declare -a array1
declare -A array2
declare -a array3
declare -A array4

echo "===Assignment tests==="
echo

echo "Assigning a simple variable:"
# References $i twice to equalize lookup times.
time for (( i=0; i&lt; $count; i++)); do
        simple=$i$i
done

echo "---"

echo "Assigning a numeric index array entry:"
time for (( i=0; i&lt; $count; i++)); do
        array1[$i]=$i
done

echo "---"

echo "Overwriting a numeric index array entry:"
time for (( i=0; i&lt; $count; i++)); do
        array1[$i]=$i
done

echo "---"

echo "Linear reading of numeric index array:"
time for (( i=0; i&lt; $count; i++)); do
        simple=array1[$i]
done

echo "---"

echo "Assigning an associative array entry:"
time for (( i=0; i&lt; $count; i++)); do
        array2[$i]=$i
done

echo "---"

echo "Overwriting an associative array entry:"
time for (( i=0; i&lt; $count; i++)); do
        array2[$i]=$i
done

echo "---"

echo "Linear reading an associative array entry:"
time for (( i=0; i&lt; $count; i++)); do
        simple=array2[$i]
done

echo "---"

echo "Assigning a random number to a simple variable:"
time for (( i=0; i&lt; $count; i++)); do
        simple=$RANDOM
done

echo "---"

echo "Assign a sparse numeric index array entry randomly into 64k cells:"
time for (( i=0; i&lt; $count; i++)); do
        array3[$RANDOM]=$i
done

echo "---"

echo "Reading sparse numeric index array entry:"
time for value in "${array3[@]}"i; do
        simple=$value
done

echo "---"

echo "Assigning a sparse associative array entry randomly into 64k cells:"
time for (( i=0; i&lt; $count; i++)); do
        array4[$RANDOM]=$i
done

echo "---"

echo "Reading sparse associative index array entry:"
time for value in "${array4[@]}"; do
        simple=$value
done

exit $?
</programlisting>
    </example>


  </appendix>
    <!-- End Contributed Scripts appendix -->




  <appendix xml:id="refcards">
      <title>Reference Cards</title>

      <para>The following reference cards provide a useful
	<emphasis>summary</emphasis> of certain scripting concepts.
	The foregoing text treats these matters in more depth, as well as
	giving usage examples.</para>

      <para><anchor xml:id="specshvartab" /></para>
      <table pgwide="0">
	<title>Special Shell Variables</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Variable</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>$0</option></entry>
	      <entry>Filename of script</entry>
	    </row>
	    <row>
	      <entry><option>$1</option></entry>
	      <entry>Positional parameter #1</entry>
	    </row>
	    <row>
	      <entry><option>$2 - $9</option></entry>
	      <entry>Positional parameters #2 - #9</entry>
	    </row>
	    <row>
	      <entry><option>${10}</option></entry>
	      <entry>Positional parameter #10</entry>
	    </row>
	    <row>
	      <entry><option>$#</option></entry>
	      <entry>Number of positional parameters</entry>
	    </row>
	    <row>
	      <entry><option>"$*"</option></entry>
	      <entry>All the positional parameters (as a single word) *</entry>
	    </row>
	    <row>
	      <entry><option>"$@"</option></entry>
	      <entry>All the positional parameters (as separate strings)</entry>
	    </row>
	    <row>
	      <entry><option>${#*}</option></entry>
	      <entry>Number of positional parameters</entry>
	    </row>
	    <row>
	      <entry><option>${#@}</option></entry>
	      <entry>Number of positional parameters</entry>
	    </row>
	    <row>
	      <entry><option>$?</option></entry>
	      <entry>Return value</entry>
	    </row>
	    <row>
	      <entry><option>$$</option></entry>
	      <entry>Process ID (PID) of script</entry>
	    </row>
	    <row>
	      <entry><option>$-</option></entry>
	      <entry>Flags passed to script (using
	        <firstterm>set</firstterm>)</entry>
	    </row>
	    <row>
	      <entry><option>$_</option></entry>
	      <entry>Last argument of previous command</entry>
	    </row>
	    <row>
	      <entry><option>$!</option></entry>
	      <entry>Process ID (PID) of last job run in background</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para><command>*</command> <emphasis>Must be quoted</emphasis>,
        otherwise it defaults to
        <varname>$@</varname>.</para>


      <para><anchor xml:id="bincomptab" /></para>
      <table>
	<title>TEST Operators: Binary Comparison</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Operator</entry>
	      <entry>Meaning</entry>
	      <entry>-----</entry>
	      <entry>Operator</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><link linkend="icomparison1">Arithmetic
	        Comparison</link></entry>
	      <entry />
	      <entry />
	      <entry><link linkend="scomparison1">String
	        Comparison</link></entry>
	      <entry />
	    </row>
	    <row>
	      <entry><option>-eq</option></entry>
	      <entry>Equal to</entry>
	      <entry />
	      <entry><option>=</option></entry>
	      <entry>Equal to</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	      <entry><option>==</option></entry>
	      <entry>Equal to</entry>
	    </row>
	    <row>
	      <entry><option>-ne</option></entry>
	      <entry>Not equal to</entry>
	      <entry />
	      <entry><option>!=</option></entry>
	      <entry>Not equal to</entry>
	    </row>
	    <row>
	      <entry><option>-lt</option></entry>
	      <entry>Less than</entry>
	      <entry />
	      <entry><option>\&lt;</option></entry>
	      <entry>Less than (<link linkend="asciidef">ASCII</link>) *</entry>
	    </row>
	    <row>
	      <entry><option>-le</option></entry>
	      <entry>Less than or equal to</entry>
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry><option>-gt</option></entry>
	      <entry>Greater than</entry>
	      <entry />
	      <entry><option>\&gt;</option></entry>
	      <entry>Greater than (ASCII) *</entry>
	    </row>
	    <row>
	      <entry><option>-ge</option></entry>
	      <entry>Greater than or equal to</entry>
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	      <entry><option>-z</option></entry>
	      <entry>String is empty</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	      <entry />
	      <entry><option>-n</option></entry>
	      <entry>String is not empty</entry>
	    </row>
	    <row>
	      <entry />
	      <entry />
	    </row>
	    <row>
	      <entry>Arithmetic Comparison</entry>
	      <entry><link linkend="dblprx">within double
	        parentheses</link> (( ... ))</entry>
	    </row>
	    <row>  
	      <entry><option>&gt;</option></entry>
	      <entry>Greater than</entry>
	    </row>
	    <row>
	      <entry><option>&gt;=</option></entry>
	      <entry>Greater than or equal to</entry>
	    </row>
	    <row>  
	      <entry><option>&lt;</option></entry>
	      <entry>Less than</entry>
	    </row>
	    <row>  
	      <entry><option>&lt;=</option></entry>
	      <entry>Less than or equal to</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <para><command>*</command> <emphasis>If within a
        double-bracket</emphasis> <token>[[ ... ]]</token> <emphasis>test construct,
        then no escape</emphasis> <token>\</token> <emphasis>is
        needed.</emphasis></para>

      <para><anchor xml:id="filestab" /></para>
      <table>
	<title>TEST Operators: Files</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Operator</entry>
	      <entry>Tests Whether</entry>
	      <entry>-----</entry>
	      <entry>Operator</entry>
	      <entry>Tests Whether</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>-e</option></entry>
	      <entry>File exists</entry>
	      <entry />
	      <entry><option>-s</option></entry>
	      <entry>File is not zero size</entry>
	    </row>
	    <row>
	      <entry><option>-f</option></entry>
	      <entry>File is a <firstterm>regular</firstterm> file</entry>
	    </row>
	    <row>
	      <entry><option>-d</option></entry>
	      <entry>File is a <firstterm>directory</firstterm></entry>
	      <entry />
	      <entry><option>-r</option></entry>
	      <entry>File has <firstterm>read</firstterm>
	         permission</entry>
	    </row>
	    <row>
	      <entry><option>-h</option></entry>
	      <entry>File is a <link linkend="symlinkref">symbolic link</link></entry>
	      <entry />
	      <entry><option>-w</option></entry>
	      <entry>File has <firstterm>write</firstterm>
	         permission</entry>
	    </row>
	    <row>
	      <entry><option>-L</option></entry>
	      <entry>File is a <firstterm>symbolic link</firstterm></entry>
	      <entry />
	      <entry><option>-x</option></entry>
	      <entry>File has <firstterm>execute</firstterm>
	        permission</entry>
	    </row>
	    <row>
	      <entry><option>-b</option></entry>
	      <entry>File is a <link linkend="blockdevref">block
	      device</link></entry>
	    </row>
	    <row>
	      <entry><option>-c</option></entry>
	      <entry>File is a <link linkend="chardevref">character
	      device</link></entry>
	      <entry />
	      <entry><option>-g</option></entry>
	      <entry><firstterm>sgid</firstterm> flag set</entry>
	    </row>
	    <row>
	      <entry><option>-p</option></entry>
	      <entry>File is a <link linkend="piperef">pipe</link></entry>
	      <entry />
	      <entry><option>-u</option></entry>
	      <entry><firstterm>suid</firstterm> flag set</entry>
	    </row>
	    <row>
	      <entry><option>-S</option></entry>
	      <entry>File is a <link linkend="socketref">socket</link></entry>
	      <entry />
	      <entry><option>-k</option></entry>
	      <entry><quote>sticky bit</quote> set</entry>
	    </row>
	    <row>
	      <entry><option>-t</option></entry>
	      <entry>File is associated with a
	        <firstterm>terminal</firstterm></entry>
	    </row>
	    <row><entry /></row>
	    <row>
	      <entry><option>-N</option></entry>
	      <entry>File modified since it was last read</entry>
	      <entry />
	      <entry><option>F1 -nt F2</option></entry>
	      <entry>File F1 is <emphasis>newer</emphasis> than F2 *</entry>
	    </row>
	    <row>
	      <entry><option>-O</option></entry>
	      <entry>You own the file</entry>
	      <entry />
	      <entry><option>F1 -ot F2</option></entry>
	      <entry>File F1 is <emphasis>older</emphasis> than F2 *</entry>
	    </row>
	    <row>
	      <entry><option>-G</option></entry>
	      <entry><firstterm>Group id</firstterm> of file same as
	        yours</entry>
	      <entry />
	      <entry><option>F1 -ef F2</option></entry>
	      <entry>Files F1 and F2 are <firstterm>hard links</firstterm>
	        to the same file *</entry>
	    </row>
	    <row><entry /></row>
	    <row>
	      <entry><option>!</option></entry>
	      <entry>NOT (inverts sense of above tests)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <para><command>*</command> <firstterm>Binary</firstterm> operator
        (requires two operands).</para>




      <para><anchor xml:id="parsubtab" /></para>
      <table pgwide="0">
	<title>Parameter Substitution and Expansion</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Expression</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>${var}</option></entry>
	      <entry>Value of <parameter>var</parameter> (same as
	        <parameter>$var</parameter>)</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${var-$DEFAULT}</option></entry>
	        <entry>If <parameter>var</parameter> not set, <link linkend="evalref">evaluate</link> expression
	        as <parameter>$DEFAULT</parameter> *</entry>
	    </row>
	    <row>
	      <entry><option>${var:-$DEFAULT}</option></entry>
	      <entry>If <parameter>var</parameter> not set or is empty,
              <firstterm>evaluate</firstterm> expression as
                <parameter>$DEFAULT</parameter>
		*</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${var=$DEFAULT}</option></entry>
	      <entry>If <parameter>var</parameter> not set, evaluate expression
	        as <parameter>$DEFAULT</parameter> *</entry>
	    </row>
	    <row>
	      <entry><option>${var:=$DEFAULT}</option></entry>
	      <entry>If <parameter>var</parameter> not set or is empty, evaluate expression
	        as <parameter>$DEFAULT</parameter> *</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${var+$OTHER}</option></entry>
	      <entry>If <parameter>var</parameter> set, evaluate expression as
	        <parameter>$OTHER</parameter>, otherwise as null string</entry>
	    </row>
	    <row>
	      <entry><option>${var:+$OTHER}</option></entry>
	      <entry>If <parameter>var</parameter> set, evaluate expression as
	        <parameter>$OTHER</parameter>, otherwise as null string</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${var?$ERR_MSG}</option></entry>
	      <entry>If <parameter>var</parameter> not set, print
		      <parameter>$ERR_MSG</parameter> and abort script
		      with an exit status of <errorcode>1</errorcode>.*</entry>
	    </row>
	    <row>
	      <entry><option>${var:?$ERR_MSG}</option></entry>
	      <entry>If <parameter>var</parameter> not set, print
		      <parameter>$ERR_MSG</parameter> and abort script
		      with an exit status of <errorcode>1</errorcode>.*</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${!varprefix*}</option></entry>
	      <entry>Matches all previously declared variables beginning with
	        <parameter>varprefix</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${!varprefix@}</option></entry>
	      <entry>Matches all previously declared variables beginning with
	        <parameter>varprefix</parameter></entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para><command>*</command> If <parameter>var</parameter>
        <emphasis>is</emphasis> set, evaluate the expression as
	<parameter>$var</parameter> with no side-effects.</para>
      <para><command># Note</command> that some of the above behavior
	of operators has changed from earlier versions of Bash.</para>


      <para><anchor xml:id="stringopstab" /></para>
      <table pgwide="0">
	<title>String Operations</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Expression</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>${#string}</option></entry>
	      <entry>Length of <parameter>$string</parameter></entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${string:position}</option></entry>
	      <entry>Extract substring from <parameter>$string</parameter>
		at <parameter>$position</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string:position:length}</option></entry>
	      <entry>Extract <parameter>$length</parameter>
		characters substring from <parameter>$string</parameter>
		at <parameter>$position</parameter> [zero-indexed,
		first character is at position 0]</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${string#substring}</option></entry>
	      <entry>Strip shortest match of
	      <parameter>$substring</parameter> from front of
	      <parameter>$string</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string##substring}</option></entry>
	      <entry>Strip longest match of
	      <parameter>$substring</parameter> from front of
	      <parameter>$string</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string%substring}</option></entry>
	      <entry>Strip shortest match of
	      <parameter>$substring</parameter> from back of
	      <parameter>$string</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string%%substring}</option></entry>
	      <entry>Strip longest match of
	      <parameter>$substring</parameter> from back of
	      <parameter>$string</parameter></entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>${string/substring/replacement}</option></entry>
	      <entry>Replace first match of
	      <parameter>$substring</parameter> with
	      <parameter>$replacement</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string//substring/replacement}</option></entry>
	      <entry>Replace <emphasis>all</emphasis> matches of
	      <parameter>$substring</parameter> with
	      <parameter>$replacement</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string/#substring/replacement}</option></entry>
	      <entry>If <parameter>$substring</parameter>
	      matches <emphasis>front</emphasis> end of
	      <parameter>$string</parameter>, substitute
	      <parameter>$replacement</parameter> for
	      <parameter>$substring</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string/%substring/replacement}</option></entry>
	      <entry>If <parameter>$substring</parameter>
	      matches <emphasis>back</emphasis> end of
	      <parameter>$string</parameter>, substitute
	      <parameter>$replacement</parameter> for
	      <parameter>$substring</parameter></entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><option>expr match "$string" '$substring'</option></entry>
	      <entry>Length of matching <parameter>$substring</parameter>*
	        at beginning of <parameter>$string</parameter></entry>
	    </row>
	    <row>
	      <entry><option>expr "$string" : '$substring'</option></entry>
	      <entry>Length of matching <parameter>$substring</parameter>*
	        at beginning of <parameter>$string</parameter></entry>
	    </row>
	    <row>
	      <entry><option>expr index "$string" $substring</option></entry>
	      <entry>Numerical position in <parameter>$string</parameter>
		of first character in <parameter>$substring</parameter>*
		that matches [0 if no match, first character counts as
		position 1]</entry>
	    </row>
	    <row>
	      <entry><option>expr substr $string $position
	        $length</option></entry>
	      <entry>Extract <parameter>$length</parameter> characters
	        from <parameter>$string</parameter> starting at
	        <parameter>$position</parameter> [0 if no match, first
		character counts as position 1]</entry>
            </row>
	    <row>
	      <entry><option>expr match "$string"
	        '\($substring\)'</option></entry>
	      <entry>Extract <parameter>$substring</parameter>*, searching
	        from beginning of <parameter>$string</parameter></entry>
            </row>
	    <row>
	      <entry><option>expr "$string" :
	        '\($substring\)'</option></entry>
	      <entry>Extract <parameter>$substring</parameter>* , searching
	        from beginning of <parameter>$string</parameter></entry>
            </row>
	    <row>
	      <entry><option>expr match "$string"
	        '.*\($substring\)'</option></entry>
	      <entry>Extract <parameter>$substring</parameter>*, searching
	        from end of <parameter>$string</parameter></entry>
            </row>
	    <row>
	      <entry><option>expr "$string" :
	        '.*\($substring\)'</option></entry>
	      <entry>Extract <parameter>$substring</parameter>*, searching
	        from end of <parameter>$string</parameter></entry>
            </row>
	  </tbody>
	</tgroup>
      </table>
      
      <para><command>*</command> Where <parameter>$substring</parameter> is a
        <link linkend="regexref">Regular Expression</link>.</para>



      <para><anchor xml:id="misctab" /></para>
      <table pgwide="0">
	<title>Miscellaneous Constructs</title>
	<tgroup cols="2">
	  <thead>

	    <row>
	      <entry>Expression</entry>
	      <entry>Interpretation</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><link linkend="bracketsref">Brackets</link></entry><entry />
	    </row>  
	    <row>
	      <entry><option>if [ CONDITION ]</option></entry>
	      <entry><link linkend="leftbracket">Test construct</link></entry>
	    </row>
	    <row>
	      <entry><option>if [[ CONDITION ]]</option></entry>
	      <entry><link linkend="dblbrackets">Extended test construct</link></entry>
	    </row>
	    <row>
	      <entry><option>Array[1]=element1</option></entry>
	      <entry><link linkend="arrayref">Array initialization</link></entry>
	    </row>
	    <row>
	      <entry><option> [a-z]</option></entry>
	      <entry><link linkend="bracketsref">Range of
	      characters</link> within a <link linkend="regexref">Regular
	      Expression</link></entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry>Curly Brackets</entry><entry />
	    </row>  
	    <row>
	      <entry><option>${variable}</option></entry>
	      <entry><link linkend="paramsubref">Parameter substitution</link></entry>
	    </row>
	    <row>
	      <entry><option>${!variable}</option></entry>
	      <entry><link linkend="ivrref">Indirect variable reference</link></entry>
	    </row>
	    <row>
	      <entry><option>{ command1; command2; . . . commandN; }</option></entry>
	      <entry><link linkend="codeblockref">Block of code</link></entry>
	    </row>
	    <row>
	      <entry><option>{string1,string2,string3,...}</option></entry>
	      <entry><link linkend="braceexpref">Brace expansion</link></entry>
	    </row>
	    <row>
	      <entry><option>{a..z}</option></entry>
	      <entry><link linkend="braceexpref3">Extended brace expansion</link></entry>
	    </row>
	    <row>
	      <entry><option>{}</option></entry>
	      <entry>Text replacement, after <link linkend="curlybracketsref">find</link> and <link linkend="xargscurlyref">xargs</link></entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><link linkend="parensref">Parentheses</link></entry><entry />
	    </row>  
	    <row>
	      <entry><option>( command1; command2 )</option></entry>
	      <entry>Command group executed within a <link linkend="subshellsref">subshell</link></entry>
	    </row>
	    <row>
	      <entry><option>Array=(element1 element2 element3)</option></entry>
	      <entry><link linkend="arrayinit0">Array initialization</link></entry>
	    </row>
	    <row>
	      <entry><option>result=$(COMMAND)</option></entry>
	      <entry><link linkend="csparens">Command substitution</link>,
	      new style</entry>
	    </row>
	    <row>
	      <entry><option>&gt;(COMMAND)</option></entry>
	      <entry><link linkend="processsubref">Process substitution</link></entry>
	    </row>
	    <row>
	      <entry><option>&lt;(COMMAND)</option></entry>
	      <entry>Process substitution</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><link linkend="dblparens">Double Parentheses</link></entry><entry />
	    </row>  
	    <row>
	      <entry><option>(( var = 78 ))</option></entry>
	      <entry><link linkend="dblparensref">Integer arithmetic</link></entry>
	    </row>
	    <row>
	      <entry><option>var=$(( 20 + 5 ))</option></entry>
	      <entry>Integer arithmetic, with variable assignment</entry>
	    </row>
	    <row>
	      <entry><option>(( var++ ))</option></entry>
	      <entry><firstterm>C-style</firstterm> <link linkend="plusplusref"> variable increment</link></entry>
	    </row>
	    <row>
	      <entry><option>(( var-- ))</option></entry>
	      <entry><firstterm>C-style</firstterm> <link linkend="plusplusref"> variable decrement</link></entry>
	    </row>
	    <row>
	      <entry><option>(( var0 = var1&lt;98?9:21 ))</option></entry>
	      <entry><firstterm>C-style</firstterm> <link linkend="cstrinary"> ternary</link> operation</entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><link linkend="quotingref">Quoting</link></entry><entry />
	    </row>  
	    <row>
	      <entry><option>"$variable"</option></entry>
	      <entry><link linkend="dblquo">"Weak" quoting</link></entry>
	    </row>  
	    <row>  
	      <entry><option>'string'</option></entry>
	      <entry><link linkend="snglquo">'Strong' quoting</link></entry>
	    </row>
	    <row><entry /><entry /></row>
	    <row>
	      <entry><link linkend="backquotesref">Back Quotes</link></entry><entry />
	    </row>  
	    <row>
	      <entry><option>result=`COMMAND`</option></entry>
	      <entry><link linkend="commandsubref">Command
	        substitution</link>, classic style</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

  </appendix>
    <!-- Reference Cards appendix -->





  <appendix xml:id="sedawk">
      <title>A Sed and Awk Micro-Primer</title>
      
      <para><anchor xml:id="sedref" /></para>

      <para>This is a very brief introduction to the <command>sed</command>
	and <command>awk</command> text processing utilities. We will
	deal with only a few basic commands here, but that will suffice
	for understanding simple sed and awk constructs within shell
	scripts.</para>


       <para><command>sed</command>: a non-interactive
         text file editor</para>

       <para><command>awk</command>: a field-oriented pattern processing
         language with a <command>C</command>-style syntax</para>

       <para>For all their differences, the two utilities share a similar
	 invocation syntax, use <link linkend="regexref">regular
	 expressions </link>, read input by default
	 from <filename>stdin</filename>, and output to
	 <filename>stdout</filename>. These are well-behaved UNIX tools,
	 and they work together well. The output from one can be piped
	 to the other, and their combined capabilities give shell scripts
	 some of the power of <link linkend="perlref">Perl</link>.</para>

       <note><para>One important difference between the utilities is
	 that while shell scripts can easily pass arguments to sed, it
	 is more cumbersome for awk (see <xref linkend="coltotaler" />
	 and <xref linkend="coltotaler2" />).
	 </para></note>


    <section>
      <title>Sed</title>

      <para><firstterm>Sed</firstterm> is a non-interactive
          <footnote><para><firstterm>Sed</firstterm> executes without
          user intervention.</para></footnote>
	<command>s</command>tream <command>ed</command>itor. It
	receives text input, whether from <filename>stdin</filename>
	or from a file, performs certain operations on specified lines
	of the input, one line at a time, then outputs the result to
	<filename>stdout</filename> or to a file.  Within a shell script,
	<firstterm>sed</firstterm> is usually one of several tool
	components in a pipe.</para>

      <para><firstterm>Sed</firstterm> determines which lines of
        its input that it will operate on from the <firstterm>address
        range</firstterm> passed to it.
	  <footnote><para>If no address range is specified, the default
	  is <emphasis>all</emphasis> lines.</para></footnote>
	Specify this address range either by line number or by a
	pattern to match. For example, <replaceable>3d</replaceable>
	signals <firstterm>sed</firstterm> to delete line 3 of the
	input, and <replaceable>/Windows/d</replaceable> tells sed
	that you want every line of the input containing a match to
	<quote>Windows</quote> deleted.</para>

      <para>Of all the operations in the <firstterm>sed</firstterm>
	toolkit, we will focus primarily on the three most commonly
	used ones. These are <command>p</command>rinting (to
	<filename>stdout</filename>), <command>d</command>eletion,
	and <command>s</command>ubstitution.</para>


      <para><anchor xml:id="sedbasictable" /></para>
      <table>
	<title>Basic sed operators</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Operator</entry>
	      <entry>Name</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>[address-range]/p</option></entry>
	      <entry>print</entry>
	      <entry>Print [specified address range]</entry>
	    </row>
	    <row>
	      <entry><option>[address-range]/d</option></entry>
	      <entry>delete</entry>
	      <entry>Delete [specified address range]</entry>
	    </row>
	    <row>
	      <entry><option>s/pattern1/pattern2/</option></entry>
	      <entry>substitute</entry>
	      <entry>Substitute pattern2 for first instance of pattern1 in a line</entry>
	    </row>
	    <row>
	      <entry><option>[address-range]/s/pattern1/pattern2/</option></entry>
	      <entry>substitute</entry>
	      <entry>Substitute pattern2 for first instance of pattern1 in a
	      line, over <replaceable>address-range</replaceable></entry>
	    </row>
	    <row>
	      <entry><option>[address-range]/y/pattern1/pattern2/</option></entry>
	      <entry>transform</entry>
	      <entry>replace any character in pattern1 with the
	        corresponding character in pattern2, over
	      <replaceable>address-range</replaceable> (equivalent of
	        <command>tr</command>)</entry>
	    </row>
	    <row>
	      <entry><option>[address] i pattern Filename</option></entry>
	      <entry>insert</entry>
	      <entry>Insert pattern at address indicated in file Filename.
                     Usually used with <option>-i</option>
                     <replaceable>in-place</replaceable> option.</entry>
	    </row>
	    <row>
	      <entry><option>g</option></entry>
	      <entry>global</entry>
	      <entry>Operate on <emphasis>every</emphasis> pattern match
	        within each matched line of input</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <note><para>Unless the <option>g</option>
	(<firstterm>global</firstterm>) operator is appended to a
	<firstterm>substitute</firstterm> command, the substitution
	operates only on the <emphasis>first</emphasis> instance of a
	pattern match within each line.</para></note>

      <para>From the command-line and in a shell script, a sed operation may
       require quoting and certain options.</para>

       <para><programlisting>sed -e '/^$/d' $filename
# The -e option causes the next string to be interpreted as an editing instruction.
#  (If passing only a single instruction to sed, the "-e" is optional.)
#  The "strong" quotes ('') protect the RE characters in the instruction
#+ from reinterpretation as special characters by the body of the script.
# (This reserves RE expansion of the instruction for sed.)
#
# Operates on the text contained in file $filename.
</programlisting></para>

       <para>In certain cases, a <firstterm>sed</firstterm> editing command will
         not work with single quotes.</para>

       <para><programlisting>
filename=file1.txt
pattern=BEGIN

  sed "/^$pattern/d" "$filename"  # Works as specified.
# sed '/^$pattern/d' "$filename"    has unexpected results.
#        In this instance, with strong quoting (' ... '),
#+      "$pattern" will not expand to "BEGIN".</programlisting></para>


       <note><para><firstterm>Sed</firstterm> uses the <option>-e</option>
	 option to specify that the following string is an instruction
	 or set of instructions. If there is only a single instruction
	 contained in the string, then this may be omitted.</para></note>

       <para><programlisting>sed -n '/xzy/p' $filename
# The -n option tells sed to print only those lines matching the pattern.
# Otherwise all input lines would print.
# The -e option not necessary here since there is only a single editing instruction.
</programlisting></para>

      <para><anchor xml:id="sedoptable" /></para>
      <table>
	<title>Examples of sed operators</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Notation</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>8d</option></entry>
	      <entry>Delete 8th line of input.</entry>
	    </row>
	    <row>
	      <entry><option>/^$/d</option></entry>
	      <entry>Delete all blank lines.</entry>
	    </row>
	    <row>
	      <entry><option>1,/^$/d</option></entry>
	      <entry>Delete from beginning of input up to, and including
	        first blank line.</entry>
	    </row>
	    <row>
	      <entry><option>/Jones/p</option></entry>
	      <entry>Print only lines containing <quote>Jones</quote> (with
	        <token>-n</token> option).</entry>
	    </row>
	    <row>
	      <entry><option>s/Windows/Linux/</option></entry>
	      <entry>Substitute <quote>Linux</quote> for first instance
	        of <quote>Windows</quote> found in each input line.</entry>
	    </row>
	    <row>
	      <entry><option>s/BSOD/stability/g</option></entry>
	      <entry>Substitute <quote>stability</quote> for every instance
	        of <quote>BSOD</quote> found in each input line.</entry>
	    </row>
	    <row>
	      <entry><option>s/ *$//</option></entry>
	      <entry>Delete all spaces at the end of every line.</entry>
	    </row>
	    <row>
	      <entry><option>s/00*/0/g</option></entry>
	      <entry>Compress all consecutive sequences of zeroes into
	        a single zero.</entry>
	    </row>
	    <row>
	      <entry><option>echo "Working on it." | sed -e '1i How far are you along?'</option></entry>
	      <entry>Prints "How far are you along?" as first line,
                    "Working on it" as second.</entry>
	    </row>
	    <row>
	      <entry><option>5i 'Linux is great.' file.txt</option></entry>
	      <entry>Inserts 'Linux is great.' at line 5 of the file
	      file.txt.</entry>
	    </row>
	    <row>
	      <entry><option>/GUI/d</option></entry>
	      <entry>Delete all lines containing <quote>GUI</quote>.</entry>
	    </row>
	    <row>
	      <entry><option>s/GUI//g</option></entry>
	      <entry>Delete all instances of <quote>GUI</quote>, leaving the 
	        remainder of each line intact.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


     <para>Substituting a zero-length string for another is equivalent
       to deleting that string within a line of input. This leaves the
       remainder of the line intact. Applying <userinput>s/GUI//</userinput>   
       to the line
       <screen><userinput>The most important parts of any application are its GUI and sound effects</userinput></screen>
       results in
       <screen><computeroutput>The most important parts of any application are its  and sound effects</computeroutput></screen></para>

     <para>A backslash forces the <command>sed</command> replacement
       command to continue on to the next line. This has the effect of
       using the <firstterm>newline</firstterm> at the end of the first
       line as the <firstterm>replacement string</firstterm>.

       <programlisting>s/^  */\
/g</programlisting>

       This substitution replaces line-beginning spaces with a
       newline. The net result is to replace paragraph indents with a
       blank line between paragraphs.</para>

     <para>An address range followed by one or more operations may require
       open and closed curly brackets, with appropriate newlines. 
       <programlisting>/[0-9A-Za-z]/,/^$/{
/^$/d
}</programlisting>
       This deletes only the first of each set of consecutive blank
       lines. That might be useful for single-spacing a text file,
       but retaining the blank line(s) between paragraphs.</para>


     <note><para>The usual delimiter that <firstterm>sed</firstterm> uses is
      <token>/</token>. However, <emphasis>sed</emphasis> allows other
      delimiters, such as <token>%</token>. This is useful when
      <token>/</token> is part of a replacement string, as in a file pathname.
      See <xref linkend="findstring" /> and <xref linkend="stripc" />.</para></note>

     <para><anchor xml:id="doublespace" /></para>
     <tip><para>A quick way to double-space a text file is <userinput>sed G
       filename</userinput>.</para></tip>  

     <para>For illustrative examples of sed within shell scripts, see:
       <orderedlist>
         <listitem><para><xref linkend="ex3" /></para></listitem>
	 <listitem><para><xref linkend="ex4" /></para></listitem>
	 <listitem><para><xref linkend="ex57" /></para></listitem>
         <listitem><para><xref linkend="rn" /></para></listitem>
	 <listitem><para><xref linkend="grp" /></para></listitem>
	 <listitem><para><xref linkend="col" /></para></listitem>
         <listitem><para><xref linkend="behead" /></para></listitem>
	 <listitem><para><xref linkend="tree" /></para></listitem>
	 <listitem><para><xref linkend="tree2" /></para></listitem>
	 <listitem><para><xref linkend="stripc" /></para></listitem>
	 <listitem><para><xref linkend="findstring" /></para></listitem>
	 <listitem><para><xref linkend="base" /></para></listitem>
	 <listitem><para><xref linkend="mailformat" /></para></listitem>
	 <listitem><para><xref linkend="rnd" /></para></listitem>
	 <listitem><para><xref linkend="wf" /></para></listitem>
	 <listitem><para><xref linkend="lifeslow" /></para></listitem>
         <listitem><para><xref linkend="selfdocument" /></para></listitem>
         <listitem><para><xref linkend="dictlookup" /></para></listitem>
         <listitem><para><xref linkend="whx" /></para></listitem>
         <listitem><para><xref linkend="bashpodder" /></para></listitem>
         <listitem><para><xref linkend="tohtml" /></para></listitem>
         <listitem><para><xref linkend="stopwatch" /></para></listitem>
         <listitem><para><xref linkend="sedappend" /></para></listitem>
       </orderedlist>
     </para>  

      <para>For a more extensive treatment of <firstterm>sed</firstterm>,
        refer to the <link linkend="dgsedref">pertinent references</link>
        in the <xref linkend="biblio" />.</para>

    </section>
    <!-- End sed primer -->



    <section xml:id="awk">
      <title>Awk</title>

      <para><anchor xml:id="awkref" /></para>

     <para><firstterm>Awk</firstterm>
       <footnote><para>Its name derives from the initials of its authors,
       <command>A</command>ho, <command>W</command>einberg, and
       <command>K</command>ernighan.</para></footnote>
       is a full-featured text processing language with a syntax
       reminiscent of <firstterm>C</firstterm>.  While it possesses an
       extensive set of operators and capabilities, we will cover only
       a few of these here - the ones most useful in shell scripts.</para>

     <para>Awk breaks each line of input passed to it into
       <anchor xml:id="fieldref2" />
       <link linkend="fieldref">fields</link>. By default, a field
       is a string of consecutive characters delimited by <link linkend="whitespaceref">whitespace</link>, though there are options
       for changing this. Awk parses and operates on each separate
       field. This makes it ideal for handling structured text files
       -- especially tables -- data organized into consistent chunks,
       such as rows and columns.</para>

     <para><link linkend="snglquo">Strong quoting</link> and <link linkend="codeblockref">curly brackets</link> enclose blocks of
       awk code within a shell script.</para>

     <para><programlisting># $1 is field #1, $2 is field #2, etc.

echo one two | awk '{print $1}'
# one

echo one two | awk '{print $2}'
# two

# But what is field #0 ($0)?
echo one two | awk '{print $0}'
# one two
# All the fields!


awk '{print $3}' $filename
# Prints field #3 of file $filename to stdout.

awk '{print $1 $5 $6}' $filename
# Prints fields #1, #5, and #6 of file $filename.

awk '{print $0}' $filename
# Prints the entire file!
# Same effect as:   cat $filename . . . or . . . sed '' $filename</programlisting></para> 

     <para>We have just seen the awk <firstterm>print</firstterm> command
       in action. The only other feature of awk we need to deal with
       here is variables. Awk handles variables similarly to shell
       scripts, though a bit more flexibly.</para>

     <para><programlisting>{ total += ${column_number} }</programlisting>
       This adds the value of <parameter>column_number</parameter> to
       the running total of <parameter>total</parameter>&gt;. Finally, to print
       <quote>total</quote>, there is an <command>END</command> command
       block, executed after the script has processed all its input.
       <programlisting>END { print total }</programlisting></para>

     <para>Corresponding to the <command>END</command>, there is a
       <command>BEGIN</command>, for a code block to be performed before awk
       starts processing its input.</para>

     <para>The following example illustrates how <command>awk</command> can
       add text-parsing tools to a shell script.</para>

    <example xml:id="lettercount2">
      <title>Counting Letter Occurrences</title>
      <programlisting>#! /bin/sh
# letter-count2.sh: Counting letter occurrences in a text file.
#
# Script by nyal [nyal@voila.fr].
# Used in ABS Guide with permission.
# Recommented and reformatted by ABS Guide author.
# Version 1.1: Modified to work with gawk 3.1.3.
#              (Will still work with earlier versions.)


INIT_TAB_AWK=""
# Parameter to initialize awk script.
count_case=0
FILE_PARSE=$1

E_PARAMERR=85

usage()
{
    echo "Usage: letter-count.sh file letters" 2&gt;&amp;1
    # For example:   ./letter-count2.sh filename.txt a b c
    exit $E_PARAMERR  # Too few arguments passed to script.
}

if [ ! -f "$1" ] ; then
    echo "$1: No such file." 2&gt;&amp;1
    usage                 # Print usage message and exit.
fi 

if [ -z "$2" ] ; then
    echo "$2: No letters specified." 2&gt;&amp;1
    usage
fi 

shift                      # Letters specified.
for letter in `echo $@`    # For each one . . .
  do
  INIT_TAB_AWK="$INIT_TAB_AWK tab_search[${count_case}] = \
  \"$letter\"; final_tab[${count_case}] = 0; " 
  # Pass as parameter to awk script below.
  count_case=`expr $count_case + 1`
done

# DEBUG:
# echo $INIT_TAB_AWK;

cat $FILE_PARSE |
# Pipe the target file to the following awk script.

# ---------------------------------------------------------------------
# Earlier version of script:
# awk -v tab_search=0 -v final_tab=0 -v tab=0 -v \
# nb_letter=0 -v chara=0 -v chara2=0 \

awk \
"BEGIN { $INIT_TAB_AWK } \
{ split(\$0, tab, \"\"); \
for (chara in tab) \
{ for (chara2 in tab_search) \
{ if (tab_search[chara2] == tab[chara]) { final_tab[chara2]++ } } } } \
END { for (chara in final_tab) \
{ print tab_search[chara] \" =&gt; \" final_tab[chara] } }"
# ---------------------------------------------------------------------
#  Nothing all that complicated, just . . .
#+ for-loops, if-tests, and a couple of specialized functions.

exit $?

# Compare this script to letter-count.sh.
</programlisting>
    </example>

     <para>For simpler examples of awk within shell scripts, see:
       <orderedlist>
         <listitem><para><xref linkend="ex44" /></para></listitem>
	 <listitem><para><xref linkend="redir4" /></para></listitem>
	 <listitem><para><xref linkend="stripc" /></para></listitem>
         <listitem><para><xref linkend="coltotaler" /></para></listitem>
         <listitem><para><xref linkend="coltotaler2" /></para></listitem>
         <listitem><para><xref linkend="coltotaler3" /></para></listitem>
         <listitem><para><xref linkend="pidid" /></para></listitem>
         <listitem><para><xref linkend="constat" /></para></listitem>
         <listitem><para><xref linkend="fileinfo" /></para></listitem>
         <listitem><para><xref linkend="blotout" /></para></listitem>
         <listitem><para><xref linkend="seedingrandom" /></para></listitem>
         <listitem><para><xref linkend="idelete" /></para></listitem>
         <listitem><para><xref linkend="substringex" /></para></listitem>
         <listitem><para><xref linkend="sumproduct" /></para></listitem>
         <listitem><para><xref linkend="userlist" /></para></listitem>
         <listitem><para><xref linkend="prasc" /></para></listitem>
         <listitem><para><xref linkend="hypot" /></para></listitem>
         <listitem><para><xref linkend="ascii3sh" /></para></listitem>
       </orderedlist>
      </para>	 

     <para>That's all the awk we'll cover here, folks, but there's lots
       more to learn. See the appropriate references in the <xref linkend="biblio" />.</para>


     </section> 
    <!-- End awk primer -->

  </appendix>
    <!-- End sed/awk appendix -->


  <appendix xml:id="pathmanagement">
      <title>Parsing and Managing Pathnames</title>

      <para>Emmanual Rouat contributed the following example of parsing
        and transforming <firstterm>filenames</firstterm> and, in
        particular, <link linkend="pathnameref">pathnames</link>. It draws
        heavily on the functionality of <firstterm>sed</firstterm>.</para>

      <para>
<programlisting>#!/usr/bin/env bash
#-----------------------------------------------------------
# Management of PATH, LD_LIBRARY_PATH, MANPATH variables...
# By Emmanuel Rouat &lt;no-email&gt;
# (Inspired by the bash documentation 'pathfuncs' and on
# discussions found on stackoverflow:
# http://stackoverflow.com/questions/370047/
# http://stackoverflow.com/questions/273909/#346860 )
# Last modified: Sat Sep 22 12:01:55 CEST 2012
#
# The following functions handle spaces correctly.
# These functions belong in .bash_profile rather than in
# .bashrc, I guess.
#
# The modular aspect of these functions should make it easy
# to expand them to handle path substitutions instead
# of path removal etc....
#
# See http://www.catonmat.net/blog/awk-one-liners-explained-part-two/
# (item 43) for an explanation of the 'duplicate-entries' removal
# (it's a nice trick!)
#-----------------------------------------------------------

# Show $@ (usually PATH) as list.
function p_show() { local p="$@" &amp;&amp; for p; do [[ ${!p} ]] &amp;&amp;
echo -e ${!p//:/\\n}; done }

# Filter out empty lines, multiple/trailing slashes, and duplicate entries.
function p_filter()
{ awk '/^[ \t]*$/ {next} {sub(/\/+$/, "");gsub(/\/+/, "/")}!x[$0]++' ;}

# Rebuild list of items into ':' separated word (PATH-like).
function p_build() { paste -sd: ;}

# Clean $1 (typically PATH) and rebuild it
function p_clean()
{ local p=${1} &amp;&amp; eval ${p}='$(p_show ${p} | p_filter | p_build)' ;}

# Remove $1 from $2 (found on stackoverflow, with modifications).
function p_rm()
{ local d=$(echo $1 | p_filter) p=${2} &amp;&amp;
  eval ${p}='$(p_show ${p} | p_filter | grep -xv "${d}" | p_build)' ;}

#  Same as previous, but filters on a pattern (dangerous...
#+ don't use 'bin' or '/' as pattern!).
function p_rmpat()
{ local d=$(echo $1 | p_filter) p=${2} &amp;&amp; eval ${p}='$(p_show ${p} |
  p_filter | grep -v "${d}" | p_build)' ;}

# Delete $1 from $2 and append it cleanly.
function p_append()
{ local d=$(echo $1 | p_filter) p=${2} &amp;&amp; p_rm "${d}" ${p} &amp;&amp;
  eval ${p}='$(p_show ${p} d | p_build)' ;}

# Delete $1 from $2 and prepend it cleanly.
function p_prepend()
{ local d=$(echo $1 | p_filter) p=${2} &amp;&amp; p_rm "${d}" ${p} &amp;&amp;
  eval ${p}='$(p_show d ${p} | p_build)' ;}

# Some tests:
echo
MYPATH="/bin:/usr/bin/:/bin://bin/"
p_append "/project//my project/bin" MYPATH
echo "Append '/project//my project/bin' to '/bin:/usr/bin/:/bin://bin/'"
echo "(result should be: /bin:/usr/bin:/project/my project/bin)"
echo $MYPATH

echo
MYOTHERPATH="/bin:/usr/bin/:/bin:/project//my project/bin"
p_prepend "/project//my project/bin" MYOTHERPATH
echo "Prepend '/project//my project/bin' \
to '/bin:/usr/bin/:/bin:/project//my project/bin/'"
echo "(result should be: /project/my project/bin:/bin:/usr/bin)"
echo $MYOTHERPATH

echo
p_prepend "/project//my project/bin" FOOPATH  # FOOPATH doesn't exist.
echo "Prepend '/project//my project/bin' to an unset variable"
echo "(result should be: /project/my project/bin)"
echo $FOOPATH

echo
BARPATH="/a:/b/://b c://a:/my local pub"
p_clean BARPATH
echo "Clean BARPATH='/a:/b/://b c://a:/my local pub'"
echo "(result should be: /a:/b:/b c:/my local pub)"
echo $BARPATH
</programlisting>
</para>

      <para>***</para>

      <para>David Wheeler kindly permitted me to use his instructive
        examples.</para>

      <para><programlisting>Doing it correctly: A quick summary
by David Wheeler
http://www.dwheeler.com/essays/filenames-in-shell.html

So, how can you process filenames correctly in shell? Here's a quick
summary about how to do it correctly, for the impatient who "just want the
answer". In short: Double-quote to use "$variable" instead of $variable,
set IFS to just newline and tab, prefix all globs/filenames so they cannot
begin with "-" when expanded, and use one of a few templates that work
correctly. Here are some of those templates that work correctly:


 IFS="$(printf '\n\t')"
 # Remove SPACE, so filenames with spaces work well.

 #  Correct glob use:
 #+ always use "for" loop, prefix glob, check for existence:
 for file in ./* ; do          # Use "./*" ... NEVER bare "*" ...
   if [ -e "$file" ] ; then    # Make sure it isn't an empty match.
     COMMAND ... "$file" ...
   fi
 done



 # Correct glob use, but requires nonstandard bash extension.
 shopt -s nullglob  #  Bash extension,
                    #+ so that empty glob matches will work.
 for file in ./* ; do        # Use "./*", NEVER bare "*"
   COMMAND ... "$file" ...
 done



 #  These handle all filenames correctly;
 #+ can be unwieldy if COMMAND is large:
 find ... -exec COMMAND... {} \;
 find ... -exec COMMAND... {} \+ # If multiple files are okay for COMMAND.



 #  This skips filenames with control characters
 #+ (including tab and newline).
 IFS="$(printf '\n\t')"
 controlchars="$(printf '*[\001-\037\177]*')"
 for file in $(find . ! -name "$controlchars"') ; do
   COMMAND "$file" ...
 done



 #  Okay if filenames can't contain tabs or newlines --
 #+ beware the assumption.
 IFS="$(printf '\n\t')"
 for file in $(find .) ; do
   COMMAND "$file" ...
 done



 # Requires nonstandard but common extensions in find and xargs:
 find . -print0 | xargs -0 COMMAND

 # Requires nonstandard extensions to find and to shell (bash works).
 # variables might not stay set once the loop ends:
 find . -print0 | while IFS="" read -r -d "" file ; do ...
   COMMAND "$file" # Use quoted "$file", not $file, everywhere.
 done



 #  Requires nonstandard extensions to find and to shell (bash works).
 #  Underlying system must include named pipes (FIFOs)
 #+ or the /dev/fd mechanism.
 #  In this version, variables *do* stay set after the loop ends,
 #  and you can read from stdin.
 #+ (Change the 4 to another number if fd 4 is needed.)

 while IFS="" read -r -d "" file &lt;&amp;4 ; do
   COMMAND "$file"   # Use quoted "$file" -- not $file, everywhere.
 done 4&lt; &lt;(find . -print0)


 #  Named pipe version.
 #  Requires nonstandard extensions to find and to shell's read (bash ok).
 #  Underlying system must include named pipes (FIFOs).
 #  Again, in this version, variables *do* stay set after the loop ends,
 #  and you can read from stdin.
 # (Change the 4 to something else if fd 4 needed).

 mkfifo mypipe

 find . -print0 &gt; mypipe &amp;
 while IFS="" read -r -d "" file &lt;&amp;4 ; do
   COMMAND "$file" # Use quoted "$file", not $file, everywhere.
 done 4&lt; mypipe</programlisting></para>

  </appendix>
    <!-- End path management appendix -->


  <appendix xml:id="exitcodes">
      <title>Exit Codes With Special Meanings</title>

      <para><anchor xml:id="exitcodesref" /></para>

      <table>
	<title><firstterm>Reserved</firstterm> Exit Codes</title>
	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry>Exit Code Number</entry>
	      <entry>Meaning</entry>
	      <entry>Example</entry>
	      <entry>Comments</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>1</option></entry>
	      <entry>Catchall for general errors</entry>
	      <entry>let "var1 = 1/0"</entry>
	      <entry>Miscellaneous errors, such as <quote>divide by
	        zero</quote> and other impermissible operations</entry>
	    </row>
	    <row>
	      <entry><option>2</option></entry>
	      <entry>Misuse of shell builtins (according to Bash documentation)</entry>
	      <entry>empty_function() {}</entry>
	      <entry><link linkend="missingkeyword">Missing keyword</link>
              or command, or permission problem (and <link linkend="differr2"><firstterm>diff</firstterm> return code
	      on a failed binary file comparison</link>).</entry>
	    </row>
	    <row>
	      <entry><option>126</option></entry>
	      <entry>Command invoked cannot execute</entry>
	      <entry>/dev/null</entry>
	      <entry>Permission problem or command is not an executable</entry>
	    </row>
	    <row>
	      <entry><option>127</option></entry>
	      <entry><quote>command not found</quote></entry>
	      <entry>illegal_command</entry>
	      <entry>Possible problem with <varname>$PATH</varname> or a typo</entry>
	    </row>
	    <row>
	      <entry><option>128</option></entry>
	      <entry>Invalid argument to <link linkend="exitcommandref">exit</link></entry>
	      <entry>exit 3.14159</entry>
	      <entry><command>exit</command> takes only integer args in the
		range <returnvalue>0 - 255</returnvalue> (see
		first footnote)</entry>
	    </row>
	    <row>
	      <entry><option>128+n</option></entry>
	      <entry>Fatal error signal <quote>n</quote></entry>
	      <entry><firstterm>kill -9</firstterm> <varname>$PPID</varname> of script</entry>
	      <entry><userinput>$?</userinput> returns
	      <errorcode>137</errorcode> (128 + 9)</entry>
	    </row>
	    <row>
	      <entry><option>130</option></entry>
	      <entry>Script terminated by Control-C</entry>
	      <entry><emphasis>Ctl-C</emphasis></entry>
	      <entry>Control-C is fatal error signal
	      <errorcode>2</errorcode>, (130 = 128 + 2, see above)</entry>
	    </row>
	    <row>
	      <entry><option>255*</option></entry>
	      <entry>Exit status out of range</entry>
	      <entry>exit <returnvalue>-1</returnvalue></entry>
	      <entry><command>exit</command> takes only integer args in the
	        range <errorcode>0 - 255</errorcode></entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>According to the above table, exit codes <errorcode>1 - 2,
        126 - 165, and 255</errorcode>

	<footnote><para><anchor xml:id="excoor" />Out of range exit values
	  can result in unexpected exit codes. An exit value
	  greater than <errorcode>255</errorcode> returns an
	  exit code <link linkend="moduloref">modulo</link>
	  <errorcode>256</errorcode>. For example, <firstterm>exit
	  3809</firstterm> gives an exit code of <errorcode>225</errorcode>
	  (3809 % 256 = 225).</para></footnote>

	have special meanings, and should therefore be avoided for
	user-specified exit parameters. Ending a script with <firstterm>exit
	127</firstterm> would certainly cause confusion when troubleshooting
	(is the error code a <quote>command not found</quote> or a
	user-defined one?). However, many scripts use an <firstterm>exit
	1</firstterm> as a general bailout-upon-error. Since exit code
	<errorcode>1</errorcode> signifies so many possible errors,
	it is not particularly useful in debugging.</para>

      <para><anchor xml:id="sysexitsref" /></para>
      <para>There has been an attempt to systematize exit status numbers
	(see <filename class="headerfile">/usr/include/sysexits.h</filename>),
	but this is intended for C and C++ programmers. A similar
	standard for scripting might be appropriate. The author of
	this document proposes restricting user-defined exit codes to
	the range <returnvalue>64 - 113</returnvalue> (in addition to
	<returnvalue>0</returnvalue>, for success), to conform with
	the C/C++ standard. This would allot 50 valid codes, and make
	troubleshooting scripts more straightforward.
	  <footnote><para>An update of <filename class="headerfile">/usr/include/sysexits.h</filename>
	  allocates previously unused exit codes from <returnvalue>64
	  - 78</returnvalue>.  It may be anticipated that the range of
	  unallotted exit codes will be further restricted in the future.
	  The author of this document will <emphasis>not</emphasis> do
	  fixups on the scripting examples to conform to the changing
	  standard. This should not cause any problems, since there
	  is no overlap or conflict in usage of exit codes between
	  compiled C/C++ binaries and shell scripts.</para></footnote>
	All user-defined exit codes in the accompanying examples to
	this document conform to this standard, except where overriding
	circumstances exist, as in <xref linkend="tmdin" />.</para>

      <note><para>Issuing a <link linkend="xstatvarref">$?</link> from
	the command-line after a shell script exits gives
	results consistent with the table above only from the
	Bash or <firstterm>sh</firstterm> prompt. Running the
	<firstterm>C-shell</firstterm> or <firstterm>tcsh</firstterm>
	may give different values in some cases.</para></note>


  </appendix>
    <!-- End Reserved Exit Code appendix -->


  <appendix xml:id="ioredirintro">
      <title>A Detailed Introduction to I/O and I/O Redirection</title>

      <para><emphasis>written by StÃ©phane Chazelas, and revised
        by the document author</emphasis></para>

      <para><anchor xml:id="stdinoutdef" /></para>
      <para>A command expects the first three <link linkend="fdref">file
        descriptors</link> to be available. The first, <firstterm>fd
        0</firstterm> (standard input, <filename>stdin</filename>),
        is for reading. The other two (<firstterm>fd 1</firstterm>,
        <filename>stdout</filename> and <firstterm>fd 2</firstterm>,
        <filename>stderr</filename>) are for writing.</para>

      <para>There is a <filename>stdin</filename>, <filename>stdout</filename>,
        and a <filename>stderr</filename> associated with each command.
        <userinput>ls 2&gt;&amp;1</userinput> means temporarily connecting the
        <filename>stderr</filename> of the <command>ls</command> command to the
        same <quote>resource</quote> as the shell's
        <filename>stdout</filename>.</para>

      <para>By convention, a command reads its input from fd 0
        (<filename>stdin</filename>), prints normal output to fd
        1 (<filename>stdout</filename>), and error ouput to fd 2
        (<filename>stderr</filename>). If one of those three fd's is
        not open, you may encounter problems:</para>

      <screen>
<prompt>bash$ </prompt><userinput>cat /etc/passwd &gt;&amp;-</userinput>
<computeroutput>cat: standard output: Bad file descriptor</computeroutput>
      </screen>

      <para>For example, when <command>xterm</command> runs, it first
        initializes itself.  Before running the user's shell,
        <command>xterm</command> opens the terminal device
        (/dev/pts/&lt;n&gt; or something similar) three times.</para>

      <para>At this point, Bash inherits these three file descriptors,
        and each command (child process) run by Bash inherits
        them in turn, except when you redirect the command.  <link linkend="ioredirref">Redirection</link> means reassigning
        one of the file descriptors to another file (or a pipe, or
        anything permissible). File descriptors may be reassigned
        locally (for a command, a command group, a <link linkend="subshellsref">subshell</link>, a <link linkend="redirref">while or if or case or for loop</link>...),
        or globally, for the remainder of the shell (using <link linkend="execref">exec</link>).</para>

      <para><userinput>ls &gt; /dev/null</userinput> means
        running <command>ls</command> with its fd 1 connected to
        <filename>/dev/null</filename>.</para>

      <para>
      <screen>
<prompt>bash$ </prompt><userinput>lsof -a -p $$ -d0,1,2</userinput>
<computeroutput>COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    363 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        2u   CHR  136,1         3 /dev/pts/1</computeroutput>


<prompt>bash$ </prompt><userinput>exec 2&gt; /dev/null</userinput>
<prompt>bash$ </prompt><userinput>lsof -a -p $$ -d0,1,2</userinput>
<computeroutput>COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    371 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        2w   CHR    1,3       120 /dev/null</computeroutput>


<prompt>bash$ </prompt><userinput>bash -c 'lsof -a -p $$ -d0,1,2' | cat</userinput>
<computeroutput>COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    379 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    379 root    1w  FIFO    0,0      7118 pipe
 lsof    379 root    2u   CHR  136,1         3 /dev/pts/1</computeroutput>


<prompt>bash$ </prompt><userinput>echo "$(bash -c 'lsof -a -p $$ -d0,1,2' 2&gt;&amp;1)"</userinput>
<computeroutput>COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    426 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    426 root    1w  FIFO    0,0      7520 pipe
 lsof    426 root    2w  FIFO    0,0      7520 pipe</computeroutput>
</screen>
</para>

<para>This works for different types of redirection.</para>

<para><userinput>Exercise:</userinput> Analyze the following script.

<programlisting>#! /usr/bin/env bash

mkfifo /tmp/fifo1 /tmp/fifo2
while read a; do echo "FIFO1: $a"; done &lt; /tmp/fifo1 &amp; exec 7&gt; /tmp/fifo1
exec 8&gt; &gt;(while read a; do echo "FD8: $a, to fd7"; done &gt;&amp;7)

exec 3&gt;&amp;1
(
 (
  (
   while read a; do echo "FIFO2: $a"; done &lt; /tmp/fifo2 | tee /dev/stderr \
   | tee /dev/fd/4 | tee /dev/fd/5 | tee /dev/fd/6 &gt;&amp;7 &amp; exec 3&gt; /tmp/fifo2

   echo 1st, to stdout
   sleep 1
   echo 2nd, to stderr &gt;&amp;2
   sleep 1
   echo 3rd, to fd 3 &gt;&amp;3
   sleep 1
   echo 4th, to fd 4 &gt;&amp;4
   sleep 1
   echo 5th, to fd 5 &gt;&amp;5
   sleep 1
   echo 6th, through a pipe | sed 's/.*/PIPE: &amp;, to fd 5/' &gt;&amp;5
   sleep 1
   echo 7th, to fd 6 &gt;&amp;6
   sleep 1
   echo 8th, to fd 7 &gt;&amp;7
   sleep 1
   echo 9th, to fd 8 &gt;&amp;8

  ) 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | while read a; do echo "FD4: $a"; done 1&gt;&amp;3 5&gt;&amp;- 6&gt;&amp;-
 ) 5&gt;&amp;1 &gt;&amp;3 | while read a; do echo "FD5: $a"; done 1&gt;&amp;3 6&gt;&amp;-
) 6&gt;&amp;1 &gt;&amp;3 | while read a; do echo "FD6: $a"; done 3&gt;&amp;-

rm -f /tmp/fifo1 /tmp/fifo2


# For each command and subshell, figure out which fd points to what.
# Good luck!

exit 0</programlisting>
      </para>

  </appendix>
    <!-- A Detailed Introduction to I/O and I/O Redirection -->


   <appendix xml:id="command-line-options">
     <title>Command-Line Options</title>

     <para>Many executables, whether binaries or script files, accept
       options to modify their run-time behavior. For example: from
       the command-line, typing <command>command -o</command>
       would invoke <emphasis>command</emphasis>, with option
       <option>o</option>.</para>


   <section xml:id="standard-options">
     <title>Standard Command-Line Options</title>

      <para>Over time, there has evolved a loose standard for the
        meanings of command-line option flags. The GNU utilities conform
        more closely to this <quote>standard</quote> than older UNIX
        utilities.</para>

      <para>Traditionally, UNIX command-line options consist of a dash,
        followed by one or more lowercase letters. The GNU utilities
        added a double-dash, followed by a complete word or compound
        word.</para>


      <para>The two most widely-accepted options are:</para>

      <itemizedlist xml:id="widelyaccopt">

      <listitem>
      <para><option>-h</option></para>
      <para><option>--help</option></para>
      <para><firstterm>Help</firstterm>: Give usage message and exit.</para>
      </listitem>

      <listitem>
      <para><option>-v</option></para>
      <para><option>--version</option></para>
      <para><firstterm>Version</firstterm>: Show program version and exit.</para>
      </listitem>

      </itemizedlist>


      <para>Other common options are:</para>

      <itemizedlist xml:id="otheroptns">

      <listitem>
      <para><option>-a</option></para>
      <para><option>--all</option></para>
      <para><firstterm>All</firstterm>: show <emphasis>all</emphasis>
        information or operate on <emphasis>all</emphasis> arguments.</para>
       
      </listitem>

      <listitem>
      <para><option>-l</option></para>
      <para><option>--list</option></para>
      <para><firstterm>List</firstterm>: list files or arguments without
        taking other action.</para>
      </listitem>

      <listitem>
      <para><option>-o</option></para>
      <para><firstterm>Output</firstterm> filename</para>
      </listitem>

      <listitem>
      <para><option>-q</option></para>
      <para><option>--quiet</option></para>
      <para><firstterm>Quiet</firstterm>: suppress
      <filename>stdout</filename>.</para>
      </listitem>

      <listitem>
      <para><option>-r</option></para>
      <para><option>-R</option></para>
      <para><option>--recursive</option></para>
      <para><firstterm>Recursive</firstterm>: Operate recursively (down
        directory tree).</para>
      </listitem>

      <listitem>
      <para><option>-v</option></para>
      <para><option>--verbose</option></para>
      <para><firstterm>Verbose</firstterm>: output additional information to
        <filename>stdout</filename> or <filename>stderr</filename>.</para>
      </listitem>

      <listitem>
      <para><option>-z</option></para>
      <para><option>--compress</option></para>
      <para><firstterm>Compress</firstterm>: apply compression (usually
        <link linkend="gzipref">gzip</link>).</para>
      </listitem>

      </itemizedlist>


      <para>However:</para>

      <itemizedlist xml:id="exceptionsopts">

      <listitem>
      <para>In <command>tar</command> and <command>gawk</command>:</para>
      <para><option>-f</option></para>
      <para><option>--file</option></para>
      <para><firstterm>File</firstterm>: filename follows.</para>
      </listitem>

      <listitem>
      <para>In <command>cp</command>, <command>mv</command>,
        <command>rm</command>:</para>
      <para><option>-f</option></para>
      <para><option>--force</option></para>
      <para><firstterm>Force</firstterm>: force overwrite of target file(s).</para>
      </listitem>

      </itemizedlist>


      <caution><para>Many UNIX and Linux utilities deviate from this
      <quote>standard,</quote> so it is dangerous to
      <emphasis>assume</emphasis> that a given option will behave in a
      standard way. Always check the man page for the command in question
      when in doubt.</para></caution>

      <para>A complete table of recommended options for the GNU utilities
        is available at <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gnu.org/prep/standards/">the GNU standards page</link>.</para>

   </section>




   <section xml:id="bash-options">
     <title>Bash Command-Line Options</title>

     <para><anchor xml:id="clopts" /></para>
     <para><firstterm>Bash</firstterm> itself has a number of command-line
       options. Here are some of the more useful ones.</para>

      <itemizedlist xml:id="bash-commline-opts">

      <listitem>
      <para><option>-c</option></para>
      <para><emphasis>Read commands from the following string and assign any
        arguments to the <link linkend="posparamref">positional
        parameters</link>.</emphasis></para>
       <para>
	      <screen>
<prompt>bash$ </prompt><userinput>bash -c 'set a b c d; IFS="+-;"; echo "$*"'</userinput>
<computeroutput>a+b+c+d</computeroutput>
	      </screen>
       </para>
      </listitem>

      <listitem>
      <para><option>-r</option></para>
      <para><option>--restricted</option></para>
      <para><emphasis>Runs the shell, or a script, in <link linkend="restrictedshref">restricted mode</link>.</emphasis></para>
      </listitem>

      <listitem>
      <para><option>--posix</option></para>
      <para><emphasis>Forces Bash to conform to <link linkend="posix2ref">POSIX</link> mode.</emphasis></para>
      </listitem>

      <listitem>
      <para><option>--version</option></para>
      <para><emphasis>Display Bash version information and
        exit.</emphasis></para>
      </listitem>

      <listitem>
      <para><option>--</option></para>
      <para><emphasis>End of options. Anything further on the command
      line is an argument, not an option.</emphasis></para>
      </listitem>

      </itemizedlist>

      </section>


   </appendix>
   <!-- End Command-Line Options appendix -->


   <appendix xml:id="files">
    <title> Important Files</title>

      <variablelist xml:id="filesref">
        <title><anchor xml:id="filesref1" />startup files</title>

	<varlistentry>
	  <term />
	<listitem>
	  <para>These files contain the aliases and <link linkend="envref">environmental variables</link>
	    made available to Bash running as a user shell and to all
	    Bash scripts invoked after system initialization.</para>
	</listitem>
	</varlistentry>


	<varlistentry>
	  <term><filename moreinfo="none">/etc/profile</filename></term>
	<listitem>
	  <para>Systemwide defaults, mostly setting the environment
	  (all Bourne-type shells, not just Bash
	     <footnote><para>This does not apply to <command>csh</command>,
	       <command>tcsh</command>, and other shells not related to or
	       descended from the classic Bourne shell
	       (<command>sh</command>).</para></footnote>)</para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><filename moreinfo="none">/etc/bashrc</filename></term>
	<listitem>
	  <para>systemwide functions and <link linkend="aliasref">aliases</link> for Bash</para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><filename moreinfo="none"><varname>$HOME</varname>/.bash_profile</filename></term>
	<listitem>
	  <para>user-specific Bash environmental default settings,
	    found in each user's home directory (the local counterpart
	    to <filename>/etc/profile</filename>)</para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><filename moreinfo="none"><varname>$HOME</varname>/.bashrc</filename></term>
	<listitem>
	  <para>user-specific Bash init file, found in each user's home
	    directory (the local counterpart to
	    <filename>/etc/bashrc</filename>).	Only interactive
	    shells and user scripts read this file. See
	    <xref linkend="sample-bashrc" /> for a sample
	    <filename>.bashrc</filename> file.</para>
	</listitem>
      </varlistentry>

      </variablelist>


      <variablelist xml:id="logoutfileref">
        <title><anchor xml:id="logoutfileref1" />logout file</title>
	<varlistentry>
	  <term><filename moreinfo="none"><varname>$HOME</varname>/.bash_logout</filename></term>

	<listitem>
	  <para>user-specific instruction file, found in
	    each user's home directory. Upon exit from a login (Bash)
	    shell, the commands in this file execute.</para>
	</listitem>

	</varlistentry>
      </variablelist>


      <variablelist xml:id="datafilesref">
        <title><anchor xml:id="datafilesref1" />data files</title>

	<varlistentry>
	  <term><filename moreinfo="none">/etc/passwd</filename></term>
	<listitem>
	  <para>A listing of all the user accounts on the system,
	    their identities, their home directories, the groups they
	    belong to, and their default shell. Note that the user
	    passwords are <emphasis>not</emphasis>
            stored in this file,
	      <footnote><para>In older versions of UNIX, passwords
	      <emphasis>were</emphasis> stored in
	      <filename>/etc/passwd</filename>, and that explains
	      the name of the file.</para></footnote>
	    but in <filename>/etc/shadow</filename> in encrypted form.</para>
	</listitem>
	</varlistentry>
      </variablelist>


      <variablelist xml:id="sysconfref">
        <title><anchor xml:id="sysconfref1" />system configuration files</title>

	<varlistentry>
	  <term><filename moreinfo="none">/etc/sysconfig/hwconf</filename></term>
	<listitem>
	  <para>Listing and description of attached hardware devices.
	     This information is in text form and can be extracted and
	     parsed.</para>
<para>
<screen>
<prompt>bash$ </prompt><userinput>grep -A 5 AUDIO /etc/sysconfig/hwconf</userinput>	      
<computeroutput>class: AUDIO
 bus: PCI
 detached: 0
 driver: snd-intel8x0
 desc: "Intel Corporation 82801CA/CAM AC'97 Audio Controller"
 vendorId: 8086</computeroutput>
 </screen>
</para>
	  <note><para>This file is present on Red Hat and Fedora Core
	     installations, but may be missing from other
	     distros.</para></note>
	</listitem>
      </varlistentry>

      </variablelist>

  </appendix>
  <!-- End Files appendix -->





  <appendix xml:id="systemdirs">

      <title>Important System Directories</title>


      <para>Sysadmins and anyone else writing administrative scripts
        should be intimately familiar with the following system
        directories.</para>

        <itemizedlist>

          <listitem>
	    <para><filename class="directory">/bin</filename></para>
	    <para>Binaries (executables). Basic system programs
	      and utilities (such as <command>bash</command>).</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/bin</filename>

            <footnote>
	    <para>Some early UNIX systems had a fast, small-capacity fixed
	      disk (containing <filename class="directory">/</filename>,
	      the root partition), and a second drive which
	      was larger, but slower (containing <filename class="directory">/usr</filename> and other
	      partitions). The most frequently used programs and
	      utilities therefore resided on the small-but-fast
	      drive, in <filename class="directory">/bin</filename>,
	      and the others on the slower drive, in <filename class="directory">/usr/bin</filename>.</para>

	    <para>This likewise accounts for the split between
	      <filename class="directory">/sbin</filename> and
	      <filename class="directory">/usr/sbin</filename>,
	      <filename class="directory">/lib</filename> and <filename class="directory">/usr/lib</filename>, etc.</para>
	    </footnote>

	    </para>

	    <para>More system binaries.</para>

          </listitem>

          <listitem>
            <para><filename class="directory">/usr/local/bin</filename></para>
	    <para>Miscellaneous binaries local to the particular machine.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/sbin</filename></para>
	    <para>System binaries. Basic system administrative programs
	      and utilities (such as <command>fsck</command>).</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/sbin</filename></para>
	    <para>More system administrative programs and utilities.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/etc</filename></para>

	    <para><firstterm>Et cetera</firstterm>. Systemwide configuration
	      scripts.</para>
	      
	    <para>Of particular interest are the
	      <link linkend="fstabref"><filename>/etc/fstab</filename></link>
	      (filesystem table),
	      <filename>/etc/mtab</filename>
	      (mounted filesystem table), and the <link linkend="inittabref"><filename>/etc/inittab</filename></link>
	      files.</para>

	  </listitem>

          <listitem>
            <para><filename class="directory">/etc/rc.d</filename></para>
	    <para>Boot scripts, on Red Hat and derivative distributions
	      of Linux.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/share/doc</filename></para>
	    <para>Documentation for installed packages.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/man</filename></para>
	    <para>The systemwide <link linkend="manref">manpages</link>.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/dev</filename></para>
	    <para>Device directory. Entries (but <emphasis>not</emphasis>
	      mount points) for physical and virtual devices.
	      See <xref linkend="devproc" />.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/proc</filename></para>
	    <para>Process directory. Contains information and statistics
	      about running processes and kernel parameters.
	      See <xref linkend="devproc" />.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/sys</filename></para>
	    <para>Systemwide device directory. Contains information and
	      statistics about device and device names. This is newly
	      added to Linux with the 2.6.X kernels.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/mnt</filename></para>
	    <para><firstterm>Mount</firstterm>. Directory for mounting
	      hard drive partitions, such as <filename class="directory">/mnt/dos</filename>, and physical
	      devices. In newer Linux distros, the <filename class="directory">/media</filename> directory has taken
	      over as the preferred mount point for I/O devices.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/media</filename></para>
	    <para>In newer Linux distros, the preferred mount point for
	      I/O devices, such as CD/DVD drives or USB flash drives.</para>
          </listitem>

          <listitem>
	    <para><filename class="directory">/var</filename></para>
	    <para><firstterm>Variable</firstterm> (changeable) system
	      files. This is a catchall <quote>scratchpad</quote>
	      directory for data generated while a Linux/UNIX machine
	      is running.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/var/log</filename></para>
	    <para>Systemwide log files.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/var/spool/mail</filename></para>
	    <para>User mail spool.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/lib</filename></para>
	    <para>Systemwide library files.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/lib</filename></para>
	    <para>More systemwide library files.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/tmp</filename></para>
	    <para>System temporary files.</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/boot</filename></para>
	    <para>System <firstterm>boot</firstterm> directory. The kernel,
	      module links, system map, and boot manager reside here.</para>
            <warning><para>Altering files in this directory may result in an
	      unbootable system.</para></warning>
          </listitem>

        </itemizedlist>

  </appendix>



  <appendix xml:id="tabexpansion">

            <title>An Introduction to Programmable Completion</title>

    <para>The <firstterm>programmable completion</firstterm> feature in
      Bash permits typing a partial command, then pressing the
      <keycap>[Tab]</keycap> key to auto-complete the command sequence.

      <footnote><para>This works only from the <firstterm>command
        line</firstterm>, of course, and not within a
        script.</para></footnote>

      If multiple completions are possible, then <keycap>[Tab]</keycap>
      lists them all. Let's see how it works.</para>

      <para>
      <screen>
<prompt>bash$ </prompt><userinput>xtra[Tab]</userinput>
<computeroutput>xtraceroute       xtrapin           xtrapproto
 xtraceroute.real  xtrapinfo         xtrapreset
 xtrapchar         xtrapout          xtrapstats</computeroutput>


<prompt>bash$ </prompt><userinput>xtrac[Tab]</userinput>
<computeroutput>xtraceroute       xtraceroute.real</computeroutput>


<prompt>bash$ </prompt><userinput>xtraceroute.r[Tab]</userinput>
<computeroutput>xtraceroute.real</computeroutput>
      </screen>
      </para>

    <para>Tab completion also works for variables and path names.</para>

      <para>
      <screen>
<prompt>bash$ </prompt><userinput>echo $BASH[Tab]</userinput>
<computeroutput>$BASH                 $BASH_COMPLETION      $BASH_SUBSHELL
 $BASH_ARGC            $BASH_COMPLETION_DIR  $BASH_VERSINFO
 $BASH_ARGV            $BASH_LINENO          $BASH_VERSION
 $BASH_COMMAND         $BASH_SOURCE</computeroutput>


<prompt>bash$ </prompt><userinput>echo /usr/local/[Tab]</userinput>
<computeroutput>bin/     etc/     include/ libexec/ sbin/    src/     
 doc/     games/   lib/     man/     share/</computeroutput>
      </screen>
      </para>


    <para><anchor xml:id="completeref" /></para>

    <para>The Bash <command>complete</command> and
      <command>compgen</command> <link linkend="builtinref">builtins</link> make it
      possible for <firstterm>tab completion</firstterm> to
      recognize partial <firstterm>parameters</firstterm> and
      <firstterm>options</firstterm> to commands. In a very simple case,
      we can use <command>complete</command> from the command-line to
      specify a short list of acceptable parameters.</para>


  <screen>
<prompt>bash$ </prompt><userinput>touch sample_command</userinput>
<prompt>bash$ </prompt><userinput>touch file1.txt file2.txt file2.doc file30.txt file4.zzz</userinput>
<prompt>bash$ </prompt><userinput>chmod +x sample_command</userinput>
<prompt>bash$ </prompt><userinput>complete -f -X '!*.txt' sample_command</userinput>


<prompt>bash$ </prompt><userinput>./sample[Tab][Tab]</userinput>
<computeroutput>sample_command</computeroutput>
<computeroutput>file1.txt   file2.txt   file30.txt</computeroutput>
  </screen>

    <para>The <option>-f</option> option to
      <firstterm>complete</firstterm> specifies filenames,
      and <option>-X</option> the filter pattern.</para>

    <para><anchor xml:id="compgenref" /></para>

    <para>For anything more complex, we could write a script that
      specifies a list of acceptable command-line parameters.
      The <command>compgen</command> builtin expands a list of
      <firstterm>arguments</firstterm> to <firstterm>generate</firstterm>
      completion matches. </para>

    <para>Let us take a <link linkend="usegetopt2">modified version</link>
      of the <emphasis>UseGetOpt.sh</emphasis> script as an example
      command. This script accepts a number of command-line parameters,
      preceded by either a single or double dash. And here is the
      corresponding <firstterm>completion script</firstterm>, by
      convention given a filename corresponding to its associated
      command.</para>

    <example xml:id="usegetoptex">
      <title>Completion script for
      <firstterm>UseGetOpt.sh</firstterm></title>
      <programlisting># file: UseGetOpt-2
# UseGetOpt-2.sh parameter-completion

_UseGetOpt-2 ()   #  By convention, the function name
{                 #+ starts with an underscore.
  local cur
  # Pointer to current completion word.
  # By convention, it's named "cur" but this isn't strictly necessary.

  COMPREPLY=()   # Array variable storing the possible completions.
  cur=${COMP_WORDS[COMP_CWORD]}

  case "$cur" in
    -*)
    COMPREPLY=( $( compgen -W '-a -d -f -l -t -h --aoption --debug \
                               --file --log --test --help --' -- $cur ) );;
#   Generate the completion matches and load them into $COMPREPLY array.
#   xx) May add more cases here.
#   yy)
#   zz)
  esac

  return 0
}

complete -F _UseGetOpt-2 -o filenames ./UseGetOpt-2.sh
#        ^^ ^^^^^^^^^^^^  Invokes the function _UseGetOpt-2.
</programlisting>
    </example>

    <para>Now, let's try it.</para>

  <screen>
<prompt>bash$ </prompt><userinput>source UseGetOpt-2</userinput>

<prompt>bash$ </prompt><userinput>./UseGetOpt-2.sh -[Tab]</userinput>
<computeroutput>--         --aoption  --debug    --file     --help     --log     --test
 -a         -d         -f         -h         -l         -t</computeroutput>


<prompt>bash$ </prompt><userinput>./UseGetOpt-2.sh --[Tab]</userinput>
<computeroutput>--         --aoption  --debug    --file     --help     --log     --test</computeroutput>
  </screen>


    <para>
      We begin by <link linkend="sourceref">sourcing</link> the <quote>completion
      script.</quote> This sets the command-line parameters.
        <footnote><para>Normally the default parameter completion files reside
        in either the <filename class="directory">/etc/profile.d</filename>
	directory or in <filename class="directory">/etc/bash_completion</filename>. These autoload on
	system startup. So, after writing a useful completion script, you
	might wish to move it (as <firstterm>root</firstterm>, of course)
	to one of these directories.</para></footnote>
    </para>

    <para>In the first instance, hitting <keycap>[Tab]</keycap> after
      a single dash, the output is all the possible parameters preceded by
      <emphasis>one or more</emphasis> dashes. Hitting <keycap>[Tab]</keycap>
      after <emphasis>two</emphasis> dashes gives the possible parameters
      preceded by <emphasis>two or more</emphasis> dashes.</para>


    <para>Now, just what is the point of having to jump through flaming
      hoops to enable command-line tab completion? <emphasis>It saves
      keystrokes.</emphasis>
         <footnote><para>It has been extensively documented that
         programmers are willing to put in long hours of effort in
         order to save ten minutes of <quote>unnecessary</quote>
         labor. This is known as
         <firstterm>optimization</firstterm>.</para></footnote>
      </para>


    <para>--</para>

    <para><emphasis>Resources:</emphasis></para>

    <para>Bash <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://freshmeat.net/projects/bashcompletion">
      programmable completion</link> project</para>

    <para>Mitch Frazier's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxjournal.com"><citetitle pubwork="journal">Linux Journal</citetitle></link> article, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxjournal.com/content/more-using-bash-complete-command"><emphasis>More
    on Using the Bash Complete Command</emphasis></link></para>

    <para>Steve's excellent two-part article, <quote>An Introduction to Bash
      Completion</quote>:

    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.debian-administration.org/article/An_introduction_to_bash_completion_part_1">Part
    1</link> and

    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.debian-administration.org/article/An_introduction_to_bash_completion_part_2">Part 2</link></para>



  </appendix>
    <!-- End Tab Expansion appendix -->



  <appendix xml:id="localization">
      <title>Localization</title>


      <para>Localization is an undocumented Bash feature.</para>

      <para><anchor xml:id="localeref" />A localized shell script echoes
        its text output in the language defined as the system's locale.
        A Linux user in Berlin, Germany, would get script output in German,
        whereas his cousin in Berlin, Maryland, would get output from
        the same script in English.</para>

      <para>To create a localized script, use the following template to
        write all messages to the user (error messages, prompts,
        etc.).</para>

      <para>
      <programlisting>#!/bin/bash
# localized.sh
#  Script by StÃ©phane Chazelas,
#+ modified by Bruno Haible, bugfixed by Alfredo Pironti.

. gettext.sh

E_CDERROR=65

error()
{
  printf "$@" &gt;&amp;2
  exit $E_CDERROR
}

cd $var || error "`eval_gettext \"Can\'t cd to \\\$var.\"`"
#  The triple backslashes (escapes) in front of $var needed
#+ "because eval_gettext expects a string
#+ where the variable values have not yet been substituted."
#    -- per Bruno Haible
read -p "`gettext \"Enter the value: \"`" var
#  ...


#  ------------------------------------------------------------------
#  Alfredo Pironti comments:

#  This script has been modified to not use the $"..." syntax in
#+ favor of the "`gettext \"...\"`" syntax.
#  This is ok, but with the new localized.sh program, the commands
#+ "bash -D filename" and "bash --dump-po-string filename"
#+ will produce no output
#+ (because those command are only searching for the $"..." strings)!
#  The ONLY way to extract strings from the new file is to use the
# 'xgettext' program. However, the xgettext program is buggy.

# Note that 'xgettext' has another bug.
#
# The shell fragment:
#    gettext -s "I like Bash"
# will be correctly extracted, but . . .
#    xgettext -s "I like Bash"
# . . . fails!
#  'xgettext' will extract "-s" because
#+ the command only extracts the
#+ very first argument after the 'gettext' word.


#  Escape characters:
#
#  To localize a sentence like
#     echo -e "Hello\tworld!"
#+ you must use
#     echo -e "`gettext \"Hello\\tworld\"`"
#  The "double escape character" before the `t' is needed because
#+ 'gettext' will search for a string like: 'Hello\tworld'
#  This is because gettext will read one literal `\')
#+ and will output a string like "Bonjour\tmonde",
#+ so the 'echo' command will display the message correctly.
#
#  You may not use
#     echo "`gettext -e \"Hello\tworld\"`"
#+ due to the xgettext bug explained above.



# Let's localize the following shell fragment:
#     echo "-h display help and exit"
#
# First, one could do this:
#     echo "`gettext \"-h display help and exit\"`"
#  This way 'xgettext' will work ok,
#+ but the 'gettext' program will read "-h" as an option!
#
# One solution could be
#     echo "`gettext -- \"-h display help and exit\"`"
#  This way 'gettext' will work,
#+ but 'xgettext' will extract "--", as referred to above.
#
# The workaround you may use to get this string localized is
#     echo -e "`gettext \"\\0-h display help and exit\"`"
#  We have added a \0 (NULL) at the beginning of the sentence.
#  This way 'gettext' works correctly, as does 'xgettext.'
#  Moreover, the NULL character won't change the behavior
#+ of the 'echo' command.
#  ------------------------------------------------------------------</programlisting>
      </para>


      <para>
      <screen><prompt>bash$ </prompt><userinput>bash -D localized.sh</userinput>
<computeroutput>"Can't cd to %s."
 "Enter the value: "</computeroutput></screen>

      This lists all the localized text. (The <option>-D</option>
      option lists double-quoted strings prefixed by a <token>$</token>,
      without executing the script.)</para>

      <para>
      <screen><prompt>bash$ </prompt><userinput>bash --dump-po-strings localized.sh</userinput>
<computeroutput>#: a:6
 msgid "Can't cd to %s."
 msgstr ""
 #: a:7
 msgid "Enter the value: "
 msgstr ""</computeroutput></screen>
      
      The <option>--dump-po-strings</option> option to Bash
      resembles the <option>-D</option> option, but uses <link linkend="gettextref">gettext</link> <quote>po</quote> format.

      </para>

      <note>
      <para>Bruno Haible points out:</para>

      <para>Starting with gettext-0.12.2, <command>xgettext -o - localized.sh</command>
      is recommended instead of <command>bash --dump-po-strings
      localized.sh</command>, because <command>xgettext</command> . . .</para>
      
      <para>1. understands the gettext and eval_gettext commands
      (whereas bash --dump-po-strings understands only its deprecated
      $"..." syntax)</para>

      <para>2. can extract comments placed by the programmer, intended
      to be read by the translator.</para>

      <para>This shell code is then not specific to Bash any
      more; it works the same way with Bash 1.x and other /bin/sh
      implementations.</para>
      </note>


      <para>Now, build a <filename>language.po</filename>
	file for each language that the script will be translated
	into, specifying the <replaceable>msgstr</replaceable>. Alfredo
	Pironti gives the following example:</para>

      <para>fr.po:

      <programlisting>#: a:6
msgid "Can't cd to $var."
msgstr "Impossible de se positionner dans le repertoire $var."
#: a:7
msgid "Enter the value: "
msgstr "Entrez la valeur : "

#  The string are dumped with the variable names, not with the %s syntax,
#+ similar to C programs.
#+ This is a very cool feature if the programmer uses
#+ variable names that make sense!</programlisting>
      </para>

      <para>Then, run <link linkend="msgfmtref">msgfmt</link>.</para>
      <para><userinput>msgfmt -o localized.sh.mo fr.po</userinput></para>

      <para>Place the resulting <filename>localized.sh.mo</filename> file in the
        <filename class="directory">/usr/local/share/locale/fr/LC_MESSAGES</filename>
        directory, and at the beginning of the script, insert the lines:

	  <programlisting>TEXTDOMAINDIR=/usr/local/share/locale
TEXTDOMAIN=localized.sh</programlisting>
      </para>

      <para>If a user on a French system runs the script, she will get
        French messages.</para>

      <note>
      <para>With older versions of Bash or other shells, localization requires
        <link linkend="gettextref">gettext</link>, using the
	<option>-s</option> option. In this case, the script becomes:</para>

      <para><anchor xml:id="gettextexample" />
      <programlisting>#!/bin/bash
# localized.sh

E_CDERROR=65

error() {
  local format=$1
  shift
  printf "$(gettext -s "$format")" "$@" &gt;&amp;2
  exit $E_CDERROR
}
cd $var || error "Can't cd to %s." "$var"
read -p "$(gettext -s "Enter the value: ")" var
# ...</programlisting>
      </para>
      </note>

      <para>The <varname>TEXTDOMAIN</varname> and
	<varname>TEXTDOMAINDIR</varname> variables need to be set and
	exported to the environment. This should be done within the
	script itself.</para>

      <para>---</para>

      <para>This appendix written by StÃ©phane Chazelas,
	with modifications suggested by Alfredo Pironti,
	and by Bruno Haible, maintainer of GNU <link linkend="gettextref">gettext</link>.</para>

  </appendix>
    <!-- Localization -->



  <appendix xml:id="histcommands">
      <title>History Commands</title>

     <para>The Bash shell provides command-line tools for editing and
       manipulating a user's <firstterm>command history</firstterm>. This
       is primarily a convenience, a means of saving keystrokes.</para>

     <para>Bash history commands:
       <orderedlist>
         <listitem><para><command>history</command></para></listitem>
         <listitem><para><command>fc</command></para></listitem>
       </orderedlist>
     </para>  

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>history</userinput>
<computeroutput>   1  mount /mnt/cdrom
    2  cd /mnt/cdrom
    3  ls
     ...</computeroutput>
	      </screen>
	    </para>

     <para>Internal variables associated with Bash history commands:
       <orderedlist>
         <listitem><para>$HISTCMD</para></listitem>
         <listitem><para>$HISTCONTROL</para></listitem>
         <listitem><para>$HISTIGNORE</para></listitem>
         <listitem><para>$HISTFILE</para></listitem>
         <listitem><para>$HISTFILESIZE</para></listitem>
         <listitem><para>$HISTSIZE</para></listitem>
         <listitem><para>$HISTTIMEFORMAT (Bash, ver. 3.0 or later)</para></listitem>
         <listitem><para>!!</para></listitem>
         <listitem><para>!$</para></listitem>
         <listitem><para>!#</para></listitem>
         <listitem><para>!N</para></listitem>
         <listitem><para>!-N</para></listitem>
         <listitem><para>!STRING</para></listitem>
         <listitem><para>!?STRING?</para></listitem>
         <listitem><para>^STRING^string^</para></listitem>
       </orderedlist>
     </para>  

     <para>Unfortunately, the Bash history tools find no use in
       scripting.</para> 

     <para><programlisting>#!/bin/bash
# history.sh
# A (vain) attempt to use the 'history' command in a script.

history                      # No output.

var=$(history); echo "$var"  # $var is empty.

#  History commands are, by default, disabled within a script.
#  However, as dhw points out,
#+ set -o history
#+ enables the history mechanism.

set -o history
var=$(history); echo "$var"   # 1  var=$(history)</programlisting>
     </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>./history.sh</userinput>
<computeroutput>(no output)</computeroutput>	      
	      </screen>
	  </para>

	  <para>The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://samrowe.com/wordpress/advancing-in-the-bash-shell/">Advancing
	    in the Bash Shell</link> site gives a good introduction to
	    the use of history commands in Bash.</para>



  </appendix>
    <!-- History Commands -->


  <appendix xml:id="sample-bashrc">
	  <title>Sample <filename>.bashrc</filename>  and
	    <filename>.bash_profile</filename> Files</title>

     <para>The <filename>~/.bashrc</filename> file determines the
       behavior of interactive shells. A good look at this file can
       lead to a better understanding of Bash.</para>

      <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:emmanuel.rouat@wanadoo.fr">Emmanuel
        Rouat</link> contributed the following very elaborate
        <filename>.bashrc</filename> file, written for a Linux system.
        He welcomes reader feedback on it.</para>
       
      <para>Study the file carefully, and feel free to reuse code
        snippets and functions from it in your own
        <filename>.bashrc</filename> file or even in your scripts.</para>


      <example xml:id="bashrc">
	<title>Sample <filename>.bashrc</filename> file</title>
	<programlisting># =============================================================== #
#
# PERSONAL $HOME/.bashrc FILE for bash-3.0 (or later)
# By Emmanuel Rouat [no-email]
#
# Last modified: Tue Nov 20 22:04:47 CET 2012

#  This file is normally read by interactive shells only.
#+ Here is the place to define your aliases, functions and
#+ other interactive features like your prompt.
#
#  The majority of the code here assumes you are on a GNU
#+ system (most likely a Linux box) and is often based on code
#+ found on Usenet or Internet.
#
#  See for instance:
#  http://tldp.org/LDP/abs/html/index.html
#  http://www.caliban.org/bash
#  http://www.shelldorado.com/scripts/categories.html
#  http://www.dotfiles.org
#
#  The choice of colors was done for a shell with a dark background
#+ (white on black), and this is usually also suited for pure text-mode
#+ consoles (no X server available). If you use a white background,
#+ you'll have to do some other choices for readability.
#
#  This bashrc file is a bit overcrowded.
#  Remember, it is just an example.
#  Tailor it to your needs.
#
# =============================================================== #

# --&gt; Comments added by HOWTO author.

# If not running interactively, don't do anything
[ -z "$PS1" ] &amp;&amp; return


#-------------------------------------------------------------
# Source global definitions (if any)
#-------------------------------------------------------------


if [ -f /etc/bashrc ]; then
      . /etc/bashrc   # --&gt; Read /etc/bashrc, if present.
fi


#--------------------------------------------------------------
#  Automatic setting of $DISPLAY (if not set already).
#  This works for me - your mileage may vary. . . .
#  The problem is that different types of terminals give
#+ different answers to 'who am i' (rxvt in particular can be
#+ troublesome) - however this code seems to work in a majority
#+ of cases.
#--------------------------------------------------------------

function get_xserver ()
{
    case $TERM in
        xterm )
            XSERVER=$(who am i | awk '{print $NF}' | tr -d ')''(' )
            # Ane-Pieter Wieringa suggests the following alternative:
            #  I_AM=$(who am i)
            #  SERVER=${I_AM#*(}
            #  SERVER=${SERVER%*)}
            XSERVER=${XSERVER%%:*}
            ;;
            aterm | rxvt)
            # Find some code that works here. ...
            ;;
    esac
}

if [ -z ${DISPLAY:=""} ]; then
    get_xserver
    if [[ -z ${XSERVER}  || ${XSERVER} == $(hostname) ||
       ${XSERVER} == "unix" ]]; then
          DISPLAY=":0.0"          # Display on local host.
    else
       DISPLAY=${XSERVER}:0.0     # Display on remote host.
    fi
fi

export DISPLAY

#-------------------------------------------------------------
# Some settings
#-------------------------------------------------------------

#set -o nounset     # These  two options are useful for debugging.
#set -o xtrace
alias debug="set -o nounset; set -o xtrace"

ulimit -S -c 0      # Don't want coredumps.
set -o notify
set -o noclobber
set -o ignoreeof


# Enable options:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s sourcepath
shopt -s no_empty_cmd_completion
shopt -s cmdhist
shopt -s histappend histreedit histverify
shopt -s extglob       # Necessary for programmable completion.

# Disable options:
shopt -u mailwarn
unset MAILCHECK        # Don't want my shell to warn me of incoming mail.


#-------------------------------------------------------------
# Greeting, motd etc. ...
#-------------------------------------------------------------

# Color definitions (taken from Color Bash Prompt HowTo).
# Some colors might look different of some terminals.
# For example, I see 'Bold Red' as 'orange' on my screen,
# hence the 'Green' 'BRed' 'Red' sequence I often use in my prompt.


# Normal Colors
Black='\e[0;30m'        # Black
Red='\e[0;31m'          # Red
Green='\e[0;32m'        # Green
Yellow='\e[0;33m'       # Yellow
Blue='\e[0;34m'         # Blue
Purple='\e[0;35m'       # Purple
Cyan='\e[0;36m'         # Cyan
White='\e[0;37m'        # White

# Bold
BBlack='\e[1;30m'       # Black
BRed='\e[1;31m'         # Red
BGreen='\e[1;32m'       # Green
BYellow='\e[1;33m'      # Yellow
BBlue='\e[1;34m'        # Blue
BPurple='\e[1;35m'      # Purple
BCyan='\e[1;36m'        # Cyan
BWhite='\e[1;37m'       # White

# Background
On_Black='\e[40m'       # Black
On_Red='\e[41m'         # Red
On_Green='\e[42m'       # Green
On_Yellow='\e[43m'      # Yellow
On_Blue='\e[44m'        # Blue
On_Purple='\e[45m'      # Purple
On_Cyan='\e[46m'        # Cyan
On_White='\e[47m'       # White

NC="\e[m"               # Color Reset


ALERT=${BWhite}${On_Red} # Bold White on red background



echo -e "${BCyan}This is BASH ${BRed}${BASH_VERSION%.*}${BCyan}\
- DISPLAY on ${BRed}$DISPLAY${NC}\n"
date
if [ -x /usr/games/fortune ]; then
    /usr/games/fortune -s     # Makes our day a bit more fun.... :-)
fi

function _exit()              # Function to run upon exit of shell.
{
    echo -e "${BRed}Hasta la vista, baby${NC}"
}
trap _exit EXIT

#-------------------------------------------------------------
# Shell Prompt - for many examples, see:
#       http://www.debian-administration.org/articles/205
#       http://www.askapache.com/linux/bash-power-prompt.html
#       http://tldp.org/HOWTO/Bash-Prompt-HOWTO
#       https://github.com/nojhan/liquidprompt
#-------------------------------------------------------------
# Current Format: [TIME USER@HOST PWD] &gt;
# TIME:
#    Green     == machine load is low
#    Orange    == machine load is medium
#    Red       == machine load is high
#    ALERT     == machine load is very high
# USER:
#    Cyan      == normal user
#    Orange    == SU to user
#    Red       == root
# HOST:
#    Cyan      == local session
#    Green     == secured remote connection (via ssh)
#    Red       == unsecured remote connection
# PWD:
#    Green     == more than 10% free disk space
#    Orange    == less than 10% free disk space
#    ALERT     == less than 5% free disk space
#    Red       == current user does not have write privileges
#    Cyan      == current filesystem is size zero (like /proc)
# &gt;:
#    White     == no background or suspended jobs in this shell
#    Cyan      == at least one background job in this shell
#    Orange    == at least one suspended job in this shell
#
#    Command is added to the history file each time you hit enter,
#    so it's available to all shells (using 'history -a').


# Test connection type:
if [ -n "${SSH_CONNECTION}" ]; then
    CNX=${Green}        # Connected on remote machine, via ssh (good).
elif [[ "${DISPLAY%%:0*}" != "" ]]; then
    CNX=${ALERT}        # Connected on remote machine, not via ssh (bad).
else
    CNX=${BCyan}        # Connected on local machine.
fi

# Test user type:
if [[ ${USER} == "root" ]]; then
    SU=${Red}           # User is root.
elif [[ ${USER} != $(logname) ]]; then
    SU=${BRed}          # User is not login user.
else
    SU=${BCyan}         # User is normal (well ... most of us are).
fi



NCPU=$(grep -c 'processor' /proc/cpuinfo)    # Number of CPUs
SLOAD=$(( 100*${NCPU} ))        # Small load
MLOAD=$(( 200*${NCPU} ))        # Medium load
XLOAD=$(( 400*${NCPU} ))        # Xlarge load

# Returns system load as percentage, i.e., '40' rather than '0.40)'.
function load()
{
    local SYSLOAD=$(cut -d " " -f1 /proc/loadavg | tr -d '.')
    # System load of the current host.
    echo $((10#$SYSLOAD))       # Convert to decimal.
}

# Returns a color indicating system load.
function load_color()
{
    local SYSLOAD=$(load)
    if [ ${SYSLOAD} -gt ${XLOAD} ]; then
        echo -en ${ALERT}
    elif [ ${SYSLOAD} -gt ${MLOAD} ]; then
        echo -en ${Red}
    elif [ ${SYSLOAD} -gt ${SLOAD} ]; then
        echo -en ${BRed}
    else
        echo -en ${Green}
    fi
}

# Returns a color according to free disk space in $PWD.
function disk_color()
{
    if [ ! -w "${PWD}" ] ; then
        echo -en ${Red}
        # No 'write' privilege in the current directory.
    elif [ -s "${PWD}" ] ; then
        local used=$(command df -P "$PWD" |
                   awk 'END {print $5} {sub(/%/,"")}')
        if [ ${used} -gt 95 ]; then
            echo -en ${ALERT}           # Disk almost full (&gt;95%).
        elif [ ${used} -gt 90 ]; then
            echo -en ${BRed}            # Free disk space almost gone.
        else
            echo -en ${Green}           # Free disk space is ok.
        fi
    else
        echo -en ${Cyan}
        # Current directory is size '0' (like /proc, /sys etc).
    fi
}

# Returns a color according to running/suspended jobs.
function job_color()
{
    if [ $(jobs -s | wc -l) -gt "0" ]; then
        echo -en ${BRed}
    elif [ $(jobs -r | wc -l) -gt "0" ] ; then
        echo -en ${BCyan}
    fi
}

# Adds some text in the terminal frame (if applicable).


# Now we construct the prompt.
PROMPT_COMMAND="history -a"
case ${TERM} in
  *term | rxvt | linux)
        PS1="\[\$(load_color)\][\A\[${NC}\] "
        # Time of day (with load info):
        PS1="\[\$(load_color)\][\A\[${NC}\] "
        # User@Host (with connection type info):
        PS1=${PS1}"\[${SU}\]\u\[${NC}\]@\[${CNX}\]\h\[${NC}\] "
        # PWD (with 'disk space' info):
        PS1=${PS1}"\[\$(disk_color)\]\W]\[${NC}\] "
        # Prompt (with 'job' info):
        PS1=${PS1}"\[\$(job_color)\]&gt;\[${NC}\] "
        # Set title of current xterm:
        PS1=${PS1}"\[\e]0;[\u@\h] \w\a\]"
        ;;
    *)
        PS1="(\A \u@\h \W) &gt; " # --&gt; PS1="(\A \u@\h \w) &gt; "
                               # --&gt; Shows full pathname of current dir.
        ;;
esac



export TIMEFORMAT=$'\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n'
export HISTIGNORE="&amp;:bg:fg:ll:h"
export HISTTIMEFORMAT="$(echo -e ${BCyan})[%d/%m %H:%M:%S]$(echo -e ${NC}) "
export HISTCONTROL=ignoredups
export HOSTFILE=$HOME/.hosts    # Put a list of remote hosts in ~/.hosts


#============================================================
#
#  ALIASES AND FUNCTIONS
#
#  Arguably, some functions defined here are quite big.
#  If you want to make this file smaller, these functions can
#+ be converted into scripts and removed from here.
#
#============================================================

#-------------------
# Personnal Aliases
#-------------------

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
# -&gt; Prevents accidentally clobbering files.
alias mkdir='mkdir -p'

alias h='history'
alias j='jobs -l'
alias which='type -a'
alias ..='cd ..'

# Pretty-print of some PATH variables:
alias path='echo -e ${PATH//:/\\n}'
alias libpath='echo -e ${LD_LIBRARY_PATH//:/\\n}'


alias du='du -kh'    # Makes a more readable output.
alias df='df -kTh'

#-------------------------------------------------------------
# The 'ls' family (this assumes you use a recent GNU ls).
#-------------------------------------------------------------
# Add colors for filetype and  human-readable sizes by default on 'ls':
alias ls='ls -h --color'
alias lx='ls -lXB'         #  Sort by extension.
alias lk='ls -lSr'         #  Sort by size, biggest last.
alias lt='ls -ltr'         #  Sort by date, most recent last.
alias lc='ls -ltcr'        #  Sort by/show change time,most recent last.
alias lu='ls -ltur'        #  Sort by/show access time,most recent last.

# The ubiquitous 'll': directories first, with alphanumeric sorting:
alias ll="ls -lv --group-directories-first"
alias lm='ll |more'        #  Pipe through 'more'
alias lr='ll -R'           #  Recursive ls.
alias la='ll -A'           #  Show hidden files.
alias tree='tree -Csuh'    #  Nice alternative to 'recursive ls' ...


#-------------------------------------------------------------
# Tailoring 'less'
#-------------------------------------------------------------

alias more='less'
export PAGER=less
export LESSCHARSET='latin1'
export LESSOPEN='|/usr/bin/lesspipe.sh %s 2&gt;&amp;-'
                # Use this if lesspipe.sh exists.
export LESS='-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \
:stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...'

# LESS man page colors (makes Man pages more readable).
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'


#-------------------------------------------------------------
# Spelling typos - highly personnal and keyboard-dependent :-)
#-------------------------------------------------------------

alias xs='cd'
alias vf='cd'
alias moer='more'
alias moew='more'
alias kk='ll'


#-------------------------------------------------------------
# A few fun ones
#-------------------------------------------------------------

# Adds some text in the terminal frame (if applicable).

function xtitle()
{
    case "$TERM" in
    *term* | rxvt)
        echo -en  "\e]0;$*\a" ;;
    *)  ;;
    esac
}


# Aliases that use xtitle
alias top='xtitle Processes on $HOST &amp;&amp; top'
alias make='xtitle Making $(basename $PWD) ; make'

# .. and functions
function man()
{
    for i ; do
        xtitle The $(basename $1|tr -d .[:digit:]) manual
        command man -a "$i"
    done
}


#-------------------------------------------------------------
# Make the following commands run in background automatically:
#-------------------------------------------------------------

function te()  # wrapper around xemacs/gnuserv
{
    if [ "$(gnuclient -batch -eval t 2&gt;&amp;-)" == "t" ]; then
       gnuclient -q "$@";
    else
       ( xemacs "$@" &amp;);
    fi
}

function soffice() { command soffice "$@" &amp; }
function firefox() { command firefox "$@" &amp; }
function xpdf() { command xpdf "$@" &amp; }


#-------------------------------------------------------------
# File &amp; strings related functions:
#-------------------------------------------------------------


# Find a file with a pattern in name:
function ff() { find . -type f -iname '*'"$*"'*' -ls ; }

# Find a file with pattern $1 in name and Execute $2 on it:
function fe() { find . -type f -iname '*'"${1:-}"'*' \
-exec ${2:-file} {} \;  ; }

#  Find a pattern in a set of files and highlight them:
#+ (needs a recent version of egrep).
function fstr()
{
    OPTIND=1
    local mycase=""
    local usage="fstr: find string in files.
Usage: fstr [-i] \"pattern\" [\"filename pattern\"] "
    while getopts :it opt
    do
        case "$opt" in
           i) mycase="-i " ;;
           *) echo "$usage"; return ;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ "$#" -lt 1 ]; then
        echo "$usage"
        return;
    fi
    find . -type f -name "${2:-*}" -print0 | \
xargs -0 egrep --color=always -sn ${case} "$1" 2&gt;&amp;- | more

}


function swap()
{ # Swap 2 filenames around, if they exist (from Uzi's bashrc).
    local TMPFILE=tmp.$$

    [ $# -ne 2 ] &amp;&amp; echo "swap: 2 arguments needed" &amp;&amp; return 1
    [ ! -e $1 ] &amp;&amp; echo "swap: $1 does not exist" &amp;&amp; return 1
    [ ! -e $2 ] &amp;&amp; echo "swap: $2 does not exist" &amp;&amp; return 1

    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

function extract()      # Handy Extract Program
{
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1     ;;
            *.tar.gz)    tar xvzf $1     ;;
            *.bz2)       bunzip2 $1      ;;
            *.rar)       unrar x $1      ;;
            *.gz)        gunzip $1       ;;
            *.tar)       tar xvf $1      ;;
            *.tbz2)      tar xvjf $1     ;;
            *.tgz)       tar xvzf $1     ;;
            *.zip)       unzip $1        ;;
            *.Z)         uncompress $1   ;;
            *.7z)        7z x $1         ;;
            *)           echo "'$1' cannot be extracted via &gt;extract&lt;" ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}


# Creates an archive (*.tar.gz) from given directory.
function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

# Create a ZIP archive of a file or folder.
function makezip() { zip -r "${1%%/}.zip" "$1" ; }

# Make your directories and files access rights sane.
function sanitize() { chmod -R u=rwX,g=rX,o= "$@" ;}

#-------------------------------------------------------------
# Process/system related functions:
#-------------------------------------------------------------


function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }
function pp() { my_ps f | awk '!/awk/ &amp;&amp; $0~var' var=${1:-".*"} ; }


function killps()   # kill by process name
{
    local pid pname sig="-TERM"   # default signal
    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        echo "Usage: killps [-SIGNAL] pattern"
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(my_ps| awk '!/awk/ &amp;&amp; $0~pat { print $1 }' pat=${!#} )
    do
        pname=$(my_ps | awk '$1~var { print $5 }' var=$pid )
        if ask "Kill process $pid &lt;$pname&gt; with signal $sig?"
            then kill $sig $pid
        fi
    done
}

function mydf()         # Pretty-print of 'df' output.
{                       # Inspired by 'dfc' utility.
    for fs ; do

        if [ ! -d $fs ]
        then
          echo -e $fs" :No such file or directory" ; continue
        fi

        local info=( $(command df -P $fs | awk 'END{ print $2,$3,$5 }') )
        local free=( $(command df -Pkh $fs | awk 'END{ print $4 }') )
        local nbstars=$(( 20 * ${info[1]} / ${info[0]} ))
        local out="["
        for ((j=0;j&lt;20;j++)); do
            if [ ${j} -lt ${nbstars} ]; then
               out=$out"*"
            else
               out=$out"-"
            fi
        done
        out=${info[2]}" "$out"] ("$free" free on "$fs")"
        echo -e $out
    done
}


function my_ip() # Get IP adress on ethernet.
{
    MY_IP=$(/sbin/ifconfig eth0 | awk '/inet/ { print $2 } ' |
      sed -e s/addr://)
    echo ${MY_IP:-"Not connected"}
}

function ii()   # Get current host related info.
{
    echo -e "\nYou are logged on ${BRed}$HOST"
    echo -e "\n${BRed}Additionnal information:$NC " ; uname -a
    echo -e "\n${BRed}Users logged on:$NC " ; w -hs |
             cut -d " " -f1 | sort | uniq
    echo -e "\n${BRed}Current date :$NC " ; date
    echo -e "\n${BRed}Machine stats :$NC " ; uptime
    echo -e "\n${BRed}Memory stats :$NC " ; free
    echo -e "\n${BRed}Diskspace :$NC " ; mydf / $HOME
    echo -e "\n${BRed}Local IP Address :$NC" ; my_ip
    echo -e "\n${BRed}Open connections :$NC "; netstat -pan --inet;
    echo
}

#-------------------------------------------------------------
# Misc utilities:
#-------------------------------------------------------------

function repeat()       # Repeat n times command.
{
    local i max
    max=$1; shift;
    for ((i=1; i &lt;= max ; i++)); do  # --&gt; C-like syntax
        eval "$@";
    done
}


function ask()          # See 'killps' for example of use.
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}

function corename()   # Get name of app that created a corefile.
{
    for file ; do
        echo -n $file : ; gdb --core=$file --batch | head -1
    done
}



#=========================================================================
#
#  PROGRAMMABLE COMPLETION SECTION
#  Most are taken from the bash 2.05 documentation and from Ian McDonald's
# 'Bash completion' package (http://www.caliban.org/bash/#completion)
#  You will in fact need bash more recent then 3.0 for some features.
#
#  Note that most linux distributions now provide many completions
# 'out of the box' - however, you might need to make your own one day,
#  so I kept those here as examples.
#=========================================================================

if [ "${BASH_VERSION%.*}" \&lt; "3.0" ]; then
    echo "You will need to upgrade to version 3.0 for full \
          programmable completion features"
    return
fi

shopt -s extglob        # Necessary.

complete -A hostname   rsh rcp telnet rlogin ftp ping disk
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A user       su mail finger

complete -A helptopic  help     # Currently same as builtins.
complete -A shopt      shopt
complete -A stopped -P '%' bg
complete -A job -P '%'     fg jobs disown

complete -A directory  mkdir rmdir
complete -A directory   -o default cd

# Compression
complete -f -o default -X '*.+(zip|ZIP)'  zip
complete -f -o default -X '!*.+(zip|ZIP)' unzip
complete -f -o default -X '*.+(z|Z)'      compress
complete -f -o default -X '!*.+(z|Z)'     uncompress
complete -f -o default -X '*.+(gz|GZ)'    gzip
complete -f -o default -X '!*.+(gz|GZ)'   gunzip
complete -f -o default -X '*.+(bz2|BZ2)'  bzip2
complete -f -o default -X '!*.+(bz2|BZ2)' bunzip2
complete -f -o default -X '!*.+(zip|ZIP|z|Z|gz|GZ|bz2|BZ2)' extract


# Documents - Postscript,pdf,dvi.....
complete -f -o default -X '!*.+(ps|PS)'  gs ghostview ps2pdf ps2ascii
complete -f -o default -X \
'!*.+(dvi|DVI)' dvips dvipdf xdvi dviselect dvitype
complete -f -o default -X '!*.+(pdf|PDF)' acroread pdf2ps
complete -f -o default -X '!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?\
(.gz|.GZ|.bz2|.BZ2|.Z))' gv ggv
complete -f -o default -X '!*.texi*' makeinfo texi2dvi texi2html texi2pdf
complete -f -o default -X '!*.tex' tex latex slitex
complete -f -o default -X '!*.lyx' lyx
complete -f -o default -X '!*.+(htm*|HTM*)' lynx html2ps
complete -f -o default -X \
'!*.+(doc|DOC|xls|XLS|ppt|PPT|sx?|SX?|csv|CSV|od?|OD?|ott|OTT)' soffice

# Multimedia
complete -f -o default -X \
'!*.+(gif|GIF|jp*g|JP*G|bmp|BMP|xpm|XPM|png|PNG)' xv gimp ee gqview
complete -f -o default -X '!*.+(mp3|MP3)' mpg123 mpg321
complete -f -o default -X '!*.+(ogg|OGG)' ogg123
complete -f -o default -X \
'!*.@(mp[23]|MP[23]|ogg|OGG|wav|WAV|pls|\
m3u|xm|mod|s[3t]m|it|mtm|ult|flac)' xmms
complete -f -o default -X '!*.@(mp?(e)g|MP?(E)G|wma|avi|AVI|\
asf|vob|VOB|bin|dat|vcd|ps|pes|fli|viv|rm|ram|yuv|mov|MOV|qt|\
QT|wmv|mp3|MP3|ogg|OGG|ogm|OGM|mp4|MP4|wav|WAV|asx|ASX)' xine



complete -f -o default -X '!*.pl'  perl perl5


#  This is a 'universal' completion function - it works when commands have
#+ a so-called 'long options' mode , ie: 'ls --all' instead of 'ls -a'
#  Needs the '-o' option of grep
#+ (try the commented-out version if not available).

#  First, remove '=' from completion word separators
#+ (this will allow completions like 'ls --color=auto' to work correctly).

COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}


_get_longopts()
{
  #$1 --help | sed  -e '/--/!d' -e 's/.*--\([^[:space:].,]*\).*/--\1/'| \
  #grep ^"$2" |sort -u ;
    $1 --help | grep -o -e "--[^[:space:].,]*" | grep -e "$2" |sort -u
}

_longopts()
{
    local cur
    cur=${COMP_WORDS[COMP_CWORD]}

    case "${cur:-*}" in
       -*)      ;;
        *)      return ;;
    esac

    case "$1" in
       \~*)     eval cmd="$1" ;;
         *)     cmd="$1" ;;
    esac
    COMPREPLY=( $(_get_longopts ${1} ${cur} ) )
}
complete  -o default -F _longopts configure bash
complete  -o default -F _longopts wget id info a2ps ls recode

_tar()
{
    local cur ext regex tar untar

    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}

    # If we want an option, return the possible long options.
    case "$cur" in
        -*)     COMPREPLY=( $(_get_longopts $1 $cur ) ); return 0;;
    esac

    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=( $( compgen -W 'c t x u r d A' -- $cur ) )
        return 0
    fi

    case "${COMP_WORDS[1]}" in
        ?(-)c*f)
            COMPREPLY=( $( compgen -f $cur ) )
            return 0
            ;;
        +([^Izjy])f)
            ext='tar'
            regex=$ext
            ;;
        *z*f)
            ext='tar.gz'
            regex='t\(ar\.\)\(gz\|Z\)'
            ;;
        *[Ijy]*f)
            ext='t?(ar.)bz?(2)'
            regex='t\(ar\.\)bz2\?'
            ;;
        *)
            COMPREPLY=( $( compgen -f $cur ) )
            return 0
            ;;

    esac

    if [[ "$COMP_LINE" == tar*.$ext' '* ]]; then
        # Complete on files in tar file.
        #
        # Get name of tar file from command line.
        tar=$( echo "$COMP_LINE" | \
                        sed -e 's|^.* \([^ ]*'$regex'\) .*$|\1|' )
        # Devise how to untar and list it.
        untar=t${COMP_WORDS[1]//[^Izjyf]/}

        COMPREPLY=( $( compgen -W "$( echo $( tar $untar $tar \
                                2&gt;/dev/null ) )" -- "$cur" ) )
        return 0

    else
        # File completion on relevant files.
        COMPREPLY=( $( compgen -G $cur\*.$ext ) )

    fi

    return 0

}

complete -F _tar -o default tar

_make()
{
    local mdef makef makef_dir="." makef_inc gcmd cur prev i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in
        -*f)
            COMPREPLY=($(compgen -f $cur ));
            return 0
            ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($(_get_longopts $1 $cur ));
            return 0
            ;;
    esac;

    # ... make reads
    #          GNUmakefile,
    #     then makefile
    #     then Makefile ...
    if [ -f ${makef_dir}/GNUmakefile ]; then
        makef=${makef_dir}/GNUmakefile
    elif [ -f ${makef_dir}/makefile ]; then
        makef=${makef_dir}/makefile
    elif [ -f ${makef_dir}/Makefile ]; then
        makef=${makef_dir}/Makefile
    else
       makef=${makef_dir}/*.mk         # Local convention.
    fi


    #  Before we scan for targets, see if a Makefile name was
    #+ specified with -f.
    for (( i=0; i &lt; ${#COMP_WORDS[@]}; i++ )); do
        if [[ ${COMP_WORDS[i]} == -f ]]; then
            # eval for tilde expansion
            eval makef=${COMP_WORDS[i+1]}
            break
        fi
    done
    [ ! -f $makef ] &amp;&amp; return 0

    # Deal with included Makefiles.
    makef_inc=$( grep -E '^-?include' $makef |
                 sed -e "s,^.* ,"$makef_dir"/," )
    for file in $makef_inc; do
        [ -f $file ] &amp;&amp; makef="$makef $file"
    done


    #  If we have a partial word to complete, restrict completions
    #+ to matches of that word.
    if [ -n "$cur" ]; then gcmd='grep "^$cur"' ; else gcmd=cat ; fi

    COMPREPLY=( $( awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
                               {split($1,A,/ /);for(i in A)print A[i]}' \
                                $makef 2&gt;/dev/null | eval $gcmd  ))

}

complete -F _make -X '+($*|*.[cho])' make gmake pmake




_killall()
{
    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}

    #  Get a list of processes
    #+ (the first sed evaluation
    #+ takes care of swapped out processes, the second
    #+ takes care of getting the basename of the process).
    COMPREPLY=( $( ps -u $USER -o comm  | \
        sed -e '1,1d' -e 's#[]\[]##g' -e 's#^.*/##'| \
        awk '{if ($0 ~ /^'$cur'/) print $0}' ))

    return 0
}

complete -F _killall killall killps



# Local Variables:
# mode:shell-script
# sh-shell:bash
# End:
</programlisting>
      </example>

      <para>And, here is a snippet from Andrzej Szelachowski's instructive
        <filename>.bash_profile</filename> file.</para>

      <example xml:id="bashprof">
	<title><filename>.bash_profile</filename> file</title>
	<programlisting># From Andrzej Szelachowski's ~/.bash_profile:


#  Note that a variable may require special treatment
#+ if it will be exported.

DARKGRAY='\e[1;30m'
LIGHTRED='\e[1;31m'
GREEN='\e[32m'
YELLOW='\e[1;33m'
LIGHTBLUE='\e[1;34m'
NC='\e[m'

PCT="\`if [[ \$EUID -eq 0 ]]; then T='$LIGHTRED' ; else T='$LIGHTBLUE'; fi; 
echo \$T \`"

#  For "literal" command substitution to be assigned to a variable,
#+ use escapes and double quotes:
#+       PCT="\` ... \`" . . .
#  Otherwise, the value of PCT variable is assigned only once,
#+ when the variable is exported/read from .bash_profile,
#+ and it will not change afterwards even if the user ID changes.


PS1="\n$GREEN[\w] \n$DARKGRAY($PCT\t$DARKGRAY)-($PCT\u$DARKGRAY)-($PCT\!
$DARKGRAY)$YELLOW-&gt; $NC"

#  Escape a variables whose value changes:
#        if [[ \$EUID -eq 0 ]],
#  Otherwise the value of the EUID variable will be assigned only once,
#+ as above.

#  When a variable is assigned, it should be called escaped:
#+       echo \$T,
#  Otherwise the value of the T variable is taken from the moment the PCT 
#+ variable is exported/read from .bash_profile.
#  So, in this example it would be null.

#  When a variable's value contains a semicolon it should be strong quoted:
#        T='$LIGHTRED',
#  Otherwise, the semicolon will be interpreted as a command separator.


#  Variables PCT and PS1 can be merged into a new PS1 variable:

PS1="\`if [[ \$EUID -eq 0 ]]; then PCT='$LIGHTRED';
else PCT='$LIGHTBLUE'; fi; 
echo '\n$GREEN[\w] \n$DARKGRAY('\$PCT'\t$DARKGRAY)-\
('\$PCT'\u$DARKGRAY)-('\$PCT'\!$DARKGRAY)$YELLOW-&gt; $NC'\`"

# The trick is to use strong quoting for parts of old PS1 variable.
</programlisting>
      </example>

  </appendix>
    <!-- End Sample .bashrc File appendix -->


  <appendix xml:id="dosbatch">
      <title>Converting DOS Batch Files to Shell Scripts</title>

  <para><anchor xml:id="dosbatch1" /></para>
  <para>Quite a number of programmers learned scripting on a PC running
    DOS. Even the crippled DOS batch file language allowed writing some
    fairly powerful scripts and applications, though they often required
    extensive kludges and workarounds. Occasionally, the need still
    arises to convert an old DOS batch file to a UNIX shell script. This
    is generally not difficult, as DOS batch file operators are only a
    limited subset of the equivalent shell scripting ones.</para>

      <table>
	<title>Batch file keywords / variables / operators, and their shell equivalents</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Batch File Operator</entry>
	      <entry>Shell Script Equivalent</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>%</option></entry>
	      <entry>$</entry>
	      <entry>command-line parameter prefix</entry>
	    </row>
	    <row>
	      <entry><option>/</option></entry>
	      <entry>-</entry>
	      <entry>command option flag</entry>
	    </row>
	    <row>
	      <entry><option>\</option></entry>
	      <entry>/</entry>
	      <entry>directory path separator</entry>
	    </row>
	    <row>
	      <entry><option>==</option></entry>
	      <entry>=</entry>
	      <entry>(equal-to) string comparison test</entry>
	    </row>
	    <row>
	      <entry><option>!==!</option></entry>
	      <entry>!=</entry>
	      <entry>(not equal-to) string comparison test</entry>
	    </row>
	    <row>
	      <entry><option>|</option></entry>
	      <entry>|</entry>
	      <entry>pipe</entry>
	    </row>
	    <row>
	      <entry><option>@</option></entry>
	      <entry>set <option>+v</option></entry>
	      <entry>do not echo current command</entry>
	    </row>
	    <row>
	      <entry><option>*</option></entry>
	      <entry>*</entry>
	      <entry>filename <quote>wild card</quote></entry>
	    </row>
	    <row>
	      <entry><option>&gt;</option></entry>
	      <entry>&gt;</entry>
	      <entry>file redirection (overwrite)</entry>
	    </row>
	    <row>
	      <entry><option>&gt;&gt;</option></entry>
	      <entry>&gt;&gt;</entry>
	      <entry>file redirection (append)</entry>
	    </row>
	    <row>
	      <entry><option>&lt;</option></entry>
	      <entry>&lt;</entry>
	      <entry>redirect <filename>stdin</filename></entry>
	    </row>
	    <row>
	      <entry><option>%VAR%</option></entry>
	      <entry>$VAR</entry>
	      <entry>environmental variable</entry>
	    </row>
	    <row>
	      <entry><option>REM</option></entry>
	      <entry>#</entry>
	      <entry>comment</entry>
	    </row>
	    <row>
	      <entry><option>NOT</option></entry>
	      <entry>!</entry>
	      <entry>negate following test</entry>
	    </row>
	    <row>
	      <entry><option>NUL</option></entry>
	      <entry><filename>/dev/null</filename></entry>
	      <entry><quote>black hole</quote> for burying command output</entry>
	    </row>
	    <row>
	      <entry><option>ECHO</option></entry>
	      <entry>echo</entry>
	      <entry>echo (many more option in Bash)</entry>
	    </row>
	    <row>
	      <entry><option>ECHO.</option></entry>
	      <entry>echo</entry>
	      <entry>echo blank line</entry>
	    </row>
	    <row>
	      <entry><option>ECHO OFF</option></entry>
	      <entry>set <option>+v</option></entry>
	      <entry>do not echo command(s) following</entry>
	    </row>
	    <row>
	      <entry><option>FOR %%VAR IN (LIST) DO</option></entry>
	      <entry>for var in [list]; do</entry>
	      <entry><quote>for</quote> loop</entry>
	    </row>
	    <row>
	      <entry><option>:LABEL</option></entry>
	      <entry>none (unnecessary)</entry>
	      <entry>label</entry>
	    </row>
	    <row>
	      <entry><option>GOTO</option></entry>
	      <entry>none (use a function)</entry>
	      <entry>jump to another location in the script</entry>
	    </row>
	    <row>
	      <entry><option>PAUSE</option></entry>
	      <entry>sleep</entry>
	      <entry>pause or wait an interval</entry>
	    </row>
	    <row>
	      <entry><option>CHOICE</option></entry>
	      <entry>case or select</entry>
	      <entry>menu choice</entry>
	    </row>
	    <row>
	      <entry><option>IF</option></entry>
	      <entry>if</entry>
	      <entry>if-test</entry>
	    </row>
	    <row>
	      <entry><option>IF EXIST <replaceable>FILENAME</replaceable></option></entry>
	      <entry>if [ -e filename ]</entry>
	      <entry>test if file exists</entry>
	    </row>
	    <row>
	      <entry><option>IF !%N==!</option></entry>
	      <entry>if [ -z "$N" ]</entry>
	      <entry>if replaceable parameter <quote>N</quote> not present</entry>
	    </row>
	    <row>
	      <entry><option>CALL</option></entry>
	      <entry>source or . (dot operator)</entry>
	      <entry><quote>include</quote> another script</entry>
	    </row>
	    <row>
	      <entry><option>COMMAND /C</option></entry>
	      <entry>source or . (dot operator)</entry>
	      <entry><quote>include</quote> another script (same as
	        CALL)</entry>
	    </row>
	    <row>
	      <entry><option>SET</option></entry>
	      <entry>export</entry>
	      <entry>set an environmental variable</entry>
	    </row>
	    <row>
	      <entry><option>SHIFT</option></entry>
	      <entry>shift</entry>
	      <entry>left shift command-line argument list</entry>
	    </row>
	    <row>
	      <entry><option>SGN</option></entry>
	      <entry>-lt or -gt</entry>
	      <entry>sign (of integer)</entry>
	    </row>
	    <row>
	      <entry><option>ERRORLEVEL</option></entry>
	      <entry>$?</entry>
	      <entry>exit status</entry>
	    </row>
	    <row>
	      <entry><option>CON</option></entry>
	      <entry><filename>stdin</filename></entry>
	      <entry><quote>console</quote> (<filename>stdin</filename>)</entry>
	    </row>
	    <row>
	      <entry><option>PRN</option></entry>
	      <entry><filename>/dev/lp0</filename></entry>
	      <entry>(generic) printer device</entry>
	    </row>
	    <row>
	      <entry><option>LPT1</option></entry>
	      <entry><filename>/dev/lp0</filename></entry>
	      <entry>first printer device</entry>
	    </row>
	    <row>
	      <entry><option>COM1</option></entry>
	      <entry><filename>/dev/ttyS0</filename></entry>
	      <entry>first serial port</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>



      <para><anchor xml:id="dosunixequiv" /></para>
      <para>Batch files usually contain DOS commands. These must be
	translated into their UNIX equivalents in order to convert a
	batch file into a shell script.</para>

      <table>
	<title>DOS commands and their UNIX equivalents</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>DOS Command</entry>
	      <entry>UNIX Equivalent</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>ASSIGN</option></entry>
	      <entry>ln</entry>
	      <entry>link file or directory</entry>
	    </row>
	    <row>
	      <entry><option>ATTRIB</option></entry>
	      <entry>chmod</entry>
	      <entry>change file permissions</entry>
	    </row>
	    <row>
	      <entry><option>CD</option></entry>
	      <entry>cd</entry>
	      <entry>change directory</entry>
	    </row>
	    <row>
	      <entry><option>CHDIR</option></entry>
	      <entry>cd</entry>
	      <entry>change directory</entry>
	    </row>
	    <row>
	      <entry><option>CLS</option></entry>
	      <entry>clear</entry>
	      <entry>clear screen</entry>
	    </row>
	    <row>
	      <entry><option>COMP</option></entry>
	      <entry>diff, comm, cmp</entry>
	      <entry>file compare</entry>
	    </row>
	    <row>
	      <entry><option>COPY</option></entry>
	      <entry>cp</entry>
	      <entry>file copy</entry>
	    </row>
	    <row>
	      <entry><option>Ctl-C</option></entry>
	      <entry>Ctl-C</entry>
	      <entry>break (signal)</entry>
	    </row>
	    <row>
	      <entry><option>Ctl-Z</option></entry>
	      <entry>Ctl-D</entry>
	      <entry>EOF (end-of-file)</entry>
	    </row>
	    <row>
	      <entry><option>DEL</option></entry>
	      <entry>rm</entry>
	      <entry>delete file(s)</entry>
	    </row>
	    <row>
	      <entry><option>DELTREE</option></entry>
	      <entry>rm -rf</entry>
	      <entry>delete directory recursively</entry>
	    </row>
	    <row>
	      <entry><option>DIR</option></entry>
	      <entry>ls -l</entry>
	      <entry>directory listing</entry>
	    </row>
	    <row>
	      <entry><option>ERASE</option></entry>
	      <entry>rm</entry>
	      <entry>delete file(s)</entry>
	    </row>
	    <row>
	      <entry><option>EXIT</option></entry>
	      <entry>exit</entry>
	      <entry>exit current process</entry>
	    </row>
	    <row>
	      <entry><option>FC</option></entry>
	      <entry>comm, cmp</entry>
	      <entry>file compare</entry>
	    </row>
	    <row>
	      <entry><option>FIND</option></entry>
	      <entry>grep</entry>
	      <entry>find strings in files</entry>
	    </row>
	    <row>
	      <entry><option>MD</option></entry>
	      <entry>mkdir</entry>
	      <entry>make directory</entry>
	    </row>
	    <row>
	      <entry><option>MKDIR</option></entry>
	      <entry>mkdir</entry>
	      <entry>make directory</entry>
	    </row>
	    <row>
	      <entry><option>MORE</option></entry>
	      <entry>more</entry>
	      <entry>text file paging filter</entry>
	    </row>
	    <row>
	      <entry><option>MOVE</option></entry>
	      <entry>mv</entry>
	      <entry>move</entry>
	    </row>
	    <row>
	      <entry><option>PATH</option></entry>
	      <entry>$PATH</entry>
	      <entry>path to executables</entry>
	    </row>
	    <row>
	      <entry><option>REN</option></entry>
	      <entry>mv</entry>
	      <entry>rename (move)</entry>
	    </row>
	    <row>
	      <entry><option>RENAME</option></entry>
	      <entry>mv</entry>
	      <entry>rename (move)</entry>
	    </row>
	    <row>
	      <entry><option>RD</option></entry>
	      <entry>rmdir</entry>
	      <entry>remove directory</entry>
	    </row>
	    <row>
	      <entry><option>RMDIR</option></entry>
	      <entry>rmdir</entry>
	      <entry>remove directory</entry>
	    </row>
	    <row>
	      <entry><option>SORT</option></entry>
	      <entry>sort</entry>
	      <entry>sort file</entry>
	    </row>
	    <row>
	      <entry><option>TIME</option></entry>
	      <entry>date</entry>
	      <entry>display system time</entry>
	    </row>
	    <row>
	      <entry><option>TYPE</option></entry>
	      <entry>cat</entry>
	      <entry>output file to <filename>stdout</filename></entry>
	    </row>
	    <row>
	      <entry><option>XCOPY</option></entry>
	      <entry>cp</entry>
	      <entry>(extended) file copy</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>	


      <note>
      <para>Virtually all UNIX and shell operators and commands have
	many more options and enhancements than their DOS and batch file
	counterparts. Many DOS batch files rely on auxiliary utilities,
	such as <command>ask.com</command>, a crippled counterpart to
	<link linkend="readref">read</link>.</para>

      <para>DOS supports only a very limited and incompatible subset of
	filename <link linkend="globbingref">wild-card expansion</link>,
	recognizing just the <token>*</token> and <token>?</token>
	characters.</para>
	</note>

      <para>Converting a DOS batch file into a shell script is generally
	straightforward, and the result ofttimes reads better than the
	original.</para>

      <example xml:id="VIEWDAT">
	<title>VIEWDATA.BAT: DOS Batch File</title>
	<programlisting>REM VIEWDATA

REM INSPIRED BY AN EXAMPLE IN "DOS POWERTOOLS"
REM                           BY PAUL SOMERSON


@ECHO OFF

IF !%1==! GOTO VIEWDATA
REM  IF NO COMMAND-LINE ARG...
FIND "%1" C:\BOZO\BOOKLIST.TXT
GOTO EXIT0
REM  PRINT LINE WITH STRING MATCH, THEN EXIT.

:VIEWDATA
TYPE C:\BOZO\BOOKLIST.TXT | MORE
REM  SHOW ENTIRE FILE, 1 PAGE AT A TIME.

:EXIT0
</programlisting>
      </example>

      <para>
      The script conversion is somewhat of an improvement.
	<footnote><para>Various readers have suggested modifications
	of the above batch file to prettify it and make it more
	compact and efficient. In the opinion of the <emphasis>ABS
	Guide</emphasis> author, this is wasted effort. A Bash script
	can access a DOS filesystem, or even an NTFS partition (with
	the help of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ntfs-3g.org">ntfs-3g</link>)
	to do batch or scripted operations.</para></footnote>
      </para>

      <example xml:id="viewdata">
	<title><firstterm>viewdata.sh</firstterm>: Shell Script Conversion
	of VIEWDATA.BAT</title>
	<programlisting>#!/bin/bash
# viewdata.sh
# Conversion of VIEWDATA.BAT to shell script.

DATAFILE=/home/bozo/datafiles/book-collection.data
ARGNO=1

# @ECHO OFF                 Command unnecessary here.

if [ $# -lt "$ARGNO" ]    # IF !%1==! GOTO VIEWDATA
then
  less $DATAFILE          # TYPE C:\MYDIR\BOOKLIST.TXT | MORE
else
  grep "$1" $DATAFILE     # FIND "%1" C:\MYDIR\BOOKLIST.TXT
fi  

exit 0                    # :EXIT0

#  GOTOs, labels, smoke-and-mirrors, and flimflam unnecessary.
#  The converted script is short, sweet, and clean,
#+ which is more than can be said for the original.
</programlisting>
      </example>



      <para>Ted Davis' <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.maem.umr.edu/batch/">Shell
	Scripts on the PC</link> site had a set of comprehensive
	tutorials on the old-fashioned art of batch file
	programming. Unfortunately the page has vanished without a
	trace.</para>

      
  </appendix>
    <!-- End DOS Batch File Conversion appendix -->


  <appendix xml:id="exercises">
    <title>Exercises</title>

      <para>The exercises that follow test and extend your knowledge
	of scripting. Think of them as a challenge, as an entertaining way
	to take you further along the stony path toward UNIX wizardry.</para>

      <para>
      <literallayout>
      On a dingy side street in a run-down section of Hoboken, New Jersey,
      there sits a nondescript squat two-story brick building with an inscription
      incised on a marble plate in its wall:

                       <computeroutput>Bash Scripting Hall of Fame</computeroutput>.

      Inside, among various dusty uninteresting exhibits is a corroding,
      cobweb-festooned brass plaque inscribed with a short, very short
      list of those few persons who have successfully mastered the material
      in the <firstterm>Advanced Bash Scripting Guide</firstterm>, as evidenced by their performance
      on the following Exercise sections.

      (Alas, the author of the <firstterm>ABS Guide</firstterm> is not represented among the exhibits.
      This is possibly due to malicious rumors about <link linkend="nocreds">lack of credentials</link> and
      <link linkend="ktour0">deficient scripting skills</link>.)
      </literallayout>
      </para>

    <section xml:id="scriptanalysis">
      <title>Analyzing Scripts</title>

      <para>Examine the following script. Run it, then explain what it
        does.  Annotate the script and rewrite it in a more compact and
        elegant manner.</para>
	
       <para>
       <programlisting>#!/bin/bash

MAX=10000


  for((nr=1; nr&lt;$MAX; nr++))
  do

    let "t1 = nr % 5"
    if [ "$t1" -ne 3 ]
    then
      continue
    fi

    let "t2 = nr % 7"
    if [ "$t2" -ne 4 ]
    then
      continue
    fi

    let "t3 = nr % 9"
    if [ "$t3" -ne 5 ]
    then
      continue
    fi

  break   # What happens when you comment out this line? Why?

  done

  echo "Number = $nr"


exit 0</programlisting>
       </para>

      <para>---</para>

      <para>Explain what the following script does. It is really just
        a parameterized command-line pipe.</para>

      <para>
        <programlisting>#!/bin/bash

DIRNAME=/usr/bin
FILETYPE="shell script"
LOGFILE=logfile

file "$DIRNAME"/* | fgrep "$FILETYPE" | tee $LOGFILE | wc -l

exit 0</programlisting>
      </para>

      <para>---</para>

      <para>Examine and explain the following script. For hints, you
        might refer to the listings for <link linkend="findref">find</link> and <link linkend="statref">stat</link>.</para>

      <para>
        <programlisting>#!/bin/bash

# Author:  Nathan Coulter
# This code is released to the public domain.
# The author gave permission to use this code snippet in the ABS Guide.

find -maxdepth 1 -type f -printf '%f\000'  | {
   while read -d $'\000'; do
      mv "$REPLY" "$(date -d "$(stat -c '%y' "$REPLY") " '+%Y%m%d%H%M%S'
      )-$REPLY"
   done
}

# Warning: Test-drive this script in a "scratch" directory.
# It will somehow affect all the files there.</programlisting>
      </para>

      <para>---</para>

      <para>A reader sent in the following code snippet.</para>

	 <para>
         <programlisting>while read LINE
do
  echo $LINE
done &lt; `tail -f /var/log/messages`</programlisting>
	 </para>

	<para>He wished to write a script tracking changes to the system log
	   file, <filename>/var/log/messages</filename>. Unfortunately,
	   the above code block hangs and does nothing
	   useful. Why? Fix this so it does work. (Hint:
	   rather than <link linkend="redirref">redirecting the
	   <filename>stdin</filename> of the loop</link>, try a <link linkend="piperef">pipe</link>.)</para>


      <para>---</para>

      <para>Analyze the following <quote>one-liner</quote> (here
        split into two lines for clarity) contributed by Rory
        Winston:</para>

	 <para>
      <programlisting>export SUM=0; for f in $(find src -name "*.java");
do export SUM=$(($SUM + $(wc -l $f | awk '{ print $1 }'))); done; echo $SUM</programlisting>
	 </para>

      <para>Hint: First, break the script up into bite-sized
	sections. Then, carefully examine its use of <link linkend="dblparens">double-parentheses</link> arithmetic,
	the <link linkend="exportref">export</link> command,
	the <link linkend="findref">find</link> command, the
	<link linkend="wcref">wc</link> command, and <link linkend="awkref">awk</link>.</para>

      <para>---</para>


      <para>Analyze <xref linkend="lifeslow" />, and reorganize it in a
	simplified and more logical style. See how many of the variables
	can be eliminated, and try to optimize the script to speed up
	its execution time.</para>

      <para>Alter the script so that it accepts any ordinary ASCII
	text file as input for its initial <quote>generation</quote>. The
	script will read the first <parameter>$ROW*$COL</parameter>
	characters, and set the occurrences of vowels as
	<quote>living</quote> cells. Hint: be sure to translate the
	spaces in the input file to underscore characters.</para>

    </section>
    <!-- End Analyzing Scripts section -->



    <section xml:id="writingscripts">
      <title>Writing Scripts</title>

      <para><anchor xml:id="writingscripts1" /></para>

      <para>Write a script to carry out each of the following tasks.</para>


      <variablelist xml:id="exeasy">
        <title><anchor xml:id="exeasy1" />EASY</title>

	  <varlistentry>
	    <term><command moreinfo="none">Self-reproducing Script</command></term>
	    <listitem>
	    <para>Write a script that backs itself up, that is, copies
	      itself to a file named <filename>backup.sh</filename>.</para>
            <para>Hint: Use the <link linkend="catref">cat</link> command
	      and the appropriate <link linkend="scrnameparam">positional
	      parameter</link>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Home Directory Listing</command></term>
	    <listitem>
	    <para>Perform a recursive directory listing on the user's home
	      directory and save the information to a file. Compress
	      the file, have the script prompt the user to insert
	      a USB flash drive, then press <keycap>ENTER</keycap>.
              Finally, save the file to the flash drive after making
              certain the flash drive has properly mounted by parsing
              the output of <link linkend="dfref">df</link>. Note that
              the flash drive must be <firstterm>unmounted</firstterm>
              before it is removed.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Converting  <link linkend="forloopref1">for</link>
	    loops to <link linkend="whileloopref">while</link> and <link linkend="untilloopref">until</link> loops</command></term>
	    <listitem>
	    <para>Convert the <firstterm>for loops</firstterm> in <xref linkend="ex22" /> to <firstterm>while
	      loops</firstterm>. Hint: store the data in an <link linkend="arrayref">array</link> and step through the array
	      elements.</para>
	    <para>Having already done the <quote>heavy lifting,</quote>
	      now convert the loops in the example to <firstterm> until
	      loops</firstterm>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Changing the line spacing of a text file</command></term>
	    <listitem>

	    <para>Write a script that reads each line of a target file, then
	      writes the line back to <filename>stdout</filename>, but with
	      an extra blank line following. This has the effect of
	      <emphasis>double-spacing</emphasis> the file.</para>

	    <para>Include all necessary code to check whether the script
	      gets the necessary command-line argument (a filename),
	      and whether the specified file exists.</para>

	    <para>When the script runs correctly, modify it to
	      <emphasis>triple-space</emphasis> the target file.</para>

	    <para>Finally, write a script to remove all blank lines from
	      the target file, <emphasis>single-spacing</emphasis> it.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Backwards Listing</command></term>
	    <listitem>
	    <para>Write a script that echoes itself to
	      <filename>stdout</filename>, but
	      <emphasis>backwards</emphasis>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Automatically Decompressing Files</command></term>
	    <listitem>
	    <para>Given a list of filenames as input, this script
	      queries each target file (parsing the output of the
	      <link linkend="fileref">file</link> command) for
	      the type of compression used on it. Then the script
	      automatically invokes the appropriate decompression command
	      (<command>gunzip</command>, <command>bunzip2</command>,
	      <command>unzip</command>, <command>uncompress</command>,
	      or whatever). If a target file is not compressed, the
	      script emits a warning message, but takes no other action
	      on that particular file.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Unique System ID</command></term>
	    <listitem>
	    <para>Generate a <quote>unique</quote> 6-digit hexadecimal
	      identifier for your computer. Do <emphasis>not</emphasis>
	      use the flawed <link linkend="hostidref">hostid</link>
	      command. Hint: <command><link linkend="md5sumref">md5sum</link>
	      <link linkend="datafilesref1"><filename>/etc/passwd</filename></link></command>,
	      then select the first 6 digits of output.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Backup</command></term>
	    <listitem>
	    <para>Archive as a <quote>tarball</quote>
	      (<filename>*.tar.gz</filename> file) all the files
	      in your home directory tree
	      (<filename>/home/your-name</filename>) that have
	      been modified in the last 24 hours. Hint: use <link linkend="findref">find</link>.</para>
	    <para>Optional: you may use this as the basis of a
              <firstterm>backup</firstterm> script.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Checking whether a process is still running</command></term>
	    <listitem>
	    <para>Given a <link linkend="processidref">process ID</link>
	      (<firstterm>PID</firstterm>) as an argument, this script
	      will check, at user-specified intervals, whether
	      the given process is still running. You may use
	      the <link linkend="ppssref">ps</link> and <link linkend="sleepref">sleep</link> commands.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Primes</command></term>
	    <listitem>
		    <para>Print (to <filename>stdout</filename>) all
		      prime numbers between 60000 and 63000. The output
		      should be nicely formatted in columns (hint:
		      use <link linkend="printfref">printf</link>).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Lottery Numbers</command></term>
	    <listitem>
	    <para>One type of lottery involves picking five
	      different numbers, in the range of 1 - 50. Write a
	      script that generates five pseudorandom numbers in this
	      range, <emphasis>with no duplicates</emphasis>. The
	      script will give the option of echoing the numbers to
	      <filename>stdout</filename> or saving them to a file,
	      along with the date and time the particular number set
	      was generated. (If your script consistently generates
	      <emphasis>winning</emphasis> lottery numbers, then you
	      can retire on the proceeds and leave shell scripting to
	      those of us who have to work for a living.)</para>
	    </listitem>
	  </varlistentry>

      </variablelist>


      <variablelist xml:id="exmedium">
        <title><anchor xml:id="exmedium1" />INTERMEDIATE</title>

	  <varlistentry>
	    <term><command moreinfo="none">Integer or String</command></term>
	    <listitem>
	    <para>Write a script <link linkend="functionref">function</link>
	      that determines if an argument passed to it is an integer
	      or a string. The function will return TRUE (0) if
	      passed an integer, and FALSE (1) if passed a string.</para>
            <para>Hint: What does the following expression return
	      when <varname>$1</varname> is <emphasis>not</emphasis>
	      an integer?</para>
            <para><varname>expr $1 + 0</varname></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
              <term><command moreinfo="none"><link linkend="asciidef">ASCII</link>
              to Integer</command></term>
	    <listitem>
              <para>The <firstterm>atoi</firstterm> function in
                <command>C</command> converts a string character to
                an integer. Write a shell script function that performs
		the same operation. Likewise, write a shell script function
		that does the inverse, mirroring the <command>C</command>
		<firstterm>itoa</firstterm> function which converts an
		integer into an ASCII character.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Managing Disk Space</command></term>
	    <listitem>
	    <para>List, one at a time, all files larger than 100K in
	      the <filename class="directory">/home/username</filename>
	      directory tree. Give the user the option to delete or
	      compress the file, then proceed to show the next one. Write
	      to a logfile the names of all deleted files and the
	      deletion times.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Banner</command></term>
	    <listitem>
	    <para>Simulate the functionality of the deprecated <link linkend="bannerref">banner</link> command in a script.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Removing Inactive Accounts</command></term>
	    <listitem>
	    <para>Inactive accounts on a network server waste disk space and may
	      become a security risk. Write an administrative script
	      (to be invoked by <firstterm>root</firstterm> or the <link linkend="cronref">cron daemon</link>) that checks
	      for and deletes user accounts that have not been accessed
	      within the last 90 days.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Enforcing Disk Quotas</command></term>
	    <listitem>
	    <para>Write a script for a multi-user system that checks users'
	      disk usage. If a user surpasses a preset limit
	      (500 MB, for example) in her <filename class="directory">/home/username</filename>
	      directory, then the script automatically sends her a
	      <quote>pigout</quote> warning e-mail.</para> <para>The
	      script will use the <link linkend="duref">du</link>
	      and <link linkend="commmail1">mail</link> commands. As
	      an option, it will allow setting and enforcing quotas
	      using the <link linkend="quotaref">quota</link> and <link linkend="setquotaref">setquota</link> commands.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Logged in User Information</command></term>
	    <listitem>

	    <para>For all logged in users, show their real names and the time
              and date of their last login.</para>
	      
	    <para>Hint: use <link linkend="whoref">who</link>,
	      <link linkend="lastlogref">lastlog</link>,
	      and parse <link linkend="datafilesref1"><filename>/etc/passwd</filename></link>.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Safe Delete</command></term>
	    <listitem>
	    <para>Implement, as a script, a <quote>safe</quote> delete
	      command, <filename>sdel.sh</filename>. Filenames passed as
	      command-line arguments to this script are not deleted,
	      but instead <link linkend="gzipref">gzipped</link>
	      if not already compressed (use <link linkend="fileref">file</link> to check), then moved
	      to a <filename class="directory">~/TRASH</filename>
	      directory. Upon invocation, the script checks the <filename class="directory">~/TRASH</filename> directory for files
	      older than 48 hours and <link linkend="rmref">permanently
	      deletes</link> them. (An better alternative might be to
	      have a second script handle this, periodically invoked
	      by the <link linkend="cronref">cron daemon</link>.)</para>
            <para><emphasis>Extra credit:</emphasis> Write the script
	      so it can handle files and directories <link linkend="rmrecurs">recursively</link>. This would give it
	      the capability of <quote>safely deleting</quote> entire
	      directory structures.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Making Change</command></term>
	    <listitem>
	    <para>What is the most efficient way to make change for $1.68,
	      using only coins in common circulations (up to 25c)? It's
	      6 quarters, 1 dime, a nickel, and three cents.</para>
            <para>Given any arbitrary command-line input in dollars and
	      cents ($*.??), calculate the change, using the minimum
	      number of coins. If your home country is not the United
	      States, you may use your local currency units instead. The
	      script will need to parse the command-line input, then
	      change it to multiples of the smallest monetary unit (cents
	      or whatever). Hint: look at <xref linkend="ex61" />.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Quadratic Equations</command></term>
	    <listitem>
	    <para>Solve a <firstterm>quadratic</firstterm> equation of the form
	      <parameter>Ax^2 + Bx + C = 0</parameter>. Have a script take
	      as arguments the coefficients, <userinput>A</userinput>,
	      <userinput>B</userinput>, and <userinput>C</userinput>,
	      and return the solutions to five decimal places.</para>

	    <para>Hint: pipe the coefficients to <link linkend="bcref">bc</link>, using the well-known formula,
	      <parameter>x = ( -B +/- sqrt( B^2 - 4AC ) ) / 2A</parameter>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Table of Logarithms</command></term>
	    <listitem>
	    <para>Using the <link linkend="bcref">bc</link> and <link linkend="printfref">printf</link> commands, print out a
	      nicely-formatted table of eight-place natural logarithms
	      in the interval between 0.00 and 100.00, in steps of
	      .01.</para>
	    <para>Hint: <firstterm>bc</firstterm> requires the
	      <option>-l</option> option to load the math library.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Unicode Table</command></term>
	    <listitem>
               <para>Using <xref linkend="asciish" /> as a template,
                 write a script that prints to a file a complete
                 <link linkend="unicoderef">Unicode</link> table.</para>
	       <para>Hint: Use the <option>-e</option> option to
		 <link linkend="echoref">echo</link>:
		 <command>echo -e '\uXXXX'</command>, where
		 <replaceable>XXXX</replaceable>
		 is the Unicode numerical character designation.
		 This requires <link linkend="bash42">version 4.2</link>
		 or later of Bash.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Sum of Matching Numbers</command></term>
	    <listitem>
	    <para>Find the sum of all five-digit numbers (in the range
	      10000 - 99999) containing <emphasis>exactly two</emphasis>
	      out of the following set of digits: { 4, 5, 6 }. These may
	      repeat within the same number, and if so, they count once
	      for each occurrence.</para>
	    <para>Some examples of <firstterm>matching numbers</firstterm> are
	      42057, 74638, and 89515.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Lucky Numbers</command></term>
	    <listitem>
	    <para>A <firstterm>lucky number</firstterm> is one whose
	      individual digits add up to 7, in successive additions. For
	      example, 62431 is a <firstterm>lucky number</firstterm>
	      (6 + 2 + 4 + 3 + 1 = 16, 1 + 6 = 7). Find all the
	      <firstterm>lucky numbers</firstterm> between 1000 and
	      10000.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Craps</command></term>
	    <listitem>
	    <para>Borrowing the ASCII graphics from <xref linkend="petals" />,
	      write a script that plays the well-known gambling game of
	      <firstterm>craps</firstterm>. The script will accept bets
	      from one or more players, roll the dice, and keep track of
	      wins and losses, as well as of each player's bankroll.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Tic-tac-toe</command></term>
	    <listitem>
	    <para>Write a script that plays the child's game of
	      <firstterm>tic-tac-toe</firstterm> against a human
	      player. The script will let the human choose whether
	      to take the first move. The script will follow
	      an optimal strategy, and therefore never lose. To simplify
	      matters, you may use ASCII graphics:</para>

	    <para><programlisting>   o | x |
   ----------
     | x |
   ----------
     | o |
     
   Your move, human (row, column)?</programlisting></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Alphabetizing a String</command></term>
	    <listitem>
	    <para>Alphabetize (in ASCII order) an arbitrary string
	      read from the command-line.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Parsing</command></term>
	    <listitem>
	    <para>Parse <link linkend="datafilesref1"><filename>/etc/passwd</filename></link>,
	    and output its contents in nice, easy-to-read tabular
	    form.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Logging Logins</command></term>
	    <listitem>
	    <para>Parse <filename>/var/log/messages</filename> to
	      produce a nicely formatted file of user logins and login
	      times. The script may need to run as
	      <firstterm>root</firstterm>. (Hint: Search for the string
	      <quote>LOGIN.</quote>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Pretty-Printing a Data File</command></term>
	    <listitem>
	    <para>Certain database and spreadsheet packages use
	    save-files with the fields separated by commas, commonly
	    referred to as <firstterm>comma-separated values</firstterm>
	    or CSVs. Other applications often need to parse these
	    files.</para> <para>Given a data file with comma-separated
	    <link linkend="fieldref">fields</link>, of the form:
	        <programlisting>Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989
Smith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612
...</programlisting>
	      Reformat the data and print it out to
	      <filename>stdout</filename> in labeled, evenly-spaced columns.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Justification</command></term>
	    <listitem>
	    <para>Given ASCII text input either from
	      <filename>stdin</filename> or a file, adjust
	      the word spacing to right-justify each line to a
	      user-specified line-width, then send the output to
	      <filename>stdout</filename>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Mailing List</command></term>
	    <listitem>
	    <para>Using the <link linkend="commmail1">mail</link> command,
	      write a script that manages a simple mailing list. The
	      script automatically e-mails the monthly company newsletter,
	      read from a specified text file, and sends it to all the
	      addresses on the mailing list, which the script reads from
	      another specified file.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Generating Passwords</command></term>
	    <listitem>
	    <para>Generate pseudorandom 8-character passwords, using
	      characters in the ranges [0-9], [A-Z], [a-z]. Each password
	      must contain at least two digits.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Monitoring a User</command></term>
	    <listitem>

	    <para>You suspect that one particular user on the network
	      has been abusing her privileges and possibly attempting to
	      hack the system. Write a script to automatically monitor
	      and log her activities when she's signed on. The log file
	      will save entries for the previous week, and delete those
	      entries more than seven days old.</para>

           <para>You may use <link linkend="lastref">last</link>,
             <link linkend="lastlogref">lastlog</link>, and <link linkend="lastcommref">lastcomm</link> to aid your
             surveillance of the suspected fiend.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Checking for Broken Links</command></term>
	    <listitem>
	    <para>Using <link linkend="lynxref">lynx</link> with the
	      <option>-traversal</option> option, write a script that
	      checks a Web site for broken links.</para>
	    </listitem>
	  </varlistentry>

      </variablelist>


      <variablelist xml:id="exdifficult">
        <title><anchor xml:id="exdifficult1" />DIFFICULT</title>

	  <varlistentry>
	    <term><command moreinfo="none">Testing Passwords</command></term>
	    <listitem>
	    <para>Write a script to check and validate passwords. The object
	      is to flag <quote>weak</quote> or easily guessed password
	      candidates.</para>

	    <para>A trial password will be input to the script as a
	       command-line parameter. To be considered acceptable,
	       a password must meet the following minimum qualifications:

            <itemizedlist>
	      <listitem>
	        <para>Minimum length of 8 characters</para>
	      </listitem>

	      <listitem>
	        <para>Must contain at least one numeric character</para>
	      </listitem>

	      <listitem>
	        <para>Must contain at least one of the following
		  non-alphabetic characters: <token>@</token>,
		  <token>#</token>, <token>$</token>, <token>%</token>,
		  <token>&amp;</token>, <token>*</token>, <token>+</token>,
		  <token>-</token>, <token>=</token></para>
	      </listitem>
            </itemizedlist></para>

	     <para>Optional:

            <itemizedlist>
	      <listitem>
	        <para>Do a dictionary check on every sequence of at least
		  four consecutive alphabetic characters in the password under
		  test. This will eliminate passwords containing embedded
		  <quote>words</quote> found in a standard dictionary.</para>
	      </listitem>

	      <listitem>
	        <para>Enable the script to check all the passwords on your
		  system. These do not reside in
		  <link linkend="datafilesref1"><filename>/etc/passwd</filename></link>.</para>
	      </listitem>
            </itemizedlist></para>

	     <para>This exercise tests mastery of <link linkend="regexref">Regular Expressions</link>.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Cross Reference</command></term>
	    <listitem>
	    <para>Write a script that generates a
	      <firstterm>cross-reference</firstterm>
	      (<firstterm>concordance</firstterm>) on a target file.
	      The output will be a listing of all word occurrences in
	      the target file, along with the line numbers in which
	      each word occurs. Traditionally, <firstterm>linked
	      list</firstterm> constructs would be used in such
	      applications. Therefore, you should investigate <link linkend="arrayref">arrays</link> in the course of
	      this exercise. <xref linkend="wf" /> is probably
	      <emphasis>not</emphasis> a good place to start.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="newtonsqrt" /><command moreinfo="none">Square Root</command></term>
	    <listitem>
            <para>Write a script to calculate square roots of numbers
              using <firstterm>Newton's Method</firstterm>.</para>

            <para>The algorithm for this, expressed as a snippet of Bash
              <link linkend="pseudocoderef">pseudo-code</link> is:</para>

            <para><programlisting>#  (Isaac) Newton's Method for speedy extraction
#+ of square roots.

guess = $argument
#  $argument is the number to find the square root of.
#  $guess is each successive calculated "guess" -- or trial solution --
#+ of the square root.
#  Our first "guess" at a square root is the argument itself.

oldguess = 0
# $oldguess is the previous $guess.

tolerance = .000001
# To how close a tolerance we wish to calculate.

loopcnt = 0
# Let's keep track of how many times through the loop.
# Some arguments will require more loop iterations than others.


while [ ABS( $guess $oldguess ) -gt $tolerance ]
#       ^^^^^^^^^^^^^^^^^^^^^^^ Fix up syntax, of course.

#      "ABS" is a (floating point) function to find the absolute value
#+      of the difference between the two terms.
#             So, as long as difference between current and previous
#+            trial solution (guess) exceeds the tolerance, keep looping.

do
   oldguess = $guess  # Update $oldguess to previous $guess.

#  =======================================================
   guess = ( $oldguess + ( $argument / $oldguess ) ) / 2.0
#        = 1/2 ( ($oldguess **2 + $argument) / $oldguess )
#  equivalent to:
#        = 1/2 ( $oldguess + $argument / $oldguess )
#  that is, "averaging out" the trial solution and
#+ the proportion of argument deviation
#+ (in effect, splitting the error in half).
#  This converges on an accurate solution
#+ with surprisingly few loop iterations . . .
#+ for arguments &gt; $tolerance, of course.
#  =======================================================

   (( loopcnt++ ))     # Update loop counter.
done</programlisting></para>

            <para>It's a simple enough recipe, and
              <emphasis>seems</emphasis> at first glance easy enough to
              convert into a working Bash script. The problem, though,
              is that Bash has <link linkend="nofloatingpoint">no native
              support for floating point numbers</link>. So, the script
              writer needs to use <link linkend="bcref">bc</link> or
              possibly <link linkend="awkref">awk</link> to convert the
              numbers and do the calculations. It could get rather messy
              . . .</para>

	    </listitem>
	  </varlistentry>




	  <varlistentry>
	    <term><command moreinfo="none">Logging File Accesses</command></term>
	    <listitem>
	    <para>Log all accesses to the files in <filename class="directory">/etc</filename> during the course of
	      a single day. This information should include the filename,
	      user name, and access time. If any alterations to the
	      files take place, that will be flagged. Write this data
	      as tabular (tab-separated) formatted records in a logfile.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Monitoring Processes</command></term>
	    <listitem>
	    <para>Write a script to continually monitor all running
	      processes and to keep track of how many child processes each
	      parent spawns. If a process spawns more than five children,
	      then the script sends an e-mail to the system administrator
	      (or <firstterm>root</firstterm>) with all relevant
	      information, including the time, PID of the parent, PIDs
	      of the children, etc. The script appends a report to a log
	      file every ten minutes.  </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Strip Comments</command></term>
	    <listitem>
	    <para>Strip all comments from a shell script whose name
              is specified on the command-line. Note that the initial
              <link linkend="shabangref">#! line</link> must not be
              stripped out.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Strip HTML Tags</command></term>
	    <listitem>
	    <para>Strip all the HTML tags from a specified HTML file, then
	      reformat it into lines between 60 and 75 characters
	      in length. Reset paragraph and block spacing, as
	      appropriate, and convert HTML tables to their approximate
	      text equivalent.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">XML Conversion</command></term>
	    <listitem>
	    <para>Convert an XML file to both HTML and text format.</para>
	    <para>Optional: A script that converts Docbook/SGML to XML.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="cspammers" /><command moreinfo="none">Chasing Spammers</command></term>
	    <listitem>

	    <para> Write a script that analyzes a spam e-mail by doing
	      DNS lookups on the IP addresses in the headers to identify
	      the relay hosts as well as the originating ISP. The
	      script will forward the unaltered spam message to the
	      responsible ISPs. Of course, it will be necessary to
	      filter out <emphasis>your own ISP's IP address</emphasis>,
	      so you don't end up complaining about yourself.</para>

            <para>As necessary, use the appropriate <link linkend="communinfo1">network analysis commands</link>.</para>

            <para>For some ideas, see <xref linkend="isspammer" /> and <xref linkend="isspammer2" />.</para>

            <para>Optional: Write a script that searches through a list of
	      e-mail messages and deletes the spam according to specified
	      filters.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Creating man pages</command></term>
	    <listitem>

	    <para>Write a script that automates the process of creating
	      <link linkend="manref">man pages</link>.</para>

            <para>Given a text file which contains information to be
	      formatted into a <firstterm>man page</firstterm>, the
	      script will read the file, then invoke the appropriate
	      <link linkend="groffref">groff</link> commands to
	      output the corresponding <firstterm>man page</firstterm>
	      to <filename>stdout</filename>. The text file contains
	      blocks of information under the standard <firstterm>man
	      page</firstterm> headings, i.e., NAME, SYNOPSIS,
	      DESCRIPTION, etc.</para>

            <para><xref linkend="maned" /> is an instructive first step.</para>

	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><command moreinfo="none">Hex Dump</command></term>
	    <listitem>
	    <para>Do a hex(adecimal) dump on a binary file
	      specified as an argument to the script. The output should
	      be in neat tabular <link linkend="fieldref">fields</link>,
	      with the first field showing the address, each of the
	      next 8 fields a 4-byte hex number, and the final field
	      the ASCII equivalent of the previous 8 fields.</para>
	      <para>The obvious followup to this is to extend the hex
	      dump script into a disassembler. Using a lookup table,
	      or some other clever gimmick, convert the hex values into
	      80x86 op codes.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Emulating a Shift Register</command></term>
	    <listitem>
	    <para>Using <xref linkend="stackex" /> as an inspiration,
	      write a script that emulates a 64-bit shift register as
	      an <link linkend="arrayref">array</link>. Implement
	      functions to <firstterm>load</firstterm> the register,
	      <firstterm>shift left</firstterm>, <firstterm>shift
	      right</firstterm>, and <firstterm>rotate</firstterm>
	      it. Finally, write a function that interprets the register
	      contents as eight 8-bit ASCII characters.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Calculating Determinants</command></term>
	    <listitem>
	    <para>Write a script that calculates
	      determinants
	        <footnote>
               <para>For all you clever types who failed intermediate algebra,
                a <firstterm>determinant</firstterm> is a numerical value
		associated with a multidimensional
		<firstterm>matrix</firstterm> (<link linkend="arrayref">array</link> of numbers).
		  <programlisting>For the simple case of a 2 x 2 determinant:

  |a  b|
  |b  a|

The solution is a*a - b*b, where "a" and "b" represent numbers.</programlisting>
                </para></footnote>
		
		by <link linkend="recursionref0">recursively</link> expanding the
	      <firstterm>minors</firstterm>. Use a 4 x 4 determinant as
	      a test case.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Hidden Words</command></term>
	    <listitem>
	    <para>Write a <quote>word-find</quote> puzzle generator,
	      a script that hides 10 input words in a 10 x 10 array
	      of random letters. The words may be hidden across, down,
	      or diagonally.</para>
            <para>Optional: Write a script that <emphasis>solves</emphasis>
	      word-find puzzles. To keep this from becoming too difficult,
	      the solution script will find only horizontal and vertical
	      words. (Hint: Treat each row and column as a string, and
	      search for substrings.)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Anagramming</command></term>
	    <listitem>
	    <para> Anagram 4-letter input. For example, the
	      anagrams of <emphasis>word</emphasis> are:
	      <emphasis>do or rod row word</emphasis>. You may use
	      <filename>/usr/share/dict/linux.words</filename> as the
	      reference list.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Word Ladders</command></term>
	    <listitem>
            <para>A <quote>word ladder</quote> is a sequence of words,
              with each successive word in the sequence differing from
              the previous one by a single letter.</para>

            <para>For example, to <quote>ladder</quote> from
              <emphasis>mark</emphasis> to
              <emphasis>vase</emphasis>:</para>

            <para>
	    <programlisting>
mark --&gt; park --&gt; part --&gt; past --&gt; vast --&gt; vase
         ^           ^       ^      ^           ^</programlisting>
            </para>

            <para>Write a script that solves word ladder puzzles. Given
	      a starting and an ending word, the script will list all
	      intermediate steps in the <quote>ladder.</quote> Note
	      that <emphasis>all</emphasis> words in the sequence must
	      be legitimate dictionary words.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Fog Index</command></term>
	    <listitem>

	    <para>The <quote>fog index</quote> of a passage of text
	      estimates its reading difficulty, as a number corresponding
	      roughly to a school grade level. For example, a passage
	      with a fog index of 12 should be comprehensible to anyone
	      with 12 years of schooling.</para>

	    <para>The Gunning version of the fog index uses the following
	      algorithm.</para>

             <orderedlist>

               <listitem><para>Choose a section of the text at least
                 100 words in length.</para></listitem>

               <listitem><para>Count the number of sentences (a portion of
                 a sentence truncated by the boundary of the text section
                 counts as one).</para></listitem>

               <listitem>
	         <para>Find the average number of words per
                   sentence.</para>
		   
		 <para>AVE_WDS_SEN = TOTAL_WORDS / SENTENCES</para>
               </listitem>

               <listitem>
		 <para>Count the number of <quote>difficult</quote>
		   words in the segment -- those containing at least
		   3 syllables. Divide this quantity by total words to
		   get the proportion of difficult words.</para>

                 <para>PRO_DIFF_WORDS = LONG_WORDS / TOTAL_WORDS</para>
               </listitem>

               <listitem>
                 <para>The Gunning fog index is the sum of the above two
                   quantities, multiplied by 0.4, then rounded to the
                   nearest integer.</para>

                 <para>G_FOG_INDEX = int ( 0.4 * ( AVE_WDS_SEN  + PRO_DIFF_WORDS ) )</para>
               </listitem>

             </orderedlist>

            <para>Step 4 is by far the most difficult portion of the
	      exercise. There exist various algorithms for estimating
	      the syllable count of a word. A rule-of-thumb formula
	      might consider the number of letters in a word and the
	      vowel-consonant mix.</para>
	      
	    <para>A strict interpretation of the Gunning fog index does
	      not count compound words and proper nouns as
	      <quote>difficult</quote> words, but this would enormously
	      complicate the script.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Calculating PI using Buffon's Needle</command></term>
	    <listitem>

            <para>The Eighteenth Century French mathematician de Buffon
	      came up with a novel experiment. Repeatedly drop a needle
	      of length <replaceable>n</replaceable> onto a wooden floor
	      composed of long and narrow parallel boards. The cracks
	      separating the equal-width floorboards are a fixed distance
	      <replaceable>d</replaceable> apart. Keep track of the
	      total drops and the number of times the needle intersects
	      a crack on the floor. The ratio of these two quantities
	      turns out to be a fractional multiple of PI.</para>

            <para>In the spirit of <xref linkend="cannon" />, write a
	      script that runs a Monte Carlo simulation of
	      <firstterm>Buffon's Needle</firstterm>. To simplify matters,
	      set the needle length equal to the distance between the
	      cracks, <parameter>n = d</parameter>.</para>

            <para>Hint: there are actually two critical variables:
              the distance from the center of the needle to the nearest
              crack, and the inclination angle of the needle to that crack.
	      You may use <link linkend="bcref">bc</link> to handle
	      the calculations.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command moreinfo="none">Playfair Cipher</command></term>
	    <listitem>

	    <para>Implement the Playfair (Wheatstone) Cipher in a
	      script.</para>

	    <para>The Playfair Cipher encrypts text by substitution
	      of <firstterm>digrams</firstterm> (2-letter groupings).
	      It is traditional to use a 5 x 5 letter scrambled-alphabet
	      <firstterm>key square</firstterm> for the encryption and
	      decryption.</para>

             <para>
	     <programlisting>   C O D E S
   A B F G H
   I K L M N
   P Q R T U
   V W X Y Z

Each letter of the alphabet appears once, except "I" also represents
"J". The arbitrarily chosen key word, "CODES" comes first, then all
the rest of the alphabet, in order from left to right, skipping letters
already used.

To encrypt, separate the plaintext message into digrams (2-letter
groups). If a group has two identical letters, delete the second, and
form a new group. If there is a single letter left over at the end,
insert a "null" character, typically an "X."

THIS IS A TOP SECRET MESSAGE

TH IS IS AT OP SE CR ET ME SA GE



For each digram, there are three possibilities.
-----------------------------------------------

1) Both letters will be on the same row of the key square:
   For each letter, substitute the one immediately to the right, in that
   row. If necessary, wrap around left to the beginning of the row.

or

2) Both letters will be in the same column of the key square:
   For each letter, substitute the one immediately below it, in that
   row. If necessary, wrap around to the top of the column.

or

3) Both letters will form the corners of a rectangle within the key square:
   For each letter, substitute the one on the other corner the rectangle
   which lies on the same row.


The "TH" digram falls under case #3.
G H
M N
T U           (Rectangle with "T" and "H" at corners)

T --&gt; U
H --&gt; G


The "SE" digram falls under case #1.
C O D E S     (Row containing "S" and "E")

S --&gt; C  (wraps around left to beginning of row)
E --&gt; S

=========================================================================

To decrypt encrypted text, reverse the above procedure under cases #1
and #2 (move in opposite direction for substitution). Under case #3,
just take the remaining two corners of the rectangle.


Helen Fouche Gaines' classic work, ELEMENTARY CRYPTANALYSIS (1939), gives a
fairly detailed description of the Playfair Cipher and its solution methods.</programlisting>
             </para>

             <para>This script will have three main sections</para>

             <orderedlist xml:id="playfairexref" numeration="upperroman">
	       <listitem><para>Generating the <firstterm>key square</firstterm>,
	         based on a user-input keyword.</para></listitem>
	       <listitem><para>Encrypting a <firstterm>plaintext</firstterm>
	         message.</para></listitem>
	       <listitem><para>Decrypting encrypted
	         text.</para></listitem>
             </orderedlist>

	     <para>The script will make extensive use of <link linkend="arrayref">arrays</link> and <link linkend="functionref">functions</link>.
               You may use <xref linkend="gronsfeld" /> as an
               inspiration.</para>

	    </listitem>
	  </varlistentry>

      </variablelist>


	  <para>--</para>
          <para>Please do not send the author your solutions to these
            exercises. There are more appropriate ways to impress him with
            your cleverness, such as submitting bugfixes and suggestions
            for improving the book.</para>


    </section>
    <!-- End Writing Scripts section -->

  </appendix>
    <!-- End Exercises appendix -->



  <appendix xml:id="revisionhistory">
    <title>Revision History</title>

    <synopsis format="linespecific">
      This document first appeared as a 60-page HOWTO in the late spring
      of 2000. Since then, it has gone through quite a number of updates
      and revisions. This book could not have been written without the
      assistance of the Linux community, and especially of the volunteers
      of the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org">Linux Documentation Project</link>.
    </synopsis>

    <para>Here is the e-mail to the LDP requesting permission to submit
     version 0.1.</para>

    <para><programlisting>From thegrendel@theriver.com Sat Jun 10 09:05:33 2000 -0700
Date: Sat, 10 Jun 2000 09:05:28 -0700 (MST)
From: "M. Leo Cooper" &lt;thegrendel@theriver.com&gt;
X-Sender: thegrendel@localhost
To: ldp-discuss@lists.linuxdoc.org
Subject: Permission to submit HOWTO

Dear HOWTO Coordinator,

I am working on and would like to submit to the LDP a HOWTO on the subject
of "Bash Scripting" (shell scripting, using 'bash'). As it happens,
I have been writing this document, off and on, for about the last eight
months or so, and I could produce a first draft in ASCII text format in
a matter of just a few more days.

I began writing this out of frustration at being unable to find a
decent book on shell scripting. I managed to locate some pretty good
articles on various aspects of scripting, but nothing like a complete,
beginning-to-end tutorial.  Well, in keeping with my philosophy, if all
else fails, do it yourself.

As it stands, this proposed "Bash-Scripting HOWTO" would serve as a
combination tutorial and reference, with the heavier emphasis on the
tutorial. It assumes Linux experience, but only a very basic level
of programming skills. Interspersed with the text are 79 illustrative
example scripts of varying complexity, all liberally commented. There
are even exercises for the reader.

At this stage, I'm up to 18,000+ words (124k), and that's over 50 pages of
text (whew!).


I haven't mentioned that I've previously authored an LDP HOWTO, the
"Software-Building HOWTO", which I wrote in Linuxdoc/SGML. I don't know
if I could handle Docbook/SGML, and I'm glad you have volunteers to do
the conversion. You people seem to have gotten on a more organized basis
these last few months. Working with Greg Hankins and Tim Bynum was nice,
but a professional team is even nicer.

Anyhow, please advise.


Mendel Cooper
thegrendel@theriver.com</programlisting></para>


      <table frame="none">
	<title>Revision History</title>
	<tgroup cols="3" colsep="0" rowsep="0">
	  <thead>
	    <row>
	      <entry>Release</entry>
	      <entry>Date</entry>
	      <entry>Comments</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0.1</entry>
	      <entry>14 Jun 2000</entry>
	      <entry>Initial release.</entry>
	    </row>
	    <row>
	      <entry><option>0.2</option></entry>
	      <entry>30 Oct 2000</entry>
	      <entry>Bugs fixed, plus much additional material and more
	      example scripts.</entry>
	    </row>
	    <row>
	      <entry><option>0.3</option></entry>
	      <entry>12 Feb 2001</entry>
	      <entry>Major update.</entry>
	    </row>
	    <row>
	      <entry><option>0.4</option></entry>
	      <entry>08 Jul 2001</entry>
	      <entry>Complete revision and expansion of the book.</entry>
	    </row>
	    <row>
	      <entry><option>0.5</option></entry>
	      <entry>03 Sep 2001</entry>
	      <entry>Major update: Bugfixes, material added,
	      sections reorganized.</entry>
	    </row>
	    <row>
	      <entry><option>1.0</option></entry>
	      <entry>14 Oct 2001</entry>
	      <entry>Stable release: Bugfixes, reorganization, material
	      added.</entry>
	    </row>
	    <row>
	      <entry><option>1.1</option></entry>
	      <entry>06 Jan 2002</entry>
	      <entry>Bugfixes, material and scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.2</option></entry>
	      <entry>31 Mar 2002</entry>
	      <entry>Bugfixes, material and scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.3</option></entry>
	      <entry>02 Jun 2002</entry>
	      <entry>TANGERINE release: A few bugfixes, much more material and
	      scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.4</option></entry>
	      <entry>16 Jun 2002</entry>
	      <entry>MANGO release: A number of typos fixed, more
	      material and scripts.</entry>
	    </row>
	    <row>
	      <entry><option>1.5</option></entry>
	      <entry>13 Jul 2002</entry>
	      <entry>PAPAYA release: A few bugfixes, much more material and
	      scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.6</option></entry>
	      <entry>29 Sep 2002</entry>
	      <entry>POMEGRANATE release: Bugfixes, more material,
	      one more script.</entry>
	    </row>
	    <row>
	      <entry><option>1.7</option></entry>
	      <entry>05 Jan 2003</entry>
	      <entry>COCONUT release: A couple of bugfixes, more material,
	      one more script.</entry>
	    </row>
	    <row>
	      <entry><option>1.8</option></entry>
	      <entry>10 May 2003</entry>
	      <entry>BREADFRUIT release: A number of bugfixes, more scripts and
	      material.</entry>
	    </row>
	    <row>
	      <entry><option>1.9</option></entry>
	      <entry>21 Jun 2003</entry>
	      <entry>PERSIMMON release: Bugfixes, and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.0</option></entry>
	      <entry>24 Aug 2003</entry>
	      <entry>GOOSEBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>2.1</option></entry>
	      <entry>14 Sep 2003</entry>
	      <entry>HUCKLEBERRY release: Bugfixes, and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.2</option></entry>
	      <entry>31 Oct 2003</entry>
	      <entry>CRANBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>2.3</option></entry>
	      <entry>03 Jan 2004</entry>
	      <entry>STRAWBERRY release: Bugfixes and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.4</option></entry>
	      <entry>25 Jan 2004</entry>
	      <entry>MUSKMELON release: Bugfixes.</entry>
	    </row>
	    <row>
	      <entry><option>2.5</option></entry>
	      <entry>15 Feb 2004</entry>
	      <entry>STARFRUIT release: Bugfixes and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.6</option></entry>
	      <entry>15 Mar 2004</entry>
	      <entry>SALAL release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>2.7</option></entry>
	      <entry>18 Apr 2004</entry>
	      <entry>MULBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>2.8</option></entry>
	      <entry>11 Jul 2004</entry>
	      <entry>ELDERBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>3.0</option></entry>
	      <entry>03 Oct 2004</entry>
	      <entry>LOGANBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>3.1</option></entry>
	      <entry>14 Nov 2004</entry>
	      <entry>BAYBERRY release: Bugfix update.</entry>
	    </row>
	    <row>
	      <entry><option>3.2</option></entry>
	      <entry>06 Feb 2005</entry>
	      <entry>BLUEBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>3.3</option></entry>
	      <entry>20 Mar 2005</entry>
	      <entry>RASPBERRY release: Bugfixes, much material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.4</option></entry>
	      <entry>08 May 2005</entry>
	      <entry>TEABERRY release: Bugfixes, stylistic revisions.</entry>
	    </row>
	    <row>
	      <entry><option>3.5</option></entry>
	      <entry>05 Jun 2005</entry>
	      <entry>BOXBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.6</option></entry>
	      <entry>28 Aug 2005</entry>
	      <entry>POKEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.7</option></entry>
	      <entry>23 Oct 2005</entry>
	      <entry>WHORTLEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.8</option></entry>
	      <entry>26 Feb 2006</entry>
	      <entry>BLAEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.9</option></entry>
	      <entry>15 May 2006</entry>
	      <entry>SPICEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>4.0</option></entry>
	      <entry>18 Jun 2006</entry>
	      <entry>WINTERBERRY release: Major reorganization.</entry>
	    </row>
	    <row>
	      <entry><option>4.1</option></entry>
	      <entry>08 Oct 2006</entry>
	      <entry>WAXBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>4.2</option></entry>
	      <entry>10 Dec 2006</entry>
	      <entry>SPARKLEBERRY release: Important update.</entry>
	    </row>
	    <row>
	      <entry><option>4.3</option></entry>
	      <entry>29 Apr 2007</entry>
	      <entry>INKBERRY release: Bugfixes, material added.</entry>
	    </row>
	    <row>
	      <entry><option>5.0</option></entry>
	      <entry>24 Jun 2007</entry>
	      <entry>SERVICEBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>5.1</option></entry>
	      <entry>10 Nov 2007</entry>
	      <entry>LINGONBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>5.2</option></entry>
	      <entry>16 Mar 2008</entry>
	      <entry>SILVERBERRY release: Important update.</entry>
	    </row>
	    <row>
	      <entry><option>5.3</option></entry>
	      <entry>11 May 2008</entry>
	      <entry>GOLDENBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>5.4</option></entry>
	      <entry>21 Jul 2008</entry>
	      <entry>ANGLEBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>5.5</option></entry>
	      <entry>23 Nov 2008</entry>
	      <entry>FARKLEBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>5.6</option></entry>
	      <entry>26 Jan 2009</entry>
	      <entry>WORCESTERBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>6.0</option></entry>
	      <entry>23 Mar 2009</entry>
	      <entry>THIMBLEBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>6.1</option></entry>
	      <entry>30 Sep 2009</entry>
	      <entry>BUFFALOBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>6.2</option></entry>
	      <entry>17 Mar 2010</entry>
	      <entry>ROWANBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>6.3</option></entry>
	      <entry>30 Apr 2011</entry>
	      <entry>SWOZZLEBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>6.4</option></entry>
	      <entry>30 Aug 2011</entry>
	      <entry>VORTEXBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>6.5</option></entry>
	      <entry>05 Apr 2012</entry>
	      <entry>TUNGSTENBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>6.6</option></entry>
	      <entry>27 Nov 2012</entry>
	      <entry>YTTERBIUMBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>10</option></entry>
	      <entry>10 Mar 2014</entry>
	      <entry>YTTERBIUMBERRY release: License change.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


  </appendix> <!-- End Revision History appendix -->

  <appendix xml:id="mirrorsites">
    <title>Download and Mirror Sites</title>

      <para><anchor xml:id="where_tarball" /></para>

      <para>The latest update of this document, as an archived,
	<link linkend="bzipref">bzip2-ed</link>
	<quote>tarball</quote> including both the SGML source
	and rendered HTML, may be downloaded from the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/abs-guide-latest.tar.bz2">author's
	home site</link>).

	A <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/abs-guide.pdf">
	pdf version</link> is also available (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.mediafire.com/file/xi34ape1bifcnlb/abs-guide.pdf">mirror
	site</link>).
	There is likewise an <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/abs-guide.epub">
	epub version</link>, courtesy of Craig Barnes and Michael Satke.

	The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/Change.log">change
	log</link> gives a detailed revision history.
	The <emphasis>ABS Guide</emphasis> even has <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://freecode.com/projects/advancedbashscriptingguide/">
	its own <filename>freshmeat.net/freecode</filename> page</link>
	to keep track of major updates, user comments, and popularity
	ratings for the project.</para>

      <para>The legacy hosting site for this document is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/LDP/abs/">Linux Documentation Project</link>,
        which maintains many other Guides and HOWTOs as well.</para>

      <para>Many thanks to Ronny Bangsund for donating <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/">server space</link> to host
        this project.</para>


  </appendix> <!-- Mirror Sites appendix -->



  <appendix xml:id="todolist">
    <title>To Do List</title>

            <itemizedlist>
	      <listitem>
		<para>A comprehensive survey of <link linkend="bashcompat">incompatibilities</link> between
		  Bash and the classic <link linkend="bashdef">Bourne
		  shell</link>.</para>
	      </listitem>

	      <listitem>
		<para>Same as above, but for the Korn shell
		  (<firstterm>ksh</firstterm>).</para>
	      </listitem>


            </itemizedlist>


  </appendix> <!-- End Todo List appendix -->


  <appendix xml:id="copyright">
    <title>Copyright</title>

    <para>The <citetitle pubwork="book">Advanced Bash Scripting
      Guide</citetitle> is herewith granted to the PUBLIC DOMAIN.
      This has the following implications and consequences.
      </para>


      <para><programlisting>
A.  All previous releases of the Advanced Bash Scripting Guide
    are as well granted to the Public Domain.

A1. All printed editions, whether authorized by the author or not,
    are as well granted to the Public Domain. This legally overrides
    any stated intention or wishes of the publishers. Any statement
    of copyright is void and invalid.
    THERE ARE NO EXCEPTIONS TO THIS.

A2. Any release of the Advanced Bash Scripting Guide, whether in
    electronic or print form is granted to the Public Domain by the
    express directive of the author and previous copyright holder, Mendel
    Cooper. No other person(s) or entities have ever held a valid copyright.

B.  As a Public Domain document, unlimited copying and distribution rights
    are granted. There can be NO restrictions. If anyone has published or will
    in the future publish an original or modified version of this document,
    then only additional original material may be copyrighted. The core
    work will remain in the Public Domain.</programlisting></para>

    <para>By law, distributors and publishers (including on-line
      publishers) are prohibited from imposing any conditions,
      strictures, or provisions on this document, any previous versions,
      or any derivative versions. The author asserts
      that he has <emphasis>not</emphasis> entered into any contractual
      obligations that would alter the foregoing declarations.</para>

    <para>Essentially, you may freely distribute this book or any
      derivative thereof in electronic or printed form. If you have previously
      purchased or are in possession of a printed copy of a current or
      previous edition, you have the LEGAL RIGHT to copy and/or redistribute
      it, regardless of any copyright notice. Any copyright notice is
      void.</para>


    <para><emphasis>Additionally, the author wishes to state his intention
		    that:</emphasis></para>

<para><programlisting>If you copy or distribute this book, kindly DO NOT
use the materials within, or any portion thereof, in a patent or copyright
lawsuit against the Open Source community, its developers, its
distributors, or against any of its associated software or documentation
including, but not limited to, the Linux kernel, Open Office, Samba,
and Wine. Kindly DO NOT use any of the materials within
this book in testimony or depositions as a plaintiff's "expert witness" in
any lawsuit against the Open Source community, any of its developers, its
distributors, or any of its associated software or documentation.
</programlisting></para>


    <para>A Public Domain license essentially does not restrict ANY
      legitimate distribution or use of this book. The author especially
      encourages its (royalty-free!) use for classroom and instructional
      purposes.</para>

    <para>
      To date, limited print rights (Lulu edition) have been granted
      to one individual and to <emphasis>no one else</emphasis>. Neither
      that individual nor Lulu holds or ever has held a valid copyright.</para>

    <warning><para>It has come to the attention of the author that
      <emphasis>unauthorized</emphasis> electronic and print
      editions of this book are being sold commercially on <trademark class="registered">itunes</trademark>, <emphasis>amazon.com</emphasis>
      and elsewhere. These are illegal and pirated editions produced
      without the author's permission, and readers of this book are
      strongly urged not to purchase them. In fact, these pirated editions are
      now legal, but necessarily fall into the Public Domain, and any
      copyright notices contained within them are invalid and void.</para></warning>

    <para>The author produced this book in a manner consistent with the
      spirit of the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/manifesto.html">LDP
      Manifesto</link>.</para>


    <sidebar>
    <para>Linux is a trademark registered to Linus Torvalds.</para>
    <para>Fedora is a trademark registered to Red Hat.</para>
    <para>Unix and UNIX are trademarks registered to the Open Group.</para>
    <para>MS Windows is a trademark registered to the Microsoft Corp.</para>
    <para>Solaris is a trademark registered to Oracle, Inc.</para>
    <para>OSX is a trademark registered to Apple, Inc.</para>
    <para>Yahoo is a trademark registered to Yahoo, Inc.</para>
    <para>Pentium is a trademark registered to Intel, Inc.</para>
    <para>Thinkpad is a trademark registered to Lenovo, Inc.</para>
    <para>Scrabble is a trademark registered to Hasbro, Inc.</para>
    <para>Librie, PRS-500, and PRS-505 are trademarks registered to
      Sony, Inc.</para>
    <para>All other commercial trademarks mentioned in the body of this work
      are registered to their respective owners.</para>
      </sidebar>


    <para>Hyun Jin Cha has done a <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/index.html">Korean
      translation</link> of version 1.0.11 of this book. Spanish,
      Portuguese, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://abs.traduc.org/">French</link>, German, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://it.tldp.org/guide/abs/index.html">Italian</link>,
      <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gazette.linux.ru.net/rus/articles/index-abs-guide.html">Russian</link>,
      <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://premekvihan.net/bash">Czech</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linuxsir.org/bbs/showthread.php?t=256887">Chinese</link>,
      Indonesian, Dutch, Romanian, Bulgarian, and Turkish translations are also
      available or in progress. If you wish to translate this document
      into another language, please feel free to do so, subject to
      the terms stated above. The author wishes to be notified of such
      efforts.</para>

      <sidebar><para>Those generous readers desiring to
        make a donation to the author may contribute a small
        amount via Paypal to my e-mail address,
	<email>thegrendel.abs@gmail.com</email>.
	(An <userinput>Honor Roll of Supporters</userinput>
	is given at the beginning of the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://bash.deta.in/Change.log">Change Log</link>.)
	This is <emphasis>not</emphasis> a requirement.
	The <firstterm>ABS Guide</firstterm> is a free and freely
	distributed document for the use and enjoyment of the Linux
	community. However, in these difficult times, showing support
	for voluntary projects and especially to authors of limited
	means is more critically important than ever.</para></sidebar>


  </appendix> <!-- End Copyright appendix -->

  <appendix xml:id="asciitable">
    <title>ASCII Table</title>


    <para>Traditionally, a book of this sort has an <link linkend="asciidef">ASCII</link> Table appendix.
      This book does not. Instead, here are several short
      scripts, each of which generates a complete ASCII table.</para>

    <example xml:id="asciish">
      <title>A script that generates an ASCII table</title>
      <programlisting>#!/bin/bash
# ascii.sh
# ver. 0.2, reldate 26 Aug 2008
# Patched by ABS Guide author.

# Original script by Sebastian Arming.
# Used with permission (thanks!).

exec &gt;ASCII.txt         #  Save stdout to file,
                        #+ as in the example scripts
                        #+ reassign-stdout.sh and upperconv.sh.

MAXNUM=256
COLUMNS=5
OCT=8
OCTSQU=64
LITTLESPACE=-3
BIGSPACE=-5

i=1 # Decimal counter
o=1 # Octal counter

while [ "$i" -lt "$MAXNUM" ]; do  # We don't have to count past 400 octal.
        paddi="    $i"
        echo -n "${paddi: $BIGSPACE}  "       # Column spacing.
        paddo="00$o"
#       echo -ne "\\${paddo: $LITTLESPACE}"   # Original.
        echo -ne "\\0${paddo: $LITTLESPACE}"  # Fixup.
#                   ^
        echo -n "     "
        if (( i % $COLUMNS == 0)); then       # New line.
           echo
        fi
        ((i++, o++))
        # The octal notation for 8 is 10, and 64 decimal is 100 octal.
        (( i % $OCT == 0))    &amp;&amp; ((o+=2))
        (( i % $OCTSQU == 0)) &amp;&amp; ((o+=20))
done

exit $?

# Compare this script with the "pr-asc.sh" example.
# This one handles "unprintable" characters.

# Exercise:
# Rewrite this script to use decimal numbers, rather than octal.
</programlisting>
    </example>

    <example xml:id="ascii2sh">
      <title>Another ASCII table script</title>
      <programlisting>#!/bin/bash
# Script author: Joseph Steinhauser
# Lightly edited by ABS Guide author, but not commented.
# Used in ABS Guide with permission.

#-------------------------------------------------------------------------
#-- File:  ascii.sh    Print ASCII chart, base 10/8/16         (JETS-2012)
#-------------------------------------------------------------------------
#-- Usage: ascii [oct|dec|hex|help|8|10|16]
#--
#-- This script prints out a summary of ASCII char codes from Zero to 127.
#-- Numeric values may be printed in Base10, Octal, or Hex.
#--
#-- Format Based on: /usr/share/lib/pub/ascii with base-10 as default.
#-- For more detail, man ascii . . .
#-------------------------------------------------------------------------

[ -n "$BASH_VERSION" ] &amp;&amp; shopt -s extglob

case "$1" in
   oct|[Oo]?([Cc][Tt])|8)       Obase=Octal;  Numy=3o;;
   hex|[Hh]?([Ee][Xx])|16|[Xx]) Obase=Hex;    Numy=2X;;
   help|?(-)[h?])        sed -n '2,/^[ ]*$/p' $0;exit;;
   code|[Cc][Oo][Dd][Ee])sed -n '/case/,$p'   $0;exit;;
   *) Obase=Decimal
esac # CODE is actually shorter than the chart!

printf "\t\t## $Obase ASCII Chart ##\n\n"; FM1="|%0${Numy:-3d}"; LD=-1

AB="nul soh stx etx eot enq ack bel bs tab nl vt np cr so si dle"
AD="dc1 dc2 dc3 dc4 nak syn etb can em sub esc fs gs rs us sp"

for TOK in $AB $AD; do ABR[$((LD+=1))]=$TOK; done;
ABR[127]=del

IDX=0
while [ $IDX -le 127 ] &amp;&amp; CHR="${ABR[$IDX]}"
   do ((${#CHR}))&amp;&amp; FM2='%-3s'|| FM2=`printf '\\\\%o  ' $IDX`
      printf "$FM1 $FM2" "$IDX" $CHR; (( (IDX+=1)%8))||echo '|'
   done

exit $?
</programlisting>
    </example>

    <example xml:id="ascii3sh">
	    <title>A third ASCII table script, using
                   <firstterm>awk</firstterm></title>
      <programlisting>#!/bin/bash
# ASCII table script, using awk.
# Author: Joseph Steinhauser
# Used in ABS Guide with permission.


#-------------------------------------------------------------------------
#-- File:  ascii     Print ASCII chart, base 10/8/16         (JETS-2010)
#-------------------------------------------------------------------------
#-- Usage: ascii [oct|dec|hex|help|8|10|16]
#--
#-- This script prints a summary of ASCII char codes from Zero to 127.
#-- Numeric values may be printed in Base10, Octal, or Hex (Base16).
#--
#-- Format Based on: /usr/share/lib/pub/ascii with base-10 as default.
#-- For more detail, man ascii
#-------------------------------------------------------------------------

[ -n "$BASH_VERSION" ] &amp;&amp; shopt -s extglob

case "$1" in
   oct|[Oo]?([Cc][Tt])|8)       Obase=Octal;  Numy=3o;;
   hex|[Hh]?([Ee][Xx])|16|[Xx]) Obase=Hex;    Numy=2X;;
   help|?(-)[h?])        sed -n '2,/^[ ]*$/p' $0;exit;;
   code|[Cc][Oo][Dd][Ee])sed -n '/case/,$p'   $0;exit;;
   *) Obase=Decimal
esac
export Obase   # CODE is actually shorter than the chart!

awk 'BEGIN{print "\n\t\t## "ENVIRON["Obase"]" ASCII Chart ##\n"
           ab="soh,stx,etx,eot,enq,ack,bel,bs,tab,nl,vt,np,cr,so,si,dle,"
           ad="dc1,dc2,dc3,dc4,nak,syn,etb,can,em,sub,esc,fs,gs,rs,us,sp"
           split(ab ad,abr,",");abr[0]="nul";abr[127]="del";
           fm1="|%0'"${Numy:- 4d}"' %-3s"
           for(idx=0;idx&lt;128;idx++){fmt=fm1 (++colz%8?"":"|\n")
           printf(fmt,idx,(idx in abr)?abr[idx]:sprintf("%c",idx))} }'

exit $?
</programlisting>
    </example>

  </appendix> <!-- End ASCII Table appendix -->



      <index xml:id="xrefindex"> <!-- Begin Index -->

            <para>This index / glossary / quick-reference lists many of the
	important topics covered in the text. Terms are arranged
	in <emphasis>approximate</emphasis> ASCII sorting order,
	<emphasis>modified as necessary</emphasis> for enhanced
	clarity.</para>

      <para>Note that <emphasis>commands</emphasis> are indexed
	in <link linkend="part4A">Part 4</link>.</para>

      

<!-- Characters and symbols -->
      <para><command>^ </command> (caret)
         <itemizedlist>
         <listitem>
	   <para>
	   <link linkend="beglineref">Beginning-of-line</link>,
	   in a <link linkend="regexref">Regular Expression</link>
	   </para>
	 </listitem>

         <listitem>
      <para><command>^</command></para>
      <para><command>^^</command></para>
      <para><link linkend="casemodparamsub">Uppercase
       conversion</link> in <firstterm>parameter
       substitution</firstterm></para>
	 </listitem>
         </itemizedlist>
	 </para>

      <para><command>~ </command> <firstterm>Tilde</firstterm>
         <itemizedlist>

	 <listitem><para>
	 <command>~ </command>
         <link linkend="tilderef">home directory</link>, corresponds
           to <link linkend="homedirref"><varname>$HOME</varname></link>
          </para></listitem>

<!-- ********************** -->

	 <listitem><para>
            <command>~/ </command>
	 <link linkend="tilderef"> <firstterm>Current user's</firstterm>
	   home directory</link>
          </para></listitem>

	 <listitem><para>
            <command>~+ </command>
         <link linkend="workingdirref"><emphasis>Current</emphasis>
         working directory</link>
          </para></listitem>

	 <listitem><para>
            <command>~- </command>
         <link linkend="prevworkingdir"><emphasis>Previous</emphasis>
         working directory</link>
          </para></listitem>

         </itemizedlist>
	 </para>

<!-- ********************** -->

      <para><command>= </command> <firstterm>Equals</firstterm> sign
         <itemizedlist>

	 <listitem><para>
            <command>= </command>
         <link linkend="eqref">Variable assignment</link> operator
          </para></listitem>

	 <listitem><para>
            <command>= </command>
         <link linkend="scomparison1">String comparison</link> operator
          </para>
	 <para>
            <command>== </command>
        <link linkend="scomparison2">String comparison</link> operator
          </para></listitem>

	 <listitem>
	   <para>
            <command>=~ </command>
            <firstterm>Regular Expression</firstterm>
	    <link linkend="regexmatchref">match</link> operator
          </para>
	   <para><link linkend="findsplit0"><firstterm>Example
	     script</firstterm></link></para>
	  </listitem>

         </itemizedlist>
	 </para>


<!-- ********************** -->


      <para><command>&lt; </command> Left angle bracket
         <itemizedlist>

	 <listitem><para>Is-less-than</para>
         <para><link linkend="ltref">String comparison</link></para>
	 <para>
         <link linkend="intlt">Integer comparison</link> within
	 <link linkend="dblparens">double parentheses</link>
          </para></listitem>


	 <listitem><para>Redirection</para>

	 <para>
            <command>&lt; </command>
         <link linkend="ioredirectionref2"><filename>stdin</filename></link>
          </para>
	 <para>
            <command>&lt;&lt; </command>
         <link linkend="heredocrrref"><firstterm>Here document</firstterm></link>
          </para>
	 <para>
            <command>&lt;&lt;&lt; </command>
         <link linkend="herestringref"><firstterm>Here string</firstterm></link>
          </para>
	 <para>
            <command>&lt;&gt; </command>
         <link linkend="redirrw">Opening a file</link> for
         <emphasis>both</emphasis> reading and writing
          </para></listitem>

         </itemizedlist>
	 </para>

<!-- ********************** -->

      <para><command>&gt; </command> Right angle bracket
         <itemizedlist>

	 <listitem><para>Is-greater-than</para>
         <para><link linkend="gtref">String comparison</link></para>
	 <para><link linkend="intgt">Integer comparison</link>,
            within <firstterm>double parentheses</firstterm>
          </para></listitem>

<!-- *** -->
	 <listitem><para>Redirection</para>

        <para><command>&gt; </command>
         <link linkend="ioredirectionref">Redirect
         <filename>stdout</filename></link> to a file
          </para>
	 <para>
            <command>&gt;&gt; </command>
         <link linkend="ioredirectionref">Redirect
         <filename>stdout</filename></link> to a file,
         but <firstterm>append</firstterm>
          </para>

	 <para><command>i&gt;&amp;j </command>
            <link linkend="ioredirectionref1">Redirect
	    <firstterm>file descriptor</firstterm>
	    <filename>i</filename></link> to
	    <firstterm>file descriptor</firstterm>
	    <filename>j</filename></para>
	 <para>
            <command>&gt;&amp;j </command>
            <link linkend="ioredirectionref1">Redirect
	    <filename>stdout</filename></link> to
	    <firstterm>file descriptor</firstterm>
	    <filename>j</filename></para>
	 <para>
            <command>&gt;&amp;2 </command>
         <link linkend="redirouterror2">Redirect
	    <filename>stdout</filename></link> of a command to
	    <filename>stderr</filename></para>
	 <para>
            <command>2&gt;&amp;1 </command>
         <link linkend="ioredirectionref1">Redirect
	    <filename>stderr</filename></link>
	    to <filename>stdout</filename></para>
	 <para>
            <command>&amp;&gt; </command>
         <link linkend="redirouterror">Redirect
	    <emphasis>both</emphasis> <filename>stdout</filename>
	    and <filename>stderr</filename></link> of a command to a
	    file</para>

	 <para><command>:&gt; <filename>file</filename></command>
         <link linkend="ioredirectionref">Truncate file</link>
          to zero length</para>
	  
	  </listitem>

         </itemizedlist>
	 </para>

<!-- ********************** -->

      <para><command>| </command>
         <link linkend="piperef">Pipe</link>, a device for passing the output
         of a command to another command or to the shell</para>
      <para><command>|| </command>
         <link linkend="orref">Logical OR test operator</link></para>

<!-- ********************** -->

      <para><command>- </command> (dash)
         <itemizedlist>

	 <listitem><para>
        <link linkend="defparam1">Prefix to <firstterm>default
	  parameter</firstterm></link>, in <firstterm>parameter
	  substitution</firstterm></para></listitem>
	 <listitem><para>
        <link linkend="dashref">Prefix to <firstterm>option
          flag</firstterm></link></para></listitem>

	 <listitem><para>
        <link linkend="dashref2">Indicating
        <firstterm>redirection</firstterm></link> from
        <filename>stdin</filename> or <filename>stdout</filename>
          </para></listitem>

	 <listitem>
	   <para><command>-- </command> (double-dash)</para>
           <para><link linkend="doubledashref">Prefix to
	     <firstterm>long</firstterm> command options</link></para>
	 <para>
         <link linkend="plusplusref"><firstterm>C-style</firstterm>
	 variable decrement</link> within <link linkend="dblparensref">double
	 parentheses</link>
          </para></listitem>

         </itemizedlist>
	 </para>

<!-- ********************** -->

      <para><command>; </command> (semicolon)
	   <itemizedlist>
      <listitem><para><link linkend="semicolonref">As command
        separator</link></para></listitem>
      <listitem><para><command>\; </command>
         <link linkend="findref0"><firstterm>Escaped</firstterm> semicolon</link>,
	 terminates a <link linkend="findref">find</link>
	 command</para></listitem>
      <listitem><para><command>;; </command>
         <link linkend="doublesemicolon">Double-semicolon</link>, terminator in a
         <link linkend="caseesac1">case</link> option</para>

        <para>Required when ...</para>
	<para><link linkend="needsemicolon"><firstterm>do</firstterm>
         keyword is on the first line of
	 <firstterm>loop</firstterm></link></para>
        <para><link linkend="omitsemicolon">
         terminating <firstterm>curly-bracketed</firstterm>
	 code block</link></para>
      </listitem>

      <listitem><para><command>;;&amp;</command> <command>;&amp;</command>
        <link linkend="ncterm">Terminators</link> in
	a <firstterm>case</firstterm> option (<link linkend="bash4ref">version 4+</link> of Bash).</para></listitem>

	   </itemizedlist></para>


      <para><command>:</command> Colon
	   <itemizedlist>

	 <listitem><para>
            <command>:&gt; <filename>filename</filename></command>
         <link linkend="ioredirectionref">Truncate file</link>
          to zero length</para></listitem>

         <listitem><para><link linkend="nullref"><firstterm>null</firstterm>
	 command</link>, equivalent to the
         <link linkend="trueref">true</link> Bash
         builtin</para></listitem>

	 <listitem><para>Used in an <link linkend="anonheredoc0">anonymous
	 here document</link></para></listitem>

	 <listitem><para>Used in an <link linkend="coloninfunction">otherwise
	 empty function</link></para></listitem>

	 <listitem><para>Used as a <link linkend="fstrangeref">function
	 name</link></para></listitem>

	   </itemizedlist></para>



      <para><command>! </command>
         <link linkend="notref">Negation operator</link>, inverts <link linkend="negcond">exit status</link> of a test or command
           <itemizedlist>
      <listitem><para><command>!= </command>
         <link linkend="notequal">not-equal-to</link>
	 String comparison operator</para></listitem>
           </itemizedlist></para>

<!-- ********************** -->
      <para><command>? </command> (question mark)
         <itemizedlist>

      <listitem><para>
        <link linkend="quexregex">Match zero or one characters</link>,
	in an <link linkend="extregex"> Extended Regular
	Expression</link></para></listitem>
      <listitem><para><link linkend="quexwc">Single-character
	<firstterm>wild card</firstterm></link>,
	in <link linkend="globbingref">globbing</link></para></listitem>
        <listitem><para>In a
        <link linkend="cstrinary"><firstterm>C</firstterm>-style
        Trinary operator</link></para></listitem>

         </itemizedlist></para>
<!-- ********************** -->


      <para><command>// </command>
        <link linkend="doubleslashref">Double forward slash</link>,
          behavior of <link linkend="cdref">cd</link> command toward</para>

<!-- ********************** -->

      <para><command>. </command> (dot / period)
         <itemizedlist>

	 <listitem><para>
            <command>. </command>
         <link linkend="dotref">Load a file</link> (into a script),
         equivalent to <link linkend="sourceref">source</link> command
	 </para></listitem>

	 <listitem><para>
            <command>. </command>
         <link linkend="regexdot">Match single character</link>,
         in a <link linkend="regexref">Regular Expression</link>
	 </para></listitem>

	 <listitem><para>
            <command>. </command>
         <link linkend="dotdirectory">Current working
         directory</link>
	 </para>
	 <para>
            <command>./ </command>
         <link linkend="currentwdref">Current working
          directory</link>
	 </para></listitem>

	 <listitem><para>
            <command>.. </command>
         <link linkend="dotdirectory"><firstterm>Parent</firstterm>
         directory</link>
	 </para></listitem>

         </itemizedlist>
	 </para>

<!-- ********************** -->

      <para><command>' ... '</command>
	 (single quotes)
         <link linkend="snglquo"><firstterm>strong</firstterm>
         quoting</link></para>

      <para><command>" ... " </command>
         (double quotes)
         <link linkend="dblquo"><firstterm>weak</firstterm>
         quoting</link>
	   <itemizedlist>
	     <listitem><para><link linkend="quotingbsl"><firstterm>Double-quoting</firstterm>
	       the <firstterm>backslash</firstterm> (<command>\</command>)
	       character</link></para></listitem>
	   </itemizedlist>
	 </para>

      <para><command>,</command>
        <itemizedlist>
	 <listitem><para>
         <link linkend="commaop">Comma operator</link>
	 </para></listitem>
         <listitem>
            <para><command>,</command></para>
            <para><command>,,</command></para>
            <para><link linkend="casemodparamsub">Lowercase
            conversion</link> in <firstterm>parameter
            substitution</firstterm></para>
	 </listitem>
         </itemizedlist>
	 </para>


<!-- ********************** -->
      <para><command>() </command> Parentheses
         <itemizedlist>

      <listitem><para><command>( ... ) </command>
         <link linkend="parensref">Command group</link>;
	 starts a
	 <link linkend="subshellsref">subshell</link></para></listitem>
      <listitem><para><command>( ... ) </command>
         <link linkend="parengrps">Enclose group</link>
	 of <firstterm>Extended Regular
	 Expressions</firstterm></para></listitem>
    <listitem>
      <para><command>&gt;( ... )</command></para>
      <para><command>&lt;( ... ) </command>
      <link linkend="processsubref">Process substitution</link></para>
   </listitem>

      <listitem><para><command> ... ) </command>
         <link linkend="caseparen">Terminates test-condition</link>
	 in <firstterm>case</firstterm> construct</para></listitem>
      <listitem><para><command>(( ... )) </command>
         <link linkend="dblparensref">Double parentheses</link>,
         in arithmetic expansion</para></listitem>
         </itemizedlist></para>
<!-- ********************** -->

      <para><command>[ </command> <link linkend="leftbracket">Left bracket</link>,
        <firstterm>test</firstterm> construct</para>

      <para><command>[ ]</command>Brackets
         <itemizedlist>
      <listitem><para><link linkend="brackarray"><firstterm>Array</firstterm>
        element</link></para></listitem>
      <listitem><para><link linkend="bracketsref">Enclose character set
        to match</link> in a <firstterm>Regular
	Expression</firstterm></para></listitem>
      <listitem><para><link linkend="bracktest"><firstterm>Test</firstterm> construct</link></para>
      </listitem>
         </itemizedlist></para>

      <para><command>[[ ... ]]</command>
         <link linkend="dblbrackets">Double brackets</link>,
	 extended <firstterm>test</firstterm> construct</para>

      <para><command>$ </command>
        <link linkend="dollarsignref"><firstterm>Anchor</firstterm></link>,
          in a <link linkend="regexref">Regular Expression</link></para>
      <para><command>$ </command>
         <link linkend="varsubn">Prefix to a variable name</link></para>
      <para><command>$( ... ) </command>
         <link linkend="commandsubref0">Command substitution</link>,
	 setting a variable with output of a command,
	 using parentheses notation</para>
      <para><command>` ... ` </command>
         <link linkend="backquotesref">Command substitution</link>,
	 using <link linkend="backticksref">backquotes</link>
	 notation</para>

      <para><command>$[ ... ]</command>
        <link linkend="bracketarith">Integer expansion</link>
	(deprecated)</para>


<!-- ********************** -->
      <para><command>${ ... }</command> Variable manipulation / evaluation

         <itemizedlist>
      <listitem><para><command>${var}</command>
      <link linkend="pssub1">Value of a variable</link></para></listitem>

      <listitem><para><command>${#var}</command>
      <link linkend="psorex1">Length of a variable</link></para></listitem>

      <listitem>
      <para><command>${#@}</command></para>
      <para><command>${#*}</command>
        <link linkend="numposparam">Number of
	 <firstterm>positional
	 parameters</firstterm></link></para></listitem>

      <listitem>
      <para><command>${parameter?err_msg}</command>
         <link linkend="qerrmsg">Parameter-unset
        message</link></para></listitem>

      <listitem>
      <para><command>${parameter-default}</command></para>
      <para><command>${parameter:-default}</command></para>
      <para><command>${parameter=default}</command></para>
      <para><command>${parameter:=default}</command>
      <link linkend="defparam1">Set default
      parameter</link></para></listitem>

      <listitem>
        <para><command>${parameter+alt_value}</command></para>
	<para><command>${parameter:+alt_value}</command></para>
        <para><link linkend="paramaltv">Alternate value</link>
          of parameter, if set</para>
      </listitem>

      <listitem>
	 <para><command>${!var}</command></para>
         <para><link linkend="ivr2">Indirect referencing of a variable</link>,
	   new notation</para>
      </listitem>

      <listitem>
         <para><command>${!#}</command></para>
         <para><link linkend="lastargref">Final <firstterm>positional
           parameter</firstterm></link>.
	   (This is an <firstterm>indirect reference</firstterm> to
	   <link linkend="clacountref">$#</link>.)</para>
      </listitem>

      <listitem>
        <para><command>${!varprefix*}</command></para>
        <para><command>${!varprefix@}</command></para>
      <para><link linkend="varprefixm">Match
        <emphasis>names</emphasis></link> of all previously declared
        variables beginning with <varname>varprefix</varname></para>
      </listitem>

      <listitem>
      <para><command>${string:position}</command></para>
      <para><command>${string:position:length}</command>
      <link linkend="substrextr01">Substring
      extraction</link></para></listitem>

      <listitem>
      <para><command>${var#Pattern}</command></para>
      <para><command>${var##Pattern}</command>
      <link linkend="psorex2">Substring
      removal</link></para></listitem>

      <listitem>
      <para><command>${var%Pattern}</command></para>
      <para><command>${var%%Pattern}</command>
      <link linkend="pctpatref">Substring
        removal</link></para></listitem>

      <listitem>
      <para><command>${string/substring/replacement}</command></para>
      <para><command>${string//substring/replacement}</command></para>
      <para><command>${string/#substring/replacement}</command></para>
      <para><command>${string/%substring/replacement}</command>
      <link linkend="substrrepl00">Substring
      replacement</link></para></listitem>

         </itemizedlist></para>
<!-- ********************** -->

      <para><command>$' ... '</command>
        <link linkend="strq">String expansion</link>,
	using <firstterm>escaped</firstterm> characters.</para>

      <para><command>\ </command>
         <link linkend="escp">Escape</link> the character following
	    <itemizedlist>
      <listitem><para><command>\&lt; ... \&gt; </command>
         <link linkend="anglebrac">Angle brackets</link>,
         <firstterm>escaped</firstterm>,
	 word boundary in a <link linkend="regexref">Regular
	 Expression</link></para></listitem>
      <listitem><para><command>\{ N \}</command>
         <link linkend="escpcb"><quote>Curly</quote> brackets</link>,
         <firstterm>escaped</firstterm>,
	 number of character sets to match in an <link linkend="extregex">Extended RE</link></para></listitem>
      <listitem><para><command>\; </command>
         <link linkend="findref0"><firstterm>Semicolon</firstterm></link>,
         <firstterm>escaped</firstterm>,
	 terminates a <link linkend="findref">find</link>
	 command</para></listitem>
      <listitem><para><command>\$$ </command> <link linkend="ivrref">Indirect
        reverencing of a variable</link>, old-style notation</para></listitem>
      <listitem><para><link linkend="escnewline">Escaping
        a <firstterm>newline</firstterm></link>,
	to write a multi-line command</para></listitem>
	    </itemizedlist></para>

<!-- ********************** -->
      <para><command>&amp; </command>
         <itemizedlist>

	 <listitem><para>
            <command>&amp;&gt; </command>
         <link linkend="redirouterror">Redirect
	    <emphasis>both</emphasis> <filename>stdout</filename>
	    and <filename>stderr</filename></link> of a command to a
	    file</para></listitem>

	 <listitem><para>
            <command>&gt;&amp;j </command>
            <link linkend="ioredirectionref1">Redirect
	    <filename>stdout</filename></link> to
	    <firstterm>file descriptor</firstterm>
	    <firstterm>j</firstterm></para>
	 <para>
            <command>&gt;&amp;2 </command>
         <link linkend="redirouterror2">Redirect
	    <filename>stdout</filename></link> of a command to
	    <filename>stderr</filename></para></listitem>

	 <listitem><para>
            <command>i&gt;&amp;j </command>
            <link linkend="ioredirectionref1">Redirect
	    <firstterm>file descriptor</firstterm></link>
	    <firstterm>i</firstterm> to
	    <firstterm>file descriptor</firstterm>
	    <firstterm>j</firstterm></para>
	 <para>
            <command>2&gt;&amp;1 </command>
         <link linkend="ioredirectionref1">Redirect
	    <filename>stderr</filename></link> to
	    <filename>stdout</filename></para></listitem>

      <listitem><para><link linkend="cfd">Closing <firstterm>file
      descriptors</firstterm></link></para>

        <para><command>n&lt;&amp;-</command>
           Close input file descriptor
	   <firstterm>n</firstterm></para>
        <para><command>0&lt;&amp;-</command>,
	   <command>&lt;&amp;-</command>
           Close <filename>stdin</filename></para>
        <para><command>n&gt;&amp;-</command>
          Close output file descriptor
	  <firstterm>n</firstterm></para>
        <para><command>1&gt;&amp;-</command>,
	   <command>&gt;&amp;-</command>
	   Close <filename>stdout</filename></para></listitem>


         <listitem><para>
	    <command>&amp;&amp; </command>
	    <link linkend="logicaland">Logical AND
	    test operator</link></para></listitem>

         <listitem><para>
	    <command>Command &amp;</command>
	    <link linkend="bgjob">Run job in
            <firstterm>background</firstterm></link></para></listitem>

         </itemizedlist></para>
<!-- ********************** -->



      <para><command># </command>
         <link linkend="hashmarkref">Hashmark</link>,
         special symbol beginning a script
         <firstterm>comment</firstterm></para>

      <para><command>#!</command>
         <link linkend="shabangref">Sha-bang</link>,
         special string starting a
         <link linkend="whatsascript">shell script</link></para>

<!-- ********************** -->
      <para><command>* </command> Asterisk
         <itemizedlist>

	 <listitem><para>
         <link linkend="asteriskref"><firstterm>Wild
         card</firstterm></link>,
	 in <link linkend="globbingref">globbing</link>
	 </para></listitem>

	 <listitem><para>
         <link linkend="asteriskref2">Any number of characters</link>
	 in a <link linkend="regexref">Regular Expression</link>
	 </para></listitem>
	    
	 <listitem><para>
            <command> ** </command>
         <link linkend="exponentiationref">Exponentiation</link>,
	 arithmetic operator
	 </para></listitem>

	 <listitem><para>
            <command> ** </command>
	 Extended <firstterm>globbing</firstterm>
         <link linkend="globstarref">file-match operator</link>
	 </para></listitem>

         </itemizedlist>
	 </para>
<!-- ********************** -->
      <para><command>% </command> Percent sign
         <itemizedlist>

	 <listitem><para>
         <link linkend="moduloref">Modulo</link>, division-remainder
         arithmetic operation
	 </para></listitem>

	 <listitem><para>
         <link linkend="pctpatref">Substring removal</link>
	   (pattern matching) operator</para></listitem>

         </itemizedlist>
	 </para>
<!-- ********************** -->

      <para><command>+ </command> Plus sign
         <itemizedlist>
         <listitem><para><link linkend="plusref"><firstterm>Character
           match</firstterm></link>, in an <link linkend="extregex">extended Regular
           Expression</link></para></listitem>
        <listitem><para><link linkend="paramaltv">Prefix to
	   <firstterm>alternate parameter</firstterm></link>, in
	   <firstterm>parameter substitution</firstterm></para></listitem>
        <listitem><para><command> ++ </command>
           <link linkend="plusplusref"><firstterm>C-style</firstterm>
           variable increment</link>, within
           <link linkend="dblparensref">double
           parentheses</link></para></listitem>
         </itemizedlist></para>

      

      <para><firstterm>Shell Variables</firstterm></para>

      <para><command>$_ </command>
        <link linkend="underscoreref">Last argument to previous
	command</link></para>
      <para><command>$- </command>
        <link linkend="flpref">Flags passed to script</link>, using <link linkend="setref">set</link></para>
      <para><command>$! </command>
         <link linkend="pidvarref"><firstterm>Process ID</firstterm>
         of last background job</link></para>
      <para><command>$? </command>
         <link linkend="exsref"><firstterm>Exit
         status</firstterm> of a command</link></para>
      <para><command>$@ </command>
         All the <firstterm>positional parameters</firstterm>, <link linkend="appref2">as <emphasis>separate</emphasis>
         words</link></para>
      <para><command> $* </command>
         All the <firstterm>positional parameters</firstterm>, <link linkend="appref">as a <emphasis>single</emphasis>
         word</link></para>
      <para><command>$$ </command>
         <link linkend="processidref">Process ID</link> of the
         script</para>
      <para><command>$# </command>
         <link linkend="clacountref">Number of arguments passed</link> to a
         <link linkend="functionref">function</link>, or to the script
         itself</para>
      <para><command>$0 </command>
         <link linkend="scrnameparam">Filename of the script</link></para>
      <para><command>$1 </command>
         <link linkend="posparamref1">First argument passed to script</link></para>
      <para><command>$9 </command>
         <link linkend="posparamref1">Ninth argument passed to script</link></para>
      <para><link linkend="specshvartab"><command>Table</command></link>
        of <firstterm>shell variables</firstterm></para>

<!-- End Characters and symbols -->

      <para>* * * * * *</para>

      <para><command>-a </command>
        <link linkend="compoundand">Logical AND</link>
	compound comparison test</para>
      <para>Address database, <link linkend="ex30">script
        example</link></para>

      <para><firstterm>Advanced Bash Scripting Guide</firstterm>,
         <link linkend="where_tarball">where to download</link></para>

      <para><link linkend="aliasref">Alias</link>
         <itemizedlist>
      <listitem><para><link linkend="unaliasref">Removing an
        <firstterm>alias</firstterm></link>, using
	<firstterm>unalias</firstterm></para></listitem>
          </itemizedlist></para>

      <para><link linkend="agram2">Anagramming</link></para>

      <para><link linkend="lcons1"><firstterm>And</firstterm> list</link>
         <itemizedlist>
      <listitem><para>
         <link linkend="anddefault">To supply default command-line
         argument</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="logops1"><firstterm>And</firstterm> logical
        operator</link> <command>&amp;&amp;</command></para>

      <para><link linkend="anglebrac">Angle brackets</link>,
         <firstterm>escaped</firstterm>,
	 <command>\&lt; . . . \&gt; </command>
	 word boundary in a <link linkend="regexref">Regular
	 Expression</link></para>
      <para><link linkend="anonheredoc0">Anonymous
         <firstterm>here document</firstterm></link>, using
         <command>:</command></para>

<!-- ********************** -->
      <para><link linkend="faarchiving1">Archiving</link>
         <itemizedlist>
      <listitem><para><link linkend="rpmref">rpm</link></para></listitem>
      <listitem><para><link linkend="tarref">tar</link></para></listitem>
         </itemizedlist></para>
<!-- ********************** -->
      <para><link linkend="arithexpref">Arithmetic expansion</link>
         <itemizedlist>
      <listitem><para><link linkend="arxs">
         <firstterm>exit status</firstterm> of</link></para></listitem>
      <listitem><para><link linkend="arithexpvar1">
         variations of</link></para></listitem>
         </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="arops1">Arithmetic operators</link>
         <itemizedlist>
      <listitem><para><link linkend="arithopscomb">
         combination operators</link>, <firstterm>C</firstterm>-style</para>
	 <para><command> += </command>
	       <command> -= </command>
	       <command> *= </command>
               <command> /= </command>
	       <command> %= </command>
	 </para>

	 <note><para><link linkend="pluseqstr">In certain contexts</link>,
	   <command>+=</command> can also function as a <firstterm>string
	   concatenation</firstterm> operator.</para></note>

	    </listitem>
	 </itemizedlist></para>


      <para><link linkend="arrayref">Arrays</link></para>
         <itemizedlist>
	   <listitem><para><link linkend="assocarr">Associative arrays</link>
	      </para>
	      <para><link linkend="assocarrtst">more efficient</link>
	      than conventional arrays</para>
	      </listitem>
	   <listitem><para><link linkend="arrayref">Bracket notation</link>
	      </para></listitem>
	   <listitem><para><link linkend="arrayappend0">Concatenating</link>,
	      <firstterm>example script</firstterm></para></listitem>
	   <listitem><para><link linkend="copyarray0">Copying</link>
	      </para></listitem>
	   <listitem><para><link linkend="arraydeclare">Declaring</link></para>
           <para><varname>declare -a
		 array_name</varname></para></listitem>

	   <listitem><para><link linkend="arrayindir">Embedded
	     arrays</link></para></listitem>
	   <listitem><para><link linkend="emptyarray0">Empty
	     arrays, empty elements</link>, <firstterm>example
	     script</firstterm></para></listitem>
	   <listitem><para><link linkend="arrayindir">Indirect references</link>
	      </para></listitem>

	   <listitem>
	      <para><link linkend="arrayinit0">Initialization</link></para>
	      <para><varname>array=( element1 element2 ... elementN)</varname></para>
	      <para><link linkend="arrayassign0"><firstterm>Example
	        script</firstterm></link></para>
	      <para>Using <link linkend="arrayinitcs">command
	         substitution</link></para>
                 </listitem>

	   <listitem><para><link linkend="arrayinitcs">Loading a
	     file</link> into an array</para></listitem>
	   <listitem><para><link linkend="arraymultidim">Multidimensional</link>,
              simulating</para></listitem>
	   <listitem><para><link linkend="arraynest">Nesting and
	      embedding</link></para></listitem>
	   <listitem><para><link linkend="arraynotation">Notation
	      and usage</link></para></listitem>
	   <listitem><para><link linkend="arraynumelements">Number of elements in</link></para>
	     <para><varname>${#array_name[@]}</varname></para>
	     <para><varname>${#array_name[*]}</varname></para></listitem>
	   <listitem><para><link linkend="arraysyntax">Operations</link></para></listitem>
           <listitem><para><link linkend="passarray">Passing
             an <firstterm>array</firstterm></link> to a
             function</para></listitem>
           <listitem><para>As <link linkend="retarray">
              <firstterm>return value</firstterm> from
	      a function</link></para></listitem>

	   <listitem><para>Special properties,
	     <link linkend="arrayspecialprops">example
	     script</link></para></listitem>
	   <listitem><para>String operations,
	     <link linkend="arraystringops">example
	     script</link></para></listitem>
	   <listitem><para><link linkend="arrayunset"><firstterm>unset</firstterm> deletes array
	     elements</link></para></listitem>
         </itemizedlist>

      <para><link linkend="readarrow">Arrow keys</link>, detecting</para>

      <para>ASCII
         <itemizedlist>
      <listitem><para><link linkend="asciidef">Definition</link></para></listitem>
      <listitem><para><link linkend="asciitable">
        Scripts for generating ASCII table</link></para></listitem>
         </itemizedlist>
      </para>

<!-- ********************** -->
      <para><link linkend="awk">awk</link> field-oriented text
         processing language
         <itemizedlist>
      <listitem><para><link linkend="awkrandomref">
         <varname>rand()</varname></link>,
	 random function</para></listitem>
      <listitem><para><link linkend="awkstringmanip2">String
        manipulation</link></para></listitem>
      <listitem><para><link linkend="exportawk">Using
	<firstterm>export</firstterm></link> to pass a variable to an
	embedded <firstterm>awk</firstterm> script</para></listitem>
         </itemizedlist></para>
<!-- ********************** -->

      

      <para>Backlight, <link linkend="backlight">setting the
        brightness</link></para>
      <para><link linkend="backticksref">Backquotes</link>,
         used in <link linkend="backquotesref">command
         substitution</link></para>
      <para><link linkend="base0">Base conversion</link>,
        <firstterm>example script</firstterm></para>

<!-- ********************** -->
      <para><link linkend="bashdef">Bash</link>
         <itemizedlist>

      <listitem><para><link linkend="bash3gotcha">Bad scripting
         practices</link></para></listitem>
      <listitem><para><link linkend="basicsrev0">Basics reviewed</link>,
        <firstterm>script example</firstterm></para></listitem>
      <listitem>
        <para><link linkend="clopts">Command-line
          options</link></para>
        <para><link linkend="optionstable"><command>Table</command></link></para>
	  </listitem>
      <listitem><para> <link linkend="bashcompat">Features that classic
        <firstterm>Bourne</firstterm> shell lacks</link></para></listitem>
      <listitem>
        <para><link linkend="internalvariables">Internal variables</link></para>
      </listitem>
      <listitem><para><link linkend="bash2ref">
        Version 2</link></para></listitem>
      <listitem><para><link linkend="bash3ref">
        Version 3</link></para></listitem>
      <listitem>
        <para><link linkend="bash4ref">Version 4</link></para>
        <para><link linkend="bash41">Version 4.1</link></para>
        <para><link linkend="bash42">Version 4.2</link></para>
      </listitem>

         </itemizedlist></para>
<!-- ********************** -->


      <para><link linkend="sample-bashrc">.bashrc</link></para>
      <para><link linkend="bashsubshellref"><varname>$BASH_SUBSHELL</varname></link></para>
      <para><link linkend="basiccommands1">Basic commands</link>, external</para>
      <para><link linkend="dosbatch1">Batch files</link>,
        <firstterm>DOS</firstterm></para>

      <para><link linkend="batchprocref">Batch processing</link></para>

      <para><link linkend="bcref">bc</link>, calculator utility
         <itemizedlist>
      <listitem><para><link linkend="bcheredoc">In a <firstterm>here
        document</firstterm></link></para></listitem>
      <listitem><para><link linkend="bctemplate">Template</link>
        for calculating a script variable</para></listitem>
         </itemizedlist></para>

      <para><link linkend="biblio">Bibliography</link></para>
      <para><link linkend="bisonref">Bison</link> utility</para>

      <para><link linkend="bitwsops1">Bitwise operators</link>
         <itemizedlist>
        <listitem><para><link linkend="base64">Example script</link>
        </para></listitem>
         </itemizedlist>
      </para>

      <para><link linkend="blockdevref">Block devices</link>
        <itemizedlist> 
	  <listitem><para><link linkend="blockdevtest">testing
	    for</link></para></listitem>
        </itemizedlist> 
       </para>

      <para><link linkend="codeblockref">Blocks of code</link>
         <itemizedlist>
      <listitem>
        <para><link linkend="nododone">Iterating / looping</link></para>
      </listitem>
      <listitem>
        <para><link linkend="blockio">Redirection</link></para>
        <para><firstterm>Script example</firstterm>:
        <link linkend="blockio2">Redirecting output of a a code
        block</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="bfs">Bootable flash drives</link>, creating</para>

<!-- ********************** -->
      <para><link linkend="braceexpref">Brace expansion</link>
         <itemizedlist>
      <listitem><para><link linkend="braceexpref33">Extended</link>,
	   <replaceable>{a..z}</replaceable></para></listitem>
      <listitem><para><link linkend="braceexpref3">Parameterizing</link>
	 </para></listitem>
      <listitem><para>With <link linkend="braceexpref4">increment and
      zero-padding</link> (new feature in Bash, <link linkend="bash4ref">version
      4</link>)</para></listitem>
         </itemizedlist></para>
<!-- ********************** -->

      <para>Brackets, <command>[ ]</command>
         <itemizedlist>
      <listitem><para><link linkend="brackarray"><firstterm>Array</firstterm>
        element</link></para></listitem>
      <listitem><para><link linkend="bracketsref">Enclose character set
        to match</link> in a <firstterm>Regular
	Expression</firstterm></para></listitem>
      <listitem><para><link linkend="bracktest"><firstterm>Test</firstterm> construct</link></para>
      </listitem>
         </itemizedlist></para>

      <para>Brackets, <firstterm>curly</firstterm>, <command>{}</command>,
        used in</para>
         <itemizedlist>
      <listitem><para><link linkend="codeblockref">Code
        block</link></para></listitem>
      <listitem><para><link linkend="curlybracketsref">
         <firstterm>find</firstterm></link></para></listitem>
      <listitem><para><link linkend="escpcb"><firstterm>Extended Regular
	 Expressions</firstterm></link></para></listitem>
      <listitem><para><link linkend="bracketnotation"><firstterm>Positional
        parameters</firstterm></link></para></listitem>
      <listitem><para><link linkend="xargscurlyref"><firstterm>xargs</firstterm></link></para></listitem>
         </itemizedlist>

<!-- ********************** -->

      <para><link linkend="brkcont1">break</link>
         <firstterm>loop</firstterm> control command
	    <itemizedlist>
      <listitem><para><link linkend="breakparam">Parameter</link>
         (optional)</para></listitem>
	    </itemizedlist></para>

      <para><link linkend="builtinref">Builtins</link> in
         <firstterm>Bash</firstterm>
	    <itemizedlist>
      <listitem><para><link linkend="bltinfrk">Do not fork a subprocess</link>
         </para></listitem>
	    </itemizedlist></para>

      

      <para><link linkend="caseesac1"><firstterm>case</firstterm>
         construct</link>
	    <itemizedlist>
      <listitem><para><link linkend="casecl">Command-line parameters</link>,
         handling</para></listitem>
      <listitem><para><link linkend="csglob">Globbing</link>,
         filtering strings with</para></listitem>
	    </itemizedlist></para>

      <para><link linkend="catref">cat</link>,
        con<firstterm>cat</firstterm>entate file(s)
	    <itemizedlist>
      <listitem><para><link linkend="catabuse">Abuse of</link></para></listitem>
      <listitem><para><link linkend="catscriptref"><firstterm>cat</firstterm>
         scripts</link></para></listitem>
      <listitem><para><link linkend="catlesseff">Less efficient than
        redirecting <filename>stdin</filename></link></para></listitem>
      <listitem><para><link linkend="readpiperef">Piping the output
        of</link>, to a <link linkend="readref">read</link></para></listitem>
      <listitem><para><link linkend="catuses">Uses of</link></para></listitem>
	    </itemizedlist></para>


      <para><link linkend="chardevref">Character devices</link>
        <itemizedlist>
	  <listitem><para><link linkend="chardevtest">testing
	  for</link></para></listitem>
        </itemizedlist>
      </para>

      <para><link linkend="checksumref">Checksum</link></para>
      <para><link linkend="childref">Child processes</link></para>
      <para><link linkend="nullref">Colon</link>, <command>: </command>,
         equivalent to the <link linkend="trueref">true</link> Bash
         builtin</para>

      <para><link linkend="colorizingref">Colorizing scripts</link>
	    <itemizedlist>
         <listitem><para>Cycling through the background colors, <link linkend="showallc">example script</link></para></listitem>
         <listitem><para><link linkend="coloriztable"><command>Table</command></link> of
	   color escape sequences</para></listitem>
         <listitem><para><link linkend="coloriztempl">Template</link>,
	   colored text on colored background</para></listitem>
	    </itemizedlist></para>

      <para><link linkend="commaop">Comma operator</link>,
         linking commands or operations</para>

      <para><link linkend="bash-options">Command-line options</link></para>

      <para><link linkend="cnfh">command_not_found_handle ()</link>
        <firstterm>builtin</firstterm> error-handling function
	(<link linkend="bash4ref">version 4+</link> of Bash)</para>

      <para><link linkend="commandsubref">Command substitution</link>
         <itemizedlist>
      <listitem>
        <para>
         <link linkend="csparens"><command>$( ... )</command></link>,
	   preferred notation</para>
      </listitem>
       <listitem><para><link linkend="backquotesref"><firstterm>Backquotes</firstterm></link></para></listitem>
       <listitem><para><link linkend="cstoolset">Extending the
         <firstterm>Bash</firstterm> toolset</link></para></listitem>
       <listitem><para><link linkend="cssubsh">Invokes a
         <firstterm>subshell</firstterm></link></para></listitem>
       <listitem><para><link linkend="csnest">Nesting</link></para></listitem>
       <listitem><para><link linkend="cstrnl">Removes trailing newlines</link>
         </para></listitem>
       <listitem><para><link linkend="csvl">Setting variable from loop output</link>
         </para></listitem>
       <listitem><para><link linkend="csws">Word
         splitting</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="commenth">Comment headers</link>,
        special purpose</para>

      <para>Commenting out blocks of code
        <itemizedlist>
      <listitem><para>Using an <link linkend="cblock1"><firstterm>anonymous</firstterm> here
        document</link></para></listitem>
      <listitem><para>Using an <link linkend="comoutbl">
        <firstterm>if-then</firstterm> construct</link></para></listitem>
         </itemizedlist></para>



      <para><link linkend="communications">Communications and
        hosts</link></para>
      <para><link linkend="ccomparison1">Compound comparison</link>
         operators</para>

<!-- ************************************************************ -->
      <para><link linkend="facompression1">Compression utilities</link>
         <itemizedlist>
      <listitem><para><link linkend="bzipref">bzip2</link></para></listitem>
      <listitem><para><link linkend="compressref">compress</link></para></listitem>
      <listitem><para><link linkend="gzipref">gzip</link></para></listitem>
      <listitem><para><link linkend="zipref">zip</link></para></listitem>
         </itemizedlist></para>
<!-- ************************************************************ -->
      <para><link linkend="brkcont1">continue</link> loop control command</para>

<!-- ***************************************************************** -->
      <para><link linkend="controlcharref">Control characters</link>
         <itemizedlist>
      <listitem><para><link linkend="ctlcref">Control-C</link>,
         <firstterm>break</firstterm></para></listitem>
      <listitem><para><link linkend="ctldref">Control-D</link>,
         terminate / log out / erase</para></listitem>
      <listitem><para><link linkend="ctlgref">Control-G</link>,
         <userinput>BEL</userinput>
         (<firstterm>beep</firstterm>)</para></listitem>
      <listitem><para><link linkend="ctlhref">Control-H</link>,
         <firstterm>rubout</firstterm></para></listitem>
      <listitem><para><link linkend="ctljref">Control-J</link>,
         <firstterm>newline</firstterm></para></listitem>
      <listitem><para><link linkend="ctlmref">Control-M</link>,
         carriage return</para></listitem>
         </itemizedlist></para>
<!-- ***************************************************************** -->

      <para><link linkend="coprocref">Coprocesses</link></para>
      <para><link linkend="cronref">cron</link>, scheduling
        <firstterm>daemon</firstterm></para>
      <para><link linkend="cstyle"><firstterm>C</firstterm>-style syntax
        </link>, for handling variables</para>

      <para><link linkend="cwsolver">Crossword puzzle solver</link></para>
      <para><link linkend="gronsfeld">Cryptography</link></para>

      <para>Curly brackets {}
           <itemizedlist>
      <listitem><para><link linkend="curlybracketsref">in
         <firstterm>find</firstterm> command</link></para></listitem>
      <listitem><para><link linkend="escpcb">in an
         <firstterm>Extended Regular
	 Expression</firstterm></link></para></listitem>
      <listitem><para><link linkend="xargscurlyref">in
         <firstterm>xargs</firstterm></link></para></listitem>
           </itemizedlist></para>

      

      <para><link linkend="daemonref">Daemons</link>, in UNIX-type OS</para>

      <para><link linkend="dateref">date</link></para>
      <para><link linkend="dcref">dc</link>, calculator utility</para>

      <para><link linkend="ddref">dd</link>, <firstterm>data
        duplicator</firstterm> command
	  <itemizedlist>

      <listitem><para><link linkend="ddconversions">Conversions</link></para></listitem>
      <listitem><para><link linkend="ddcopy">Copying raw data</link>
        to/from devices</para></listitem>
      <listitem><para><link linkend="ddfdel">File deletion</link>,
        <firstterm>secure</firstterm></para></listitem>
      <listitem><para><link linkend="ddkeystrokes">Keystrokes</link>, capturing</para></listitem>
      <listitem><para><link linkend="ddoptions">Options</link></para></listitem>
      <listitem><para><link linkend="ddrandom">Random access</link> on a data
        stream</para></listitem>
      <listitem><para><emphasis>Raspberry Pi</emphasis>,
      <link linkend="rpsdcard01">script for preparing a bootable SD
      card</link>
	</para></listitem>
      <listitem><para><link linkend="ddswap">Swapfiles</link>, initializing</para></listitem>
      <listitem><para><link linkend="ddlink">Thread on
        <firstterm>www.linuxquestions.org</firstterm></link></para></listitem>

	  </itemizedlist></para>

      <para><link linkend="debugging">Debugging scripts</link>
         <itemizedlist>
      <listitem><para><link linkend="debugtools">Tools</link></para></listitem>
      <listitem><para><link linkend="debugtrap"><firstterm>Trapping</firstterm> at
        exit</link></para></listitem>
      <listitem><para><link linkend="trapref1"><firstterm>Trapping</firstterm>
          signals</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="numconstants">Decimal number</link>,
         Bash interprets numbers as</para>

      <para><link linkend="declare1ref">declare</link> builtin</para>
         <itemizedlist>
      <listitem>
      <para><link linkend="declareopsref1">options</link></para>
      <para><link linkend="declarecasemod">case-modification</link>
        options (<link linkend="bash4ref">version 4+</link> of Bash)
	</para></listitem>
         </itemizedlist>

      <para><link linkend="defparam">Default parameters</link></para>

<!-- ******************************************************************* -->
      <para><link linkend="devprocref"><filename class="directory">/dev</filename></link> directory

         <itemizedlist>
      <listitem><para><link linkend="devnullref"><filename>/dev/null</filename></link>
           pseudo-device file</para></listitem>

      <listitem><para><link linkend="urandomref"><filename>/dev/urandom</filename></link>
         pseudo-device file, generating pseudorandom numbers
         with</para></listitem>

      <listitem><para><link linkend="zerosref1"><filename>/dev/zero</filename></link>,
         pseudo-device file</para></listitem>
         </itemizedlist></para>
<!-- ******************************************************************* -->


      <para><link linkend="devfileref">Device file</link></para>
      <para><link linkend="dialogref"><firstterm>dialog</firstterm></link>,
         utility for generating <firstterm>dialog</firstterm> boxes in
         a script</para>
      <para><link linkend="dirstackref"><varname>$DIRSTACK</varname></link>
         <firstterm>directory stack</firstterm></para>
      <para><link linkend="disabledcommref">Disabled commands</link>,
         in <firstterm>restricted shells</firstterm></para>
      <para><link linkend="doinref">do</link> keyword,
         begins execution of commands within a <link linkend="loopref00">loop</link></para>
      <para><link linkend="doinref">done</link> keyword,
         terminates a loop</para>
      <para><link linkend="dosbatch1"><firstterm>DOS</firstterm> batch
         files</link>, converting to shell scripts</para>
      <para><link linkend="dosunixequiv"><firstterm>DOS</firstterm>
        commands</link>, UNIX equivalents of
        (<command>table</command>)</para>
      <para><link linkend="dotfilesref"><firstterm>dot files</firstterm></link>,
         <quote>hidden</quote> setup and configuration files</para>

      <para><link linkend="dblbrackets">Double brackets</link>
         <command>[[ ... ]]</command> <link linkend="ifthen">test</link>
         construct</para>
         <itemizedlist>
      <listitem><para>and <link linkend="dblbraev">evaluation of
        <firstterm>octal/hex</firstterm> constants</link></para></listitem>
         </itemizedlist>

      <para><link linkend="dblparensref">Double parentheses</link>
      <command>(( ... )) </command> arithmetic expansion/evaluation
      construct</para>

      <para><link linkend="dblquo">Double quotes</link>
      <command>" ... "</command> <firstterm>weak</firstterm> quoting
	   <itemizedlist>
	     <listitem><para><link linkend="quotingbsl"><firstterm>Double-quoting</firstterm>
	       the <firstterm>backslash</firstterm> (<command>\</command>)
	       character</link></para></listitem>
	   </itemizedlist>
      </para>

      <para><link linkend="doublespace">Double-spacing a text
        file</link>, using <link linkend="sedref">sed</link></para>

      

      <para><command>-e </command>
        <link linkend="rtif">File exists</link> test</para>

      <para><link linkend="echoref">echo</link>
         <itemizedlist>
      <listitem><para><link linkend="echogrepref">Feeding commands down
        a <firstterm>pipe</firstterm></link></para></listitem>
      <listitem><para><link linkend="echocs">Setting a variable</link>
        using <link linkend="commandsubref">command
        substitution</link></para></listitem>
      <listitem><para><link linkend="binecho"><filename>/bin/echo</filename></link>,
	external <firstterm>echo</firstterm> command</para></listitem>
         </itemizedlist></para>

      <para><link linkend="elifref1">elif</link>,
        Contraction of <firstterm>else</firstterm>
        and <link linkend="ifthen">if</link></para>
      <para><link linkend="elseref">else</link></para>
      <para>Encrypting files, using <link linkend="opensslref">openssl</link></para>
      <para><link linkend="caseesac1">esac</link>, keyword terminating
        <firstterm>case</firstterm> construct</para>
      <para><link linkend="envref"><firstterm>Environmental</firstterm>
         variables</link></para>
      <para><link linkend="equalref"> -eq </link>,
         <firstterm>is-equal-to</firstterm> <link linkend="icomparison1">integer
	 comparison</link> test</para>
       <para><link linkend="primes0">Eratosthenes,
         Sieve of</link>, algorithm for generating prime numbers</para>

      <para><link linkend="spm">Escaped characters</link>,
         special meanings of
	 <itemizedlist>
	   <listitem><para>Within <link linkend="strq">$' ... '</link>
	   string expansion</para></listitem>
	   <listitem><para><link linkend="unicoderef2">Used with
	   <firstterm>Unicode</firstterm> characters</link></para></listitem>
          </itemizedlist>
	   </para>

      <para><link linkend="fstabref"><filename>/etc/fstab</filename></link>
        (filesystem mount) file</para>
      <para><link linkend="datafilesref1"><filename>/etc/passwd</filename></link>
        (user account) file</para>
      <para><link linkend="euidref"><varname>$EUID</varname></link>,
         <firstterm>Effective user ID</firstterm></para>

      <para><link linkend="evalref">eval</link>,
         Combine and <firstterm>evaluate</firstterm> expression(s),
	 with variable expansion
	 <itemizedlist>
      <listitem><para><link linkend="evaleff">Effects
        of</link>, <firstterm>Example script</firstterm></para></listitem>
      <listitem><para><link linkend="evalforced">Forces
        <firstterm>reevaluation</firstterm></link> of
	arguments</para></listitem>
      <listitem><para>And <link linkend="evalindref">indirect
      references</link></para></listitem>
      <listitem><para><link linkend="evalrisk">Risk of
        using</link></para></listitem>
      <listitem><para><link linkend="samorse">Using
        <firstterm>eval</firstterm> to convert <firstterm>array</firstterm>
	elements into a command list</link></para></listitem>
      <listitem><para><link linkend="arrchoice0">Using
        <firstterm>eval</firstterm> to select among
        variables</link></para></listitem>
	 </itemizedlist></para>

      <para><link linkend="dblbraev">Evaluation of
        <firstterm>octal/hex</firstterm> constants within
	[[ ... ]]</link></para>

      <para><link linkend="usingexecref">exec</link> command,
         using in <link linkend="ioredirref">redirection</link></para>

      <para><link linkend="exercises">Exercises</link></para>

<!-- ********************** -->
      <para>Exit and Exit status
        <itemizedlist>
      <listitem><para><link linkend="exitcommandref">exit</link>
         command</para></listitem>

      <listitem>
        <para><link linkend="exitstatusref">Exit status</link>
	  (<firstterm>exit code</firstterm>, <firstterm>return</firstterm>
	  status of a command)</para>
        <para><link linkend="exitcodesref"><command>Table</command></link>,
	  <firstterm>Exit
          codes</firstterm> with special meanings</para>
        <para>
          <link linkend="gotchaexitvalanamalies">Anomalous</link>
        </para>
        <para><link linkend="excoor">Out of range</link></para>
        <para><link linkend="pipeex"><firstterm>Pipe</firstterm></link>
	   exit status</para>
         <para><link linkend="exitreturn1">
           Specified by a <firstterm>function
           return</firstterm></link></para>
         <para><link linkend="exitsuccess"><firstterm>Successful</firstterm></link>,
	   <command>0</command></para>
         <para><link linkend="sysexitsref"><filename>/usr/include/sysexits.h</filename></link>,
	   system file listing C/C++ standard exit codes</para>
      </listitem>

        </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="exportref2">Export</link>,
         to make available variables to <link linkend="childref">child processes</link>
	 <itemizedlist>
      <listitem><para><link linkend="exportawk">Passing a variable
        to an embedded <firstterm>awk</firstterm>
	script</link></para></listitem>
	 </itemizedlist></para>

<!-- ********************** -->
      <para><link linkend="exprref">expr</link>,
         <firstterm>Expression</firstterm> evaluator
	   <itemizedlist>
      <listitem><para><link linkend="expextrsub">Substring
         extraction</link></para></listitem>
      <listitem><para><link linkend="substringindex2">Substring
         <firstterm>index</firstterm> (numerical position in
         string)</link></para></listitem>
      <listitem><para><link linkend="exprmatch">Substring
         matching</link></para></listitem>
	   </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="extregex">Extended <firstterm>Regular
         Expressions</firstterm></link>
	  <itemizedlist>
      <listitem><para><command>? </command> (question mark)
          <link linkend="quexregex">Match zero / one characters</link>
	  </para></listitem>
        <listitem><para><command>( ... ) </command>
          <link linkend="parengrps">Group
	  of expressions</link></para></listitem>
        <listitem><para><command>\{ N \}</command>
         <link linkend="escpcb"><quote>Curly</quote> brackets</link>,
         <firstterm>escaped</firstterm>,
	 number of character sets to match</para></listitem>
      <listitem><para><command>+ </command>
          <link linkend="plusref"><firstterm>Character
          match</firstterm></link></para></listitem>
	  </itemizedlist></para>

      

      <para><link linkend="factorref">factor</link>, decomposes an
        integer into its prime factors
	  <itemizedlist>
       <listitem><para>Application: <link linkend="primes2">Generating
            prime numbers</link></para></listitem>
	  </itemizedlist></para>

      <para><link linkend="falseref">false</link>,
        returns <firstterm>unsuccessful</firstterm> (1) <link linkend="exitstatusref">exit status</link></para>

      <para><link linkend="fieldref">Field</link>, a group of characters
        that comprises an item of data</para>

      <para><link linkend="filearchiv">Files / Archiving</link></para>

      <para><link linkend="fdref">File descriptors</link></para>
         <itemizedlist>
      <listitem><para><link linkend="cfd">Closing</link></para>

        <para><command>n&lt;&amp;-</command>
           Close input file descriptor <firstterm>n</firstterm></para>
        <para><command>0&lt;&amp;-</command>,
	   <command>&lt;&amp;-</command>
           Close <filename>stdin</filename></para>

        <para><command>n&gt;&amp;-</command>
          Close output file descriptor <firstterm>n</firstterm></para>
        <para><command>1&gt;&amp;-</command>,
	   <command>&gt;&amp;-</command>
	   Close <filename>stdout</filename></para>

      </listitem>

      <listitem><para><link linkend="fdref1">File handles in
        <firstterm>C</firstterm></link>, similarity to</para></listitem>

         </itemizedlist>


      <para><link linkend="opensslref">File encryption</link></para>

      <para><link linkend="findref">find</link>
         <itemizedlist>
      <listitem><para><command>{} </command>
        <link linkend="curlybracketsref">Curly
        brackets</link></para></listitem>
      <listitem><para><command>\; </command>
        <link linkend="findref0"><firstterm>Escaped</firstterm>
        semicolon</link></para></listitem>
	 </itemizedlist></para>

      <para><link linkend="filterdef">Filter</link>
         <itemizedlist>
      <listitem><para><link linkend="filterdash">Using <token>-</token>
        with file-processing utility as a filter</link></para></listitem>
      <listitem><para><link linkend="filteroutp">
         Feeding output of a filter back to <emphasis>same</emphasis>
	 filter</link></para></listitem>
	 </itemizedlist></para>

      <para><link linkend="nofloatingpoint">Floating point numbers</link>,
         Bash does not recognize</para>
      <para><link linkend="foldref">fold</link>, a filter to wrap lines of
        text</para>
      <para><link linkend="forkref">Forking</link> a <firstterm>child</firstterm>
         process</para>
      <para><link linkend="forloopref1"><firstterm>for</firstterm>
         loops</link></para>

      <para><link linkend="functionref">Functions</link></para>
         <itemizedlist>
      <listitem><para><link linkend="passedargs">Arguments
         passed</link> referred to by position</para></listitem>
      <listitem><para><link linkend="captureretval">Capturing
        the return value</link> of a function
	using <link linkend="echoref">echo</link></para></listitem>
      <listitem><para><link linkend="colonfname"><firstterm>Colon</firstterm></link>
	as function name</para></listitem>
      <listitem><para><link linkend="functdefmust">Definition
         must precede</link> first call to function</para></listitem>
      <listitem><para><link linkend="exitreturn1">Exit
         status</link></para></listitem>
      <listitem>
        <para><link linkend="localref1">Local variables</link></para>
        <para>and <link linkend="locvarrecur">recursion</link></para></listitem>

      <listitem><para><link linkend="passarray">Passing
        an <firstterm>array</firstterm></link> to a
        function</para></listitem>
      <listitem><para><link linkend="funcpointers">Passing pointers</link>
	 to a function</para></listitem>
      <listitem><para><link linkend="passedargs">Positional
         parameters</link></para></listitem>
      <listitem><para><link linkend="recursionref0">Recursion</link></para></listitem>
      <listitem><para><link linkend="redstdinfunc1">Redirecting
	 <filename>stdin</filename></link>
	 of a function</para></listitem>

      <listitem>
         <para><link linkend="returnref">return</link></para>
         <para>Multiple <firstterm>return values</firstterm> from
         a function,
	   <link linkend="stddev">example script</link></para>
         <para><link linkend="retarray">
           Returning an <firstterm>array</firstterm></link> from
	   a function</para>
         <para><link linkend="rvt"><firstterm>Return</firstterm>
           range limits</link>, workarounds</para>
      </listitem>

      <listitem><para><link linkend="fshiftref"><firstterm>Shift</firstterm>
	 arguments passed</link> to a function</para></listitem>
      <listitem><para><link linkend="fstrangeref">Unusual function
         names</link></para></listitem>
         </itemizedlist>

      

      <para>Games and amusements
        <itemizedlist>
	  <listitem><para><link linkend="agram">Anagrams</link></para></listitem>
	  <listitem><para><link linkend="agram2">Anagrams</link>, again</para></listitem>
	  <listitem><para><link linkend="bingo">Bingo Number Generator</link></para></listitem>
	  <listitem><para><link linkend="cwsolver">Crossword puzzle
	    solver</link></para></listitem>
	  <listitem><para><link linkend="cryptoquote">Crypto-Quotes</link></para></listitem>
	  <listitem><para><link linkend="cards">Dealing a deck of cards</link></para></listitem>
	  <listitem><para><link linkend="fifteen">Fifteen Puzzle</link></para></listitem>
	  <listitem><para><link linkend="horserace">Horse race</link></para></listitem>
	  <listitem><para><link linkend="ktour">Knight's Tour</link></para></listitem>
	  <listitem><para><link linkend="lifeslow"><quote>Life</quote>
	    game</link></para></listitem>
	  <listitem><para><link linkend="msquare">Magic Squares</link></para></listitem>
	  <listitem><para><link linkend="musicscr">Music-playing
	    script</link></para></listitem>
	  <listitem><para><link linkend="nim">Nim</link></para></listitem>
	  <listitem><para><link linkend="brownian">Pachinko</link></para></listitem>
	  <listitem><para><link linkend="qky">Perquackey</link></para></listitem>
	  <listitem><para><link linkend="petals">Petals Around the Rose</link></para></listitem>
	  <listitem><para><link linkend="bashpodder">Podcasting</link></para></listitem>
	  <listitem><para><link linkend="poem">Poem</link></para></listitem>
	  <listitem><para><link linkend="speech00">Speech
	    generation</link></para></listitem>
	  <listitem><para><link linkend="hanoi">Towers of Hanoi</link></para>
	    <para><link linkend="hanoi2">Graphic
	    version</link></para>
	    <para><link linkend="hanoi2a">Alternate graphic
	    version</link></para>
	    </listitem>
        </itemizedlist></para>

      <para><link linkend="getopty">getopt</link>,
        <firstterm>external</firstterm> command for parsing script
        <firstterm>command-line</firstterm> arguments
	   <itemizedlist>
       <listitem><para><link linkend="getoptsimple1">Emulated
         in a script</link></para></listitem>
	   </itemizedlist></para>

      <para><link linkend="getoptsx">getopts</link>,
        Bash <firstterm>builtin</firstterm> for parsing script
        <firstterm>command-line</firstterm> arguments
	   <itemizedlist>
       <listitem><para><link linkend="getoptsopt"><varname>$OPTIND</varname> /
         <varname>$OPTARG</varname></link></para></listitem>
	   </itemizedlist></para>

      <para><link linkend="scoperef">Global</link>
        variable</para>

      <para><link linkend="globbingref2">Globbing</link>,
         filename expansion
	   <itemizedlist>
         <listitem><para><link linkend="handlingfnames">Handling
	 filenames correctly</link></para></listitem>
         <listitem><para><link linkend="asteriskref"><firstterm>Wild
         cards</firstterm></link></para></listitem>
        <listitem><para><link linkend="wdotfilewc">Will not match
          <filename>dot files</filename></link></para></listitem>
	   </itemizedlist></para>

      <para><link linkend="goldenratio">Golden Ratio</link>
        (<firstterm>Phi</firstterm>)</para>

      <para><link linkend="ge0ref"> -ge </link>,
         <firstterm>greater-than or equal</firstterm>
	 <link linkend="icomparison1">integer comparison</link> test</para>
      <para><link linkend="gt0ref"> -gt </link>,
         <firstterm>greater-than</firstterm> <link linkend="icomparison1">integer
	 comparison</link> test</para>
      <para><link linkend="groffref"><firstterm>groff</firstterm></link>,
        text markup and formatting language</para>
      <para><link linkend="gronsfeld">Gronsfeld cipher</link></para>
      <para><link linkend="groupsref"><varname>$GROUPS</varname></link>,
         <firstterm>Groups</firstterm> user belongs to</para>
      <para><link linkend="gzipref">gzip</link>, compression utility</para>

      

      <para><link linkend="hashref">Hashing</link>, creating lookup keys
         in a table
	   <itemizedlist>
	 <listitem><para><link linkend="hashex2_0"><firstterm>Example
	   script</firstterm></link></para></listitem>
	   </itemizedlist></para>

      <para><link linkend="headref">head</link>, <firstterm>echo</firstterm>
        to <filename>stdout</filename> lines at the beginning of a text
        file</para>
      <para><link linkend="helpref">help</link>, gives usage summary of
        a Bash <link linkend="builtinref">builtin</link></para>

<!-- ********************** -->
      <para><link linkend="heredocref"><firstterm>Here</firstterm>
         documents</link>

	 <itemizedlist>

      <listitem>
        <para><link linkend="anonheredoc0"><firstterm>Anonymous</firstterm>
           here documents</link>, using <command>:</command></para>
        <para><link linkend="cblock1">Commenting out</link>
	   blocks of code</para>
        <para><link linkend="hselfdoc">Self-documenting</link>
	   scripts</para>
      </listitem>
      <listitem><para><link linkend="bcheredoc"><firstterm>bc</firstterm> in a <firstterm>here
        document</firstterm></link></para></listitem>

      <listitem><para><link linkend="catscriptref"><firstterm>cat</firstterm>
         scripts</link></para></listitem>
      <listitem><para><link linkend="herecs">Command
         substitution</link></para></listitem>
      <listitem><para><link linkend="exscriptref"><firstterm>ex</firstterm>
         scripts</link></para></listitem>
      <listitem><para><link linkend="herefunc"><firstterm>Function</firstterm></link>,
	 supplying input to</para></listitem>

      <listitem>
        <para><link linkend="herestringsref"><firstterm>Here</firstterm>
           strings</link></para>
        <para>Calculating the <link linkend="goldenratio">Golden
          Ratio</link></para>
        <para><link linkend="hspre">Prepending text</link></para>
        <para><link linkend="hsloop">As the <filename>stdin</filename> of a
	  <firstterm>loop</firstterm></link></para>
        <para><link linkend="hsread">Using
	   <firstterm>read</firstterm></link></para>
      </listitem>

      <listitem><para><link linkend="limitstringref"><firstterm>Limit</firstterm>
      string</link></para>
         <para><link linkend="exclls"><token>!</token> as a
         <firstterm>limit string</firstterm></link></para>
         <para><link linkend="indentedls">Closing <firstterm>limit
            string</firstterm></link> may not be indented</para>
         <para><link linkend="limitstrdash">Dash option</link>
           to limit string, <option>&lt;&lt;-LimitString</option>
           </para></listitem>
      <listitem><para><link linkend="herelit">Literal
         text output</link>,
	 for generating program code</para></listitem>

      <listitem>
         <para><link linkend="hereparamsub">Parameter
           substitution</link></para>
	 <para><link linkend="hereesc">Disabling</link>
	   <firstterm>parameter substitution</firstterm></para>
      </listitem>

      <listitem><para><link linkend="herepassp">Passing
         parameters</link></para></listitem>
      <listitem><para><link linkend="heretemp">Temporary
         files</link></para></listitem>
      <listitem><para><link linkend="vihere">Using
        <firstterm>vi</firstterm> non-interactively</link></para></listitem>
	 </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="histcommands">History commands</link></para>

      <para><link linkend="homedirref"><varname>$HOME</varname></link>,
         <firstterm>user's home directory</firstterm></para>
      <para><link linkend="homework">Homework assignment solver</link></para>
      <para><link linkend="hostnameref"><varname>$HOSTNAME</varname></link>,
        system <firstterm>host name</firstterm></para>

      

<!-- ********************** -->
      <para><link linkend="rcsref"><varname>$Id</varname>
        parameter</link>, in <firstterm>rcs</firstterm> (Revision Control
	System)</para>

      <para><link linkend="ifthen">if [ condition ]; then ...</link>
         <firstterm>test</firstterm> construct
	 <itemizedlist>

      <listitem>
        <para><link linkend="ifgrepref">if-grep</link>,
          <firstterm>if</firstterm> and <link linkend="grepref">grep</link>
          in combination</para>
        <para><link linkend="ifgrepfix">Fixup</link>
          for <firstterm>if-grep</firstterm> test</para>
      </listitem>

         </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="ifsref"><varname>$IFS</varname></link>,
         <firstterm>Internal field separator</firstterm> variable
	   <itemizedlist>
      <listitem><para><link linkend="ifsws">Defaults to
        <firstterm>whitespace</firstterm></link></para></listitem>
	   </itemizedlist></para>

      <para><link linkend="icomparison1">Integer comparison
         operators</link></para>
      <para><link linkend="doinref">in</link>,
         <firstterm>keyword</firstterm> preceding
         <varname>[list]</varname> in a <firstterm>for</firstterm>
         loop</para>
      <para><link linkend="inittabref">Initialization table</link>,
         <filename>/etc/inittab</filename></para>
      <para><link linkend="codeblockref">Inline group</link>,
        i.e., code block</para>
      <para><link linkend="iitest">Interactive script</link>, test for</para>
      <para><link linkend="ioredirref">I/O redirection</link></para>

<!-- ********************** -->
      <para><link linkend="ivrref">Indirect referencing of variables</link>
         <itemizedlist>
      <listitem><para><link linkend="ivr2">New notation</link>, introduced
         in <link linkend="bash2ref">version 2</link> of Bash (<link linkend="varrefnew"> example script</link>)</para></listitem>
         </itemizedlist></para>
<!-- ********************** -->


      <para><link linkend="iptablesref">iptables</link>,
        packet filtering and firewall utility
         <itemizedlist>
      <listitem><para><link linkend="iptables01">Usage
        example</link></para></listitem>
      <listitem><para><link linkend="iptables02">Example
        script</link></para></listitem>
         </itemizedlist></para>


      <para><link linkend="iterationref">Iteration</link></para>

      


      <para><link linkend="jobidtable0">Job IDs</link>, table</para>
      <para><link linkend="jotref">jot</link>,
        Emit a sequence of integers. Equivalent to <link linkend="seqref">seq</link>.
	  <itemizedlist>
       <listitem><para><link linkend="jotrandom">Random sequence
         generation</link></para></listitem>
         </itemizedlist></para>
      <para><link linkend="jabh">Just another Bash hacker!</link></para>

      

      <para><link linkend="keywordref">Keywords</link>
	  <itemizedlist>
      <listitem><para><link linkend="missingkeyword">error</link>,
        if missing</para></listitem>
	  </itemizedlist></para>

      <para><link linkend="killref">kill</link>,
        terminate a process by <link linkend="processiddef">process ID</link>
	  <itemizedlist>
      <listitem><para><link linkend="zombieref">Options</link> (<option>-l</option>,
	<option>-9</option>)</para></listitem>
         </itemizedlist></para>

      <para><link linkend="killallref">killall</link>,
        terminate a process <emphasis>by name</emphasis></para>
      <para><link linkend="killall2ref"><firstterm>killall
         script</firstterm></link> in <filename class="directory">/etc/rc.d/init.d</filename></para>

      

      <para><link linkend="lastpiperef">lastpipe</link> shell
        option</para>

      <para><link linkend="le0ref"> -le </link>,
         <firstterm>less-than or equal</firstterm>
	 <link linkend="icomparison1">integer comparison</link> test</para>

      <para><link linkend="letref">let</link>,
        setting and carrying out arithmetic operations on variables
        <itemizedlist>
      <listitem><para><firstterm>C-style</firstterm>
        <link linkend="ex46">increment and decrement
        operators</link></para></listitem>
        </itemizedlist></para>

      <para><link linkend="limitstringref">Limit string</link>,
         in a <link linkend="heredocref">here document</link></para>
      <para><link linkend="linenoref"><varname>$LINENO</varname></link>,
         variable indicating the <firstterm>line number</firstterm> where
         it appears in a script</para>

      <para><link linkend="linkref">Link</link>, file
         (using <firstterm>ln</firstterm> command)
	     <itemizedlist>
        <listitem><para><link linkend="linkminvok">Invoking script with multiple names</link>,
          using <firstterm>ln</firstterm></para></listitem>
        <listitem><para><link linkend="symlinkref"><firstterm>symbolic</firstterm>
	  links</link>, <firstterm>ln -s </firstterm></para></listitem>
             </itemizedlist></para>

      <para><link linkend="listconsref">List constructs</link>
        <itemizedlist>

      <listitem><para><link linkend="lcons1"><firstterm>And</firstterm>
        list</link></para></listitem>
      <listitem><para><link linkend="orlistref"><firstterm>Or</firstterm>
        list</link></para></listitem>
        </itemizedlist></para>

      <para><link linkend="localref1">Local variables</link>
         <itemizedlist>
      <listitem><para>and <link linkend="locvarrecur">recursion</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="localization">Localization</link></para>

      <para><link linkend="logops1">Logical operators</link>
         (<varname>&amp;&amp;</varname>, <varname>||</varname>,
         etc.)</para>
      <para><link linkend="logoutfileref1">Logout file</link>,
         the <filename>~/.bash_logout</filename> file</para>
      <para><link linkend="isomountref0">Loopback device</link>,
         mounting a file on a <link linkend="blockdevref">block
	 device</link></para>


      <para><link linkend="loops1">Loops</link>
        <itemizedlist>

      <listitem><para><link linkend="brkcont1">break</link>
         loop control command</para></listitem>
      <listitem><para><link linkend="brkcont1">continue</link> loop
        control command</para></listitem>

      <listitem>
        <para><firstterm>C</firstterm>-style
	loop within <link linkend="dblparensref">double
	parentheses</link></para>
	<para><link linkend="loopcstyle"><firstterm>for</firstterm> loop</link></para>
	<para><link linkend="wloopcstyle"><firstterm>while</firstterm> loop</link></para>
	</listitem>

      <listitem><para><link linkend="doinref">do</link> (keyword),
         begins execution of commands within a loop</para></listitem>
      <listitem><para><link linkend="doinref">done</link> (keyword),
         terminates a loop</para></listitem>

      <listitem>
        <para><link linkend="forloopref1"><firstterm>for</firstterm>
           loops</link></para>
        <para><replaceable>for</replaceable> <varname>arg</varname>
          <replaceable>in</replaceable> <varname>[list]</varname>;
          <replaceable>do</replaceable></para>

        <para><link linkend="loopcs"><firstterm>Command
	  substitution</firstterm> to generate
	  <varname>[list]</varname></link></para>
        <para><link linkend="liglob">Filename expansion
	  in <varname>[list]</varname></link></para>
        <para><link linkend="multparaml">Multiple parameters
	  in each <varname>[list]</varname> element</link></para>
        <para><link linkend="omitlist">Omitting
	  <varname>[list]</varname></link>, defaults to
	  <link linkend="posparamref">positional parameters</link></para>
        <para><link linkend="paramli">Parameterizing
	   <varname>[list]</varname></link></para>
      <para><link linkend="loopredir">Redirection</link></para>
      </listitem>

      <listitem><para><link linkend="doinref">in</link>,
         (keyword) preceding [list] in a
         <firstterm>for</firstterm> loop</para></listitem>
      <listitem><para><link linkend="nestedloops">Nested
         loops</link></para></listitem>
      <listitem><para><link linkend="bgloop0">Running a
         loop <emphasis>in the background</emphasis></link>,
	 <firstterm>script example</firstterm></para></listitem>

      <listitem>
        <para>Semicolon required, when <firstterm>do</firstterm> is on first line
	  of loop</para>
	<para><link linkend="needsemicolon"><firstterm>for</firstterm>
	  loop</link></para>
	<para><link linkend="whileneedsemi"><firstterm>while</firstterm>
	  loop</link></para>
      </listitem>

      <listitem><para><link linkend="untilloopref">until</link> loop</para>
         <para><replaceable>until [ condition-is-true ]; do</replaceable>
	 </para></listitem>

      <listitem><para><link linkend="whileloopref">while</link>
        loop</para>
	<para><replaceable>while [ condition ]; do</replaceable></para>

	<para><link linkend="whilefunc">Function call</link>
	  inside test brackets</para>
	<para><link linkend="whmultcond">Multiple conditions</link></para>
	<para><link linkend="whilenobrackets">Omitting <firstterm>test
	  brackets</firstterm></link></para>
        <para><link linkend="whredir">Redirection</link></para>
        <para><link linkend="whilereadref2">
         <firstterm>while read</firstterm></link> construct</para>
	</listitem>

      <listitem><para><link linkend="chooseloop">Which type of loop to
        use</link></para></listitem>

        </itemizedlist></para>


      <para>Loopback devices
         <itemizedlist>
      <listitem><para><link linkend="loopbackref">In <filename class="directory">/dev</filename> directory</link></para></listitem>
      <listitem><para><link linkend="isomountref0">Mounting an ISO image</link></para></listitem>
      </itemizedlist></para>


      <para><link linkend="lt0ref"> -lt </link>,
         <firstterm>less-than</firstterm> <link linkend="icomparison1">integer
	 comparison</link> test</para>

      

      <para><link linkend="m4ref">m4</link>, macro processing language</para>
      <para><link linkend="machtyperef"><varname>$MACHTYPE</varname></link>,
         <firstterm>Machine type</firstterm></para>
      <para><link linkend="magnumref">Magic number</link>,
         marker at the head of a file indicating the file type</para>
      <para><link linkend="makefileref"><filename>Makefile</filename></link>,
         file containing the list of dependencies used by <link linkend="makeref">make</link> command</para>

      <para><link linkend="manref">man</link>, <firstterm>manual
        page</firstterm> (lookup)
         <itemizedlist>
      <listitem><para><link linkend="maned"><firstterm>Man page</firstterm>
         editor</link> (script)</para></listitem>
         </itemizedlist>
      </para>

      <para><link linkend="mapfileref">mapfile</link> builtin,
        loads an array with a text file</para>
      <para><link linkend="mathc">Math commands</link></para>
      <para><link linkend="metameaningref">Meta-meaning</link></para>

      <para><link linkend="samorse">Morse code training</link> script</para>

      <para><link linkend="moduloref">Modulo</link>, arithmetic
         <firstterm>remainder</firstterm> operator
	    <itemizedlist>
          <listitem><para>Application: <link linkend="primes1">Generating
            prime numbers</link></para></listitem>
	    </itemizedlist></para>
      <para><link linkend="monthlypmt0">Mortgage calculations</link>,
        <firstterm>example script</firstterm></para>

      

      <para><command>-n </command>
        <link linkend="stringnotnull">String not
        <firstterm>null</firstterm></link> test</para>
      <para><link linkend="namedpiperef">Named pipe</link>, a temporary
         FIFO buffer
	 <itemizedlist>
      <listitem><para><link linkend="zfifo"><firstterm>Example
         script</firstterm></link></para></listitem>
	 </itemizedlist></para>

      <para><link linkend="ncref">nc</link>, <firstterm>netcat</firstterm>,
        a network toolkit for TCP and UDP ports</para>
      <para><link linkend="nequalref">-ne</link>,
         <firstterm>not-equal-to</firstterm> <link linkend="icomparison1">integer comparison</link> test</para>
      <para><link linkend="notref">Negation operator</link>,
         <command>!</command>, reverses the sense of a <link linkend="ifthen">test</link></para>
      <para><link linkend="netstatref">netstat</link>, Network
         statistics</para>
      <para><link linkend="networkprogramming">Network programming</link></para>
      <para><link linkend="nlref">nl</link>, a filter to number lines of
        text</para>
      <para><link linkend="noclobberref"><firstterm>Noclobber</firstterm></link>,
         <option>-C</option> option to Bash to prevent overwriting
         of files</para>
      <para><link linkend="logops1"><firstterm>NOT</firstterm> logical
        operator</link>, <command>!</command></para>
      <para><link linkend="nullvar"><firstterm>null</firstterm> variable
        assignment</link>, avoiding</para>

      

      <para><command>-o </command>
        <link linkend="compoundor">Logical OR</link>
	compound comparison test</para>
       
       <para>Obfuscation
         <itemizedlist>
      <listitem><para><link linkend="colonfname"><firstterm>Colon</firstterm></link>
	as function name</para></listitem>
      <listitem><para><link linkend="homework">Homework assignment</link></para></listitem>
      <listitem><para><link linkend="jabh">Just another Bash
        hacker!</link></para>
        </listitem>
         </itemizedlist>
	 </para>

      <para><link linkend="octalref">octal</link>, base-8 numbers</para>
      <para><link linkend="odref">od</link>, <firstterm>octal
        dump</firstterm></para>
      <para><link linkend="oldpwd"><varname>$OLDPWD</varname></link>
         Previous working directory</para>

      <para><link linkend="opensslref">openssl</link> encryption
        utility</para>
      <para>Operator
         <itemizedlist>
      <listitem><para><link linkend="operatordef">Definition
        of</link></para></listitem>
      <listitem><para><link linkend="opprecedence1">Precedence</link></para></listitem>
         </itemizedlist></para>
      <para><link linkend="optionsref">Options</link>,
         passed to shell or script on command line or by <link linkend="setref">set</link> command</para>
      <para><link linkend="orlistref"><firstterm>Or</firstterm>
        list</link></para>
      <para><link linkend="orref"><firstterm>Or</firstterm> logical
        operator</link>, <command>||</command></para>

      


<!-- ********************** -->
      <para><link linkend="paramsubref">Parameter
         substitution</link>
	   <itemizedlist>

      <listitem>
        <para><firstterm>${parameter+alt_value}</firstterm></para>
	<para><firstterm>${parameter:+alt_value}</firstterm></para>
        <para><link linkend="paramaltv">Alternate value</link>
          of parameter, if set</para>
      </listitem>
      <listitem>
        <para><firstterm>${parameter-default}</firstterm></para>
	<para><firstterm>${parameter:-default}</firstterm></para>
        <para><firstterm>${parameter=default}</firstterm></para>
	<para><firstterm>${parameter:=default}</firstterm></para>
      <para><link linkend="defparam1">Default
        parameters</link></para></listitem>
      <listitem>
        <para><firstterm>${!varprefix*}</firstterm></para>
        <para><firstterm>${!varprefix@}</firstterm></para>
      <para><link linkend="varprefixm">Parameter
        <emphasis>name</emphasis> match</link></para>
      </listitem>
      <listitem>
	 <para><firstterm>${parameter?err_msg}</firstterm></para>
         <para><link linkend="qerrmsg">Parameter-unset message</link></para>
      </listitem>
      <listitem>
        <para><firstterm>${parameter}</firstterm></para>
        <para><link linkend="pssub1">Value of
	<firstterm>parameter</firstterm></link></para>
      </listitem>

      <listitem><para><link linkend="casemodparamsub">
        <firstterm>Case modification</firstterm></link>
	(<link linkend="bash4ref">version 4+</link> of
	Bash).</para></listitem>

      <listitem><para><link linkend="pw0"><firstterm>Script
        example</firstterm></link></para></listitem>
      <listitem><para><link linkend="parsubtab"><command>Table</command></link>
        of <firstterm>parameter
        substitution</firstterm></para></listitem>

	   </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="parchildprobref">Parent / child process
         problem</link>, a <firstterm>child</firstterm> process cannot
         <link linkend="exportref">export</link> variables to a <link linkend="forkref">parent process</link></para>

<!-- ********************** -->
      <para>Parentheses
         <itemizedlist>
      <listitem><para><link linkend="parensref">Command
         group</link></para></listitem>
      <listitem><para><link linkend="parengrps">Enclose group</link>
	 of <firstterm>Extended Regular
	 Expressions</firstterm></para></listitem>
      <listitem><para><link linkend="dblparensref">Double parentheses</link>,
         in arithmetic expansion</para></listitem>
         </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="pathref"><varname>$PATH</varname></link>,
         the <firstterm>path</firstterm> (location of system
         binaries)
         <itemizedlist>
      <listitem><para>Appending directories to <varname>$PATH</varname>
      <link linkend="pathappend">using the <varname>+=</varname>
        operator</link>.</para></listitem>
         </itemizedlist></para>

      <para><link linkend="pathnameref">Pathname</link>,
        a <filename>filename</filename> that incorporates the complete
	<firstterm>path</firstterm> of a given file.
         <itemizedlist>
      <listitem><para><link linkend="pathmanagement">Parsing
      <firstterm>pathnames</firstterm></link></para></listitem>
         </itemizedlist></para>
	
      <para><link linkend="perlref">Perl</link>, programming language
         <itemizedlist>
      <listitem><para><link linkend="bashandperl0">Combined</link> in the
        same file with a <firstterm>Bash</firstterm> script</para></listitem>
      <listitem><para><link linkend="perlemb">Embedded</link> in a
        <firstterm>Bash</firstterm> script</para></listitem>
         </itemizedlist></para>

      <para><link linkend="qky"><emphasis>Perquackey</emphasis>-type
        anagramming game</link> (<emphasis>Quackey</emphasis> script)</para>

      <para><link linkend="petals"><emphasis>Petals Around the
        Rose</emphasis></link></para>

      <para><link linkend="processiddef">PID</link>,
        <firstterm>Process ID</firstterm>, an identification
	number assigned to a running process.</para>

<!-- ********************** -->
      <para><link linkend="piperef">Pipe</link>, <command>| </command>,
         a device for passing the output of a command to another command
         or to the shell

	   <itemizedlist>
      <listitem><para><link linkend="catabuse">Avoiding
        unnecessary commands</link> in a
        <firstterm>pipe</firstterm></para></listitem>
      <listitem><para><link linkend="comminpipe"><firstterm>Comments</firstterm> embedded
	within</link></para></listitem>
      <listitem><para><link linkend="pipeex">Exit status</link>
         of a pipe</para></listitem>
      <listitem><para><link linkend="pipefailref">Pipefail</link>,
         <firstterm>set -o pipefail</firstterm>
         option to indicate <link linkend="exitstatusref">exit status</link>
         within a <firstterm>pipe</firstterm></para></listitem>
      <listitem><para><link linkend="pipestatusref"><varname>$PIPESTATUS</varname></link>,
	<firstterm>exit status</firstterm> of last executed
	pipe</para></listitem>
      <listitem><para><link linkend="ucref">Piping output of a command</link>
         to a script</para></listitem>
      <listitem><para><link linkend="catlesseff">Redirecting
        <filename>stdin</filename></link>, rather than using
	<link linkend="catref">cat</link> in a
	<firstterm>pipe</firstterm></para></listitem>
	   </itemizedlist></para>
<!-- ********************** -->

      <para><link linkend="gotchas">Pitfalls</link>
         <itemizedlist>

      <listitem><para><link linkend="dashnredr"><command>-</command>
        (dash) is <emphasis>not</emphasis> redirection
        operator</link></para></listitem>
      <listitem><para><link linkend="doubleslashref"><command>//
        </command> (double forward slash)</link>, behavior of <link linkend="cdref">cd</link> command toward</para></listitem>
      <listitem><para><link linkend="binsh"><token>#!/bin/sh</token></link>
	script header disables <link linkend="bashcompat">extended <firstterm>Bash</firstterm> 
	features</link></para></listitem>
      <listitem><para><link linkend="catabuse">Abuse of
        <firstterm>cat</firstterm></link></para></listitem>
      <listitem><para><link linkend="cgiref"><firstterm>CGI</firstterm>
        programming</link>, using scripts for</para></listitem>
      <listitem><para>Closing <firstterm>limit string</firstterm>
        in a <firstterm>here document</firstterm>,
      <link linkend="indentedls">indenting</link></para></listitem>
      <listitem><para><link linkend="dosnewlines">DOS-type newlines
        (<token>\r\n</token>)</link> crash a script</para></listitem>
      <listitem><para><link linkend="quotingbsl"><firstterm>Double-quoting</firstterm>
        the <firstterm>backslash</firstterm> (<command>\</command>)
        character</link></para></listitem>
      <listitem><para><link linkend="evalrisk">eval</link>, risk of
        using</para></listitem>
      <listitem><para><link linkend="execperm">Execute permission
        lacking</link> for commands within a script</para></listitem>

      <listitem><para>
      <firstterm>Exit status</firstterm>,
      <link linkend="gotchaexitvalanamalies">anomalous</link>
      </para></listitem>

      <listitem><para>
      <firstterm>Exit status</firstterm>
      <link linkend="arxs1">of arithmetic expression <emphasis>not</emphasis>
      equivalent to an <firstterm>error code</firstterm></link>
      </para></listitem>

      <listitem><para><link linkend="parchildprobref"><firstterm>Export</firstterm>
         problem</link>, <firstterm>child</firstterm> process
	 to <firstterm>parent</firstterm> process</para></listitem>
      <listitem><para><link linkend="lateverf">Extended
        <firstterm>Bash</firstterm> features</link> not
	available</para></listitem>
      <listitem><para><link linkend="failquote">Failing to
        <firstterm>quote</firstterm> variables</link>
	within <firstterm>test</firstterm> brackets</para></listitem>
      <listitem><para><link linkend="gnuref"><firstterm>GNU</firstterm>
         command set</link>, in cross-platform scripts</para></listitem>
      <listitem><para><firstterm>let</firstterm> misuse:
         <link linkend="letbad">attempting to set string variables</link>
	 </para></listitem>
      <listitem><para><link linkend="rvtcaution2">Multiple echo
        statements</link> in a <link linkend="rvt">function whose
	output is captured</link></para></listitem>
      <listitem><para><link linkend="nullvar"><firstterm>null</firstterm>
        variable assignment</link></para></listitem>
      <listitem>
        <para><link linkend="numstrcompne">Numerical and string
          comparison operators</link> <emphasis>not</emphasis>
          equivalent</para>
        <para><link linkend="eqdif"><command>=</command>
          and <command>-eq</command></link> <emphasis>not</emphasis>
	  interchangeable</para>
      </listitem>
      <listitem><para><link linkend="omitsemicolon">Omitting
         terminal <firstterm>semicolon</firstterm></link>,
	 in a <firstterm>curly-bracketed</firstterm> <link linkend="codeblockref">code block</link></para></listitem>
      <listitem>
        <para>Piping</para>
        <para><link linkend="pipeloop"><firstterm>echo</firstterm>
	   to a loop</link></para>
        <para><link linkend="badread0"><firstterm>echo</firstterm>
	   to <firstterm>read</firstterm></link> (however, this problem
	   <link linkend="goodread0">can be circumvented</link>)</para>

        <para><link linkend="ptailgrep"><firstterm>tail</firstterm>
	   <option>-f</option> to <firstterm>grep</firstterm></link></para>
      </listitem>
      <listitem><para>Preserving <firstterm>whitespace</firstterm>
        within a variable, <link linkend="varsplitting">unintended
	consequences</link></para></listitem>
      <listitem><para><link linkend="suidscr"><firstterm>suid</firstterm>
           commands inside a script</link></para></listitem>
      <listitem><para><link linkend="undocf">Undocumented
        <firstterm>Bash</firstterm> features</link>,
	danger of</para></listitem>
      <listitem><para>Updates to <firstterm>Bash</firstterm>
        <link linkend="updatebreaks">breaking older
        scripts</link></para></listitem>
      <listitem><para><link linkend="uninitvar">Uninitialized
         variables</link></para></listitem>
      <listitem><para><link linkend="inappvn">Variable names</link>,
         inappropriate</para></listitem>
      <listitem><para><link linkend="varsubsh">Variables in a
        <firstterm>subshell</firstterm></link>, <firstterm>scope</firstterm>
	limited</para></listitem>
      <listitem><para><link linkend="badread0">Subshell in <firstterm>while-read</firstterm>
	loop</link></para></listitem>
      <listitem><para><link linkend="wsbad">Whitespace</link>,
         misuse of</para></listitem>

	   </itemizedlist></para>

<!-- ********************** -->
    <para>Pointers</para>
         <itemizedlist>
      <listitem><para><link linkend="fdref1">and file descriptors</link></para></listitem>
      <listitem><para><link linkend="funcpointers">and functions</link></para></listitem>
      <listitem><para><link linkend="irrref">and <firstterm>indirect
         references</firstterm></link></para></listitem>
      <listitem><para><link linkend="pointerref">and
         <firstterm>variables</firstterm></link></para></listitem>
         </itemizedlist>
<!-- ********************** -->


      <para><link linkend="portabilityissues">Portability issues</link>
        in shell scripting
	   <itemizedlist>
      <listitem><para><link linkend="setpum">Setting <firstterm>path</firstterm>
	  and <firstterm>umask</firstterm></link></para></listitem>
      <listitem><para><link linkend="testsuite0">A <firstterm>test suite</firstterm>
	  script</link> (Bash versus classic Bourne
	  shell)</para></listitem>
      <listitem><para><link linkend="whatisref3">Using <firstterm>whatis</firstterm></link>
	  </para></listitem>
	   </itemizedlist></para>

<!-- *************************************************************** -->
      <para><link linkend="posparamref1">Positional parameters</link>

	   <itemizedlist>
      <listitem><para><link linkend="appref2"><varname>$@</varname></link>,
      as <firstterm>separate</firstterm> words</para></listitem>
      <listitem><para><link linkend="appref"><varname>$*</varname></link>,
      as a <firstterm>single</firstterm> word</para></listitem>
      <listitem><para><link linkend="passedargs">in
        functions</link></para></listitem>
	   </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="posix2ref"><acronym>POSIX</acronym></link>,
         <firstterm>Portable Operating System Interface /
         UNIX</firstterm>

         <itemizedlist>
      <listitem><para><link linkend="posix3ref"><option>--posix</option>
        option</link></para></listitem>
      <listitem><para><link linkend="posix3ref">1003.2 standard</link></para></listitem>
      <listitem><para><link linkend="posixref">Character
         classes</link></para></listitem>
         </itemizedlist></para>



      <para><link linkend="ppidref"><varname>$PPID</varname></link>,
         <firstterm>process ID</firstterm> of parent process</para>
        <para><link linkend="opprecedence1">Precedence</link>, operator</para>
         <para><link linkend="prependref"><firstterm>Prepending</firstterm></link>
         lines at head of a file, <firstterm>script
         example</firstterm></para>


       <para>Prime numbers
          <itemizedlist>
       <listitem><para>Generating primes
         <link linkend="primes2">using the <firstterm>factor</firstterm>
         command</link></para></listitem>
       <listitem><para>Generating primes
         <link linkend="primes1">using the <firstterm>modulo</firstterm>
         operator</link></para></listitem>
       <listitem><para>Sieve of Eratosthenes, <link linkend="primes0">example script</link></para></listitem>
          </itemizedlist></para>

      <para><link linkend="printfref">printf</link>,
        <firstterm>formatted print</firstterm> command</para>
      <para><link linkend="procref2"><filename class="directory">/proc</filename></link> directory
          <itemizedlist>
      <listitem><para><link linkend="procrunning">Running processes</link>,
        files describing</para></listitem>
      <listitem><para><link linkend="procwarning">Writing to
        files in <filename class="directory">/proc</filename></link>,
	<emphasis>warning</emphasis></para></listitem>
           </itemizedlist></para>

<!-- *************************************************************** -->
      <para><link linkend="processref">Process</link>
         <itemizedlist>
      <listitem><para><link linkend="childref2">Child
        process</link></para></listitem>
      <listitem><para><link linkend="parentref">Parent
        process</link></para></listitem>
      <listitem><para><link linkend="processiddef">Process
      ID</link> (PID)</para></listitem>
         </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="processsubref">Process substitution</link>
         <itemizedlist>
      <listitem><para><link linkend="pcc2dir">To compare contents of
           directories</link></para></listitem>
      <listitem><para><link linkend="psfdstdin">To supply <filename>stdin</filename> of a
         command</link></para></listitem>
      <listitem><para><link linkend="commandsparens1">Template</link></para></listitem>
      <listitem><para><link linkend="goodread0"><firstterm>while-read</firstterm> loop
	 without a
	 <firstterm>subshell</firstterm></link></para></listitem>
         </itemizedlist></para>
<!-- *************************************************************** -->
      <para><link linkend="tabexpansion">Programmable completion</link>
        (tab expansion)</para>
      <para>Prompt

         <itemizedlist>

      <listitem><para><link linkend="ps1ref"><varname>$PS1</varname></link>, <firstterm>Main
         prompt</firstterm>, seen at command
         line</para></listitem>

      <listitem><para><link linkend="secpromptref"><varname>$PS2</varname></link>,
         Secondary prompt</para></listitem>
         </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="pseudocoderef">Pseudo-code</link>,
         as problem-solving method</para>
      <para><link linkend="pwdref"><varname>$PWD</varname></link>,
         Current working directory</para>

      

      <para><link linkend="qky">Quackey</link>, a
        <emphasis>Perquackey</emphasis>-type anagramming game (script)</para>

      <para>Question mark, <command>? </command>
         <itemizedlist>
           <listitem><para><link linkend="quexregex">Character
             match</link> in an Extended <firstterm>Regular
             Expression</firstterm></para></listitem>
           <listitem><para><link linkend="quexwc">Single-character
	     <firstterm>wild card</firstterm></link>,
	     in <link linkend="globbingref">globbing</link></para></listitem>
           <listitem><para>In a
              <link linkend="cstrinary"><firstterm>C</firstterm>-style
              Trinary (ternary) operator</link></para></listitem>
         </itemizedlist></para>

<!-- *************************************************************** -->
      <para><link linkend="quotingdef">Quoting</link>
        <itemizedlist>
      
      <listitem><para><link linkend="quotingref">Character
        string</link></para></listitem>

      <listitem><para><link linkend="quotingvar">Variables</link></para>
        <para><link linkend="failquote">within <firstterm>test</firstterm>
          brackets</link></para></listitem>

        <listitem><para><link linkend="wsquo"><firstterm>Whitespace</firstterm></link>,
	  using <firstterm>quoting</firstterm> to
	  preserve</para></listitem>

        </itemizedlist></para>
<!-- *************************************************************** -->

      

<!-- *************************************************************** -->
      <para>Random numbers

         <itemizedlist>

      <listitem><para><link linkend="urandomref"><filename>/dev/urandom</filename></link>
	</para></listitem>

      <listitem><para><link linkend="awkrandomref">
         <varname>rand()</varname></link>,
	 random function in <link linkend="awkref">awk</link></para></listitem>

      <listitem><para><link linkend="randomvar01"><varname>$RANDOM</varname></link>, Bash
        function that returns a pseudorandom integer</para></listitem>

      <listitem><para><link linkend="daterandref">Random sequence
        generation</link>, using <link linkend="dateref">date</link>
        command</para></listitem>
       <listitem><para><link linkend="jotrandom">Random sequence
         generation</link>, using <link linkend="jotref">jot</link></para></listitem>

      <listitem><para><link linkend="randstring0">Random string</link>,
        generating</para></listitem>

         </itemizedlist></para>

<!-- *************************************************************** -->
      <para>Raspberry Pi (single-board computer)

         <itemizedlist>

      <listitem><para><link linkend="rpsdcard01">Script for preparing a bootable SD card</link>
	</para></listitem>

         </itemizedlist></para>
<!-- *************************************************************** -->



      <para><link linkend="rcsref">rcs</link></para>

<!-- *************************************************************** -->

      <para><link linkend="readref">read</link>, set value of a
        variable from <link linkend="stdinoutdef"><filename>stdin</filename></link>
         <itemizedlist>

      <listitem><para><link linkend="readarrow">Detecting
        <firstterm>arrow</firstterm> keys</link></para></listitem>
      <listitem><para><link linkend="readoptions">Options</link></para></listitem>
      <listitem><para><link linkend="readpiperef">Piping
        output of <firstterm>cat</firstterm></link>
        to <firstterm>read</firstterm></para></listitem>
      <listitem><para><link linkend="hsread"><quote>Prepending</quote>
	   text</link></para></listitem>
      <listitem><para><link linkend="badread0">
         Problems piping <firstterm>echo</firstterm></link>
	 to <firstterm>read</firstterm></para></listitem>
      <listitem><para><link linkend="readredir0">Redirection from a
        file</link> to <firstterm>read</firstterm></para></listitem>
      <listitem><para><link linkend="replyref"><varname>$REPLY</varname></link>,
	default <firstterm>read</firstterm> variable</para></listitem>
      <listitem><para><link linkend="readtimed">Timed
        input</link></para></listitem>
      <listitem><para><link linkend="whilereadref2">
         <firstterm>while read</firstterm></link>
         construct</para></listitem>
         </itemizedlist></para>

      <para><link linkend="readlineref">readline</link> library</para>

      <para><link linkend="recursionref">Recursion</link>
         <itemizedlist>
      <listitem><para><link linkend="recursiondemo0">Demonstration of</link></para></listitem>
      <listitem><para><link linkend="factorialref">Factorial</link></para></listitem>
      <listitem><para><link linkend="fiboref">Fibonacci
        sequence</link></para></listitem>
      <listitem><para><link linkend="locvarrecur">Local
        variables</link></para></listitem>
      <listitem><para><link linkend="scriptrecursion">Script
        calling itself recursively</link></para></listitem>
      <listitem><para><link linkend="hanoiref">Towers
        of Hanoi</link></para></listitem>
         </itemizedlist></para>


<!-- *************************************************************** -->
      <para>Redirection
         <itemizedlist>

      <listitem><para><link linkend="redirref">Code
         blocks</link></para></listitem>
      <listitem><para><link linkend="usingexecref">exec
        &lt;<filename>filename</filename></link>,</para>
	<para>to reassign
        <link linkend="fdref">file descriptors</link></para></listitem>
	 <listitem><para><link linkend="ioredirintro">Introductory-level
	   explanation</link> of <firstterm>I/O
	   redirection</firstterm></para></listitem>
      <listitem><para><link linkend="ioredirectionref2">
	   Open a file</link> for <emphasis>both</emphasis>
	   reading and writing</para>
           <para><filename>&lt;&gt;filename</filename>
	   </para></listitem>
      <listitem><para><link linkend="readredir0"><firstterm>read</firstterm>
        input redirected</link> from a file</para></listitem>
	 <listitem><para>
         <link linkend="ioredirectionref1">
	    <filename>stderr</filename> to
	    <filename>stdout</filename></link></para>
            <para><filename>2&gt;&amp;1 </filename></para></listitem>

      <listitem><para><link linkend="coxex"><filename>stdin</filename> /
         <filename>stdout</filename></link>,
         using <command> - </command></para></listitem>
      <listitem><para><link linkend="redstdinfunc1">
         <filename>stdin</filename>of a
         <firstterm>function</firstterm></link></para></listitem>
      <listitem><para><link linkend="ioredirectionref">
         <filename>stdout</filename> to a file</link></para>
	 <para><replaceable>&gt;</replaceable> ... <replaceable>&gt;&gt;</replaceable>
	 </para></listitem>

      <listitem><para>
        <link linkend="ioredirectionref1">
	<filename>stdout</filename> to
	<firstterm>file descriptor</firstterm></link>
	<firstterm>j</firstterm></para>
	<para><filename>&gt;&amp;j </filename></para></listitem>
      <listitem><para>
        <link linkend="ioredirectionref1">
	file descriptor<filename>i</filename> to
	<firstterm>file descriptor</firstterm></link>
	<firstterm>j</firstterm></para>
	<para><filename>i&gt;&amp;j </filename></para></listitem>

     <listitem><para>
         <link linkend="redirouterror2"><filename>stdout</filename>
	  of a command</link> to <filename>stderr</filename></para>
          <para><filename>&gt;&amp;2</filename></para></listitem>
     <listitem><para>
         <link linkend="redirouterror"><filename>stdout</filename>
         <emphasis>and</emphasis> <filename>stderr</filename>
	 of a command</link> to a file</para>
         <para><filename>&amp;&gt; </filename></para></listitem>
     <listitem><para>
         <link linkend="teeref">tee</link>, redirect to a file
	    output of command(s) partway through a <link linkend="piperef">pipe</link></para></listitem>

         </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="refcards">Reference Cards</link>
         <itemizedlist>
        <listitem><para><link linkend="misctab">Miscellaneous
	  constructs</link></para></listitem>
        <listitem><para><link linkend="parsubtab">Parameter
	  substitution/expansion</link></para></listitem>
        <listitem><para><link linkend="specshvartab">Special shell
           variables</link></para></listitem>
        <listitem><para><link linkend="stringopstab">String
	  operations</link></para></listitem>
        <listitem><para>Test operators</para>
	  <para><link linkend="bincomptab">Binary comparison</link></para>
	  <para><link linkend="filestab">Files</link></para>
       </listitem>
         </itemizedlist></para>

<!-- *************************************************************** -->

      <para><link linkend="regexref"><firstterm>Regular
         Expressions</firstterm></link>
	    <itemizedlist>
         <listitem><para><command>^ </command> (caret)
           <link linkend="beglineref">Beginning-of-line</link>
	   </para></listitem>
         <listitem><para><command>$ </command> (dollar sign)
        <link linkend="dollarsignref"><firstterm>Anchor</firstterm></link>
           </para></listitem>
	 <listitem><para><command>. </command> (dot)
           <link linkend="regexdot">Match single
	   character</link></para></listitem>
	 <listitem><para><command>* </command> (asterisk)
           <link linkend="asteriskref2">Any number of
	   characters</link></para></listitem>
      <listitem><para><command>[ ]</command> (brackets) <link linkend="bracketsref">Enclose character set
        to match</link></para></listitem>
      <listitem><para><command>\ </command> (backslash) <link linkend="regexbs">Escape</link>, interpret following
	 character literally</para></listitem>
         <listitem><para><command>\&lt; ... \&gt; </command>
	   (angle brackets, <firstterm>escaped</firstterm>)
           <link linkend="anglebrac">Word boundary</link></para></listitem>
         <listitem>
	   <para><link linkend="extregex">Extended</link>
             REs</para>
           <para><command>+ </command>
            <link linkend="plusref"><firstterm>Character
            match</firstterm></link></para>
            <para><command>\{ \} </command> <link linkend="escpcb">Escaped
              <quote>curly</quote> brackets</link></para>
            <para><command>[:   :] </command> <link linkend="posixref">POSIX character classes</link></para>
	 </listitem>
	    </itemizedlist></para>

      <para><link linkend="replyref"><varname>$REPLY</varname></link>,
         Default value associated with <link linkend="readref">read</link>
         command</para>
      <para><link linkend="restrictedshref">Restricted shell</link>,
         shell (or script) with certain commands disabled</para>
      <para><link linkend="returnref">return</link>,
         command that terminates a <link linkend="functionref">function</link></para>

      <para><link linkend="runpartsref">run-parts</link>
         <itemizedlist>
        <listitem><para><link linkend="runpartsref2">Running scripts
          in sequence</link>, without user intervention</para></listitem>
         </itemizedlist></para>

      

      <para><link linkend="scoperef">Scope</link> of a variable,
         definition</para>
      <para><link linkend="invocationoptionsref">Script options</link>,
         set at command line</para>
      <para><link linkend="libroutines">Scripting routines</link>,
        library of useful definitions and <link linkend="functionref">functions</link></para>
      <para><link linkend="secpromptref">Secondary prompt</link>,
         <command><varname>$PS2</varname></command></para>

      <para><link linkend="securityissues">Security issues</link>
	   <itemizedlist>
      <listitem><para><link linkend="nmapref">nmap</link>,
        <firstterm>network mapper</firstterm>
	/ port scanner</para></listitem>
      <listitem><para><link linkend="sudoref">sudo</link></para></listitem>
      <listitem><para><link linkend="suidscr"><firstterm>suid</firstterm>
           commands inside a script</link></para></listitem>
      <listitem><para><link linkend="infectedscripts1">Viruses,
        trojans, and worms</link> in scripts</para></listitem>
      <listitem><para><link linkend="securitytips1">Writing
        secure scripts</link></para></listitem>
	   </itemizedlist></para>



      <para><link linkend="sedref">sed</link>,
         pattern-based programming language
	    <itemizedlist>
      <listitem><para><link linkend="sedbasictable"><command>Table</command></link>,
         basic operators</para></listitem>
      <listitem><para><link linkend="sedoptable"><command>Table</command></link>,
         examples of operators</para></listitem>
	   </itemizedlist></para>

      <para><link linkend="selectref">select</link>,
         construct for menu building
	    <itemizedlist>
      <listitem><para><link linkend="inlistomit"><userinput>in
         <replaceable>list</replaceable></userinput> omitted</link>
	 </para></listitem>
	    </itemizedlist></para>

      <para><link linkend="semaphoreref">Semaphore</link></para>

      <para><link linkend="needsemicolon">Semicolon required</link>,
         when <link linkend="doinref">do</link>
         <firstterm>keyword</firstterm> is on first line of <link linkend="forloopref1">loop</link>
             <itemizedlist>
      <listitem><para><link linkend="omitsemicolon">When
         terminating <firstterm>curly-bracketed</firstterm>
	 code block</link></para></listitem>
             </itemizedlist></para>

      <para><link linkend="seqref">seq</link>,
        Emit a sequence of integers. Equivalent to <link linkend="jotref">jot</link>.</para>

      <para><link linkend="setref">set</link>,
         Change value of internal script variables
         <itemizedlist>
      <listitem><para><link linkend="undvarerr">set -u</link>,
        Abort script with error message if attempting to use
	an <firstterm>undeclared</firstterm> variable.</para></listitem>
         </itemizedlist>
	   </para>

      <para><link linkend="whatsascript">Shell script</link>,
         definition of</para>
      <para><link linkend="shwrapper">Shell wrapper</link>,
         script embedding a command or utility</para>
      <para><link linkend="shiftref">shift</link>, reassigning
         <firstterm>positional parameters</firstterm></para>
	 <para><link linkend="shlvlref"><varname>$SHLVL</varname></link>,
            <firstterm>shell level</firstterm>, depth to which the shell
            (or script) is nested</para> 
      <para><link linkend="shoptref">shopt</link>,
        change <firstterm>shell options</firstterm></para>
      <para><link linkend="signald">Signal</link>,
         a message sent to a process</para>

      <para>Simulations
         <itemizedlist>
      <listitem><para><link linkend="brownianref">Brownian
        motion</link></para></listitem>
      <listitem><para><link linkend="brownianref">Galton
        board</link></para></listitem>
      <listitem><para><link linkend="horseraceref">Horserace</link></para></listitem>
      <listitem><para><link linkend="liferef"><emphasis>Life</emphasis></link>,
        game of</para></listitem>
      <listitem><para><link linkend="cannonref">PI</link>,
         approximating by firing cannonballs</para></listitem>
      <listitem><para><link linkend="stackex0">Pushdown
        <firstterm>stack</firstterm></link></para></listitem>
          </itemizedlist></para>

      <para><link linkend="snglquo">Single quotes</link>
         (<command>' ... '</command>) <firstterm>strong</firstterm> <link linkend="quotingref">quoting</link></para>
      <para><link linkend="socketref">Socket</link>, a communication
         node associated with an I/O port</para>

      <para>Sorting
         <itemizedlist>
      <listitem><para><link linkend="bubblesort">Bubble
        sort</link></para></listitem>
      <listitem><para><link linkend="insertionsort0">Insertion
        sort</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="sourceref">source</link>,
        execute a script or, within a script, import a file
	  <itemizedlist>
      <listitem><para><link linkend="sourceparams">Passing positional
        parameters</link></para></listitem>
          </itemizedlist></para>

      <para><firstterm>Spam</firstterm>, dealing with
          <itemizedlist>
      <listitem><para><link linkend="spamlookup_0"><firstterm>Example
        script</firstterm></link></para></listitem>
      <listitem><para><link linkend="isspammer_0"><firstterm>Example
        script</firstterm></link></para></listitem>
      <listitem><para><link linkend="isspammer2_0"><firstterm>Example
        script</firstterm></link></para></listitem>
      <listitem><para><link linkend="whx0"><firstterm>Example
        script</firstterm></link></para></listitem>
          </itemizedlist></para>

      <para><link linkend="scharlist1">Special characters</link></para>

      <para>Stack
        <itemizedlist>
        <listitem><para><link linkend="stackdefref">Definition</link></para></listitem>
        <listitem><para>Emulating a <firstterm>push-down stack</firstterm>,
          <link linkend="stackex0">example script</link></para></listitem>
          </itemizedlist></para>

      <para>Standard Deviation, <link linkend="stddev">example script</link></para>
      <para><link linkend="filesref1">Startup files</link>, Bash</para>

      <para><link linkend="stdinoutdef"><filename>stdin</filename>
         and <filename>stdout</filename></link></para>

      <para><link linkend="stopwatch">Stopwatch</link>,
        example script</para>

<!-- *************************************************************** -->
      <para>Strings
         <itemizedlist>

      <listitem><para>
         <command>=~ </command>
      <link linkend="regexmatchref">String match operator</link>
        </para></listitem>

      <listitem><para><link linkend="scomparison1">Comparison</link></para></listitem>
      <listitem><para><link linkend="psorex1">Length</link></para>
         <para><replaceable>${#string}</replaceable></para></listitem>
      <listitem><para><link linkend="stringmanip">Manipulation</link></para></listitem>
      <listitem><para><link linkend="awkstringmanip2">Manipulation</link>,
         using <link linkend="awkref">awk</link></para></listitem>
      <listitem><para><link linkend="stringnotnull"><firstterm>Null</firstterm>
        string</link>, testing for</para></listitem>
      <listitem>
        <para><link linkend="protectliteral0">Protecting strings</link>
	  from expansion and/or reinterpretation,
	  <firstterm>script example</firstterm></para>
        <para><link linkend="unprotectliteral0"><firstterm>Unprotecting</firstterm>
            strings</link>,
	  <firstterm>script example</firstterm></para>
      </listitem>

      <listitem>
      <para><firstterm>strchr()</firstterm>, <link linkend="substringindex2">equivalent of</link></para>
      </listitem>

      <listitem>
      <para><firstterm>strlen()</firstterm>, <link linkend="strlen">equivalent of</link></para>
      </listitem>

      <listitem>
      <para><link linkend="stringsref">strings</link> command,
        find printable strings in a binary or data file</para>
      </listitem>

      <listitem>
      <para>Substring extraction</para>
      <para><link linkend="substrextr01">${string:position}</link></para>
      <para><link linkend="substrextr02">${string:position:length}</link></para>
      <para><link linkend="expextrsub">Using
	 <firstterm>expr</firstterm></link>
      </para></listitem>

      <listitem><para><link linkend="substringindex2">Substring
         <firstterm>index</firstterm></link> (numerical position in
         string)</para></listitem>
      <listitem><para><link linkend="exprparen">Substring
         <firstterm>matching</firstterm></link>, using
         <link linkend="exprref">expr</link></para></listitem>

      <listitem>
        <para><link linkend="psorex1">Substring
           <firstterm>removal</firstterm></link></para>
      <para><link linkend="psorexsh">${var#Pattern}</link></para>
      <para><link linkend="psorexlo">${var##Pattern}</link></para>
      <para><link linkend="pctrep1">${var%Pattern}</link></para>
      <para><link linkend="pctrep2">${var%%Pattern}</link></para>
      </listitem>

      <listitem>
      <para>Substring replacement</para>
      <para><link linkend="substrrepl00">${string/substring/replacement}</link></para>
      <para><link linkend="substrrepl01">${string//substring/replacement}</link></para>
      <para><link linkend="substrrepl02">${string/#substring/replacement}</link></para>
      <para><link linkend="substrrepl03">${string/%substring/replacement}</link>
      </para>

      <para><link linkend="daysbetween0"><firstterm>Script
	  example</firstterm></link></para>
    </listitem>

        <listitem><para><link linkend="stringopstab"><command>Table</command></link>
	  of <firstterm>string/substring</firstterm> manipulation and
	  extraction operators</para></listitem>

         </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="snglquo"><firstterm>Strong</firstterm> quoting</link>
         <command>' ... '</command></para>

      <para><link linkend="scrstyle">Stylesheet</link>
        for writing scripts</para>

<!-- *************************************************************** -->
      <para><link linkend="subshellsref">Subshell</link>
         <itemizedlist>
      <listitem><para><link linkend="subshellparens1">Command list within
        parentheses</link></para></listitem>
      <listitem><para><link linkend="subshnlevref">Variables</link>,
        <varname>$BASH_SUBSHELL</varname> and
        <varname>$SHLVL</varname></para></listitem>

      <listitem>
        <para>Variables in a <firstterm>subshell</firstterm></para>

	<para><link linkend="varsubsh"><firstterm>scope</firstterm>
	  limited</link>, but ...</para>

        <para> ... <link linkend="subshtmp">can be accessed outside
          the subshell?</link>
	</para>
      </listitem>

         </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="suref">su</link> <firstterm>Substitute
        user</firstterm>, log on as a different user or as
	<firstterm>root</firstterm></para>
      <para><link linkend="suidref">suid</link> (<firstterm>set user
         id</firstterm>) file flag
	   <itemizedlist>
      <listitem><para><link linkend="suidscr"><firstterm>suid</firstterm>
         commands inside a script</link>, not advisable</para></listitem>
	 </itemizedlist></para>
       
      <para><link linkend="symlinkref">Symbolic links</link></para>

      <para><link linkend="swapfileref">Swapfiles</link></para>

      

      <para><link linkend="tabexpansion">Tab completion</link></para>
      <para>Table lookup, <link linkend="resistor">script
        example</link></para>
      <para><link linkend="tailref">tail</link>, <firstterm>echo</firstterm>
        to <filename>stdout</filename> lines at the (tail) end of a text
        file</para>
      <para><link linkend="tarref">tar</link>, archiving utility</para>
      <para><link linkend="teeref">tee</link>, redirect to a file
	output of command(s) partway through a <link linkend="piperef">pipe</link></para>

      <para><link linkend="terminalssys1">Terminals</link>
         <itemizedlist>
      <listitem><para><link linkend="setserialref">setserial</link></para></listitem>
      <listitem><para><link linkend="settermref">setterm</link></para></listitem>
      <listitem><para><link linkend="sttyref">stty</link></para></listitem>
      <listitem><para><link linkend="tputref">tput</link></para></listitem>
      <listitem><para><link linkend="wallref">wall</link></para></listitem>
         </itemizedlist></para>

      <para><firstterm>test</firstterm> command
         <itemizedlist>
      <listitem><para><link linkend="ttestref">Bash
        <firstterm>builtin</firstterm></link></para></listitem>
      <listitem><para><link linkend="usrbintest">external
        command</link>, <filename>/usr/bin/test</filename>
        (equivalent to <filename>/usr/bin/[</filename>)</para></listitem>
         </itemizedlist></para>

      <para><link linkend="testconstructs1">Test constructs</link></para>

<!-- *************************************************************** -->
      <para>Test operators
         <itemizedlist>

      <listitem><para><command>-a </command>
        <link linkend="compoundand">Logical AND</link>
	compound comparison</para></listitem>
      <listitem><para><command>-e </command>
        <link linkend="rtif">File exists</link></para></listitem>
      <listitem><para><command>-eq </command>
         <link linkend="equalref">is-equal-to</link> (integer
	 comparison)</para></listitem>
      <listitem><para><command>-f </command>
        <link linkend="regularfile">File is a <firstterm>regular</firstterm>
	file</link></para></listitem>
      <listitem><para><command>-ge </command>
         <link linkend="ge0ref">greater-than or equal</link>
	 (integer comparison)</para></listitem>
      <listitem><para><command>-gt </command>
         <link linkend="gt0ref">greater-than</link> (integer
	 comparison)</para></listitem>
      <listitem><para><command>-le </command>
         <link linkend="le0ref">less-than or equal</link>
	 (integer comparison)</para></listitem>
      <listitem><para><command>-lt </command>
         <link linkend="lt0ref">less-than</link>
	 (integer comparison)</para></listitem>
      <listitem><para><command>-n </command>
        <link linkend="stringnotnull">not-zero-length</link>
	(string comparison)</para></listitem>
      <listitem><para><command>-ne </command>
         <link linkend="nequalref">not-equal-to</link>
	 (integer comparison)</para></listitem>
      <listitem><para><command>-o </command>
        <link linkend="compoundor">Logical OR</link>
	compound comparison</para></listitem>
      <listitem><para><command>-u </command>
        <link linkend="suidref"><firstterm>suid</firstterm>
	flag set</link>, file test</para></listitem>
      <listitem><para><command>-z </command>
        <link linkend="stringnull">is-zero-length</link>
	(string comparison)</para></listitem>

	 <listitem><para><command>= </command>
           <link linkend="scomparison1">is-equal-to</link>
	   (string comparison)</para>
	           <para><command>== </command>
                      <link linkend="scomparison2">is-equal-to</link>
	              (string comparison)</para></listitem>
	 <listitem><para> <command>&lt; </command>
           <link linkend="ltref">less-than</link>
	   (string comparison)</para></listitem>
	 <listitem><para><command>&lt; </command>
            <link linkend="intlt">less-than</link>,
	    (integer comparison, within
	    <link linkend="dblparens">double parentheses</link>)
          </para></listitem>
	 <listitem><para><command>&lt;= </command>
            <link linkend="lteq">less-than-or-equal</link>,
	    (integer comparison, within
	    <firstterm>double parentheses</firstterm>)
          </para></listitem>
	 <listitem><para><command>&gt; </command>
            <link linkend="gtref">greater-than</link>
	    (string comparison)</para></listitem>
	 <listitem><para><command>&gt; </command>
            <link linkend="intgt">greater-than</link>,
            (integer comparison, within
            <firstterm>double parentheses</firstterm>)</para></listitem>
	 <listitem><para><command>&gt;= </command>
            <link linkend="gteq">greater-than-or-equal</link>,
	    (integer comparison, within
	    <firstterm>double parentheses</firstterm>)
          </para></listitem>
         <listitem><para><command>|| </command>
         <link linkend="orref">Logical OR </link></para></listitem>
         <listitem><para><command>&amp;&amp; </command>
	    <link linkend="logicaland">Logical AND</link></para></listitem>

      <listitem><para><command>! </command>
         <link linkend="notref">Negation operator</link>, inverts <link linkend="exitstatusref">exit status</link> of a
	 test</para>
                <para><command>!= </command>
                   <link linkend="notequal">not-equal-to</link>
                   (string comparison)</para></listitem>

      <listitem>
        <para><command>Tables</command> of <firstterm>test</firstterm>
	  operators</para>
        <para><link linkend="bincomptab">Binary comparison</link></para>
        <para><link linkend="filestab">File</link></para>
      </listitem>

         </itemizedlist></para>
<!-- *************************************************************** -->

      <para><link linkend="textproc">Text and text file
        processing</link></para>
      <para><link linkend="timedate">Time / Date</link></para>

<!-- *************************************************************** -->
      <para>Timed input
         <itemizedlist>
      <listitem><para><link linkend="readtimed">Using
        <firstterm>read -t</firstterm></link></para></listitem>
      <listitem><para><link linkend="sttyto">Using
        <firstterm>stty</firstterm></link></para></listitem>
      <listitem><para><link linkend="timingloop">Using
        timing loop</link></para></listitem>
      <listitem><para><link linkend="tmoutref">Using
        <varname>$TMOUT</varname></link></para></listitem>

         </itemizedlist></para>

<!-- *************************************************************** -->
      <para><link linkend="assortedtips">Tips and hints</link>
        for Bash scripts
	   <itemizedlist>

      <listitem><para>Array, <link linkend="retarray">as
        <firstterm>return value</firstterm> from
	a function</link></para>
	<para><firstterm>Associative</firstterm> array
	<link linkend="assocarrtst">more efficient</link>
	than a numerically-indexed array</para></listitem>

      <listitem><para><link linkend="captureretval">Capturing
        the return value</link> of a function, using
	<firstterm>echo</firstterm></para></listitem>

      <listitem><para><link linkend="cgiscript"><firstterm>CGI</firstterm>
        programming</link>, using scripts for</para></listitem>

      <listitem>
        <para>Comment blocks</para>
        <para>Using <link linkend="cblock1"><firstterm>anonymous
	  here documents</firstterm></link></para>
        <para>Using <link linkend="comoutbl"> <firstterm>if-then</firstterm>
	constructs</link></para>
      </listitem>

      <listitem><para><link linkend="commenth">Comment headers</link>,
        special purpose</para></listitem>
      <listitem><para><link linkend="cstyle"><firstterm>C</firstterm>-style syntax </link>,
        for manipulating variables</para></listitem>

      <listitem><para><link linkend="doublespace">Double-spacing a text
        file</link></para></listitem>

      <listitem><para>Filenames prefixed with a dash,
        <link linkend="dashrem">removing</link></para></listitem>

      <listitem><para><link linkend="filteroutp">Filter</link>,
         feeding output back to <emphasis>same</emphasis>
         filter</para></listitem>
      <listitem><para>Function<link linkend="rvt">
        <firstterm>return</firstterm> value
	workarounds</link></para></listitem>
      <listitem><para><link linkend="ifgrepfix"><firstterm>if-grep</firstterm>
        test fixup</link></para></listitem>
      <listitem><para><link linkend="libroutines">Library</link>
        of useful definitions and
        <firstterm>functions</firstterm></para></listitem>
      <listitem><para><link linkend="nullvar"><firstterm>null</firstterm>
        variable assignment</link>, avoiding</para></listitem>
      <listitem><para><link linkend="passarray">Passing
        an <firstterm>array</firstterm></link> to a
        function</para></listitem>
      <listitem><para><varname>$PATH</varname>,
        appending to, <link linkend="pathappend">using the
        <varname>+=</varname> operator</link>.</para></listitem>
      <listitem><para><link linkend="prependref"><firstterm>Prepending</firstterm></link>
        lines at head of a file</para></listitem>
      <listitem><para><link linkend="progressbar">Progress
        bar</link> template</para></listitem>
      <listitem><para><link linkend="pseudocoderef">Pseudo-code</link></para></listitem>
      <listitem><para><link linkend="rcsref">rcs</link></para></listitem>
      <listitem><para><link linkend="devnullredirect">Redirecting a <firstterm>test</firstterm>
	to <filename>/dev/null</filename></link> to suppress output</para></listitem>
      <listitem><para><link linkend="runpartsref2">Running scripts in
        sequence</link> without user intervention, using <link linkend="runpartsref">run-parts</link></para></listitem>
      <listitem><para>Script<link linkend="scriptasemb"> as embedded
        command</link></para></listitem>
      <listitem>
        <para>Script <firstterm>portability</firstterm></para>
        <para><link linkend="setpum">Setting <firstterm>path</firstterm>
	  and <firstterm>umask</firstterm></link></para>
        <para><link linkend="whatisref3">Using <firstterm>whatis</firstterm></link>
	  </para>
      </listitem>

      <listitem><para><link linkend="setvaremb">Setting script variable</link>
	to a block of embedded <firstterm>sed</firstterm> or
	<firstterm>awk</firstterm> code</para></listitem>
      <listitem><para>Speeding up script execution by <link linkend="lcall">disabling <firstterm>unicode</firstterm></link>
	 </para></listitem>
      <listitem><para>Subshell variable,
        <link linkend="subshtmp">accessing outside the subshell</link>
	</para></listitem>
      <listitem><para><link linkend="intparam">Testing a variable</link>
        to see if it contains only digits</para></listitem>
      <listitem><para><link linkend="devnullredirect">Testing whether
        a command exists</link>, using <link linkend="typeref">type</link></para></listitem>
      <listitem><para><link linkend="trackingscr">Tracking script
        usage</link></para></listitem>
      <listitem><para><link linkend="goodread0"><firstterm>while-read</firstterm> loop
	 without a
	 <firstterm>subshell</firstterm></link></para></listitem>
      <listitem><para><link linkend="widgetref">Widgets</link>, invoking from a
	script</para></listitem>

         </itemizedlist></para>


      <para><link linkend="tmoutref"><varname>$TMOUT</varname></link>,
        Timeout interval</para>
      <para><link linkend="tokenref">Token</link>, a symbol that may
        expand to a <link linkend="keywordref">keyword</link> or
        command</para>
      <para><link linkend="tputref">tput</link>, terminal-control
        command</para>

      <para><link linkend="trref">tr</link>, character translation filter
         <itemizedlist>
      <listitem><para><link linkend="trd2u">DOS to Unix text file
        conversion</link></para></listitem>
      <listitem><para><link linkend="troptions">Options</link></para></listitem>
      <listitem><para><link linkend="soundex0">Soundex</link>, <firstterm>example
        script</firstterm></para></listitem>
      <listitem><para><link linkend="trvariants">Variants</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="trapref1"><firstterm>Trap</firstterm></link>,
         specifying an action upon receipt of a <link linkend="signald">signal</link></para>

      <para><firstterm>Trinary (ternary)</firstterm> operator,
         <firstterm>C</firstterm>-style,
	 <userinput>var&gt;10?88:99</userinput>
         <itemizedlist>
      <listitem><para><link linkend="cstrinary">in
        <firstterm>double-parentheses</firstterm>
        construct</link></para></listitem>
      <listitem><para><link linkend="ex46">in <firstterm>let</firstterm>
        construct</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="trueref">true</link>,
        returns <firstterm>successful</firstterm> (0) <link linkend="exitstatusref">exit status</link></para>
      <para><link linkend="declare1ref">typeset</link> builtin
         <itemizedlist>
      <listitem><para><link linkend="declareopsref1">options</link></para></listitem>
         </itemizedlist></para>

      

      <para><link linkend="uidref"><varname>$UID</varname></link>,
         User ID number</para>
      <para><link linkend="unaliasref">unalias</link>,
        to remove an <link linkend="aliasref">alias</link></para>
      <para><link linkend="unameref">uname</link>,
        output system information</para>
      <para><link linkend="unicoderef">Unicode</link>, encoding standard
        for representing letters and symbols
         <itemizedlist>
      <listitem><para><link linkend="lcall">Disabling <firstterm>unicode</firstterm></link>
	 to optimize script</para></listitem>
         </itemizedlist></para>


      <para><link linkend="uninitvar">Uninitialized variables</link> </para>
      <para><link linkend="uniqref">uniq</link>,
        filter to remove duplicate lines from a sorted file</para>
      <para><link linkend="unsetref">unset</link>,
         delete a shell variable</para>
      <para><link linkend="untilloopref">until</link> loop</para>
         <para><firstterm>until [ condition-is-true ]; do</firstterm></para>

      

      <para><firstterm>Variables</firstterm>

         <itemizedlist>

      <listitem><para><link linkend="arrayopsvars">Array operations on
        </link></para></listitem>
      <listitem>
        <para><link linkend="asnop1">Assignment</link></para>
        <para><link linkend="ex15_0"><firstterm>Script
          example</firstterm></link></para>
        <para><link linkend="ex16_0"><firstterm>Script
          example</firstterm></link></para>
        <para><link linkend="varunsetting"><firstterm>Script
          example</firstterm></link></para>
	</listitem>

      <listitem><para><link linkend="internalvariables"><firstterm>Bash</firstterm>
        internal variables</link></para></listitem>
      <listitem><para><link linkend="setvaremb">Block of <firstterm>sed</firstterm> or
	<firstterm>awk</firstterm> code</link>, setting a variable
	to</para></listitem>
      <listitem><para>
	<firstterm>C-style</firstterm>
        <link linkend="plusplusref">
        increment/decrement/trinary operations</link></para></listitem>
      <listitem><para>
        <link linkend="setref">Change value of internal script variables</link>
        using <firstterm>set</firstterm></para></listitem>
      <listitem><para><link linkend="declare1ref">declare</link>,
        to modify the properties of variables</para></listitem>
      <listitem><para><link linkend="unsetref">Deleting a shell variable</link>
         using <firstterm>unset</firstterm></para></listitem>
      <listitem><para><link linkend="envref">Environmental</link></para></listitem>
      <listitem><para><link linkend="exprepl1">Expansion / Substring
        replacement</link> operators</para></listitem>

      <listitem>
        <para><link linkend="ivrref">Indirect
          referencing</link></para>
	<para><replaceable>eval variable1=\$$variable2</replaceable></para>

         <para><link linkend="ivr2">Newer notation</link></para>
	 <para><replaceable>${!variable}</replaceable></para>
       </listitem>

      <listitem><para><link linkend="intvarref">Integer</link></para></listitem>
      <listitem><para><link linkend="bvuntyped">Integer / string</link> (variables are
	untyped)</para></listitem>

      <listitem><para><link linkend="psorex1">Length</link></para>
         <para><replaceable>${#var}</replaceable></para></listitem>
      <listitem><para><link linkend="lvalueref">Lvalue</link></para></listitem>
      <listitem><para><link linkend="pssub1">Manipulating and
        expanding</link></para></listitem>
      <listitem><para><link linkend="varnameval"><firstterm>Name</firstterm>
        and <firstterm>value</firstterm> of a variable</link>,
	distinguishing between</para></listitem>
      <listitem><para><link linkend="stringnotnull"><firstterm>Null</firstterm>
        string</link>, testing for</para></listitem>
      <listitem><para><link linkend="nullvar"><firstterm>Null</firstterm>
        variable assignment</link>, avoiding</para></listitem>
      <listitem>
        <para><link linkend="quotingvar">Quoting</link></para>
        <para><link linkend="failquote">within <firstterm>test</firstterm>
          brackets</link></para>
        <para><link linkend="wsquo">to preserve
	  <firstterm>whitespace</firstterm></link></para>
      </listitem>
      <listitem><para><link linkend="lvalueref">rvalue</link></para></listitem>
      <listitem><para><link linkend="varunsetting">Setting to <firstterm>null</firstterm>
        value</link></para></listitem>
      <listitem><para><link linkend="parvis">In
        <firstterm>subshell</firstterm></link>
	not visible to parent shell</para></listitem>
      <listitem><para>Testing a variable <link linkend="intparam">
        if it contains only digits</link></para></listitem>
      <listitem><para><link linkend="typingref">Typing</link>,
        restricting the properties of a variable</para></listitem>
      <listitem><para><link linkend="undvarerr">Undeclared</link>,
        error message</para></listitem>
      <listitem><para><link linkend="uninitvar1">Uninitialized</link>
        </para></listitem>
      <listitem><para><link linkend="varsplitting">Unquoted
	variable</link>,
	<firstterm>splitting</firstterm></para></listitem>
	<listitem><para><link linkend="unsetref">Unsetting</link></para></listitem>
      <listitem><para><link linkend="bvuntyped">Untyped</link></para></listitem>

         </itemizedlist></para>

      

      <para><link linkend="waitref">wait</link>,
        suspend script execution
	   <itemizedlist>
       <listitem><para><link linkend="waithang">To remedy
         script hang</link></para></listitem>
         </itemizedlist></para>


      <para><link linkend="dblquo"><firstterm>Weak</firstterm> quoting</link>
      <command>" ... "</command></para>


      <para><link linkend="whileloopref">while</link> loop</para>
	 <para><firstterm>while [ condition ]; do</firstterm>
         <itemizedlist>
      <listitem><para><link linkend="whloopc">C-style syntax</link>
        </para></listitem>
      <listitem><para><link linkend="whilefunc">Calling a
        <firstterm>function</firstterm> within
        <firstterm>test</firstterm> brackets</link></para></listitem>
      <listitem><para><link linkend="whmultcond">Multiple
         conditions</link></para></listitem>
      <listitem><para><link linkend="whilenobrackets">Omitting
        <firstterm>test</firstterm> brackets</link></para></listitem>
      <listitem>
        <para><link linkend="whilereadref2">
           <firstterm>while read</firstterm></link>
           construct
	</para>
	<para><link linkend="goodread0">Avoiding a
	  <firstterm>subshell</firstterm></link></para>
	</listitem>
         </itemizedlist></para>

      <para><link linkend="whitespaceref">Whitespace</link>,
         spaces, tabs, and newline characters
         <itemizedlist>
      <listitem><para><link linkend="ifsws"><varname>$IFS</varname> defaults
        to</link></para></listitem>
      <listitem><para><link linkend="wsbad">Inappropriate use
        of</link></para></listitem>
      <listitem><para><link linkend="indentedls">Preceding closing
        <firstterm>limit string</firstterm></link> in a <firstterm>here
	document</firstterm>, error</para></listitem>
      <listitem><para><link linkend="wsbcomm">Preceding script
        comments</link></para></listitem>
      <listitem><para><link linkend="wsquo"><firstterm>Quoting</firstterm></link>,
         to preserve <firstterm>whitespace</firstterm> within strings
         or variables</para></listitem>
      <listitem><para><link linkend="wsposix">[:space:]</link>,
        <firstterm>POSIX</firstterm> character class</para></listitem>
         </itemizedlist></para>

      <para><link linkend="whoref">who</link>, information about logged on users
          <itemizedlist>
        <listitem><para><link linkend="wref">w</link></para></listitem>
	<listitem><para><link linkend="whoamiref">whoami</link></para></listitem>
        <listitem><para><link linkend="lognameref">logname</link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="widgetref">Widgets</link></para>

      <para><link linkend="wildcarddef">Wild card</link> characters
         <itemizedlist>
      <listitem><para><link linkend="asteriskref">Asterisk
        *</link></para></listitem>
      <listitem><para>In <link linkend="liglob">
        <replaceable>[list]</replaceable> constructs</link>
        </para></listitem>
      <listitem><para><link linkend="wildcardqu">Question mark
        ?</link></para></listitem>
      <listitem><para><link linkend="wdotfilewc">Will not match
        <filename>dot files</filename></link></para></listitem>
         </itemizedlist></para>

      <para>Word splitting
         <itemizedlist>
      <listitem><para><link linkend="wsplitref">Definition</link></para></listitem>
      <listitem><para><link linkend="csws">Resulting from <firstterm>command
	substitution</firstterm></link></para></listitem>
         </itemizedlist></para>

      <para><link linkend="shwrapper">Wrapper</link>, shell</para>

      

      <para><link linkend="xargsref">xargs</link>,
         Filter for grouping arguments
         <itemizedlist>
      <listitem><para><link linkend="xargscurlyref">
         Curly brackets</link></para></listitem>
      <listitem><para><link linkend="xargslimargs">
         Limiting arguments passed</link></para></listitem>
      <listitem><para><link linkend="xargslimargs">Options</link></para></listitem>
      <listitem><para>Processes arguments <link linkend="xargsoneatatime">one at a time</link></para></listitem>
      <listitem><para><link linkend="xargsws">
         Whitespace</link>, handling</para></listitem>
         </itemizedlist></para>

      

      <para><link linkend="yesref">yes</link>
        <itemizedlist>
      <listitem><para><link linkend="yesemu">Emulation</link></para></listitem>	
        </itemizedlist></para>

      

      <para><command>-z </command>
        <link linkend="stringnull">String is
	<firstterm>null</firstterm></link></para>
      <para><link linkend="zombieref"><firstterm>Zombie</firstterm></link>,
         a process that has terminated, but not yet been <link linkend="killref">killed</link> by its
         <link linkend="parentref">parent</link></para>


      </index> <!-- End Index -->



</book>